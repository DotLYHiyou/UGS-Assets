! function() {
  try {
    var e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : {},
      n = (new e.Error).stack;
    n && (e._sentryDebugIds = e._sentryDebugIds || {}, e._sentryDebugIds[n] = "74ebc269-8aaf-5abf-b0a9-c59e8e8c8e35")
  } catch (e) {}
}();
var z7 = Object.defineProperty;
var e2 = e => {
  throw TypeError(e)
};
var Y7 = (e, t, n) => t in e ? z7(e, t, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: n
}) : e[t] = n;
var Re = (e, t, n) => Y7(e, typeof t != "symbol" ? t + "" : t, n),
  l1 = (e, t, n) => t.has(e) || e2("Cannot " + n);
var Z = (e, t, n) => (l1(e, t, "read from private field"), n ? n.call(e) : t.get(e)),
  Qe = (e, t, n) => t.has(e) ? e2("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n),
  De = (e, t, n, r) => (l1(e, t, "write to private field"), r ? r.call(e, n) : t.set(e, n), n),
  lt = (e, t, n) => (l1(e, t, "access private method"), n);
var Ed = (e, t, n, r) => ({
  set _(s) {
    De(e, t, s, n)
  },
  get _() {
    return Z(e, t, r)
  }
});
(function() {
  const t = document.createElement("link").relList;
  if (t && t.supports && t.supports("modulepreload")) return;
  for (const s of document.querySelectorAll('link[rel="modulepreload"]')) r(s);
  new MutationObserver(s => {
    for (const a of s)
      if (a.type === "childList")
        for (const o of a.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && r(o)
  }).observe(document, {
    childList: !0,
    subtree: !0
  });

  function n(s) {
    const a = {};
    return s.integrity && (a.integrity = s.integrity), s.referrerPolicy && (a.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? a.credentials = "include" : s.crossOrigin === "anonymous" ? a.credentials = "omit" : a.credentials = "same-origin", a
  }

  function r(s) {
    if (s.ep) return;
    s.ep = !0;
    const a = n(s);
    fetch(s.href, a)
  }
})();
/**
 * @vue/shared v3.5.15
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
/*! #__NO_SIDE_EFFECTS__ */
function e0(e) {
  const t = Object.create(null);
  for (const n of e.split(",")) t[n] = 1;
  return n => n in t
}
const kt = {},
  gl = [],
  Ys = () => {},
  W7 = () => !1,
  lp = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97),
  t0 = e => e.startsWith("onUpdate:"),
  An = Object.assign,
  n0 = (e, t) => {
    const n = e.indexOf(t);
    n > -1 && e.splice(n, 1)
  },
  G7 = Object.prototype.hasOwnProperty,
  Et = (e, t) => G7.call(e, t),
  ze = Array.isArray,
  vl = e => Qc(e) === "[object Map]",
  pu = e => Qc(e) === "[object Set]",
  t2 = e => Qc(e) === "[object Date]",
  et = e => typeof e == "function",
  Xt = e => typeof e == "string",
  Cs = e => typeof e == "symbol",
  Ft = e => e !== null && typeof e == "object",
  I3 = e => (Ft(e) || et(e)) && et(e.then) && et(e.catch),
  $3 = Object.prototype.toString,
  Qc = e => $3.call(e),
  Q7 = e => Qc(e).slice(8, -1),
  M3 = e => Qc(e) === "[object Object]",
  r0 = e => Xt(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e,
  Xu = e0(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
  up = e => {
    const t = Object.create(null);
    return n => t[n] || (t[n] = e(n))
  },
  q7 = /-(\w)/g,
  dr = up(e => e.replace(q7, (t, n) => n ? n.toUpperCase() : "")),
  K7 = /\B([A-Z])/g,
  Ya = up(e => e.replace(K7, "-$1").toLowerCase()),
  cp = up(e => e.charAt(0).toUpperCase() + e.slice(1)),
  nf = up(e => e ? `on${cp(e)}` : ""),
  wr = (e, t) => !Object.is(e, t),
  rf = (e, ...t) => {
    for (let n = 0; n < e.length; n++) e[n](...t)
  },
  O3 = (e, t, n, r = !1) => {
    Object.defineProperty(e, t, {
      configurable: !0,
      enumerable: !1,
      writable: r,
      value: n
    })
  },
  wf = e => {
    const t = parseFloat(e);
    return isNaN(t) ? e : t
  },
  Z7 = e => {
    const t = Xt(e) ? Number(e) : NaN;
    return isNaN(t) ? e : t
  };
let n2;
const dp = () => n2 || (n2 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});

function Mt(e) {
  if (ze(e)) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
      const r = e[n],
        s = Xt(r) ? t6(r) : Mt(r);
      if (s)
        for (const a in s) t[a] = s[a]
    }
    return t
  } else if (Xt(e) || Ft(e)) return e
}
const J7 = /;(?![^(]*\))/g,
  X7 = /:([^]+)/,
  e6 = /\/\*[^]*?\*\//g;

function t6(e) {
  const t = {};
  return e.replace(e6, "").split(J7).forEach(n => {
    if (n) {
      const r = n.split(X7);
      r.length > 1 && (t[r[0].trim()] = r[1].trim())
    }
  }), t
}

function we(e) {
  let t = "";
  if (Xt(e)) t = e;
  else if (ze(e))
    for (let n = 0; n < e.length; n++) {
      const r = we(e[n]);
      r && (t += r + " ")
    } else if (Ft(e))
      for (const n in e) e[n] && (t += n + " ");
  return t.trim()
}

function Nt(e) {
  if (!e) return null;
  let {
    class: t,
    style: n
  } = e;
  return t && !Xt(t) && (e.class = we(t)), n && (e.style = Mt(n)), e
}
const n6 = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
  r6 = e0(n6);

function D3(e) {
  return !!e || e === ""
}

function s6(e, t) {
  if (e.length !== t.length) return !1;
  let n = !0;
  for (let r = 0; n && r < e.length; r++) n = qc(e[r], t[r]);
  return n
}

function qc(e, t) {
  if (e === t) return !0;
  let n = t2(e),
    r = t2(t);
  if (n || r) return n && r ? e.getTime() === t.getTime() : !1;
  if (n = Cs(e), r = Cs(t), n || r) return e === t;
  if (n = ze(e), r = ze(t), n || r) return n && r ? s6(e, t) : !1;
  if (n = Ft(e), r = Ft(t), n || r) {
    if (!n || !r) return !1;
    const s = Object.keys(e).length,
      a = Object.keys(t).length;
    if (s !== a) return !1;
    for (const o in e) {
      const i = e.hasOwnProperty(o),
        l = t.hasOwnProperty(o);
      if (i && !l || !i && l || !qc(e[o], t[o])) return !1
    }
  }
  return String(e) === String(t)
}

function s0(e, t) {
  return e.findIndex(n => qc(n, t))
}
const L3 = e => !!(e && e.__v_isRef === !0),
  R = e => Xt(e) ? e : e == null ? "" : ze(e) || Ft(e) && (e.toString === $3 || !et(e.toString)) ? L3(e) ? R(e.value) : JSON.stringify(e, R3, 2) : String(e),
  R3 = (e, t) => L3(t) ? R3(e, t.value) : vl(t) ? {
    [`Map(${t.size})`]: [...t.entries()].reduce((n, [r, s], a) => (n[u1(r, a) + " =>"] = s, n), {})
  } : pu(t) ? {
    [`Set(${t.size})`]: [...t.values()].map(n => u1(n))
  } : Cs(t) ? u1(t) : Ft(t) && !ze(t) && !M3(t) ? String(t) : t,
  u1 = (e, t = "") => {
    var n;
    return Cs(e) ? `Symbol(${(n=e.description)!=null?n:t})` : e
  };
/**
 * @vue/reactivity v3.5.15
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
let zn;
class N3 {
  constructor(t = !1) {
    this.detached = t, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = zn, !t && zn && (this.index = (zn.scopes || (zn.scopes = [])).push(this) - 1)
  }
  get active() {
    return this._active
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let t, n;
      if (this.scopes)
        for (t = 0, n = this.scopes.length; t < n; t++) this.scopes[t].pause();
      for (t = 0, n = this.effects.length; t < n; t++) this.effects[t].pause()
    }
  }
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let t, n;
      if (this.scopes)
        for (t = 0, n = this.scopes.length; t < n; t++) this.scopes[t].resume();
      for (t = 0, n = this.effects.length; t < n; t++) this.effects[t].resume()
    }
  }
  run(t) {
    if (this._active) {
      const n = zn;
      try {
        return zn = this, t()
      } finally {
        zn = n
      }
    }
  }
  on() {
    ++this._on === 1 && (this.prevScope = zn, zn = this)
  }
  off() {
    this._on > 0 && --this._on === 0 && (zn = this.prevScope, this.prevScope = void 0)
  }
  stop(t) {
    if (this._active) {
      this._active = !1;
      let n, r;
      for (n = 0, r = this.effects.length; n < r; n++) this.effects[n].stop();
      for (this.effects.length = 0, n = 0, r = this.cleanups.length; n < r; n++) this.cleanups[n]();
      if (this.cleanups.length = 0, this.scopes) {
        for (n = 0, r = this.scopes.length; n < r; n++) this.scopes[n].stop(!0);
        this.scopes.length = 0
      }
      if (!this.detached && this.parent && !t) {
        const s = this.parent.scopes.pop();
        s && s !== this && (this.parent.scopes[this.index] = s, s.index = this.index)
      }
      this.parent = void 0
    }
  }
}

function a0(e) {
  return new N3(e)
}

function Kc() {
  return zn
}

function hu(e, t = !1) {
  zn && zn.cleanups.push(e)
}
let Vt;
const c1 = new WeakSet;
class F3 {
  constructor(t) {
    this.fn = t, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, zn && zn.active && zn.effects.push(this)
  }
  pause() {
    this.flags |= 64
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, c1.has(this) && (c1.delete(this), this.trigger()))
  }
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || j3(this)
  }
  run() {
    if (!(this.flags & 1)) return this.fn();
    this.flags |= 2, r2(this), H3(this);
    const t = Vt,
      n = bs;
    Vt = this, bs = !0;
    try {
      return this.fn()
    } finally {
      V3(this), Vt = t, bs = n, this.flags &= -3
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let t = this.deps; t; t = t.nextDep) l0(t);
      this.deps = this.depsTail = void 0, r2(this), this.onStop && this.onStop(), this.flags &= -2
    }
  }
  trigger() {
    this.flags & 64 ? c1.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty()
  }
  runIfDirty() {
    dh(this) && this.run()
  }
  get dirty() {
    return dh(this)
  }
}
let B3 = 0,
  ec, tc;

function j3(e, t = !1) {
  if (e.flags |= 8, t) {
    e.next = tc, tc = e;
    return
  }
  e.next = ec, ec = e
}

function o0() {
  B3++
}

function i0() {
  if (--B3 > 0) return;
  if (tc) {
    let t = tc;
    for (tc = void 0; t;) {
      const n = t.next;
      t.next = void 0, t.flags &= -9, t = n
    }
  }
  let e;
  for (; ec;) {
    let t = ec;
    for (ec = void 0; t;) {
      const n = t.next;
      if (t.next = void 0, t.flags &= -9, t.flags & 1) try {
        t.trigger()
      } catch (r) {
        e || (e = r)
      }
      t = n
    }
  }
  if (e) throw e
}

function H3(e) {
  for (let t = e.deps; t; t = t.nextDep) t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t
}

function V3(e) {
  let t, n = e.depsTail,
    r = n;
  for (; r;) {
    const s = r.prevDep;
    r.version === -1 ? (r === n && (n = s), l0(r), a6(r)) : t = r, r.dep.activeLink = r.prevActiveLink, r.prevActiveLink = void 0, r = s
  }
  e.deps = t, e.depsTail = n
}

function dh(e) {
  for (let t = e.deps; t; t = t.nextDep)
    if (t.dep.version !== t.version || t.dep.computed && (U3(t.dep.computed) || t.dep.version !== t.version)) return !0;
  return !!e._dirty
}

function U3(e) {
  if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === hc) || (e.globalVersion = hc, !e.isSSR && e.flags & 128 && (!e.deps && !e._dirty || !dh(e)))) return;
  e.flags |= 2;
  const t = e.dep,
    n = Vt,
    r = bs;
  Vt = e, bs = !0;
  try {
    H3(e);
    const s = e.fn(e._value);
    (t.version === 0 || wr(s, e._value)) && (e.flags |= 128, e._value = s, t.version++)
  } catch (s) {
    throw t.version++, s
  } finally {
    Vt = n, bs = r, V3(e), e.flags &= -3
  }
}

function l0(e, t = !1) {
  const {
    dep: n,
    prevSub: r,
    nextSub: s
  } = e;
  if (r && (r.nextSub = s, e.prevSub = void 0), s && (s.prevSub = r, e.nextSub = void 0), n.subs === e && (n.subs = r, !r && n.computed)) {
    n.computed.flags &= -5;
    for (let a = n.computed.deps; a; a = a.nextDep) l0(a, !0)
  }!t && !--n.sc && n.map && n.map.delete(n.key)
}

function a6(e) {
  const {
    prevDep: t,
    nextDep: n
  } = e;
  t && (t.nextDep = n, e.prevDep = void 0), n && (n.prevDep = t, e.nextDep = void 0)
}
let bs = !0;
const z3 = [];

function Da() {
  z3.push(bs), bs = !1
}

function La() {
  const e = z3.pop();
  bs = e === void 0 ? !0 : e
}

function r2(e) {
  const {
    cleanup: t
  } = e;
  if (e.cleanup = void 0, t) {
    const n = Vt;
    Vt = void 0;
    try {
      t()
    } finally {
      Vt = n
    }
  }
}
let hc = 0;
class o6 {
  constructor(t, n) {
    this.sub = t, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0
  }
}
class fp {
  constructor(t) {
    this.computed = t, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0
  }
  track(t) {
    if (!Vt || !bs || Vt === this.computed) return;
    let n = this.activeLink;
    if (n === void 0 || n.sub !== Vt) n = this.activeLink = new o6(Vt, this), Vt.deps ? (n.prevDep = Vt.depsTail, Vt.depsTail.nextDep = n, Vt.depsTail = n) : Vt.deps = Vt.depsTail = n, Y3(n);
    else if (n.version === -1 && (n.version = this.version, n.nextDep)) {
      const r = n.nextDep;
      r.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = r), n.prevDep = Vt.depsTail, n.nextDep = void 0, Vt.depsTail.nextDep = n, Vt.depsTail = n, Vt.deps === n && (Vt.deps = r)
    }
    return n
  }
  trigger(t) {
    this.version++, hc++, this.notify(t)
  }
  notify(t) {
    o0();
    try {
      for (let n = this.subs; n; n = n.prevSub) n.sub.notify() && n.sub.dep.notify()
    } finally {
      i0()
    }
  }
}

function Y3(e) {
  if (e.dep.sc++, e.sub.flags & 4) {
    const t = e.dep.computed;
    if (t && !e.dep.subs) {
      t.flags |= 20;
      for (let r = t.deps; r; r = r.nextDep) Y3(r)
    }
    const n = e.dep.subs;
    n !== e && (e.prevSub = n, n && (n.nextSub = e)), e.dep.subs = e
  }
}
const Cf = new WeakMap,
  wi = Symbol(""),
  fh = Symbol(""),
  mc = Symbol("");

function Wn(e, t, n) {
  if (bs && Vt) {
    let r = Cf.get(e);
    r || Cf.set(e, r = new Map);
    let s = r.get(n);
    s || (r.set(n, s = new fp), s.map = r, s.key = n), s.track()
  }
}

function wa(e, t, n, r, s, a) {
  const o = Cf.get(e);
  if (!o) {
    hc++;
    return
  }
  const i = l => {
    l && l.trigger()
  };
  if (o0(), t === "clear") o.forEach(i);
  else {
    const l = ze(e),
      c = l && r0(n);
    if (l && n === "length") {
      const d = Number(r);
      o.forEach((f, p) => {
        (p === "length" || p === mc || !Cs(p) && p >= d) && i(f)
      })
    } else switch ((n !== void 0 || o.has(void 0)) && i(o.get(n)), c && i(o.get(mc)), t) {
      case "add":
        l ? c && i(o.get("length")) : (i(o.get(wi)), vl(e) && i(o.get(fh)));
        break;
      case "delete":
        l || (i(o.get(wi)), vl(e) && i(o.get(fh)));
        break;
      case "set":
        vl(e) && i(o.get(wi));
        break
    }
  }
  i0()
}

function i6(e, t) {
  const n = Cf.get(e);
  return n && n.get(t)
}

function nl(e) {
  const t = yt(e);
  return t === e ? t : (Wn(t, "iterate", mc), Gr(e) ? t : t.map(Rn))
}

function pp(e) {
  return Wn(e = yt(e), "iterate", mc), e
}
const l6 = {
  __proto__: null,
  [Symbol.iterator]() {
    return d1(this, Symbol.iterator, Rn)
  },
  concat(...e) {
    return nl(this).concat(...e.map(t => ze(t) ? nl(t) : t))
  },
  entries() {
    return d1(this, "entries", e => (e[1] = Rn(e[1]), e))
  },
  every(e, t) {
    return ia(this, "every", e, t, void 0, arguments)
  },
  filter(e, t) {
    return ia(this, "filter", e, t, n => n.map(Rn), arguments)
  },
  find(e, t) {
    return ia(this, "find", e, t, Rn, arguments)
  },
  findIndex(e, t) {
    return ia(this, "findIndex", e, t, void 0, arguments)
  },
  findLast(e, t) {
    return ia(this, "findLast", e, t, Rn, arguments)
  },
  findLastIndex(e, t) {
    return ia(this, "findLastIndex", e, t, void 0, arguments)
  },
  forEach(e, t) {
    return ia(this, "forEach", e, t, void 0, arguments)
  },
  includes(...e) {
    return f1(this, "includes", e)
  },
  indexOf(...e) {
    return f1(this, "indexOf", e)
  },
  join(e) {
    return nl(this).join(e)
  },
  lastIndexOf(...e) {
    return f1(this, "lastIndexOf", e)
  },
  map(e, t) {
    return ia(this, "map", e, t, void 0, arguments)
  },
  pop() {
    return Ru(this, "pop")
  },
  push(...e) {
    return Ru(this, "push", e)
  },
  reduce(e, ...t) {
    return s2(this, "reduce", e, t)
  },
  reduceRight(e, ...t) {
    return s2(this, "reduceRight", e, t)
  },
  shift() {
    return Ru(this, "shift")
  },
  some(e, t) {
    return ia(this, "some", e, t, void 0, arguments)
  },
  splice(...e) {
    return Ru(this, "splice", e)
  },
  toReversed() {
    return nl(this).toReversed()
  },
  toSorted(e) {
    return nl(this).toSorted(e)
  },
  toSpliced(...e) {
    return nl(this).toSpliced(...e)
  },
  unshift(...e) {
    return Ru(this, "unshift", e)
  },
  values() {
    return d1(this, "values", Rn)
  }
};

function d1(e, t, n) {
  const r = pp(e),
    s = r[t]();
  return r !== e && !Gr(e) && (s._next = s.next, s.next = () => {
    const a = s._next();
    return a.value && (a.value = n(a.value)), a
  }), s
}
const u6 = Array.prototype;

function ia(e, t, n, r, s, a) {
  const o = pp(e),
    i = o !== e && !Gr(e),
    l = o[t];
  if (l !== u6[t]) {
    const f = l.apply(e, a);
    return i ? Rn(f) : f
  }
  let c = n;
  o !== e && (i ? c = function(f, p) {
    return n.call(this, Rn(f), p, e)
  } : n.length > 2 && (c = function(f, p) {
    return n.call(this, f, p, e)
  }));
  const d = l.call(o, c, r);
  return i && s ? s(d) : d
}

function s2(e, t, n, r) {
  const s = pp(e);
  let a = n;
  return s !== e && (Gr(e) ? n.length > 3 && (a = function(o, i, l) {
    return n.call(this, o, i, l, e)
  }) : a = function(o, i, l) {
    return n.call(this, o, Rn(i), l, e)
  }), s[t](a, ...r)
}

function f1(e, t, n) {
  const r = yt(e);
  Wn(r, "iterate", mc);
  const s = r[t](...n);
  return (s === -1 || s === !1) && u0(n[0]) ? (n[0] = yt(n[0]), r[t](...n)) : s
}

function Ru(e, t, n = []) {
  Da(), o0();
  const r = yt(e)[t].apply(e, n);
  return i0(), La(), r
}
const c6 = e0("__proto__,__v_isRef,__isVue"),
  W3 = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(Cs));

function d6(e) {
  Cs(e) || (e = String(e));
  const t = yt(this);
  return Wn(t, "has", e), t.hasOwnProperty(e)
}
class G3 {
  constructor(t = !1, n = !1) {
    this._isReadonly = t, this._isShallow = n
  }
  get(t, n, r) {
    if (n === "__v_skip") return t.__v_skip;
    const s = this._isReadonly,
      a = this._isShallow;
    if (n === "__v_isReactive") return !s;
    if (n === "__v_isReadonly") return s;
    if (n === "__v_isShallow") return a;
    if (n === "__v_raw") return r === (s ? a ? X3 : J3 : a ? Z3 : K3).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(r) ? t : void 0;
    const o = ze(t);
    if (!s) {
      let l;
      if (o && (l = l6[n])) return l;
      if (n === "hasOwnProperty") return d6
    }
    const i = Reflect.get(t, n, Ht(t) ? t : r);
    return (Cs(n) ? W3.has(n) : c6(n)) || (s || Wn(t, "get", n), a) ? i : Ht(i) ? o && r0(n) ? i : i.value : Ft(i) ? s ? Ui(i) : xn(i) : i
  }
}
class Q3 extends G3 {
  constructor(t = !1) {
    super(!1, t)
  }
  set(t, n, r, s) {
    let a = t[n];
    if (!this._isShallow) {
      const l = Oo(a);
      if (!Gr(r) && !Oo(r) && (a = yt(a), r = yt(r)), !ze(t) && Ht(a) && !Ht(r)) return l ? !1 : (a.value = r, !0)
    }
    const o = ze(t) && r0(n) ? Number(n) < t.length : Et(t, n),
      i = Reflect.set(t, n, r, Ht(t) ? t : s);
    return t === yt(s) && (o ? wr(r, a) && wa(t, "set", n, r) : wa(t, "add", n, r)), i
  }
  deleteProperty(t, n) {
    const r = Et(t, n);
    t[n];
    const s = Reflect.deleteProperty(t, n);
    return s && r && wa(t, "delete", n, void 0), s
  }
  has(t, n) {
    const r = Reflect.has(t, n);
    return (!Cs(n) || !W3.has(n)) && Wn(t, "has", n), r
  }
  ownKeys(t) {
    return Wn(t, "iterate", ze(t) ? "length" : wi), Reflect.ownKeys(t)
  }
}
class q3 extends G3 {
  constructor(t = !1) {
    super(!0, t)
  }
  set(t, n) {
    return !0
  }
  deleteProperty(t, n) {
    return !0
  }
}
const f6 = new Q3,
  p6 = new q3,
  h6 = new Q3(!0),
  m6 = new q3(!0),
  ph = e => e,
  Td = e => Reflect.getPrototypeOf(e);

function g6(e, t, n) {
  return function(...r) {
    const s = this.__v_raw,
      a = yt(s),
      o = vl(a),
      i = e === "entries" || e === Symbol.iterator && o,
      l = e === "keys" && o,
      c = s[e](...r),
      d = n ? ph : t ? xf : Rn;
    return !t && Wn(a, "iterate", l ? fh : wi), {
      next() {
        const {
          value: f,
          done: p
        } = c.next();
        return p ? {
          value: f,
          done: p
        } : {
          value: i ? [d(f[0]), d(f[1])] : d(f),
          done: p
        }
      },
      [Symbol.iterator]() {
        return this
      }
    }
  }
}

function Ad(e) {
  return function(...t) {
    return e === "delete" ? !1 : e === "clear" ? void 0 : this
  }
}

function v6(e, t) {
  const n = {
    get(s) {
      const a = this.__v_raw,
        o = yt(a),
        i = yt(s);
      e || (wr(s, i) && Wn(o, "get", s), Wn(o, "get", i));
      const {
        has: l
      } = Td(o), c = t ? ph : e ? xf : Rn;
      if (l.call(o, s)) return c(a.get(s));
      if (l.call(o, i)) return c(a.get(i));
      a !== o && a.get(s)
    },
    get size() {
      const s = this.__v_raw;
      return !e && Wn(yt(s), "iterate", wi), Reflect.get(s, "size", s)
    },
    has(s) {
      const a = this.__v_raw,
        o = yt(a),
        i = yt(s);
      return e || (wr(s, i) && Wn(o, "has", s), Wn(o, "has", i)), s === i ? a.has(s) : a.has(s) || a.has(i)
    },
    forEach(s, a) {
      const o = this,
        i = o.__v_raw,
        l = yt(i),
        c = t ? ph : e ? xf : Rn;
      return !e && Wn(l, "iterate", wi), i.forEach((d, f) => s.call(a, c(d), c(f), o))
    }
  };
  return An(n, e ? {
    add: Ad("add"),
    set: Ad("set"),
    delete: Ad("delete"),
    clear: Ad("clear")
  } : {
    add(s) {
      !t && !Gr(s) && !Oo(s) && (s = yt(s));
      const a = yt(this);
      return Td(a).has.call(a, s) || (a.add(s), wa(a, "add", s, s)), this
    },
    set(s, a) {
      !t && !Gr(a) && !Oo(a) && (a = yt(a));
      const o = yt(this),
        {
          has: i,
          get: l
        } = Td(o);
      let c = i.call(o, s);
      c || (s = yt(s), c = i.call(o, s));
      const d = l.call(o, s);
      return o.set(s, a), c ? wr(a, d) && wa(o, "set", s, a) : wa(o, "add", s, a), this
    },
    delete(s) {
      const a = yt(this),
        {
          has: o,
          get: i
        } = Td(a);
      let l = o.call(a, s);
      l || (s = yt(s), l = o.call(a, s)), i && i.call(a, s);
      const c = a.delete(s);
      return l && wa(a, "delete", s, void 0), c
    },
    clear() {
      const s = yt(this),
        a = s.size !== 0,
        o = s.clear();
      return a && wa(s, "clear", void 0, void 0), o
    }
  }), ["keys", "values", "entries", Symbol.iterator].forEach(s => {
    n[s] = g6(s, e, t)
  }), n
}

function hp(e, t) {
  const n = v6(e, t);
  return (r, s, a) => s === "__v_isReactive" ? !e : s === "__v_isReadonly" ? e : s === "__v_raw" ? r : Reflect.get(Et(n, s) && s in r ? n : r, s, a)
}
const _6 = {
    get: hp(!1, !1)
  },
  y6 = {
    get: hp(!1, !0)
  },
  b6 = {
    get: hp(!0, !1)
  },
  w6 = {
    get: hp(!0, !0)
  },
  K3 = new WeakMap,
  Z3 = new WeakMap,
  J3 = new WeakMap,
  X3 = new WeakMap;

function C6(e) {
  switch (e) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0
  }
}

function x6(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : C6(Q7(e))
}

function xn(e) {
  return Oo(e) ? e : gp(e, !1, f6, _6, K3)
}

function mp(e) {
  return gp(e, !1, h6, y6, Z3)
}

function Ui(e) {
  return gp(e, !0, p6, b6, J3)
}

function lo(e) {
  return gp(e, !0, m6, w6, X3)
}

function gp(e, t, n, r, s) {
  if (!Ft(e) || e.__v_raw && !(t && e.__v_isReactive)) return e;
  const a = x6(e);
  if (a === 0) return e;
  const o = s.get(e);
  if (o) return o;
  const i = new Proxy(e, a === 2 ? r : n);
  return s.set(e, i), i
}

function _l(e) {
  return Oo(e) ? _l(e.__v_raw) : !!(e && e.__v_isReactive)
}

function Oo(e) {
  return !!(e && e.__v_isReadonly)
}

function Gr(e) {
  return !!(e && e.__v_isShallow)
}

function u0(e) {
  return e ? !!e.__v_raw : !1
}

function yt(e) {
  const t = e && e.__v_raw;
  return t ? yt(t) : e
}

function k6(e) {
  return !Et(e, "__v_skip") && Object.isExtensible(e) && O3(e, "__v_skip", !0), e
}
const Rn = e => Ft(e) ? xn(e) : e,
  xf = e => Ft(e) ? Ui(e) : e;

function Ht(e) {
  return e ? e.__v_isRef === !0 : !1
}

function U(e) {
  return e5(e, !1)
}

function vp(e) {
  return e5(e, !0)
}

function e5(e, t) {
  return Ht(e) ? e : new S6(e, t)
}
class S6 {
  constructor(t, n) {
    this.dep = new fp, this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = n ? t : yt(t), this._value = n ? t : Rn(t), this.__v_isShallow = n
  }
  get value() {
    return this.dep.track(), this._value
  }
  set value(t) {
    const n = this._rawValue,
      r = this.__v_isShallow || Gr(t) || Oo(t);
    t = r ? t : yt(t), wr(t, n) && (this._rawValue = t, this._value = r ? t : Rn(t), this.dep.trigger())
  }
}

function u(e) {
  return Ht(e) ? e.value : e
}
const E6 = {
  get: (e, t, n) => t === "__v_raw" ? e : u(Reflect.get(e, t, n)),
  set: (e, t, n, r) => {
    const s = e[t];
    return Ht(s) && !Ht(n) ? (s.value = n, !0) : Reflect.set(e, t, n, r)
  }
};

function t5(e) {
  return _l(e) ? e : new Proxy(e, E6)
}
class T6 {
  constructor(t) {
    this.__v_isRef = !0, this._value = void 0;
    const n = this.dep = new fp,
      {
        get: r,
        set: s
      } = t(n.track.bind(n), n.trigger.bind(n));
    this._get = r, this._set = s
  }
  get value() {
    return this._value = this._get()
  }
  set value(t) {
    this._set(t)
  }
}

function n5(e) {
  return new T6(e)
}

function Hr(e) {
  const t = ze(e) ? new Array(e.length) : {};
  for (const n in e) t[n] = r5(e, n);
  return t
}
class A6 {
  constructor(t, n, r) {
    this._object = t, this._key = n, this._defaultValue = r, this.__v_isRef = !0, this._value = void 0
  }
  get value() {
    const t = this._object[this._key];
    return this._value = t === void 0 ? this._defaultValue : t
  }
  set value(t) {
    this._object[this._key] = t
  }
  get dep() {
    return i6(yt(this._object), this._key)
  }
}
class P6 {
  constructor(t) {
    this._getter = t, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0
  }
  get value() {
    return this._value = this._getter()
  }
}

function zl(e, t, n) {
  return Ht(e) ? e : et(e) ? new P6(e) : Ft(e) && arguments.length > 1 ? r5(e, t, n) : U(e)
}

function r5(e, t, n) {
  const r = e[t];
  return Ht(r) ? r : new A6(e, t, n)
}
class I6 {
  constructor(t, n, r) {
    this.fn = t, this.setter = n, this._value = void 0, this.dep = new fp(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = hc - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = r
  }
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && Vt !== this) return j3(this, !0), !0
  }
  get value() {
    const t = this.dep.track();
    return U3(this), t && (t.version = this.dep.version), this._value
  }
  set value(t) {
    this.setter && this.setter(t)
  }
}

function $6(e, t, n = !1) {
  let r, s;
  return et(e) ? r = e : (r = e.get, s = e.set), new I6(r, s, n)
}
const Pd = {},
  kf = new WeakMap;
let oi;

function M6(e, t = !1, n = oi) {
  if (n) {
    let r = kf.get(n);
    r || kf.set(n, r = []), r.push(e)
  }
}

function O6(e, t, n = kt) {
  const {
    immediate: r,
    deep: s,
    once: a,
    scheduler: o,
    augmentJob: i,
    call: l
  } = n, c = x => s ? x : Gr(x) || s === !1 || s === 0 ? Ca(x, 1) : Ca(x);
  let d, f, p, h, _ = !1,
    v = !1;
  if (Ht(e) ? (f = () => e.value, _ = Gr(e)) : _l(e) ? (f = () => c(e), _ = !0) : ze(e) ? (v = !0, _ = e.some(x => _l(x) || Gr(x)), f = () => e.map(x => {
      if (Ht(x)) return x.value;
      if (_l(x)) return c(x);
      if (et(x)) return l ? l(x, 2) : x()
    })) : et(e) ? t ? f = l ? () => l(e, 2) : e : f = () => {
      if (p) {
        Da();
        try {
          p()
        } finally {
          La()
        }
      }
      const x = oi;
      oi = d;
      try {
        return l ? l(e, 3, [h]) : e(h)
      } finally {
        oi = x
      }
    } : f = Ys, t && s) {
    const x = f,
      E = s === !0 ? 1 / 0 : s;
    f = () => Ca(x(), E)
  }
  const C = Kc(),
    y = () => {
      d.stop(), C && C.active && n0(C.effects, d)
    };
  if (a && t) {
    const x = t;
    t = (...E) => {
      x(...E), y()
    }
  }
  let b = v ? new Array(e.length).fill(Pd) : Pd;
  const w = x => {
    if (!(!(d.flags & 1) || !d.dirty && !x))
      if (t) {
        const E = d.run();
        if (s || _ || (v ? E.some((S, T) => wr(S, b[T])) : wr(E, b))) {
          p && p();
          const S = oi;
          oi = d;
          try {
            const T = [E, b === Pd ? void 0 : v && b[0] === Pd ? [] : b, h];
            b = E, l ? l(t, 3, T) : t(...T)
          } finally {
            oi = S
          }
        }
      } else d.run()
  };
  return i && i(w), d = new F3(f), d.scheduler = o ? () => o(w, !1) : w, h = x => M6(x, !1, d), p = d.onStop = () => {
    const x = kf.get(d);
    if (x) {
      if (l) l(x, 4);
      else
        for (const E of x) E();
      kf.delete(d)
    }
  }, t ? r ? w(!0) : b = d.run() : o ? o(w.bind(null, !0), !0) : d.run(), y.pause = d.pause.bind(d), y.resume = d.resume.bind(d), y.stop = y, y
}

function Ca(e, t = 1 / 0, n) {
  if (t <= 0 || !Ft(e) || e.__v_skip || (n = n || new Set, n.has(e))) return e;
  if (n.add(e), t--, Ht(e)) Ca(e.value, t, n);
  else if (ze(e))
    for (let r = 0; r < e.length; r++) Ca(e[r], t, n);
  else if (pu(e) || vl(e)) e.forEach(r => {
    Ca(r, t, n)
  });
  else if (M3(e)) {
    for (const r in e) Ca(e[r], t, n);
    for (const r of Object.getOwnPropertySymbols(e)) Object.prototype.propertyIsEnumerable.call(e, r) && Ca(e[r], t, n)
  }
  return e
}
/**
 * @vue/runtime-core v3.5.15
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
function Zc(e, t, n, r) {
  try {
    return r ? e(...r) : e()
  } catch (s) {
    _p(s, t, n)
  }
}

function xs(e, t, n, r) {
  if (et(e)) {
    const s = Zc(e, t, n, r);
    return s && I3(s) && s.catch(a => {
      _p(a, t, n)
    }), s
  }
  if (ze(e)) {
    const s = [];
    for (let a = 0; a < e.length; a++) s.push(xs(e[a], t, n, r));
    return s
  }
}

function _p(e, t, n, r = !0) {
  const s = t ? t.vnode : null,
    {
      errorHandler: a,
      throwUnhandledErrorInProduction: o
    } = t && t.appContext.config || kt;
  if (t) {
    let i = t.parent;
    const l = t.proxy,
      c = `https://vuejs.org/error-reference/#runtime-${n}`;
    for (; i;) {
      const d = i.ec;
      if (d) {
        for (let f = 0; f < d.length; f++)
          if (d[f](e, l, c) === !1) return
      }
      i = i.parent
    }
    if (a) {
      Da(), Zc(a, null, 10, [e, l, c]), La();
      return
    }
  }
  D6(e, n, s, r, o)
}

function D6(e, t, n, r = !0, s = !1) {
  if (s) throw e;
  console.error(e)
}
const ir = [];
let Ls = -1;
const yl = [];
let uo = null,
  il = 0;
const s5 = Promise.resolve();
let Sf = null;

function Ot(e) {
  const t = Sf || s5;
  return e ? t.then(this ? e.bind(this) : e) : t
}

function L6(e) {
  let t = Ls + 1,
    n = ir.length;
  for (; t < n;) {
    const r = t + n >>> 1,
      s = ir[r],
      a = gc(s);
    a < e || a === e && s.flags & 2 ? t = r + 1 : n = r
  }
  return t
}

function c0(e) {
  if (!(e.flags & 1)) {
    const t = gc(e),
      n = ir[ir.length - 1];
    !n || !(e.flags & 2) && t >= gc(n) ? ir.push(e) : ir.splice(L6(t), 0, e), e.flags |= 1, a5()
  }
}

function a5() {
  Sf || (Sf = s5.then(i5))
}

function R6(e) {
  ze(e) ? yl.push(...e) : uo && e.id === -1 ? uo.splice(il + 1, 0, e) : e.flags & 1 || (yl.push(e), e.flags |= 1), a5()
}

function a2(e, t, n = Ls + 1) {
  for (; n < ir.length; n++) {
    const r = ir[n];
    if (r && r.flags & 2) {
      if (e && r.id !== e.uid) continue;
      ir.splice(n, 1), n--, r.flags & 4 && (r.flags &= -2), r(), r.flags & 4 || (r.flags &= -2)
    }
  }
}

function o5(e) {
  if (yl.length) {
    const t = [...new Set(yl)].sort((n, r) => gc(n) - gc(r));
    if (yl.length = 0, uo) {
      uo.push(...t);
      return
    }
    for (uo = t, il = 0; il < uo.length; il++) {
      const n = uo[il];
      n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2
    }
    uo = null, il = 0
  }
}
const gc = e => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id;

function i5(e) {
  try {
    for (Ls = 0; Ls < ir.length; Ls++) {
      const t = ir[Ls];
      t && !(t.flags & 8) && (t.flags & 4 && (t.flags &= -2), Zc(t, t.i, t.i ? 15 : 14), t.flags & 4 || (t.flags &= -2))
    }
  } finally {
    for (; Ls < ir.length; Ls++) {
      const t = ir[Ls];
      t && (t.flags &= -2)
    }
    Ls = -1, ir.length = 0, o5(), Sf = null, (ir.length || yl.length) && i5()
  }
}
let En = null,
  l5 = null;

function Ef(e) {
  const t = En;
  return En = e, l5 = e && e.type.__scopeId || null, t
}

function V(e, t = En, n) {
  if (!t || e._n) return e;
  const r = (...s) => {
    r._d && y2(-1);
    const a = Ef(t);
    let o;
    try {
      o = e(...s)
    } finally {
      Ef(a), r._d && y2(1)
    }
    return o
  };
  return r._n = !0, r._c = !0, r._d = !0, r
}

function Tn(e, t) {
  if (En === null) return e;
  const n = Cp(En),
    r = e.dirs || (e.dirs = []);
  for (let s = 0; s < t.length; s++) {
    let [a, o, i, l = kt] = t[s];
    a && (et(a) && (a = {
      mounted: a,
      updated: a
    }), a.deep && Ca(o), r.push({
      dir: a,
      instance: n,
      value: o,
      oldValue: void 0,
      arg: i,
      modifiers: l
    }))
  }
  return e
}

function ni(e, t, n, r) {
  const s = e.dirs,
    a = t && t.dirs;
  for (let o = 0; o < s.length; o++) {
    const i = s[o];
    a && (i.oldValue = a[o].value);
    let l = i.dir[r];
    l && (Da(), xs(l, n, 8, [e.el, i, e, t]), La())
  }
}
const u5 = Symbol("_vte"),
  c5 = e => e.__isTeleport,
  nc = e => e && (e.disabled || e.disabled === ""),
  o2 = e => e && (e.defer || e.defer === ""),
  i2 = e => typeof SVGElement < "u" && e instanceof SVGElement,
  l2 = e => typeof MathMLElement == "function" && e instanceof MathMLElement,
  hh = (e, t) => {
    const n = e && e.to;
    return Xt(n) ? t ? t(n) : null : n
  },
  d5 = {
    name: "Teleport",
    __isTeleport: !0,
    process(e, t, n, r, s, a, o, i, l, c) {
      const {
        mc: d,
        pc: f,
        pbc: p,
        o: {
          insert: h,
          querySelector: _,
          createText: v,
          createComment: C
        }
      } = c, y = nc(t.props);
      let {
        shapeFlag: b,
        children: w,
        dynamicChildren: x
      } = t;
      if (e == null) {
        const E = t.el = v(""),
          S = t.anchor = v("");
        h(E, n, r), h(S, n, r);
        const T = (P, N) => {
            b & 16 && (s && s.isCE && (s.ce._teleportTarget = P), d(w, P, N, s, a, o, i, l))
          },
          j = () => {
            const P = t.target = hh(t.props, _),
              N = f5(P, t, v, h);
            P && (o !== "svg" && i2(P) ? o = "svg" : o !== "mathml" && l2(P) && (o = "mathml"), y || (T(P, N), sf(t, !1)))
          };
        y && (T(n, S), sf(t, !0)), o2(t.props) ? (t.el.__isMounted = !1, ar(() => {
          j(), delete t.el.__isMounted
        }, a)) : j()
      } else {
        if (o2(t.props) && e.el.__isMounted === !1) {
          ar(() => {
            d5.process(e, t, n, r, s, a, o, i, l, c)
          }, a);
          return
        }
        t.el = e.el, t.targetStart = e.targetStart;
        const E = t.anchor = e.anchor,
          S = t.target = e.target,
          T = t.targetAnchor = e.targetAnchor,
          j = nc(e.props),
          P = j ? n : S,
          N = j ? E : T;
        if (o === "svg" || i2(S) ? o = "svg" : (o === "mathml" || l2(S)) && (o = "mathml"), x ? (p(e.dynamicChildren, x, P, s, a, o, i), v0(e, t, !0)) : l || f(e, t, P, N, s, a, o, i, !1), y) j ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to) : Id(t, n, E, c, 1);
        else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
          const ne = t.target = hh(t.props, _);
          ne && Id(t, ne, null, c, 0)
        } else j && Id(t, S, T, c, 1);
        sf(t, y)
      }
    },
    remove(e, t, n, {
      um: r,
      o: {
        remove: s
      }
    }, a) {
      const {
        shapeFlag: o,
        children: i,
        anchor: l,
        targetStart: c,
        targetAnchor: d,
        target: f,
        props: p
      } = e;
      if (f && (s(c), s(d)), a && s(l), o & 16) {
        const h = a || !nc(p);
        for (let _ = 0; _ < i.length; _++) {
          const v = i[_];
          r(v, t, n, h, !!v.dynamicChildren)
        }
      }
    },
    move: Id,
    hydrate: N6
  };

function Id(e, t, n, {
  o: {
    insert: r
  },
  m: s
}, a = 2) {
  a === 0 && r(e.targetAnchor, t, n);
  const {
    el: o,
    anchor: i,
    shapeFlag: l,
    children: c,
    props: d
  } = e, f = a === 2;
  if (f && r(o, t, n), (!f || nc(d)) && l & 16)
    for (let p = 0; p < c.length; p++) s(c[p], t, n, 2);
  f && r(i, t, n)
}

function N6(e, t, n, r, s, a, {
  o: {
    nextSibling: o,
    parentNode: i,
    querySelector: l,
    insert: c,
    createText: d
  }
}, f) {
  const p = t.target = hh(t.props, l);
  if (p) {
    const h = nc(t.props),
      _ = p._lpa || p.firstChild;
    if (t.shapeFlag & 16)
      if (h) t.anchor = f(o(e), t, i(e), n, r, s, a), t.targetStart = _, t.targetAnchor = _ && o(_);
      else {
        t.anchor = o(e);
        let v = _;
        for (; v;) {
          if (v && v.nodeType === 8) {
            if (v.data === "teleport start anchor") t.targetStart = v;
            else if (v.data === "teleport anchor") {
              t.targetAnchor = v, p._lpa = t.targetAnchor && o(t.targetAnchor);
              break
            }
          }
          v = o(v)
        }
        t.targetAnchor || f5(p, t, d, c), f(_ && o(_), t, p, n, r, s, a)
      } sf(t, h)
  }
  return t.anchor && o(t.anchor)
}
const Jc = d5;

function sf(e, t) {
  const n = e.ctx;
  if (n && n.ut) {
    let r, s;
    for (t ? (r = e.el, s = e.anchor) : (r = e.targetStart, s = e.targetAnchor); r && r !== s;) r.nodeType === 1 && r.setAttribute("data-v-owner", n.uid), r = r.nextSibling;
    n.ut()
  }
}

function f5(e, t, n, r) {
  const s = t.targetStart = n(""),
    a = t.targetAnchor = n("");
  return s[u5] = a, e && (r(s, e), r(a, e)), a
}
const co = Symbol("_leaveCb"),
  $d = Symbol("_enterCb");

function F6() {
  const e = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: new Map
  };
  return Ge(() => {
    e.isMounted = !0
  }), Xc(() => {
    e.isUnmounting = !0
  }), e
}
const Vr = [Function, Array],
  p5 = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: Vr,
    onEnter: Vr,
    onAfterEnter: Vr,
    onEnterCancelled: Vr,
    onBeforeLeave: Vr,
    onLeave: Vr,
    onAfterLeave: Vr,
    onLeaveCancelled: Vr,
    onBeforeAppear: Vr,
    onAppear: Vr,
    onAfterAppear: Vr,
    onAppearCancelled: Vr
  },
  h5 = e => {
    const t = e.subTree;
    return t.component ? h5(t.component) : t
  },
  B6 = {
    name: "BaseTransition",
    props: p5,
    setup(e, {
      slots: t
    }) {
      const n = gr(),
        r = F6();
      return () => {
        const s = t.default && v5(t.default(), !0);
        if (!s || !s.length) return;
        const a = m5(s),
          o = yt(e),
          {
            mode: i
          } = o;
        if (r.isLeaving) return p1(a);
        const l = u2(a);
        if (!l) return p1(a);
        let c = mh(l, o, r, n, f => c = f);
        l.type !== Fn && vc(l, c);
        let d = n.subTree && u2(n.subTree);
        if (d && d.type !== Fn && !ui(l, d) && h5(n).type !== Fn) {
          let f = mh(d, o, r, n);
          if (vc(d, f), i === "out-in" && l.type !== Fn) return r.isLeaving = !0, f.afterLeave = () => {
            r.isLeaving = !1, n.job.flags & 8 || n.update(), delete f.afterLeave, d = void 0
          }, p1(a);
          i === "in-out" && l.type !== Fn ? f.delayLeave = (p, h, _) => {
            const v = g5(r, d);
            v[String(d.key)] = d, p[co] = () => {
              h(), p[co] = void 0, delete c.delayedLeave, d = void 0
            }, c.delayedLeave = () => {
              _(), delete c.delayedLeave, d = void 0
            }
          } : d = void 0
        } else d && (d = void 0);
        return a
      }
    }
  };

function m5(e) {
  let t = e[0];
  if (e.length > 1) {
    for (const n of e)
      if (n.type !== Fn) {
        t = n;
        break
      }
  }
  return t
}
const j6 = B6;

function g5(e, t) {
  const {
    leavingVNodes: n
  } = e;
  let r = n.get(t.type);
  return r || (r = Object.create(null), n.set(t.type, r)), r
}

function mh(e, t, n, r, s) {
  const {
    appear: a,
    mode: o,
    persisted: i = !1,
    onBeforeEnter: l,
    onEnter: c,
    onAfterEnter: d,
    onEnterCancelled: f,
    onBeforeLeave: p,
    onLeave: h,
    onAfterLeave: _,
    onLeaveCancelled: v,
    onBeforeAppear: C,
    onAppear: y,
    onAfterAppear: b,
    onAppearCancelled: w
  } = t, x = String(e.key), E = g5(n, e), S = (P, N) => {
    P && xs(P, r, 9, N)
  }, T = (P, N) => {
    const ne = N[1];
    S(P, N), ze(P) ? P.every(Y => Y.length <= 1) && ne() : P.length <= 1 && ne()
  }, j = {
    mode: o,
    persisted: i,
    beforeEnter(P) {
      let N = l;
      if (!n.isMounted)
        if (a) N = C || l;
        else return;
      P[co] && P[co](!0);
      const ne = E[x];
      ne && ui(e, ne) && ne.el[co] && ne.el[co](), S(N, [P])
    },
    enter(P) {
      let N = c,
        ne = d,
        Y = f;
      if (!n.isMounted)
        if (a) N = y || c, ne = b || d, Y = w || f;
        else return;
      let _e = !1;
      const Q = P[$d] = re => {
        _e || (_e = !0, re ? S(Y, [P]) : S(ne, [P]), j.delayedLeave && j.delayedLeave(), P[$d] = void 0)
      };
      N ? T(N, [P, Q]) : Q()
    },
    leave(P, N) {
      const ne = String(e.key);
      if (P[$d] && P[$d](!0), n.isUnmounting) return N();
      S(p, [P]);
      let Y = !1;
      const _e = P[co] = Q => {
        Y || (Y = !0, N(), Q ? S(v, [P]) : S(_, [P]), P[co] = void 0, E[ne] === e && delete E[ne])
      };
      E[ne] = e, h ? T(h, [P, _e]) : _e()
    },
    clone(P) {
      const N = mh(P, t, n, r, s);
      return s && s(N), N
    }
  };
  return j
}

function p1(e) {
  if (yp(e)) return e = Ra(e), e.children = null, e
}

function u2(e) {
  if (!yp(e)) return c5(e.type) && e.children ? m5(e.children) : e;
  if (e.component) return e.component.subTree;
  const {
    shapeFlag: t,
    children: n
  } = e;
  if (n) {
    if (t & 16) return n[0];
    if (t & 32 && et(n.default)) return n.default()
  }
}

function vc(e, t) {
  e.shapeFlag & 6 && e.component ? (e.transition = t, vc(e.component.subTree, t)) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t
}

function v5(e, t = !1, n) {
  let r = [],
    s = 0;
  for (let a = 0; a < e.length; a++) {
    let o = e[a];
    const i = n == null ? o.key : String(n) + String(o.key != null ? o.key : a);
    o.type === Ee ? (o.patchFlag & 128 && s++, r = r.concat(v5(o.children, t, i))) : (t || o.type !== Fn) && r.push(i != null ? Ra(o, {
      key: i
    }) : o)
  }
  if (s > 1)
    for (let a = 0; a < r.length; a++) r[a].patchFlag = -2;
  return r
} /*! #__NO_SIDE_EFFECTS__ */
function te(e, t) {
  return et(e) ? An({
    name: e.name
  }, t, {
    setup: e
  }) : e
}

function c2() {
  const e = gr();
  return e ? (e.appContext.config.idPrefix || "v") + "-" + e.ids[0] + e.ids[1]++ : ""
}

function _5(e) {
  e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0]
}

function Tf(e, t, n, r, s = !1) {
  if (ze(e)) {
    e.forEach((_, v) => Tf(_, t && (ze(t) ? t[v] : t), n, r, s));
    return
  }
  if (bl(r) && !s) {
    r.shapeFlag & 512 && r.type.__asyncResolved && r.component.subTree.component && Tf(e, t, n, r.component.subTree);
    return
  }
  const a = r.shapeFlag & 4 ? Cp(r.component) : r.el,
    o = s ? null : a,
    {
      i,
      r: l
    } = e,
    c = t && t.r,
    d = i.refs === kt ? i.refs = {} : i.refs,
    f = i.setupState,
    p = yt(f),
    h = f === kt ? () => !1 : _ => Et(p, _);
  if (c != null && c !== l && (Xt(c) ? (d[c] = null, h(c) && (f[c] = null)) : Ht(c) && (c.value = null)), et(l)) Zc(l, i, 12, [o, d]);
  else {
    const _ = Xt(l),
      v = Ht(l);
    if (_ || v) {
      const C = () => {
        if (e.f) {
          const y = _ ? h(l) ? f[l] : d[l] : l.value;
          s ? ze(y) && n0(y, a) : ze(y) ? y.includes(a) || y.push(a) : _ ? (d[l] = [a], h(l) && (f[l] = d[l])) : (l.value = [a], e.k && (d[e.k] = l.value))
        } else _ ? (d[l] = o, h(l) && (f[l] = o)) : v && (l.value = o, e.k && (d[e.k] = o))
      };
      o ? (C.id = -1, ar(C, n)) : C()
    }
  }
}
dp().requestIdleCallback;
dp().cancelIdleCallback;
const bl = e => !!e.type.__asyncLoader,
  yp = e => e.type.__isKeepAlive;

function H6(e, t) {
  y5(e, "a", t)
}

function V6(e, t) {
  y5(e, "da", t)
}

function y5(e, t, n = $n) {
  const r = e.__wdc || (e.__wdc = () => {
    let s = n;
    for (; s;) {
      if (s.isDeactivated) return;
      s = s.parent
    }
    return e()
  });
  if (bp(t, r, n), n) {
    let s = n.parent;
    for (; s && s.parent;) yp(s.parent.vnode) && U6(r, t, n, s), s = s.parent
  }
}

function U6(e, t, n, r) {
  const s = bp(t, e, r, !0);
  en(() => {
    n0(r[t], s)
  }, n)
}

function bp(e, t, n = $n, r = !1) {
  if (n) {
    const s = n[e] || (n[e] = []),
      a = t.__weh || (t.__weh = (...o) => {
        Da();
        const i = nd(n),
          l = xs(t, n, e, o);
        return i(), La(), l
      });
    return r ? s.unshift(a) : s.push(a), a
  }
}
const Wa = e => (t, n = $n) => {
    (!bc || e === "sp") && bp(e, (...r) => t(...r), n)
  },
  d0 = Wa("bm"),
  Ge = Wa("m"),
  f0 = Wa("bu"),
  b5 = Wa("u"),
  Xc = Wa("bum"),
  en = Wa("um"),
  z6 = Wa("sp"),
  Y6 = Wa("rtg"),
  W6 = Wa("rtc");

function G6(e, t = $n) {
  bp("ec", e, t)
}
const p0 = "components",
  Q6 = "directives";

function w5(e, t) {
  return h0(p0, e, !0, t) || e
}
const C5 = Symbol.for("v-ndc");

function Kr(e) {
  return Xt(e) ? h0(p0, e, !1) || e : e || C5
}

function x5(e) {
  return h0(Q6, e)
}

function h0(e, t, n = !0, r = !1) {
  const s = En || $n;
  if (s) {
    const a = s.type;
    if (e === p0) {
      const i = Nw(a, !1);
      if (i && (i === t || i === dr(t) || i === cp(dr(t)))) return a
    }
    const o = d2(s[e] || a[e], t) || d2(s.appContext[e], t);
    return !o && r ? a : o
  }
}

function d2(e, t) {
  return e && (e[t] || e[dr(t)] || e[cp(dr(t))])
}

function Je(e, t, n, r) {
  let s;
  const a = n,
    o = ze(e);
  if (o || Xt(e)) {
    const i = o && _l(e);
    let l = !1,
      c = !1;
    i && (l = !Gr(e), c = Oo(e), e = pp(e)), s = new Array(e.length);
    for (let d = 0, f = e.length; d < f; d++) s[d] = t(l ? c ? xf(Rn(e[d])) : Rn(e[d]) : e[d], d, void 0, a)
  } else if (typeof e == "number") {
    s = new Array(e);
    for (let i = 0; i < e; i++) s[i] = t(i + 1, i, void 0, a)
  } else if (Ft(e))
    if (e[Symbol.iterator]) s = Array.from(e, (i, l) => t(i, l, void 0, a));
    else {
      const i = Object.keys(e);
      s = new Array(i.length);
      for (let l = 0, c = i.length; l < c; l++) {
        const d = i[l];
        s[l] = t(e[d], d, l, a)
      }
    }
  else s = [];
  return s
}

function Qn(e, t) {
  for (let n = 0; n < t.length; n++) {
    const r = t[n];
    if (ze(r))
      for (let s = 0; s < r.length; s++) e[r[s].name] = r[s].fn;
    else r && (e[r.name] = r.key ? (...s) => {
      const a = r.fn(...s);
      return a && (a.key = r.key), a
    } : r.fn)
  }
  return e
}

function ie(e, t, n = {}, r, s) {
  if (En.ce || En.parent && bl(En.parent) && En.parent.ce) return t !== "default" && (n.name = t), g(), G(Ee, null, [$("slot", n, r && r())], 64);
  let a = e[t];
  a && a._c && (a._d = !1), g();
  const o = a && k5(a(n)),
    i = n.key || o && o.key,
    l = G(Ee, {
      key: (i && !Cs(i) ? i : `_${t}`) + (!o && r ? "_fb" : "")
    }, o || (r ? r() : []), o && e._ === 1 ? 64 : -2);
  return l.scopeId && (l.slotScopeIds = [l.scopeId + "-s"]), a && a._c && (a._d = !0), l
}

function k5(e) {
  return e.some(t => Yl(t) ? !(t.type === Fn || t.type === Ee && !k5(t.children)) : !0) ? e : null
}
const gh = e => e ? z5(e) ? Cp(e) : gh(e.parent) : null,
  rc = An(Object.create(null), {
    $: e => e,
    $el: e => e.vnode.el,
    $data: e => e.data,
    $props: e => e.props,
    $attrs: e => e.attrs,
    $slots: e => e.slots,
    $refs: e => e.refs,
    $parent: e => gh(e.parent),
    $root: e => gh(e.root),
    $host: e => e.ce,
    $emit: e => e.emit,
    $options: e => T5(e),
    $forceUpdate: e => e.f || (e.f = () => {
      c0(e.update)
    }),
    $nextTick: e => e.n || (e.n = Ot.bind(e.proxy)),
    $watch: e => ww.bind(e)
  }),
  h1 = (e, t) => e !== kt && !e.__isScriptSetup && Et(e, t),
  q6 = {
    get({
      _: e
    }, t) {
      if (t === "__v_skip") return !0;
      const {
        ctx: n,
        setupState: r,
        data: s,
        props: a,
        accessCache: o,
        type: i,
        appContext: l
      } = e;
      let c;
      if (t[0] !== "$") {
        const h = o[t];
        if (h !== void 0) switch (h) {
          case 1:
            return r[t];
          case 2:
            return s[t];
          case 4:
            return n[t];
          case 3:
            return a[t]
        } else {
          if (h1(r, t)) return o[t] = 1, r[t];
          if (s !== kt && Et(s, t)) return o[t] = 2, s[t];
          if ((c = e.propsOptions[0]) && Et(c, t)) return o[t] = 3, a[t];
          if (n !== kt && Et(n, t)) return o[t] = 4, n[t];
          vh && (o[t] = 0)
        }
      }
      const d = rc[t];
      let f, p;
      if (d) return t === "$attrs" && Wn(e.attrs, "get", ""), d(e);
      if ((f = i.__cssModules) && (f = f[t])) return f;
      if (n !== kt && Et(n, t)) return o[t] = 4, n[t];
      if (p = l.config.globalProperties, Et(p, t)) return p[t]
    },
    set({
      _: e
    }, t, n) {
      const {
        data: r,
        setupState: s,
        ctx: a
      } = e;
      return h1(s, t) ? (s[t] = n, !0) : r !== kt && Et(r, t) ? (r[t] = n, !0) : Et(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (a[t] = n, !0)
    },
    has({
      _: {
        data: e,
        setupState: t,
        accessCache: n,
        ctx: r,
        appContext: s,
        propsOptions: a
      }
    }, o) {
      let i;
      return !!n[o] || e !== kt && Et(e, o) || h1(t, o) || (i = a[0]) && Et(i, o) || Et(r, o) || Et(rc, o) || Et(s.config.globalProperties, o)
    },
    defineProperty(e, t, n) {
      return n.get != null ? e._.accessCache[t] = 0 : Et(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n)
    }
  };

function zo() {
  return S5().slots
}

function K6() {
  return S5().attrs
}

function S5() {
  const e = gr();
  return e.setupContext || (e.setupContext = W5(e))
}

function _c(e) {
  return ze(e) ? e.reduce((t, n) => (t[n] = null, t), {}) : e
}

function Z6(e, t) {
  const n = _c(e);
  for (const r in t) {
    if (r.startsWith("__skip")) continue;
    let s = n[r];
    s ? ze(s) || et(s) ? s = n[r] = {
      type: s,
      default: t[r]
    } : s.default = t[r] : s === null && (s = n[r] = {
      default: t[r]
    }), s && t[`__skip_${r}`] && (s.skipFactory = !0)
  }
  return n
}

function J6(e, t) {
  return !e || !t ? e || t : ze(e) && ze(t) ? e.concat(t) : An({}, _c(e), _c(t))
}
let vh = !0;

function X6(e) {
  const t = T5(e),
    n = e.proxy,
    r = e.ctx;
  vh = !1, t.beforeCreate && f2(t.beforeCreate, e, "bc");
  const {
    data: s,
    computed: a,
    methods: o,
    watch: i,
    provide: l,
    inject: c,
    created: d,
    beforeMount: f,
    mounted: p,
    beforeUpdate: h,
    updated: _,
    activated: v,
    deactivated: C,
    beforeDestroy: y,
    beforeUnmount: b,
    destroyed: w,
    unmounted: x,
    render: E,
    renderTracked: S,
    renderTriggered: T,
    errorCaptured: j,
    serverPrefetch: P,
    expose: N,
    inheritAttrs: ne,
    components: Y,
    directives: _e,
    filters: Q
  } = t;
  if (c && ew(c, r, null), o)
    for (const ee in o) {
      const de = o[ee];
      et(de) && (r[ee] = de.bind(n))
    }
  if (s) {
    const ee = s.call(n, n);
    Ft(ee) && (e.data = xn(ee))
  }
  if (vh = !0, a)
    for (const ee in a) {
      const de = a[ee],
        se = et(de) ? de.bind(n, n) : et(de.get) ? de.get.bind(n, n) : Ys,
        ae = !et(de) && et(de.set) ? de.set.bind(n) : Ys,
        ke = L({
          get: se,
          set: ae
        });
      Object.defineProperty(r, ee, {
        enumerable: !0,
        configurable: !0,
        get: () => ke.value,
        set: be => ke.value = be
      })
    }
  if (i)
    for (const ee in i) E5(i[ee], r, n, ee);
  if (l) {
    const ee = et(l) ? l.call(n) : l;
    Reflect.ownKeys(ee).forEach(de => {
      xi(de, ee[de])
    })
  }
  d && f2(d, e, "c");

  function J(ee, de) {
    ze(de) ? de.forEach(se => ee(se.bind(n))) : de && ee(de.bind(n))
  }
  if (J(d0, f), J(Ge, p), J(f0, h), J(b5, _), J(H6, v), J(V6, C), J(G6, j), J(W6, S), J(Y6, T), J(Xc, b), J(en, x), J(z6, P), ze(N))
    if (N.length) {
      const ee = e.exposed || (e.exposed = {});
      N.forEach(de => {
        Object.defineProperty(ee, de, {
          get: () => n[de],
          set: se => n[de] = se
        })
      })
    } else e.exposed || (e.exposed = {});
  E && e.render === Ys && (e.render = E), ne != null && (e.inheritAttrs = ne), Y && (e.components = Y), _e && (e.directives = _e), P && _5(e)
}

function ew(e, t, n = Ys) {
  ze(e) && (e = _h(e));
  for (const r in e) {
    const s = e[r];
    let a;
    Ft(s) ? "default" in s ? a = Hn(s.from || r, s.default, !0) : a = Hn(s.from || r) : a = Hn(s), Ht(a) ? Object.defineProperty(t, r, {
      enumerable: !0,
      configurable: !0,
      get: () => a.value,
      set: o => a.value = o
    }) : t[r] = a
  }
}

function f2(e, t, n) {
  xs(ze(e) ? e.map(r => r.bind(t.proxy)) : e.bind(t.proxy), t, n)
}

function E5(e, t, n, r) {
  let s = r.includes(".") ? F5(n, r) : () => n[r];
  if (Xt(e)) {
    const a = t[e];
    et(a) && Ne(s, a)
  } else if (et(e)) Ne(s, e.bind(n));
  else if (Ft(e))
    if (ze(e)) e.forEach(a => E5(a, t, n, r));
    else {
      const a = et(e.handler) ? e.handler.bind(n) : t[e.handler];
      et(a) && Ne(s, a, e)
    }
}

function T5(e) {
  const t = e.type,
    {
      mixins: n,
      extends: r
    } = t,
    {
      mixins: s,
      optionsCache: a,
      config: {
        optionMergeStrategies: o
      }
    } = e.appContext,
    i = a.get(t);
  let l;
  return i ? l = i : !s.length && !n && !r ? l = t : (l = {}, s.length && s.forEach(c => Af(l, c, o, !0)), Af(l, t, o)), Ft(t) && a.set(t, l), l
}

function Af(e, t, n, r = !1) {
  const {
    mixins: s,
    extends: a
  } = t;
  a && Af(e, a, n, !0), s && s.forEach(o => Af(e, o, n, !0));
  for (const o in t)
    if (!(r && o === "expose")) {
      const i = tw[o] || n && n[o];
      e[o] = i ? i(e[o], t[o]) : t[o]
    } return e
}
const tw = {
  data: p2,
  props: h2,
  emits: h2,
  methods: Qu,
  computed: Qu,
  beforeCreate: er,
  created: er,
  beforeMount: er,
  mounted: er,
  beforeUpdate: er,
  updated: er,
  beforeDestroy: er,
  beforeUnmount: er,
  destroyed: er,
  unmounted: er,
  activated: er,
  deactivated: er,
  errorCaptured: er,
  serverPrefetch: er,
  components: Qu,
  directives: Qu,
  watch: rw,
  provide: p2,
  inject: nw
};

function p2(e, t) {
  return t ? e ? function() {
    return An(et(e) ? e.call(this, this) : e, et(t) ? t.call(this, this) : t)
  } : t : e
}

function nw(e, t) {
  return Qu(_h(e), _h(t))
}

function _h(e) {
  if (ze(e)) {
    const t = {};
    for (let n = 0; n < e.length; n++) t[e[n]] = e[n];
    return t
  }
  return e
}

function er(e, t) {
  return e ? [...new Set([].concat(e, t))] : t
}

function Qu(e, t) {
  return e ? An(Object.create(null), e, t) : t
}

function h2(e, t) {
  return e ? ze(e) && ze(t) ? [...new Set([...e, ...t])] : An(Object.create(null), _c(e), _c(t ?? {})) : t
}

function rw(e, t) {
  if (!e) return t;
  if (!t) return e;
  const n = An(Object.create(null), e);
  for (const r in t) n[r] = er(e[r], t[r]);
  return n
}

function A5() {
  return {
    app: null,
    config: {
      isNativeTag: W7,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: Object.create(null),
    optionsCache: new WeakMap,
    propsCache: new WeakMap,
    emitsCache: new WeakMap
  }
}
let sw = 0;

function aw(e, t) {
  return function(r, s = null) {
    et(r) || (r = An({}, r)), s != null && !Ft(s) && (s = null);
    const a = A5(),
      o = new WeakSet,
      i = [];
    let l = !1;
    const c = a.app = {
      _uid: sw++,
      _component: r,
      _props: s,
      _container: null,
      _context: a,
      _instance: null,
      version: Bw,
      get config() {
        return a.config
      },
      set config(d) {},
      use(d, ...f) {
        return o.has(d) || (d && et(d.install) ? (o.add(d), d.install(c, ...f)) : et(d) && (o.add(d), d(c, ...f))), c
      },
      mixin(d) {
        return a.mixins.includes(d) || a.mixins.push(d), c
      },
      component(d, f) {
        return f ? (a.components[d] = f, c) : a.components[d]
      },
      directive(d, f) {
        return f ? (a.directives[d] = f, c) : a.directives[d]
      },
      mount(d, f, p) {
        if (!l) {
          const h = c._ceVNode || $(r, s);
          return h.appContext = a, p === !0 ? p = "svg" : p === !1 && (p = void 0), e(h, d, p), l = !0, c._container = d, d.__vue_app__ = c, Cp(h.component)
        }
      },
      onUnmount(d) {
        i.push(d)
      },
      unmount() {
        l && (xs(i, c._instance, 16), e(null, c._container), delete c._container.__vue_app__)
      },
      provide(d, f) {
        return a.provides[d] = f, c
      },
      runWithContext(d) {
        const f = Ci;
        Ci = c;
        try {
          return d()
        } finally {
          Ci = f
        }
      }
    };
    return c
  }
}
let Ci = null;

function xi(e, t) {
  if ($n) {
    let n = $n.provides;
    const r = $n.parent && $n.parent.provides;
    r === n && (n = $n.provides = Object.create(r)), n[e] = t
  }
}

function Hn(e, t, n = !1) {
  const r = $n || En;
  if (r || Ci) {
    let s = Ci ? Ci._context.provides : r ? r.parent == null || r.ce ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : void 0;
    if (s && e in s) return s[e];
    if (arguments.length > 1) return n && et(t) ? t.call(r && r.proxy) : t
  }
}

function ow() {
  return !!($n || En || Ci)
}
const P5 = {},
  I5 = () => Object.create(P5),
  $5 = e => Object.getPrototypeOf(e) === P5;

function iw(e, t, n, r = !1) {
  const s = {},
    a = I5();
  e.propsDefaults = Object.create(null), M5(e, t, s, a);
  for (const o in e.propsOptions[0]) o in s || (s[o] = void 0);
  n ? e.props = r ? s : mp(s) : e.type.props ? e.props = s : e.props = a, e.attrs = a
}

function lw(e, t, n, r) {
  const {
    props: s,
    attrs: a,
    vnode: {
      patchFlag: o
    }
  } = e, i = yt(s), [l] = e.propsOptions;
  let c = !1;
  if ((r || o > 0) && !(o & 16)) {
    if (o & 8) {
      const d = e.vnode.dynamicProps;
      for (let f = 0; f < d.length; f++) {
        let p = d[f];
        if (wp(e.emitsOptions, p)) continue;
        const h = t[p];
        if (l)
          if (Et(a, p)) h !== a[p] && (a[p] = h, c = !0);
          else {
            const _ = dr(p);
            s[_] = yh(l, i, _, h, e, !1)
          }
        else h !== a[p] && (a[p] = h, c = !0)
      }
    }
  } else {
    M5(e, t, s, a) && (c = !0);
    let d;
    for (const f in i)(!t || !Et(t, f) && ((d = Ya(f)) === f || !Et(t, d))) && (l ? n && (n[f] !== void 0 || n[d] !== void 0) && (s[f] = yh(l, i, f, void 0, e, !0)) : delete s[f]);
    if (a !== i)
      for (const f in a)(!t || !Et(t, f)) && (delete a[f], c = !0)
  }
  c && wa(e.attrs, "set", "")
}

function M5(e, t, n, r) {
  const [s, a] = e.propsOptions;
  let o = !1,
    i;
  if (t)
    for (let l in t) {
      if (Xu(l)) continue;
      const c = t[l];
      let d;
      s && Et(s, d = dr(l)) ? !a || !a.includes(d) ? n[d] = c : (i || (i = {}))[d] = c : wp(e.emitsOptions, l) || (!(l in r) || c !== r[l]) && (r[l] = c, o = !0)
    }
  if (a) {
    const l = yt(n),
      c = i || kt;
    for (let d = 0; d < a.length; d++) {
      const f = a[d];
      n[f] = yh(s, l, f, c[f], e, !Et(c, f))
    }
  }
  return o
}

function yh(e, t, n, r, s, a) {
  const o = e[n];
  if (o != null) {
    const i = Et(o, "default");
    if (i && r === void 0) {
      const l = o.default;
      if (o.type !== Function && !o.skipFactory && et(l)) {
        const {
          propsDefaults: c
        } = s;
        if (n in c) r = c[n];
        else {
          const d = nd(s);
          r = c[n] = l.call(null, t), d()
        }
      } else r = l;
      s.ce && s.ce._setProp(n, r)
    }
    o[0] && (a && !i ? r = !1 : o[1] && (r === "" || r === Ya(n)) && (r = !0))
  }
  return r
}
const uw = new WeakMap;

function O5(e, t, n = !1) {
  const r = n ? uw : t.propsCache,
    s = r.get(e);
  if (s) return s;
  const a = e.props,
    o = {},
    i = [];
  let l = !1;
  if (!et(e)) {
    const d = f => {
      l = !0;
      const [p, h] = O5(f, t, !0);
      An(o, p), h && i.push(...h)
    };
    !n && t.mixins.length && t.mixins.forEach(d), e.extends && d(e.extends), e.mixins && e.mixins.forEach(d)
  }
  if (!a && !l) return Ft(e) && r.set(e, gl), gl;
  if (ze(a))
    for (let d = 0; d < a.length; d++) {
      const f = dr(a[d]);
      m2(f) && (o[f] = kt)
    } else if (a)
      for (const d in a) {
        const f = dr(d);
        if (m2(f)) {
          const p = a[d],
            h = o[f] = ze(p) || et(p) ? {
              type: p
            } : An({}, p),
            _ = h.type;
          let v = !1,
            C = !0;
          if (ze(_))
            for (let y = 0; y < _.length; ++y) {
              const b = _[y],
                w = et(b) && b.name;
              if (w === "Boolean") {
                v = !0;
                break
              } else w === "String" && (C = !1)
            } else v = et(_) && _.name === "Boolean";
          h[0] = v, h[1] = C, (v || Et(h, "default")) && i.push(f)
        }
      }
  const c = [o, i];
  return Ft(e) && r.set(e, c), c
}

function m2(e) {
  return e[0] !== "$" && !Xu(e)
}
const m0 = e => e[0] === "_" || e === "$stable",
  g0 = e => ze(e) ? e.map(Bs) : [Bs(e)],
  cw = (e, t, n) => {
    if (t._n) return t;
    const r = V((...s) => g0(t(...s)), n);
    return r._c = !1, r
  },
  D5 = (e, t, n) => {
    const r = e._ctx;
    for (const s in e) {
      if (m0(s)) continue;
      const a = e[s];
      if (et(a)) t[s] = cw(s, a, r);
      else if (a != null) {
        const o = g0(a);
        t[s] = () => o
      }
    }
  },
  L5 = (e, t) => {
    const n = g0(t);
    e.slots.default = () => n
  },
  R5 = (e, t, n) => {
    for (const r in t)(n || !m0(r)) && (e[r] = t[r])
  },
  dw = (e, t, n) => {
    const r = e.slots = I5();
    if (e.vnode.shapeFlag & 32) {
      const s = t._;
      s ? (R5(r, t, n), n && O3(r, "_", s, !0)) : D5(t, r)
    } else t && L5(e, t)
  },
  fw = (e, t, n) => {
    const {
      vnode: r,
      slots: s
    } = e;
    let a = !0,
      o = kt;
    if (r.shapeFlag & 32) {
      const i = t._;
      i ? n && i === 1 ? a = !1 : R5(s, t, n) : (a = !t.$stable, D5(t, s)), o = t
    } else t && (L5(e, t), o = {
      default: 1
    });
    if (a)
      for (const i in s) !m0(i) && o[i] == null && delete s[i]
  },
  ar = Aw;

function pw(e) {
  return hw(e)
}

function hw(e, t) {
  const n = dp();
  n.__VUE__ = !0;
  const {
    insert: r,
    remove: s,
    patchProp: a,
    createElement: o,
    createText: i,
    createComment: l,
    setText: c,
    setElementText: d,
    parentNode: f,
    nextSibling: p,
    setScopeId: h = Ys,
    insertStaticContent: _
  } = e, v = (I, M, W, O = null, q = null, he = null, A = void 0, F = null, K = !!M.dynamicChildren) => {
    if (I === M) return;
    I && !ui(I, M) && (O = D(I), be(I, q, he, !0), I = null), M.patchFlag === -2 && (K = !1, M.dynamicChildren = null);
    const {
      type: B,
      ref: ce,
      shapeFlag: le
    } = M;
    switch (B) {
      case td:
        C(I, M, W, O);
        break;
      case Fn:
        y(I, M, W, O);
        break;
      case af:
        I == null && b(M, W, O, A);
        break;
      case Ee:
        Y(I, M, W, O, q, he, A, F, K);
        break;
      default:
        le & 1 ? E(I, M, W, O, q, he, A, F, K) : le & 6 ? _e(I, M, W, O, q, he, A, F, K) : (le & 64 || le & 128) && B.process(I, M, W, O, q, he, A, F, K, Ae)
    }
    ce != null && q && Tf(ce, I && I.ref, he, M || I, !M)
  }, C = (I, M, W, O) => {
    if (I == null) r(M.el = i(M.children), W, O);
    else {
      const q = M.el = I.el;
      M.children !== I.children && c(q, M.children)
    }
  }, y = (I, M, W, O) => {
    I == null ? r(M.el = l(M.children || ""), W, O) : M.el = I.el
  }, b = (I, M, W, O) => {
    [I.el, I.anchor] = _(I.children, M, W, O, I.el, I.anchor)
  }, w = ({
    el: I,
    anchor: M
  }, W, O) => {
    let q;
    for (; I && I !== M;) q = p(I), r(I, W, O), I = q;
    r(M, W, O)
  }, x = ({
    el: I,
    anchor: M
  }) => {
    let W;
    for (; I && I !== M;) W = p(I), s(I), I = W;
    s(M)
  }, E = (I, M, W, O, q, he, A, F, K) => {
    M.type === "svg" ? A = "svg" : M.type === "math" && (A = "mathml"), I == null ? S(M, W, O, q, he, A, F, K) : P(I, M, q, he, A, F, K)
  }, S = (I, M, W, O, q, he, A, F) => {
    let K, B;
    const {
      props: ce,
      shapeFlag: le,
      transition: X,
      dirs: ve
    } = I;
    if (K = I.el = o(I.type, he, ce && ce.is, ce), le & 8 ? d(K, I.children) : le & 16 && j(I.children, K, null, O, q, m1(I, he), A, F), ve && ni(I, null, O, "created"), T(K, I, I.scopeId, A, O), ce) {
      for (const He in ce) He !== "value" && !Xu(He) && a(K, He, null, ce[He], he, O);
      "value" in ce && a(K, "value", null, ce.value, he), (B = ce.onVnodeBeforeMount) && Ms(B, O, I)
    }
    ve && ni(I, null, O, "beforeMount");
    const Se = mw(q, X);
    Se && X.beforeEnter(K), r(K, M, W), ((B = ce && ce.onVnodeMounted) || Se || ve) && ar(() => {
      B && Ms(B, O, I), Se && X.enter(K), ve && ni(I, null, O, "mounted")
    }, q)
  }, T = (I, M, W, O, q) => {
    if (W && h(I, W), O)
      for (let he = 0; he < O.length; he++) h(I, O[he]);
    if (q) {
      let he = q.subTree;
      if (M === he || H5(he.type) && (he.ssContent === M || he.ssFallback === M)) {
        const A = q.vnode;
        T(I, A, A.scopeId, A.slotScopeIds, q.parent)
      }
    }
  }, j = (I, M, W, O, q, he, A, F, K = 0) => {
    for (let B = K; B < I.length; B++) {
      const ce = I[B] = F ? fo(I[B]) : Bs(I[B]);
      v(null, ce, M, W, O, q, he, A, F)
    }
  }, P = (I, M, W, O, q, he, A) => {
    const F = M.el = I.el;
    let {
      patchFlag: K,
      dynamicChildren: B,
      dirs: ce
    } = M;
    K |= I.patchFlag & 16;
    const le = I.props || kt,
      X = M.props || kt;
    let ve;
    if (W && ri(W, !1), (ve = X.onVnodeBeforeUpdate) && Ms(ve, W, M, I), ce && ni(M, I, W, "beforeUpdate"), W && ri(W, !0), (le.innerHTML && X.innerHTML == null || le.textContent && X.textContent == null) && d(F, ""), B ? N(I.dynamicChildren, B, F, W, O, m1(M, q), he) : A || de(I, M, F, null, W, O, m1(M, q), he, !1), K > 0) {
      if (K & 16) ne(F, le, X, W, q);
      else if (K & 2 && le.class !== X.class && a(F, "class", null, X.class, q), K & 4 && a(F, "style", le.style, X.style, q), K & 8) {
        const Se = M.dynamicProps;
        for (let He = 0; He < Se.length; He++) {
          const Ve = Se[He],
            sn = le[Ve],
            Ut = X[Ve];
          (Ut !== sn || Ve === "value") && a(F, Ve, sn, Ut, q, W)
        }
      }
      K & 1 && I.children !== M.children && d(F, M.children)
    } else !A && B == null && ne(F, le, X, W, q);
    ((ve = X.onVnodeUpdated) || ce) && ar(() => {
      ve && Ms(ve, W, M, I), ce && ni(M, I, W, "updated")
    }, O)
  }, N = (I, M, W, O, q, he, A) => {
    for (let F = 0; F < M.length; F++) {
      const K = I[F],
        B = M[F],
        ce = K.el && (K.type === Ee || !ui(K, B) || K.shapeFlag & 198) ? f(K.el) : W;
      v(K, B, ce, null, O, q, he, A, !0)
    }
  }, ne = (I, M, W, O, q) => {
    if (M !== W) {
      if (M !== kt)
        for (const he in M) !Xu(he) && !(he in W) && a(I, he, M[he], null, q, O);
      for (const he in W) {
        if (Xu(he)) continue;
        const A = W[he],
          F = M[he];
        A !== F && he !== "value" && a(I, he, F, A, q, O)
      }
      "value" in W && a(I, "value", M.value, W.value, q)
    }
  }, Y = (I, M, W, O, q, he, A, F, K) => {
    const B = M.el = I ? I.el : i(""),
      ce = M.anchor = I ? I.anchor : i("");
    let {
      patchFlag: le,
      dynamicChildren: X,
      slotScopeIds: ve
    } = M;
    ve && (F = F ? F.concat(ve) : ve), I == null ? (r(B, W, O), r(ce, W, O), j(M.children || [], W, ce, q, he, A, F, K)) : le > 0 && le & 64 && X && I.dynamicChildren ? (N(I.dynamicChildren, X, W, q, he, A, F), (M.key != null || q && M === q.subTree) && v0(I, M, !0)) : de(I, M, W, ce, q, he, A, F, K)
  }, _e = (I, M, W, O, q, he, A, F, K) => {
    M.slotScopeIds = F, I == null ? M.shapeFlag & 512 ? q.ctx.activate(M, W, O, A, K) : Q(M, W, O, q, he, A, K) : re(I, M, K)
  }, Q = (I, M, W, O, q, he, A) => {
    const F = I.component = Ow(I, O, q);
    if (yp(I) && (F.ctx.renderer = Ae), Dw(F, !1, A), F.asyncDep) {
      if (q && q.registerDep(F, J, A), !I.el) {
        const K = F.subTree = $(Fn);
        y(null, K, M, W)
      }
    } else J(F, I, M, W, q, he, A)
  }, re = (I, M, W) => {
    const O = M.component = I.component;
    if (Ew(I, M, W))
      if (O.asyncDep && !O.asyncResolved) {
        ee(O, M, W);
        return
      } else O.next = M, O.update();
    else M.el = I.el, O.vnode = M
  }, J = (I, M, W, O, q, he, A) => {
    const F = () => {
      if (I.isMounted) {
        let {
          next: le,
          bu: X,
          u: ve,
          parent: Se,
          vnode: He
        } = I;
        {
          const Xn = N5(I);
          if (Xn) {
            le && (le.el = He.el, ee(I, le, A)), Xn.asyncDep.then(() => {
              I.isUnmounted || F()
            });
            return
          }
        }
        let Ve = le,
          sn;
        ri(I, !1), le ? (le.el = He.el, ee(I, le, A)) : le = He, X && rf(X), (sn = le.props && le.props.onVnodeBeforeUpdate) && Ms(sn, Se, le, He), ri(I, !0);
        const Ut = v2(I),
          On = I.subTree;
        I.subTree = Ut, v(On, Ut, f(On.el), D(On), I, q, he), le.el = Ut.el, Ve === null && Tw(I, Ut.el), ve && ar(ve, q), (sn = le.props && le.props.onVnodeUpdated) && ar(() => Ms(sn, Se, le, He), q)
      } else {
        let le;
        const {
          el: X,
          props: ve
        } = M, {
          bm: Se,
          m: He,
          parent: Ve,
          root: sn,
          type: Ut
        } = I, On = bl(M);
        ri(I, !1), Se && rf(Se), !On && (le = ve && ve.onVnodeBeforeMount) && Ms(le, Ve, M), ri(I, !0);
        {
          sn.ce && sn.ce._injectChildStyle(Ut);
          const Xn = I.subTree = v2(I);
          v(null, Xn, W, O, I, q, he), M.el = Xn.el
        }
        if (He && ar(He, q), !On && (le = ve && ve.onVnodeMounted)) {
          const Xn = M;
          ar(() => Ms(le, Ve, Xn), q)
        }(M.shapeFlag & 256 || Ve && bl(Ve.vnode) && Ve.vnode.shapeFlag & 256) && I.a && ar(I.a, q), I.isMounted = !0, M = W = O = null
      }
    };
    I.scope.on();
    const K = I.effect = new F3(F);
    I.scope.off();
    const B = I.update = K.run.bind(K),
      ce = I.job = K.runIfDirty.bind(K);
    ce.i = I, ce.id = I.uid, K.scheduler = () => c0(ce), ri(I, !0), B()
  }, ee = (I, M, W) => {
    M.component = I;
    const O = I.vnode.props;
    I.vnode = M, I.next = null, lw(I, M.props, O, W), fw(I, M.children, W), Da(), a2(I), La()
  }, de = (I, M, W, O, q, he, A, F, K = !1) => {
    const B = I && I.children,
      ce = I ? I.shapeFlag : 0,
      le = M.children,
      {
        patchFlag: X,
        shapeFlag: ve
      } = M;
    if (X > 0) {
      if (X & 128) {
        ae(B, le, W, O, q, he, A, F, K);
        return
      } else if (X & 256) {
        se(B, le, W, O, q, he, A, F, K);
        return
      }
    }
    ve & 8 ? (ce & 16 && Ce(B, q, he), le !== B && d(W, le)) : ce & 16 ? ve & 16 ? ae(B, le, W, O, q, he, A, F, K) : Ce(B, q, he, !0) : (ce & 8 && d(W, ""), ve & 16 && j(le, W, O, q, he, A, F, K))
  }, se = (I, M, W, O, q, he, A, F, K) => {
    I = I || gl, M = M || gl;
    const B = I.length,
      ce = M.length,
      le = Math.min(B, ce);
    let X;
    for (X = 0; X < le; X++) {
      const ve = M[X] = K ? fo(M[X]) : Bs(M[X]);
      v(I[X], ve, W, null, q, he, A, F, K)
    }
    B > ce ? Ce(I, q, he, !0, !1, le) : j(M, W, O, q, he, A, F, K, le)
  }, ae = (I, M, W, O, q, he, A, F, K) => {
    let B = 0;
    const ce = M.length;
    let le = I.length - 1,
      X = ce - 1;
    for (; B <= le && B <= X;) {
      const ve = I[B],
        Se = M[B] = K ? fo(M[B]) : Bs(M[B]);
      if (ui(ve, Se)) v(ve, Se, W, null, q, he, A, F, K);
      else break;
      B++
    }
    for (; B <= le && B <= X;) {
      const ve = I[le],
        Se = M[X] = K ? fo(M[X]) : Bs(M[X]);
      if (ui(ve, Se)) v(ve, Se, W, null, q, he, A, F, K);
      else break;
      le--, X--
    }
    if (B > le) {
      if (B <= X) {
        const ve = X + 1,
          Se = ve < ce ? M[ve].el : O;
        for (; B <= X;) v(null, M[B] = K ? fo(M[B]) : Bs(M[B]), W, Se, q, he, A, F, K), B++
      }
    } else if (B > X)
      for (; B <= le;) be(I[B], q, he, !0), B++;
    else {
      const ve = B,
        Se = B,
        He = new Map;
      for (B = Se; B <= X; B++) {
        const Dn = M[B] = K ? fo(M[B]) : Bs(M[B]);
        Dn.key != null && He.set(Dn.key, B)
      }
      let Ve, sn = 0;
      const Ut = X - Se + 1;
      let On = !1,
        Xn = 0;
      const oa = new Array(Ut);
      for (B = 0; B < Ut; B++) oa[B] = 0;
      for (B = ve; B <= le; B++) {
        const Dn = I[B];
        if (sn >= Ut) {
          be(Dn, q, he, !0);
          continue
        }
        let vr;
        if (Dn.key != null) vr = He.get(Dn.key);
        else
          for (Ve = Se; Ve <= X; Ve++)
            if (oa[Ve - Se] === 0 && ui(Dn, M[Ve])) {
              vr = Ve;
              break
            } vr === void 0 ? be(Dn, q, he, !0) : (oa[vr - Se] = B + 1, vr >= Xn ? Xn = vr : On = !0, v(Dn, M[vr], W, null, q, he, A, F, K), sn++)
      }
      const el = On ? gw(oa) : gl;
      for (Ve = el.length - 1, B = Ut - 1; B >= 0; B--) {
        const Dn = Se + B,
          vr = M[Dn],
          me = Dn + 1 < ce ? M[Dn + 1].el : O;
        oa[B] === 0 ? v(null, vr, W, me, q, he, A, F, K) : On && (Ve < 0 || B !== el[Ve] ? ke(vr, W, me, 2) : Ve--)
      }
    }
  }, ke = (I, M, W, O, q = null) => {
    const {
      el: he,
      type: A,
      transition: F,
      children: K,
      shapeFlag: B
    } = I;
    if (B & 6) {
      ke(I.component.subTree, M, W, O);
      return
    }
    if (B & 128) {
      I.suspense.move(M, W, O);
      return
    }
    if (B & 64) {
      A.move(I, M, W, Ae);
      return
    }
    if (A === Ee) {
      r(he, M, W);
      for (let le = 0; le < K.length; le++) ke(K[le], M, W, O);
      r(I.anchor, M, W);
      return
    }
    if (A === af) {
      w(I, M, W);
      return
    }
    if (O !== 2 && B & 1 && F)
      if (O === 0) F.beforeEnter(he), r(he, M, W), ar(() => F.enter(he), q);
      else {
        const {
          leave: le,
          delayLeave: X,
          afterLeave: ve
        } = F, Se = () => {
          I.ctx.isUnmounted ? s(he) : r(he, M, W)
        }, He = () => {
          le(he, () => {
            Se(), ve && ve()
          })
        };
        X ? X(he, Se, He) : He()
      }
    else r(he, M, W)
  }, be = (I, M, W, O = !1, q = !1) => {
    const {
      type: he,
      props: A,
      ref: F,
      children: K,
      dynamicChildren: B,
      shapeFlag: ce,
      patchFlag: le,
      dirs: X,
      cacheIndex: ve
    } = I;
    if (le === -2 && (q = !1), F != null && (Da(), Tf(F, null, W, I, !0), La()), ve != null && (M.renderCache[ve] = void 0), ce & 256) {
      M.ctx.deactivate(I);
      return
    }
    const Se = ce & 1 && X,
      He = !bl(I);
    let Ve;
    if (He && (Ve = A && A.onVnodeBeforeUnmount) && Ms(Ve, M, I), ce & 6) oe(I.component, W, O);
    else {
      if (ce & 128) {
        I.suspense.unmount(W, O);
        return
      }
      Se && ni(I, null, M, "beforeUnmount"), ce & 64 ? I.type.remove(I, M, W, Ae, O) : B && !B.hasOnce && (he !== Ee || le > 0 && le & 64) ? Ce(B, M, W, !1, !0) : (he === Ee && le & 384 || !q && ce & 16) && Ce(K, M, W), O && ge(I)
    }(He && (Ve = A && A.onVnodeUnmounted) || Se) && ar(() => {
      Ve && Ms(Ve, M, I), Se && ni(I, null, M, "unmounted")
    }, W)
  }, ge = I => {
    const {
      type: M,
      el: W,
      anchor: O,
      transition: q
    } = I;
    if (M === Ee) {
      H(W, O);
      return
    }
    if (M === af) {
      x(I);
      return
    }
    const he = () => {
      s(W), q && !q.persisted && q.afterLeave && q.afterLeave()
    };
    if (I.shapeFlag & 1 && q && !q.persisted) {
      const {
        leave: A,
        delayLeave: F
      } = q, K = () => A(W, he);
      F ? F(I.el, he, K) : K()
    } else he()
  }, H = (I, M) => {
    let W;
    for (; I !== M;) W = p(I), s(I), I = W;
    s(M)
  }, oe = (I, M, W) => {
    const {
      bum: O,
      scope: q,
      job: he,
      subTree: A,
      um: F,
      m: K,
      a: B,
      parent: ce,
      slots: {
        __: le
      }
    } = I;
    g2(K), g2(B), O && rf(O), ce && ze(le) && le.forEach(X => {
      ce.renderCache[X] = void 0
    }), q.stop(), he && (he.flags |= 8, be(A, I, M, W)), F && ar(F, M), ar(() => {
      I.isUnmounted = !0
    }, M), M && M.pendingBranch && !M.isUnmounted && I.asyncDep && !I.asyncResolved && I.suspenseId === M.pendingId && (M.deps--, M.deps === 0 && M.resolve())
  }, Ce = (I, M, W, O = !1, q = !1, he = 0) => {
    for (let A = he; A < I.length; A++) be(I[A], M, W, O, q)
  }, D = I => {
    if (I.shapeFlag & 6) return D(I.component.subTree);
    if (I.shapeFlag & 128) return I.suspense.next();
    const M = p(I.anchor || I.el),
      W = M && M[u5];
    return W ? p(W) : M
  };
  let pe = !1;
  const ye = (I, M, W) => {
      I == null ? M._vnode && be(M._vnode, null, null, !0) : v(M._vnode || null, I, M, null, null, null, W), M._vnode = I, pe || (pe = !0, a2(), o5(), pe = !1)
    },
    Ae = {
      p: v,
      um: be,
      m: ke,
      r: ge,
      mt: Q,
      mc: j,
      pc: de,
      pbc: N,
      n: D,
      o: e
    };
  return {
    render: ye,
    hydrate: void 0,
    createApp: aw(ye)
  }
}

function m1({
  type: e,
  props: t
}, n) {
  return n === "svg" && e === "foreignObject" || n === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : n
}

function ri({
  effect: e,
  job: t
}, n) {
  n ? (e.flags |= 32, t.flags |= 4) : (e.flags &= -33, t.flags &= -5)
}

function mw(e, t) {
  return (!e || e && !e.pendingBranch) && t && !t.persisted
}

function v0(e, t, n = !1) {
  const r = e.children,
    s = t.children;
  if (ze(r) && ze(s))
    for (let a = 0; a < r.length; a++) {
      const o = r[a];
      let i = s[a];
      i.shapeFlag & 1 && !i.dynamicChildren && ((i.patchFlag <= 0 || i.patchFlag === 32) && (i = s[a] = fo(s[a]), i.el = o.el), !n && i.patchFlag !== -2 && v0(o, i)), i.type === td && (i.el = o.el), i.type === Fn && !i.el && (i.el = o.el)
    }
}

function gw(e) {
  const t = e.slice(),
    n = [0];
  let r, s, a, o, i;
  const l = e.length;
  for (r = 0; r < l; r++) {
    const c = e[r];
    if (c !== 0) {
      if (s = n[n.length - 1], e[s] < c) {
        t[r] = s, n.push(r);
        continue
      }
      for (a = 0, o = n.length - 1; a < o;) i = a + o >> 1, e[n[i]] < c ? a = i + 1 : o = i;
      c < e[n[a]] && (a > 0 && (t[r] = n[a - 1]), n[a] = r)
    }
  }
  for (a = n.length, o = n[a - 1]; a-- > 0;) n[a] = o, o = t[o];
  return n
}

function N5(e) {
  const t = e.subTree.component;
  if (t) return t.asyncDep && !t.asyncResolved ? t : N5(t)
}

function g2(e) {
  if (e)
    for (let t = 0; t < e.length; t++) e[t].flags |= 8
}
const vw = Symbol.for("v-scx"),
  _w = () => Hn(vw);

function gn(e, t) {
  return ed(e, null, t)
}

function yw(e, t) {
  return ed(e, null, {
    flush: "post"
  })
}

function bw(e, t) {
  return ed(e, null, {
    flush: "sync"
  })
}

function Ne(e, t, n) {
  return ed(e, t, n)
}

function ed(e, t, n = kt) {
  const {
    immediate: r,
    deep: s,
    flush: a,
    once: o
  } = n, i = An({}, n), l = t && r || !t && a !== "post";
  let c;
  if (bc) {
    if (a === "sync") {
      const h = _w();
      c = h.__watcherHandles || (h.__watcherHandles = [])
    } else if (!l) {
      const h = () => {};
      return h.stop = Ys, h.resume = Ys, h.pause = Ys, h
    }
  }
  const d = $n;
  i.call = (h, _, v) => xs(h, d, _, v);
  let f = !1;
  a === "post" ? i.scheduler = h => {
    ar(h, d && d.suspense)
  } : a !== "sync" && (f = !0, i.scheduler = (h, _) => {
    _ ? h() : c0(h)
  }), i.augmentJob = h => {
    t && (h.flags |= 4), f && (h.flags |= 2, d && (h.id = d.uid, h.i = d))
  };
  const p = O6(e, t, i);
  return bc && (c ? c.push(p) : l && p()), p
}

function ww(e, t, n) {
  const r = this.proxy,
    s = Xt(e) ? e.includes(".") ? F5(r, e) : () => r[e] : e.bind(r, r);
  let a;
  et(t) ? a = t : (a = t.handler, n = t);
  const o = nd(this),
    i = ed(s, a.bind(r), n);
  return o(), i
}

function F5(e, t) {
  const n = t.split(".");
  return () => {
    let r = e;
    for (let s = 0; s < n.length && r; s++) r = r[n[s]];
    return r
  }
}

function Cw(e, t, n = kt) {
  const r = gr(),
    s = dr(t),
    a = Ya(t),
    o = B5(e, s),
    i = n5((l, c) => {
      let d, f = kt,
        p;
      return bw(() => {
        const h = e[s];
        wr(d, h) && (d = h, c())
      }), {
        get() {
          return l(), n.get ? n.get(d) : d
        },
        set(h) {
          const _ = n.set ? n.set(h) : h;
          if (!wr(_, d) && !(f !== kt && wr(h, f))) return;
          const v = r.vnode.props;
          v && (t in v || s in v || a in v) && (`onUpdate:${t}` in v || `onUpdate:${s}` in v || `onUpdate:${a}` in v) || (d = h, c()), r.emit(`update:${t}`, _), wr(h, _) && wr(h, f) && !wr(_, p) && c(), f = h, p = _
        }
      }
    });
  return i[Symbol.iterator] = () => {
    let l = 0;
    return {
      next() {
        return l < 2 ? {
          value: l++ ? o || kt : i,
          done: !1
        } : {
          done: !0
        }
      }
    }
  }, i
}
const B5 = (e, t) => t === "modelValue" || t === "model-value" ? e.modelModifiers : e[`${t}Modifiers`] || e[`${dr(t)}Modifiers`] || e[`${Ya(t)}Modifiers`];

function xw(e, t, ...n) {
  if (e.isUnmounted) return;
  const r = e.vnode.props || kt;
  let s = n;
  const a = t.startsWith("update:"),
    o = a && B5(r, t.slice(7));
  o && (o.trim && (s = n.map(d => Xt(d) ? d.trim() : d)), o.number && (s = n.map(wf)));
  let i, l = r[i = nf(t)] || r[i = nf(dr(t))];
  !l && a && (l = r[i = nf(Ya(t))]), l && xs(l, e, 6, s);
  const c = r[i + "Once"];
  if (c) {
    if (!e.emitted) e.emitted = {};
    else if (e.emitted[i]) return;
    e.emitted[i] = !0, xs(c, e, 6, s)
  }
}

function j5(e, t, n = !1) {
  const r = t.emitsCache,
    s = r.get(e);
  if (s !== void 0) return s;
  const a = e.emits;
  let o = {},
    i = !1;
  if (!et(e)) {
    const l = c => {
      const d = j5(c, t, !0);
      d && (i = !0, An(o, d))
    };
    !n && t.mixins.length && t.mixins.forEach(l), e.extends && l(e.extends), e.mixins && e.mixins.forEach(l)
  }
  return !a && !i ? (Ft(e) && r.set(e, null), null) : (ze(a) ? a.forEach(l => o[l] = null) : An(o, a), Ft(e) && r.set(e, o), o)
}

function wp(e, t) {
  return !e || !lp(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), Et(e, t[0].toLowerCase() + t.slice(1)) || Et(e, Ya(t)) || Et(e, t))
}

function v2(e) {
  const {
    type: t,
    vnode: n,
    proxy: r,
    withProxy: s,
    propsOptions: [a],
    slots: o,
    attrs: i,
    emit: l,
    render: c,
    renderCache: d,
    props: f,
    data: p,
    setupState: h,
    ctx: _,
    inheritAttrs: v
  } = e, C = Ef(e);
  let y, b;
  try {
    if (n.shapeFlag & 4) {
      const x = s || r,
        E = x;
      y = Bs(c.call(E, x, d, f, h, p, _)), b = i
    } else {
      const x = t;
      y = Bs(x.length > 1 ? x(f, {
        attrs: i,
        slots: o,
        emit: l
      }) : x(f, null)), b = t.props ? i : kw(i)
    }
  } catch (x) {
    sc.length = 0, _p(x, e, 1), y = $(Fn)
  }
  let w = y;
  if (b && v !== !1) {
    const x = Object.keys(b),
      {
        shapeFlag: E
      } = w;
    x.length && E & 7 && (a && x.some(t0) && (b = Sw(b, a)), w = Ra(w, b, !1, !0))
  }
  return n.dirs && (w = Ra(w, null, !1, !0), w.dirs = w.dirs ? w.dirs.concat(n.dirs) : n.dirs), n.transition && vc(w, n.transition), y = w, Ef(C), y
}
const kw = e => {
    let t;
    for (const n in e)(n === "class" || n === "style" || lp(n)) && ((t || (t = {}))[n] = e[n]);
    return t
  },
  Sw = (e, t) => {
    const n = {};
    for (const r in e)(!t0(r) || !(r.slice(9) in t)) && (n[r] = e[r]);
    return n
  };

function Ew(e, t, n) {
  const {
    props: r,
    children: s,
    component: a
  } = e, {
    props: o,
    children: i,
    patchFlag: l
  } = t, c = a.emitsOptions;
  if (t.dirs || t.transition) return !0;
  if (n && l >= 0) {
    if (l & 1024) return !0;
    if (l & 16) return r ? _2(r, o, c) : !!o;
    if (l & 8) {
      const d = t.dynamicProps;
      for (let f = 0; f < d.length; f++) {
        const p = d[f];
        if (o[p] !== r[p] && !wp(c, p)) return !0
      }
    }
  } else return (s || i) && (!i || !i.$stable) ? !0 : r === o ? !1 : r ? o ? _2(r, o, c) : !0 : !!o;
  return !1
}

function _2(e, t, n) {
  const r = Object.keys(t);
  if (r.length !== Object.keys(e).length) return !0;
  for (let s = 0; s < r.length; s++) {
    const a = r[s];
    if (t[a] !== e[a] && !wp(n, a)) return !0
  }
  return !1
}

function Tw({
  vnode: e,
  parent: t
}, n) {
  for (; t;) {
    const r = t.subTree;
    if (r.suspense && r.suspense.activeBranch === e && (r.el = e.el), r === e)(e = t.vnode).el = n, t = t.parent;
    else break
  }
}
const H5 = e => e.__isSuspense;

function Aw(e, t) {
  t && t.pendingBranch ? ze(e) ? t.effects.push(...e) : t.effects.push(e) : R6(e)
}
const Ee = Symbol.for("v-fgt"),
  td = Symbol.for("v-txt"),
  Fn = Symbol.for("v-cmt"),
  af = Symbol.for("v-stc"),
  sc = [];
let Rr = null;

function g(e = !1) {
  sc.push(Rr = e ? null : [])
}

function Pw() {
  sc.pop(), Rr = sc[sc.length - 1] || null
}
let yc = 1;

function y2(e, t = !1) {
  yc += e, e < 0 && Rr && t && (Rr.hasOnce = !0)
}

function V5(e) {
  return e.dynamicChildren = yc > 0 ? Rr || gl : null, Pw(), yc > 0 && Rr && Rr.push(e), e
}

function k(e, t, n, r, s, a) {
  return V5(m(e, t, n, r, s, a, !0))
}

function G(e, t, n, r, s) {
  return V5($(e, t, n, r, s, !0))
}

function Yl(e) {
  return e ? e.__v_isVNode === !0 : !1
}

function ui(e, t) {
  return e.type === t.type && e.key === t.key
}
const U5 = ({
    key: e
  }) => e ?? null,
  of = ({
    ref: e,
    ref_key: t,
    ref_for: n
  }) => (typeof e == "number" && (e = "" + e), e != null ? Xt(e) || Ht(e) || et(e) ? {
    i: En,
    r: e,
    k: t,
    f: !!n
  } : e : null);

function m(e, t = null, n = null, r = 0, s = null, a = e === Ee ? 0 : 1, o = !1, i = !1) {
  const l = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e,
    props: t,
    key: t && U5(t),
    ref: t && of(t),
    scopeId: l5,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: a,
    patchFlag: r,
    dynamicProps: s,
    dynamicChildren: null,
    appContext: null,
    ctx: En
  };
  return i ? (_0(l, n), a & 128 && e.normalize(l)) : n && (l.shapeFlag |= Xt(n) ? 8 : 16), yc > 0 && !o && Rr && (l.patchFlag > 0 || a & 6) && l.patchFlag !== 32 && Rr.push(l), l
}
const $ = Iw;

function Iw(e, t = null, n = null, r = 0, s = null, a = !1) {
  if ((!e || e === C5) && (e = Fn), Yl(e)) {
    const i = Ra(e, t, !0);
    return n && _0(i, n), yc > 0 && !a && Rr && (i.shapeFlag & 6 ? Rr[Rr.indexOf(e)] = i : Rr.push(i)), i.patchFlag = -2, i
  }
  if (Fw(e) && (e = e.__vccOpts), t) {
    t = Qt(t);
    let {
      class: i,
      style: l
    } = t;
    i && !Xt(i) && (t.class = we(i)), Ft(l) && (u0(l) && !ze(l) && (l = An({}, l)), t.style = Mt(l))
  }
  const o = Xt(e) ? 1 : H5(e) ? 128 : c5(e) ? 64 : Ft(e) ? 4 : et(e) ? 2 : 0;
  return m(e, t, n, r, s, o, a, !0)
}

function Qt(e) {
  return e ? u0(e) || $5(e) ? An({}, e) : e : null
}

function Ra(e, t, n = !1, r = !1) {
  const {
    props: s,
    ref: a,
    patchFlag: o,
    children: i,
    transition: l
  } = e, c = t ? Le(s || {}, t) : s, d = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e.type,
    props: c,
    key: c && U5(c),
    ref: t && t.ref ? n && a ? ze(a) ? a.concat(of(t)) : [a, of(t)] : of(t) : a,
    scopeId: e.scopeId,
    slotScopeIds: e.slotScopeIds,
    children: i,
    target: e.target,
    targetStart: e.targetStart,
    targetAnchor: e.targetAnchor,
    staticCount: e.staticCount,
    shapeFlag: e.shapeFlag,
    patchFlag: t && e.type !== Ee ? o === -1 ? 16 : o | 16 : o,
    dynamicProps: e.dynamicProps,
    dynamicChildren: e.dynamicChildren,
    appContext: e.appContext,
    dirs: e.dirs,
    transition: l,
    component: e.component,
    suspense: e.suspense,
    ssContent: e.ssContent && Ra(e.ssContent),
    ssFallback: e.ssFallback && Ra(e.ssFallback),
    el: e.el,
    anchor: e.anchor,
    ctx: e.ctx,
    ce: e.ce
  };
  return l && r && vc(d, l.clone(d)), d
}

function Ye(e = " ", t = 0) {
  return $(td, null, e, t)
}

function mu(e, t) {
  const n = $(af, null, e);
  return n.staticCount = t, n
}

function z(e = "", t = !1) {
  return t ? (g(), G(Fn, null, e)) : $(Fn, null, e)
}

function Bs(e) {
  return e == null || typeof e == "boolean" ? $(Fn) : ze(e) ? $(Ee, null, e.slice()) : Yl(e) ? fo(e) : $(td, null, String(e))
}

function fo(e) {
  return e.el === null && e.patchFlag !== -1 || e.memo ? e : Ra(e)
}

function _0(e, t) {
  let n = 0;
  const {
    shapeFlag: r
  } = e;
  if (t == null) t = null;
  else if (ze(t)) n = 16;
  else if (typeof t == "object")
    if (r & 65) {
      const s = t.default;
      s && (s._c && (s._d = !1), _0(e, s()), s._c && (s._d = !0));
      return
    } else {
      n = 32;
      const s = t._;
      !s && !$5(t) ? t._ctx = En : s === 3 && En && (En.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024))
    }
  else et(t) ? (t = {
    default: t,
    _ctx: En
  }, n = 32) : (t = String(t), r & 64 ? (n = 16, t = [Ye(t)]) : n = 8);
  e.children = t, e.shapeFlag |= n
}

function Le(...e) {
  const t = {};
  for (let n = 0; n < e.length; n++) {
    const r = e[n];
    for (const s in r)
      if (s === "class") t.class !== r.class && (t.class = we([t.class, r.class]));
      else if (s === "style") t.style = Mt([t.style, r.style]);
    else if (lp(s)) {
      const a = t[s],
        o = r[s];
      o && a !== o && !(ze(a) && a.includes(o)) && (t[s] = a ? [].concat(a, o) : o)
    } else s !== "" && (t[s] = r[s])
  }
  return t
}

function Ms(e, t, n, r = null) {
  xs(e, t, 7, [n, r])
}
const $w = A5();
let Mw = 0;

function Ow(e, t, n) {
  const r = e.type,
    s = (t ? t.appContext : e.appContext) || $w,
    a = {
      uid: Mw++,
      vnode: e,
      type: r,
      parent: t,
      appContext: s,
      root: null,
      next: null,
      subTree: null,
      effect: null,
      update: null,
      job: null,
      scope: new N3(!0),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: t ? t.provides : Object.create(s.provides),
      ids: t ? t.ids : ["", 0, 0],
      accessCache: null,
      renderCache: [],
      components: null,
      directives: null,
      propsOptions: O5(r, s),
      emitsOptions: j5(r, s),
      emit: null,
      emitted: null,
      propsDefaults: kt,
      inheritAttrs: r.inheritAttrs,
      ctx: kt,
      data: kt,
      props: kt,
      attrs: kt,
      slots: kt,
      refs: kt,
      setupState: kt,
      setupContext: null,
      suspense: n,
      suspenseId: n ? n.pendingId : 0,
      asyncDep: null,
      asyncResolved: !1,
      isMounted: !1,
      isUnmounted: !1,
      isDeactivated: !1,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
  return a.ctx = {
    _: a
  }, a.root = t ? t.root : a, a.emit = xw.bind(null, a), e.ce && e.ce(a), a
}
let $n = null;
const gr = () => $n || En;
let Pf, bh;
{
  const e = dp(),
    t = (n, r) => {
      let s;
      return (s = e[n]) || (s = e[n] = []), s.push(r), a => {
        s.length > 1 ? s.forEach(o => o(a)) : s[0](a)
      }
    };
  Pf = t("__VUE_INSTANCE_SETTERS__", n => $n = n), bh = t("__VUE_SSR_SETTERS__", n => bc = n)
}
const nd = e => {
    const t = $n;
    return Pf(e), e.scope.on(), () => {
      e.scope.off(), Pf(t)
    }
  },
  b2 = () => {
    $n && $n.scope.off(), Pf(null)
  };

function z5(e) {
  return e.vnode.shapeFlag & 4
}
let bc = !1;

function Dw(e, t = !1, n = !1) {
  t && bh(t);
  const {
    props: r,
    children: s
  } = e.vnode, a = z5(e);
  iw(e, r, a, t), dw(e, s, n || t);
  const o = a ? Lw(e, t) : void 0;
  return t && bh(!1), o
}

function Lw(e, t) {
  const n = e.type;
  e.accessCache = Object.create(null), e.proxy = new Proxy(e.ctx, q6);
  const {
    setup: r
  } = n;
  if (r) {
    Da();
    const s = e.setupContext = r.length > 1 ? W5(e) : null,
      a = nd(e),
      o = Zc(r, e, 0, [e.props, s]),
      i = I3(o);
    if (La(), a(), (i || e.sp) && !bl(e) && _5(e), i) {
      if (o.then(b2, b2), t) return o.then(l => {
        w2(e, l)
      }).catch(l => {
        _p(l, e, 0)
      });
      e.asyncDep = o
    } else w2(e, o)
  } else Y5(e)
}

function w2(e, t, n) {
  et(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : Ft(t) && (e.setupState = t5(t)), Y5(e)
}

function Y5(e, t, n) {
  const r = e.type;
  e.render || (e.render = r.render || Ys);
  {
    const s = nd(e);
    Da();
    try {
      X6(e)
    } finally {
      La(), s()
    }
  }
}
const Rw = {
  get(e, t) {
    return Wn(e, "get", ""), e[t]
  }
};

function W5(e) {
  const t = n => {
    e.exposed = n || {}
  };
  return {
    attrs: new Proxy(e.attrs, Rw),
    slots: e.slots,
    emit: e.emit,
    expose: t
  }
}

function Cp(e) {
  return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(t5(k6(e.exposed)), {
    get(t, n) {
      if (n in t) return t[n];
      if (n in rc) return rc[n](e)
    },
    has(t, n) {
      return n in t || n in rc
    }
  })) : e.proxy
}

function Nw(e, t = !0) {
  return et(e) ? e.displayName || e.name : e.name || t && e.__name
}

function Fw(e) {
  return et(e) && "__vccOpts" in e
}
const L = (e, t) => $6(e, t, bc);

function yn(e, t, n) {
  const r = arguments.length;
  return r === 2 ? Ft(t) && !ze(t) ? Yl(t) ? $(e, null, [t]) : $(e, t) : $(e, null, t) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : r === 3 && Yl(n) && (n = [n]), $(e, t, n))
}
const Bw = "3.5.15";
/**
 * @vue/runtime-dom v3.5.15
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
let wh;
const C2 = typeof window < "u" && window.trustedTypes;
if (C2) try {
  wh = C2.createPolicy("vue", {
    createHTML: e => e
  })
} catch {}
const G5 = wh ? e => wh.createHTML(e) : e => e,
  jw = "http://www.w3.org/2000/svg",
  Hw = "http://www.w3.org/1998/Math/MathML",
  pa = typeof document < "u" ? document : null,
  x2 = pa && pa.createElement("template"),
  Vw = {
    insert: (e, t, n) => {
      t.insertBefore(e, n || null)
    },
    remove: e => {
      const t = e.parentNode;
      t && t.removeChild(e)
    },
    createElement: (e, t, n, r) => {
      const s = t === "svg" ? pa.createElementNS(jw, e) : t === "mathml" ? pa.createElementNS(Hw, e) : n ? pa.createElement(e, {
        is: n
      }) : pa.createElement(e);
      return e === "select" && r && r.multiple != null && s.setAttribute("multiple", r.multiple), s
    },
    createText: e => pa.createTextNode(e),
    createComment: e => pa.createComment(e),
    setText: (e, t) => {
      e.nodeValue = t
    },
    setElementText: (e, t) => {
      e.textContent = t
    },
    parentNode: e => e.parentNode,
    nextSibling: e => e.nextSibling,
    querySelector: e => pa.querySelector(e),
    setScopeId(e, t) {
      e.setAttribute(t, "")
    },
    insertStaticContent(e, t, n, r, s, a) {
      const o = n ? n.previousSibling : t.lastChild;
      if (s && (s === a || s.nextSibling))
        for (; t.insertBefore(s.cloneNode(!0), n), !(s === a || !(s = s.nextSibling)););
      else {
        x2.innerHTML = G5(r === "svg" ? `<svg>${e}</svg>` : r === "mathml" ? `<math>${e}</math>` : e);
        const i = x2.content;
        if (r === "svg" || r === "mathml") {
          const l = i.firstChild;
          for (; l.firstChild;) i.appendChild(l.firstChild);
          i.removeChild(l)
        }
        t.insertBefore(i, n)
      }
      return [o ? o.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild]
    }
  },
  Xa = "transition",
  Nu = "animation",
  wc = Symbol("_vtc"),
  Q5 = {
    name: String,
    type: String,
    css: {
      type: Boolean,
      default: !0
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
  },
  Uw = An({}, p5, Q5),
  zw = e => (e.displayName = "Transition", e.props = Uw, e),
  zi = zw((e, {
    slots: t
  }) => yn(j6, Yw(e), t)),
  si = (e, t = []) => {
    ze(e) ? e.forEach(n => n(...t)) : e && e(...t)
  },
  k2 = e => e ? ze(e) ? e.some(t => t.length > 1) : e.length > 1 : !1;

function Yw(e) {
  const t = {};
  for (const Y in e) Y in Q5 || (t[Y] = e[Y]);
  if (e.css === !1) return t;
  const {
    name: n = "v",
    type: r,
    duration: s,
    enterFromClass: a = `${n}-enter-from`,
    enterActiveClass: o = `${n}-enter-active`,
    enterToClass: i = `${n}-enter-to`,
    appearFromClass: l = a,
    appearActiveClass: c = o,
    appearToClass: d = i,
    leaveFromClass: f = `${n}-leave-from`,
    leaveActiveClass: p = `${n}-leave-active`,
    leaveToClass: h = `${n}-leave-to`
  } = e, _ = Ww(s), v = _ && _[0], C = _ && _[1], {
    onBeforeEnter: y,
    onEnter: b,
    onEnterCancelled: w,
    onLeave: x,
    onLeaveCancelled: E,
    onBeforeAppear: S = y,
    onAppear: T = b,
    onAppearCancelled: j = w
  } = t, P = (Y, _e, Q, re) => {
    Y._enterCancelled = re, ai(Y, _e ? d : i), ai(Y, _e ? c : o), Q && Q()
  }, N = (Y, _e) => {
    Y._isLeaving = !1, ai(Y, f), ai(Y, h), ai(Y, p), _e && _e()
  }, ne = Y => (_e, Q) => {
    const re = Y ? T : b,
      J = () => P(_e, Y, Q);
    si(re, [_e, J]), S2(() => {
      ai(_e, Y ? l : a), la(_e, Y ? d : i), k2(re) || E2(_e, r, v, J)
    })
  };
  return An(t, {
    onBeforeEnter(Y) {
      si(y, [Y]), la(Y, a), la(Y, o)
    },
    onBeforeAppear(Y) {
      si(S, [Y]), la(Y, l), la(Y, c)
    },
    onEnter: ne(!1),
    onAppear: ne(!0),
    onLeave(Y, _e) {
      Y._isLeaving = !0;
      const Q = () => N(Y, _e);
      la(Y, f), Y._enterCancelled ? (la(Y, p), P2()) : (P2(), la(Y, p)), S2(() => {
        Y._isLeaving && (ai(Y, f), la(Y, h), k2(x) || E2(Y, r, C, Q))
      }), si(x, [Y, Q])
    },
    onEnterCancelled(Y) {
      P(Y, !1, void 0, !0), si(w, [Y])
    },
    onAppearCancelled(Y) {
      P(Y, !0, void 0, !0), si(j, [Y])
    },
    onLeaveCancelled(Y) {
      N(Y), si(E, [Y])
    }
  })
}

function Ww(e) {
  if (e == null) return null;
  if (Ft(e)) return [g1(e.enter), g1(e.leave)];
  {
    const t = g1(e);
    return [t, t]
  }
}

function g1(e) {
  return Z7(e)
}

function la(e, t) {
  t.split(/\s+/).forEach(n => n && e.classList.add(n)), (e[wc] || (e[wc] = new Set)).add(t)
}

function ai(e, t) {
  t.split(/\s+/).forEach(r => r && e.classList.remove(r));
  const n = e[wc];
  n && (n.delete(t), n.size || (e[wc] = void 0))
}

function S2(e) {
  requestAnimationFrame(() => {
    requestAnimationFrame(e)
  })
}
let Gw = 0;

function E2(e, t, n, r) {
  const s = e._endId = ++Gw,
    a = () => {
      s === e._endId && r()
    };
  if (n != null) return setTimeout(a, n);
  const {
    type: o,
    timeout: i,
    propCount: l
  } = Qw(e, t);
  if (!o) return r();
  const c = o + "end";
  let d = 0;
  const f = () => {
      e.removeEventListener(c, p), a()
    },
    p = h => {
      h.target === e && ++d >= l && f()
    };
  setTimeout(() => {
    d < l && f()
  }, i + 1), e.addEventListener(c, p)
}

function Qw(e, t) {
  const n = window.getComputedStyle(e),
    r = _ => (n[_] || "").split(", "),
    s = r(`${Xa}Delay`),
    a = r(`${Xa}Duration`),
    o = T2(s, a),
    i = r(`${Nu}Delay`),
    l = r(`${Nu}Duration`),
    c = T2(i, l);
  let d = null,
    f = 0,
    p = 0;
  t === Xa ? o > 0 && (d = Xa, f = o, p = a.length) : t === Nu ? c > 0 && (d = Nu, f = c, p = l.length) : (f = Math.max(o, c), d = f > 0 ? o > c ? Xa : Nu : null, p = d ? d === Xa ? a.length : l.length : 0);
  const h = d === Xa && /\b(transform|all)(,|$)/.test(r(`${Xa}Property`).toString());
  return {
    type: d,
    timeout: f,
    propCount: p,
    hasTransform: h
  }
}

function T2(e, t) {
  for (; e.length < t.length;) e = e.concat(e);
  return Math.max(...t.map((n, r) => A2(n) + A2(e[r])))
}

function A2(e) {
  return e === "auto" ? 0 : Number(e.slice(0, -1).replace(",", ".")) * 1e3
}

function P2() {
  return document.body.offsetHeight
}

function qw(e, t, n) {
  const r = e[wc];
  r && (t = (t ? [t, ...r] : [...r]).join(" ")), t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t
}
const If = Symbol("_vod"),
  q5 = Symbol("_vsh"),
  wl = {
    beforeMount(e, {
      value: t
    }, {
      transition: n
    }) {
      e[If] = e.style.display === "none" ? "" : e.style.display, n && t ? n.beforeEnter(e) : Fu(e, t)
    },
    mounted(e, {
      value: t
    }, {
      transition: n
    }) {
      n && t && n.enter(e)
    },
    updated(e, {
      value: t,
      oldValue: n
    }, {
      transition: r
    }) {
      !t != !n && (r ? t ? (r.beforeEnter(e), Fu(e, !0), r.enter(e)) : r.leave(e, () => {
        Fu(e, !1)
      }) : Fu(e, t))
    },
    beforeUnmount(e, {
      value: t
    }) {
      Fu(e, t)
    }
  };

function Fu(e, t) {
  e.style.display = t ? e[If] : "none", e[q5] = !t
}
const Kw = Symbol(""),
  Zw = /(^|;)\s*display\s*:/;

function Jw(e, t, n) {
  const r = e.style,
    s = Xt(n);
  let a = !1;
  if (n && !s) {
    if (t)
      if (Xt(t))
        for (const o of t.split(";")) {
          const i = o.slice(0, o.indexOf(":")).trim();
          n[i] == null && lf(r, i, "")
        } else
          for (const o in t) n[o] == null && lf(r, o, "");
    for (const o in n) o === "display" && (a = !0), lf(r, o, n[o])
  } else if (s) {
    if (t !== n) {
      const o = r[Kw];
      o && (n += ";" + o), r.cssText = n, a = Zw.test(n)
    }
  } else t && e.removeAttribute("style");
  If in e && (e[If] = a ? r.display : "", e[q5] && (r.display = "none"))
}
const I2 = /\s*!important$/;

function lf(e, t, n) {
  if (ze(n)) n.forEach(r => lf(e, t, r));
  else if (n == null && (n = ""), t.startsWith("--")) e.setProperty(t, n);
  else {
    const r = Xw(e, t);
    I2.test(n) ? e.setProperty(Ya(r), n.replace(I2, ""), "important") : e[r] = n
  }
}
const $2 = ["Webkit", "Moz", "ms"],
  v1 = {};

function Xw(e, t) {
  const n = v1[t];
  if (n) return n;
  let r = dr(t);
  if (r !== "filter" && r in e) return v1[t] = r;
  r = cp(r);
  for (let s = 0; s < $2.length; s++) {
    const a = $2[s] + r;
    if (a in e) return v1[t] = a
  }
  return t
}
const M2 = "http://www.w3.org/1999/xlink";

function O2(e, t, n, r, s, a = r6(t)) {
  r && t.startsWith("xlink:") ? n == null ? e.removeAttributeNS(M2, t.slice(6, t.length)) : e.setAttributeNS(M2, t, n) : n == null || a && !D3(n) ? e.removeAttribute(t) : e.setAttribute(t, a ? "" : Cs(n) ? String(n) : n)
}

function D2(e, t, n, r, s) {
  if (t === "innerHTML" || t === "textContent") {
    n != null && (e[t] = t === "innerHTML" ? G5(n) : n);
    return
  }
  const a = e.tagName;
  if (t === "value" && a !== "PROGRESS" && !a.includes("-")) {
    const i = a === "OPTION" ? e.getAttribute("value") || "" : e.value,
      l = n == null ? e.type === "checkbox" ? "on" : "" : String(n);
    (i !== l || !("_value" in e)) && (e.value = l), n == null && e.removeAttribute(t), e._value = n;
    return
  }
  let o = !1;
  if (n === "" || n == null) {
    const i = typeof e[t];
    i === "boolean" ? n = D3(n) : n == null && i === "string" ? (n = "", o = !0) : i === "number" && (n = 0, o = !0)
  }
  try {
    e[t] = n
  } catch {}
  o && e.removeAttribute(s || t)
}

function vo(e, t, n, r) {
  e.addEventListener(t, n, r)
}

function eC(e, t, n, r) {
  e.removeEventListener(t, n, r)
}
const L2 = Symbol("_vei");

function tC(e, t, n, r, s = null) {
  const a = e[L2] || (e[L2] = {}),
    o = a[t];
  if (r && o) o.value = r;
  else {
    const [i, l] = nC(t);
    if (r) {
      const c = a[t] = aC(r, s);
      vo(e, i, c, l)
    } else o && (eC(e, i, o, l), a[t] = void 0)
  }
}
const R2 = /(?:Once|Passive|Capture)$/;

function nC(e) {
  let t;
  if (R2.test(e)) {
    t = {};
    let r;
    for (; r = e.match(R2);) e = e.slice(0, e.length - r[0].length), t[r[0].toLowerCase()] = !0
  }
  return [e[2] === ":" ? e.slice(3) : Ya(e.slice(2)), t]
}
let _1 = 0;
const rC = Promise.resolve(),
  sC = () => _1 || (rC.then(() => _1 = 0), _1 = Date.now());

function aC(e, t) {
  const n = r => {
    if (!r._vts) r._vts = Date.now();
    else if (r._vts <= n.attached) return;
    xs(oC(r, n.value), t, 5, [r])
  };
  return n.value = e, n.attached = sC(), n
}

function oC(e, t) {
  if (ze(t)) {
    const n = e.stopImmediatePropagation;
    return e.stopImmediatePropagation = () => {
      n.call(e), e._stopped = !0
    }, t.map(r => s => !s._stopped && r && r(s))
  } else return t
}
const N2 = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123,
  iC = (e, t, n, r, s, a) => {
    const o = s === "svg";
    t === "class" ? qw(e, r, o) : t === "style" ? Jw(e, n, r) : lp(t) ? t0(t) || tC(e, t, n, r, a) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : lC(e, t, r, o)) ? (D2(e, t, r), !e.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && O2(e, t, r, o, a, t !== "value")) : e._isVueCE && (/[A-Z]/.test(t) || !Xt(r)) ? D2(e, dr(t), r, a, t) : (t === "true-value" ? e._trueValue = r : t === "false-value" && (e._falseValue = r), O2(e, t, r, o))
  };

function lC(e, t, n, r) {
  if (r) return !!(t === "innerHTML" || t === "textContent" || t in e && N2(t) && et(n));
  if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "autocorrect" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA") return !1;
  if (t === "width" || t === "height") {
    const s = e.tagName;
    if (s === "IMG" || s === "VIDEO" || s === "CANVAS" || s === "SOURCE") return !1
  }
  return N2(t) && Xt(n) ? !1 : t in e
}
const Wl = e => {
  const t = e.props["onUpdate:modelValue"] || !1;
  return ze(t) ? n => rf(t, n) : t
};

function uC(e) {
  e.target.composing = !0
}

function F2(e) {
  const t = e.target;
  t.composing && (t.composing = !1, t.dispatchEvent(new Event("input")))
}
const Ia = Symbol("_assign"),
  Mi = {
    created(e, {
      modifiers: {
        lazy: t,
        trim: n,
        number: r
      }
    }, s) {
      e[Ia] = Wl(s);
      const a = r || s.props && s.props.type === "number";
      vo(e, t ? "change" : "input", o => {
        if (o.target.composing) return;
        let i = e.value;
        n && (i = i.trim()), a && (i = wf(i)), e[Ia](i)
      }), n && vo(e, "change", () => {
        e.value = e.value.trim()
      }), t || (vo(e, "compositionstart", uC), vo(e, "compositionend", F2), vo(e, "change", F2))
    },
    mounted(e, {
      value: t
    }) {
      e.value = t ?? ""
    },
    beforeUpdate(e, {
      value: t,
      oldValue: n,
      modifiers: {
        lazy: r,
        trim: s,
        number: a
      }
    }, o) {
      if (e[Ia] = Wl(o), e.composing) return;
      const i = (a || e.type === "number") && !/^0\d/.test(e.value) ? wf(e.value) : e.value,
        l = t ?? "";
      i !== l && (document.activeElement === e && e.type !== "range" && (r && t === n || s && e.value.trim() === l) || (e.value = l))
    }
  },
  B2 = {
    deep: !0,
    created(e, t, n) {
      e[Ia] = Wl(n), vo(e, "change", () => {
        const r = e._modelValue,
          s = Cc(e),
          a = e.checked,
          o = e[Ia];
        if (ze(r)) {
          const i = s0(r, s),
            l = i !== -1;
          if (a && !l) o(r.concat(s));
          else if (!a && l) {
            const c = [...r];
            c.splice(i, 1), o(c)
          }
        } else if (pu(r)) {
          const i = new Set(r);
          a ? i.add(s) : i.delete(s), o(i)
        } else o(K5(e, a))
      })
    },
    mounted: j2,
    beforeUpdate(e, t, n) {
      e[Ia] = Wl(n), j2(e, t, n)
    }
  };

function j2(e, {
  value: t,
  oldValue: n
}, r) {
  e._modelValue = t;
  let s;
  if (ze(t)) s = s0(t, r.props.value) > -1;
  else if (pu(t)) s = t.has(r.props.value);
  else {
    if (t === n) return;
    s = qc(t, K5(e, !0))
  }
  e.checked !== s && (e.checked = s)
}
const cC = {
  deep: !0,
  created(e, {
    value: t,
    modifiers: {
      number: n
    }
  }, r) {
    const s = pu(t);
    vo(e, "change", () => {
      const a = Array.prototype.filter.call(e.options, o => o.selected).map(o => n ? wf(Cc(o)) : Cc(o));
      e[Ia](e.multiple ? s ? new Set(a) : a : a[0]), e._assigning = !0, Ot(() => {
        e._assigning = !1
      })
    }), e[Ia] = Wl(r)
  },
  mounted(e, {
    value: t
  }) {
    H2(e, t)
  },
  beforeUpdate(e, t, n) {
    e[Ia] = Wl(n)
  },
  updated(e, {
    value: t
  }) {
    e._assigning || H2(e, t)
  }
};

function H2(e, t) {
  const n = e.multiple,
    r = ze(t);
  if (!(n && !r && !pu(t))) {
    for (let s = 0, a = e.options.length; s < a; s++) {
      const o = e.options[s],
        i = Cc(o);
      if (n)
        if (r) {
          const l = typeof i;
          l === "string" || l === "number" ? o.selected = t.some(c => String(c) === String(i)) : o.selected = s0(t, i) > -1
        } else o.selected = t.has(i);
      else if (qc(Cc(o), t)) {
        e.selectedIndex !== s && (e.selectedIndex = s);
        return
      }
    }!n && e.selectedIndex !== -1 && (e.selectedIndex = -1)
  }
}

function Cc(e) {
  return "_value" in e ? e._value : e.value
}

function K5(e, t) {
  const n = t ? "_trueValue" : "_falseValue";
  return n in e ? e[n] : t
}
const dC = ["ctrl", "shift", "alt", "meta"],
  fC = {
    stop: e => e.stopPropagation(),
    prevent: e => e.preventDefault(),
    self: e => e.target !== e.currentTarget,
    ctrl: e => !e.ctrlKey,
    shift: e => !e.shiftKey,
    alt: e => !e.altKey,
    meta: e => !e.metaKey,
    left: e => "button" in e && e.button !== 0,
    middle: e => "button" in e && e.button !== 1,
    right: e => "button" in e && e.button !== 2,
    exact: (e, t) => dC.some(n => e[`${n}Key`] && !t.includes(n))
  },
  Er = (e, t) => {
    const n = e._withMods || (e._withMods = {}),
      r = t.join(".");
    return n[r] || (n[r] = (s, ...a) => {
      for (let o = 0; o < t.length; o++) {
        const i = fC[t[o]];
        if (i && i(s, t)) return
      }
      return e(s, ...a)
    })
  },
  pC = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
  },
  Z5 = (e, t) => {
    const n = e._withKeys || (e._withKeys = {}),
      r = t.join(".");
    return n[r] || (n[r] = s => {
      if (!("key" in s)) return;
      const a = Ya(s.key);
      if (t.some(o => o === a || pC[o] === a)) return e(s)
    })
  },
  hC = An({
    patchProp: iC
  }, Vw);
let V2;

function J5() {
  return V2 || (V2 = pw(hC))
}
const U2 = (...e) => {
    J5().render(...e)
  },
  mC = (...e) => {
    const t = J5().createApp(...e),
      {
        mount: n
      } = t;
    return t.mount = r => {
      const s = vC(r);
      if (!s) return;
      const a = t._component;
      !et(a) && !a.render && !a.template && (a.template = s.innerHTML), s.nodeType === 1 && (s.textContent = "");
      const o = n(s, !1, gC(s));
      return s instanceof Element && (s.removeAttribute("v-cloak"), s.setAttribute("data-v-app", "")), o
    }, t
  };

function gC(e) {
  if (e instanceof SVGElement) return "svg";
  if (typeof MathMLElement == "function" && e instanceof MathMLElement) return "mathml"
}

function vC(e) {
  return Xt(e) ? document.querySelector(e) : e
}
/*!
 * vue-router v4.5.1
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
const ll = typeof document < "u";

function X5(e) {
  return typeof e == "object" || "displayName" in e || "props" in e || "__vccOpts" in e
}

function _C(e) {
  return e.__esModule || e[Symbol.toStringTag] === "Module" || e.default && X5(e.default)
}
const Wt = Object.assign;

function y1(e, t) {
  const n = {};
  for (const r in t) {
    const s = t[r];
    n[r] = ks(s) ? s.map(e) : e(s)
  }
  return n
}
const ac = () => {},
  ks = Array.isArray,
  eb = /#/g,
  yC = /&/g,
  bC = /\//g,
  wC = /=/g,
  CC = /\?/g,
  tb = /\+/g,
  xC = /%5B/g,
  kC = /%5D/g,
  nb = /%5E/g,
  SC = /%60/g,
  rb = /%7B/g,
  EC = /%7C/g,
  sb = /%7D/g,
  TC = /%20/g;

function y0(e) {
  return encodeURI("" + e).replace(EC, "|").replace(xC, "[").replace(kC, "]")
}

function AC(e) {
  return y0(e).replace(rb, "{").replace(sb, "}").replace(nb, "^")
}

function Ch(e) {
  return y0(e).replace(tb, "%2B").replace(TC, "+").replace(eb, "%23").replace(yC, "%26").replace(SC, "`").replace(rb, "{").replace(sb, "}").replace(nb, "^")
}

function PC(e) {
  return Ch(e).replace(wC, "%3D")
}

function IC(e) {
  return y0(e).replace(eb, "%23").replace(CC, "%3F")
}

function $C(e) {
  return e == null ? "" : IC(e).replace(bC, "%2F")
}

function xc(e) {
  try {
    return decodeURIComponent("" + e)
  } catch {}
  return "" + e
}
const MC = /\/$/,
  OC = e => e.replace(MC, "");

function b1(e, t, n = "/") {
  let r, s = {},
    a = "",
    o = "";
  const i = t.indexOf("#");
  let l = t.indexOf("?");
  return i < l && i >= 0 && (l = -1), l > -1 && (r = t.slice(0, l), a = t.slice(l + 1, i > -1 ? i : t.length), s = e(a)), i > -1 && (r = r || t.slice(0, i), o = t.slice(i, t.length)), r = NC(r ?? t, n), {
    fullPath: r + (a && "?") + a + o,
    path: r,
    query: s,
    hash: xc(o)
  }
}

function DC(e, t) {
  const n = t.query ? e(t.query) : "";
  return t.path + (n && "?") + n + (t.hash || "")
}

function LC(e, t, n) {
  const r = t.matched.length - 1,
    s = n.matched.length - 1;
  return r > -1 && r === s && Gl(t.matched[r], n.matched[s]) && ab(t.params, n.params) && e(t.query) === e(n.query) && t.hash === n.hash
}

function Gl(e, t) {
  return (e.aliasOf || e) === (t.aliasOf || t)
}

function ab(e, t) {
  if (Object.keys(e).length !== Object.keys(t).length) return !1;
  for (const n in e)
    if (!RC(e[n], t[n])) return !1;
  return !0
}

function RC(e, t) {
  return ks(e) ? z2(e, t) : ks(t) ? z2(t, e) : e === t
}

function z2(e, t) {
  return ks(t) ? e.length === t.length && e.every((n, r) => n === t[r]) : e.length === 1 && e[0] === t
}

function NC(e, t) {
  if (e.startsWith("/")) return e;
  if (!e) return t;
  const n = t.split("/"),
    r = e.split("/"),
    s = r[r.length - 1];
  (s === ".." || s === ".") && r.push("");
  let a = n.length - 1,
    o, i;
  for (o = 0; o < r.length; o++)
    if (i = r[o], i !== ".")
      if (i === "..") a > 1 && a--;
      else break;
  return n.slice(0, a).join("/") + "/" + r.slice(o).join("/")
}
const eo = {
  path: "/",
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
};
var kc;
(function(e) {
  e.pop = "pop", e.push = "push"
})(kc || (kc = {}));
var $f;
(function(e) {
  e.back = "back", e.forward = "forward", e.unknown = ""
})($f || ($f = {}));
const w1 = "";

function FC(e) {
  if (!e)
    if (ll) {
      const t = document.querySelector("base");
      e = t && t.getAttribute("href") || "/", e = e.replace(/^\w+:\/\/[^\/]+/, "")
    } else e = "/";
  return e[0] !== "/" && e[0] !== "#" && (e = "/" + e), OC(e)
}
const BC = /^[^#]+#/;

function jC(e, t) {
  return e.replace(BC, "#") + t
}

function HC(e, t) {
  const n = document.documentElement.getBoundingClientRect(),
    r = e.getBoundingClientRect();
  return {
    behavior: t.behavior,
    left: r.left - n.left - (t.left || 0),
    top: r.top - n.top - (t.top || 0)
  }
}
const VC = () => ({
  left: window.scrollX,
  top: window.scrollY
});

function UC(e) {
  let t;
  if ("el" in e) {
    const n = e.el,
      r = typeof n == "string" && n.startsWith("#"),
      s = typeof n == "string" ? r ? document.getElementById(n.slice(1)) : document.querySelector(n) : n;
    if (!s) return;
    t = HC(s, e)
  } else t = e;
  "scrollBehavior" in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(t.left != null ? t.left : window.scrollX, t.top != null ? t.top : window.scrollY)
}

function Y2(e, t) {
  return (history.state ? history.state.position - t : -1) + e
}
const xh = new Map;

function zC(e, t) {
  xh.set(e, t)
}

function YC(e) {
  const t = xh.get(e);
  return xh.delete(e), t
}

function WC(e = "") {
  let t = [],
    n = [
      [w1, {}]
    ],
    r = 0;
  e = FC(e);

  function s(i, l = {}) {
    r++, r !== n.length && n.splice(r), n.push([i, l])
  }

  function a(i, l, {
    direction: c,
    delta: d
  }) {
    const f = {
      direction: c,
      delta: d,
      type: kc.pop
    };
    for (const p of t) p(i, l, f)
  }
  const o = {
    location: w1,
    state: {},
    base: e,
    createHref: jC.bind(null, e),
    replace(i, l) {
      n.splice(r--, 1), s(i, l)
    },
    push(i, l) {
      s(i, l)
    },
    listen(i) {
      return t.push(i), () => {
        const l = t.indexOf(i);
        l > -1 && t.splice(l, 1)
      }
    },
    destroy() {
      t = [], n = [
        [w1, {}]
      ], r = 0
    },
    go(i, l = !0) {
      const c = this.location,
        d = i < 0 ? $f.back : $f.forward;
      r = Math.max(0, Math.min(r + i, n.length - 1)), l && a(this.location, c, {
        direction: d,
        delta: i
      })
    }
  };
  return Object.defineProperty(o, "location", {
    enumerable: !0,
    get: () => n[r][0]
  }), Object.defineProperty(o, "state", {
    enumerable: !0,
    get: () => n[r][1]
  }), o
}

function GC(e) {
  return typeof e == "string" || e && typeof e == "object"
}

function ob(e) {
  return typeof e == "string" || typeof e == "symbol"
}
const ib = Symbol("");
var W2;
(function(e) {
  e[e.aborted = 4] = "aborted", e[e.cancelled = 8] = "cancelled", e[e.duplicated = 16] = "duplicated"
})(W2 || (W2 = {}));

function Ql(e, t) {
  return Wt(new Error, {
    type: e,
    [ib]: !0
  }, t)
}

function ua(e, t) {
  return e instanceof Error && ib in e && (t == null || !!(e.type & t))
}
const G2 = "[^/]+?",
  QC = {
    sensitive: !1,
    strict: !1,
    start: !0,
    end: !0
  },
  qC = /[.+*?^${}()[\]/\\]/g;

function KC(e, t) {
  const n = Wt({}, QC, t),
    r = [];
  let s = n.start ? "^" : "";
  const a = [];
  for (const c of e) {
    const d = c.length ? [] : [90];
    n.strict && !c.length && (s += "/");
    for (let f = 0; f < c.length; f++) {
      const p = c[f];
      let h = 40 + (n.sensitive ? .25 : 0);
      if (p.type === 0) f || (s += "/"), s += p.value.replace(qC, "\\$&"), h += 40;
      else if (p.type === 1) {
        const {
          value: _,
          repeatable: v,
          optional: C,
          regexp: y
        } = p;
        a.push({
          name: _,
          repeatable: v,
          optional: C
        });
        const b = y || G2;
        if (b !== G2) {
          h += 10;
          try {
            new RegExp(`(${b})`)
          } catch (x) {
            throw new Error(`Invalid custom RegExp for param "${_}" (${b}): ` + x.message)
          }
        }
        let w = v ? `((?:${b})(?:/(?:${b}))*)` : `(${b})`;
        f || (w = C && c.length < 2 ? `(?:/${w})` : "/" + w), C && (w += "?"), s += w, h += 20, C && (h += -8), v && (h += -20), b === ".*" && (h += -50)
      }
      d.push(h)
    }
    r.push(d)
  }
  if (n.strict && n.end) {
    const c = r.length - 1;
    r[c][r[c].length - 1] += .7000000000000001
  }
  n.strict || (s += "/?"), n.end ? s += "$" : n.strict && !s.endsWith("/") && (s += "(?:/|$)");
  const o = new RegExp(s, n.sensitive ? "" : "i");

  function i(c) {
    const d = c.match(o),
      f = {};
    if (!d) return null;
    for (let p = 1; p < d.length; p++) {
      const h = d[p] || "",
        _ = a[p - 1];
      f[_.name] = h && _.repeatable ? h.split("/") : h
    }
    return f
  }

  function l(c) {
    let d = "",
      f = !1;
    for (const p of e) {
      (!f || !d.endsWith("/")) && (d += "/"), f = !1;
      for (const h of p)
        if (h.type === 0) d += h.value;
        else if (h.type === 1) {
        const {
          value: _,
          repeatable: v,
          optional: C
        } = h, y = _ in c ? c[_] : "";
        if (ks(y) && !v) throw new Error(`Provided param "${_}" is an array but it is not repeatable (* or + modifiers)`);
        const b = ks(y) ? y.join("/") : y;
        if (!b)
          if (C) p.length < 2 && (d.endsWith("/") ? d = d.slice(0, -1) : f = !0);
          else throw new Error(`Missing required param "${_}"`);
        d += b
      }
    }
    return d || "/"
  }
  return {
    re: o,
    score: r,
    keys: a,
    parse: i,
    stringify: l
  }
}

function ZC(e, t) {
  let n = 0;
  for (; n < e.length && n < t.length;) {
    const r = t[n] - e[n];
    if (r) return r;
    n++
  }
  return e.length < t.length ? e.length === 1 && e[0] === 80 ? -1 : 1 : e.length > t.length ? t.length === 1 && t[0] === 80 ? 1 : -1 : 0
}

function lb(e, t) {
  let n = 0;
  const r = e.score,
    s = t.score;
  for (; n < r.length && n < s.length;) {
    const a = ZC(r[n], s[n]);
    if (a) return a;
    n++
  }
  if (Math.abs(s.length - r.length) === 1) {
    if (Q2(r)) return 1;
    if (Q2(s)) return -1
  }
  return s.length - r.length
}

function Q2(e) {
  const t = e[e.length - 1];
  return e.length > 0 && t[t.length - 1] < 0
}
const JC = {
    type: 0,
    value: ""
  },
  XC = /[a-zA-Z0-9_]/;

function ex(e) {
  if (!e) return [
    []
  ];
  if (e === "/") return [
    [JC]
  ];
  if (!e.startsWith("/")) throw new Error(`Invalid path "${e}"`);

  function t(h) {
    throw new Error(`ERR (${n})/"${c}": ${h}`)
  }
  let n = 0,
    r = n;
  const s = [];
  let a;

  function o() {
    a && s.push(a), a = []
  }
  let i = 0,
    l, c = "",
    d = "";

  function f() {
    c && (n === 0 ? a.push({
      type: 0,
      value: c
    }) : n === 1 || n === 2 || n === 3 ? (a.length > 1 && (l === "*" || l === "+") && t(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`), a.push({
      type: 1,
      value: c,
      regexp: d,
      repeatable: l === "*" || l === "+",
      optional: l === "*" || l === "?"
    })) : t("Invalid state to consume buffer"), c = "")
  }

  function p() {
    c += l
  }
  for (; i < e.length;) {
    if (l = e[i++], l === "\\" && n !== 2) {
      r = n, n = 4;
      continue
    }
    switch (n) {
      case 0:
        l === "/" ? (c && f(), o()) : l === ":" ? (f(), n = 1) : p();
        break;
      case 4:
        p(), n = r;
        break;
      case 1:
        l === "(" ? n = 2 : XC.test(l) ? p() : (f(), n = 0, l !== "*" && l !== "?" && l !== "+" && i--);
        break;
      case 2:
        l === ")" ? d[d.length - 1] == "\\" ? d = d.slice(0, -1) + l : n = 3 : d += l;
        break;
      case 3:
        f(), n = 0, l !== "*" && l !== "?" && l !== "+" && i--, d = "";
        break;
      default:
        t("Unknown state");
        break
    }
  }
  return n === 2 && t(`Unfinished custom RegExp for param "${c}"`), f(), o(), s
}

function tx(e, t, n) {
  const r = KC(ex(e.path), n),
    s = Wt(r, {
      record: e,
      parent: t,
      children: [],
      alias: []
    });
  return t && !s.record.aliasOf == !t.record.aliasOf && t.children.push(s), s
}

function nx(e, t) {
  const n = [],
    r = new Map;
  t = J2({
    strict: !1,
    end: !0,
    sensitive: !1
  }, t);

  function s(f) {
    return r.get(f)
  }

  function a(f, p, h) {
    const _ = !h,
      v = K2(f);
    v.aliasOf = h && h.record;
    const C = J2(t, f),
      y = [v];
    if ("alias" in f) {
      const x = typeof f.alias == "string" ? [f.alias] : f.alias;
      for (const E of x) y.push(K2(Wt({}, v, {
        components: h ? h.record.components : v.components,
        path: E,
        aliasOf: h ? h.record : v
      })))
    }
    let b, w;
    for (const x of y) {
      const {
        path: E
      } = x;
      if (p && E[0] !== "/") {
        const S = p.record.path,
          T = S[S.length - 1] === "/" ? "" : "/";
        x.path = p.record.path + (E && T + E)
      }
      if (b = tx(x, p, C), h ? h.alias.push(b) : (w = w || b, w !== b && w.alias.push(b), _ && f.name && !Z2(b) && o(f.name)), ub(b) && l(b), v.children) {
        const S = v.children;
        for (let T = 0; T < S.length; T++) a(S[T], b, h && h.children[T])
      }
      h = h || b
    }
    return w ? () => {
      o(w)
    } : ac
  }

  function o(f) {
    if (ob(f)) {
      const p = r.get(f);
      p && (r.delete(f), n.splice(n.indexOf(p), 1), p.children.forEach(o), p.alias.forEach(o))
    } else {
      const p = n.indexOf(f);
      p > -1 && (n.splice(p, 1), f.record.name && r.delete(f.record.name), f.children.forEach(o), f.alias.forEach(o))
    }
  }

  function i() {
    return n
  }

  function l(f) {
    const p = ax(f, n);
    n.splice(p, 0, f), f.record.name && !Z2(f) && r.set(f.record.name, f)
  }

  function c(f, p) {
    let h, _ = {},
      v, C;
    if ("name" in f && f.name) {
      if (h = r.get(f.name), !h) throw Ql(1, {
        location: f
      });
      C = h.record.name, _ = Wt(q2(p.params, h.keys.filter(w => !w.optional).concat(h.parent ? h.parent.keys.filter(w => w.optional) : []).map(w => w.name)), f.params && q2(f.params, h.keys.map(w => w.name))), v = h.stringify(_)
    } else if (f.path != null) v = f.path, h = n.find(w => w.re.test(v)), h && (_ = h.parse(v), C = h.record.name);
    else {
      if (h = p.name ? r.get(p.name) : n.find(w => w.re.test(p.path)), !h) throw Ql(1, {
        location: f,
        currentLocation: p
      });
      C = h.record.name, _ = Wt({}, p.params, f.params), v = h.stringify(_)
    }
    const y = [];
    let b = h;
    for (; b;) y.unshift(b.record), b = b.parent;
    return {
      name: C,
      path: v,
      params: _,
      matched: y,
      meta: sx(y)
    }
  }
  e.forEach(f => a(f));

  function d() {
    n.length = 0, r.clear()
  }
  return {
    addRoute: a,
    resolve: c,
    removeRoute: o,
    clearRoutes: d,
    getRoutes: i,
    getRecordMatcher: s
  }
}

function q2(e, t) {
  const n = {};
  for (const r of t) r in e && (n[r] = e[r]);
  return n
}

function K2(e) {
  const t = {
    path: e.path,
    redirect: e.redirect,
    name: e.name,
    meta: e.meta || {},
    aliasOf: e.aliasOf,
    beforeEnter: e.beforeEnter,
    props: rx(e),
    children: e.children || [],
    instances: {},
    leaveGuards: new Set,
    updateGuards: new Set,
    enterCallbacks: {},
    components: "components" in e ? e.components || null : e.component && {
      default: e.component
    }
  };
  return Object.defineProperty(t, "mods", {
    value: {}
  }), t
}

function rx(e) {
  const t = {},
    n = e.props || !1;
  if ("component" in e) t.default = n;
  else
    for (const r in e.components) t[r] = typeof n == "object" ? n[r] : n;
  return t
}

function Z2(e) {
  for (; e;) {
    if (e.record.aliasOf) return !0;
    e = e.parent
  }
  return !1
}

function sx(e) {
  return e.reduce((t, n) => Wt(t, n.meta), {})
}

function J2(e, t) {
  const n = {};
  for (const r in e) n[r] = r in t ? t[r] : e[r];
  return n
}

function ax(e, t) {
  let n = 0,
    r = t.length;
  for (; n !== r;) {
    const a = n + r >> 1;
    lb(e, t[a]) < 0 ? r = a : n = a + 1
  }
  const s = ox(e);
  return s && (r = t.lastIndexOf(s, r - 1)), r
}

function ox(e) {
  let t = e;
  for (; t = t.parent;)
    if (ub(t) && lb(e, t) === 0) return t
}

function ub({
  record: e
}) {
  return !!(e.name || e.components && Object.keys(e.components).length || e.redirect)
}

function ix(e) {
  const t = {};
  if (e === "" || e === "?") return t;
  const r = (e[0] === "?" ? e.slice(1) : e).split("&");
  for (let s = 0; s < r.length; ++s) {
    const a = r[s].replace(tb, " "),
      o = a.indexOf("="),
      i = xc(o < 0 ? a : a.slice(0, o)),
      l = o < 0 ? null : xc(a.slice(o + 1));
    if (i in t) {
      let c = t[i];
      ks(c) || (c = t[i] = [c]), c.push(l)
    } else t[i] = l
  }
  return t
}

function X2(e) {
  let t = "";
  for (let n in e) {
    const r = e[n];
    if (n = PC(n), r == null) {
      r !== void 0 && (t += (t.length ? "&" : "") + n);
      continue
    }(ks(r) ? r.map(a => a && Ch(a)) : [r && Ch(r)]).forEach(a => {
      a !== void 0 && (t += (t.length ? "&" : "") + n, a != null && (t += "=" + a))
    })
  }
  return t
}

function lx(e) {
  const t = {};
  for (const n in e) {
    const r = e[n];
    r !== void 0 && (t[n] = ks(r) ? r.map(s => s == null ? null : "" + s) : r == null ? r : "" + r)
  }
  return t
}
const ux = Symbol(""),
  ev = Symbol(""),
  b0 = Symbol(""),
  w0 = Symbol(""),
  kh = Symbol("");

function Bu() {
  let e = [];

  function t(r) {
    return e.push(r), () => {
      const s = e.indexOf(r);
      s > -1 && e.splice(s, 1)
    }
  }

  function n() {
    e = []
  }
  return {
    add: t,
    list: () => e.slice(),
    reset: n
  }
}

function po(e, t, n, r, s, a = o => o()) {
  const o = r && (r.enterCallbacks[s] = r.enterCallbacks[s] || []);
  return () => new Promise((i, l) => {
    const c = p => {
        p === !1 ? l(Ql(4, {
          from: n,
          to: t
        })) : p instanceof Error ? l(p) : GC(p) ? l(Ql(2, {
          from: t,
          to: p
        })) : (o && r.enterCallbacks[s] === o && typeof p == "function" && o.push(p), i())
      },
      d = a(() => e.call(r && r.instances[s], t, n, c));
    let f = Promise.resolve(d);
    e.length < 3 && (f = f.then(c)), f.catch(p => l(p))
  })
}

function C1(e, t, n, r, s = a => a()) {
  const a = [];
  for (const o of e)
    for (const i in o.components) {
      let l = o.components[i];
      if (!(t !== "beforeRouteEnter" && !o.instances[i]))
        if (X5(l)) {
          const d = (l.__vccOpts || l)[t];
          d && a.push(po(d, n, r, o, i, s))
        } else {
          let c = l();
          a.push(() => c.then(d => {
            if (!d) throw new Error(`Couldn't resolve component "${i}" at "${o.path}"`);
            const f = _C(d) ? d.default : d;
            o.mods[i] = d, o.components[i] = f;
            const h = (f.__vccOpts || f)[t];
            return h && po(h, n, r, o, i, s)()
          }))
        }
    }
  return a
}

function tv(e) {
  const t = Hn(b0),
    n = Hn(w0),
    r = L(() => {
      const l = u(e.to);
      return t.resolve(l)
    }),
    s = L(() => {
      const {
        matched: l
      } = r.value, {
        length: c
      } = l, d = l[c - 1], f = n.matched;
      if (!d || !f.length) return -1;
      const p = f.findIndex(Gl.bind(null, d));
      if (p > -1) return p;
      const h = nv(l[c - 2]);
      return c > 1 && nv(d) === h && f[f.length - 1].path !== h ? f.findIndex(Gl.bind(null, l[c - 2])) : p
    }),
    a = L(() => s.value > -1 && hx(n.params, r.value.params)),
    o = L(() => s.value > -1 && s.value === n.matched.length - 1 && ab(n.params, r.value.params));

  function i(l = {}) {
    if (px(l)) {
      const c = t[u(e.replace) ? "replace" : "push"](u(e.to)).catch(ac);
      return e.viewTransition && typeof document < "u" && "startViewTransition" in document && document.startViewTransition(() => c), c
    }
    return Promise.resolve()
  }
  return {
    route: r,
    href: L(() => r.value.href),
    isActive: a,
    isExactActive: o,
    navigate: i
  }
}

function cx(e) {
  return e.length === 1 ? e[0] : e
}
const dx = te({
    name: "RouterLink",
    compatConfig: {
      MODE: 3
    },
    props: {
      to: {
        type: [String, Object],
        required: !0
      },
      replace: Boolean,
      activeClass: String,
      exactActiveClass: String,
      custom: Boolean,
      ariaCurrentValue: {
        type: String,
        default: "page"
      },
      viewTransition: Boolean
    },
    useLink: tv,
    setup(e, {
      slots: t
    }) {
      const n = xn(tv(e)),
        {
          options: r
        } = Hn(b0),
        s = L(() => ({
          [rv(e.activeClass, r.linkActiveClass, "router-link-active")]: n.isActive,
          [rv(e.exactActiveClass, r.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive
        }));
      return () => {
        const a = t.default && cx(t.default(n));
        return e.custom ? a : yn("a", {
          "aria-current": n.isExactActive ? e.ariaCurrentValue : null,
          href: n.href,
          onClick: n.navigate,
          class: s.value
        }, a)
      }
    }
  }),
  fx = dx;

function px(e) {
  if (!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && !e.defaultPrevented && !(e.button !== void 0 && e.button !== 0)) {
    if (e.currentTarget && e.currentTarget.getAttribute) {
      const t = e.currentTarget.getAttribute("target");
      if (/\b_blank\b/i.test(t)) return
    }
    return e.preventDefault && e.preventDefault(), !0
  }
}

function hx(e, t) {
  for (const n in t) {
    const r = t[n],
      s = e[n];
    if (typeof r == "string") {
      if (r !== s) return !1
    } else if (!ks(s) || s.length !== r.length || r.some((a, o) => a !== s[o])) return !1
  }
  return !0
}

function nv(e) {
  return e ? e.aliasOf ? e.aliasOf.path : e.path : ""
}
const rv = (e, t, n) => e ?? t ?? n,
  mx = te({
    name: "RouterView",
    inheritAttrs: !1,
    props: {
      name: {
        type: String,
        default: "default"
      },
      route: Object
    },
    compatConfig: {
      MODE: 3
    },
    setup(e, {
      attrs: t,
      slots: n
    }) {
      const r = Hn(kh),
        s = L(() => e.route || r.value),
        a = Hn(ev, 0),
        o = L(() => {
          let c = u(a);
          const {
            matched: d
          } = s.value;
          let f;
          for (;
            (f = d[c]) && !f.components;) c++;
          return c
        }),
        i = L(() => s.value.matched[o.value]);
      xi(ev, L(() => o.value + 1)), xi(ux, i), xi(kh, s);
      const l = U();
      return Ne(() => [l.value, i.value, e.name], ([c, d, f], [p, h, _]) => {
        d && (d.instances[f] = c, h && h !== d && c && c === p && (d.leaveGuards.size || (d.leaveGuards = h.leaveGuards), d.updateGuards.size || (d.updateGuards = h.updateGuards))), c && d && (!h || !Gl(d, h) || !p) && (d.enterCallbacks[f] || []).forEach(v => v(c))
      }, {
        flush: "post"
      }), () => {
        const c = s.value,
          d = e.name,
          f = i.value,
          p = f && f.components[d];
        if (!p) return sv(n.default, {
          Component: p,
          route: c
        });
        const h = f.props[d],
          _ = h ? h === !0 ? c.params : typeof h == "function" ? h(c) : h : null,
          C = yn(p, Wt({}, _, t, {
            onVnodeUnmounted: y => {
              y.component.isUnmounted && (f.instances[d] = null)
            },
            ref: l
          }));
        return sv(n.default, {
          Component: C,
          route: c
        }) || C
      }
    }
  });

function sv(e, t) {
  if (!e) return null;
  const n = e(t);
  return n.length === 1 ? n[0] : n
}
const gx = mx;

function vx(e) {
  const t = nx(e.routes, e),
    n = e.parseQuery || ix,
    r = e.stringifyQuery || X2,
    s = e.history,
    a = Bu(),
    o = Bu(),
    i = Bu(),
    l = vp(eo);
  let c = eo;
  ll && e.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual");
  const d = y1.bind(null, D => "" + D),
    f = y1.bind(null, $C),
    p = y1.bind(null, xc);

  function h(D, pe) {
    let ye, Ae;
    return ob(D) ? (ye = t.getRecordMatcher(D), Ae = pe) : Ae = D, t.addRoute(Ae, ye)
  }

  function _(D) {
    const pe = t.getRecordMatcher(D);
    pe && t.removeRoute(pe)
  }

  function v() {
    return t.getRoutes().map(D => D.record)
  }

  function C(D) {
    return !!t.getRecordMatcher(D)
  }

  function y(D, pe) {
    if (pe = Wt({}, pe || l.value), typeof D == "string") {
      const W = b1(n, D, pe.path),
        O = t.resolve({
          path: W.path
        }, pe),
        q = s.createHref(W.fullPath);
      return Wt(W, O, {
        params: p(O.params),
        hash: xc(W.hash),
        redirectedFrom: void 0,
        href: q
      })
    }
    let ye;
    if (D.path != null) ye = Wt({}, D, {
      path: b1(n, D.path, pe.path).path
    });
    else {
      const W = Wt({}, D.params);
      for (const O in W) W[O] == null && delete W[O];
      ye = Wt({}, D, {
        params: f(W)
      }), pe.params = f(pe.params)
    }
    const Ae = t.resolve(ye, pe),
      fe = D.hash || "";
    Ae.params = d(p(Ae.params));
    const I = DC(r, Wt({}, D, {
        hash: AC(fe),
        path: Ae.path
      })),
      M = s.createHref(I);
    return Wt({
      fullPath: I,
      hash: fe,
      query: r === X2 ? lx(D.query) : D.query || {}
    }, Ae, {
      redirectedFrom: void 0,
      href: M
    })
  }

  function b(D) {
    return typeof D == "string" ? b1(n, D, l.value.path) : Wt({}, D)
  }

  function w(D, pe) {
    if (c !== D) return Ql(8, {
      from: pe,
      to: D
    })
  }

  function x(D) {
    return T(D)
  }

  function E(D) {
    return x(Wt(b(D), {
      replace: !0
    }))
  }

  function S(D) {
    const pe = D.matched[D.matched.length - 1];
    if (pe && pe.redirect) {
      const {
        redirect: ye
      } = pe;
      let Ae = typeof ye == "function" ? ye(D) : ye;
      return typeof Ae == "string" && (Ae = Ae.includes("?") || Ae.includes("#") ? Ae = b(Ae) : {
        path: Ae
      }, Ae.params = {}), Wt({
        query: D.query,
        hash: D.hash,
        params: Ae.path != null ? {} : D.params
      }, Ae)
    }
  }

  function T(D, pe) {
    const ye = c = y(D),
      Ae = l.value,
      fe = D.state,
      I = D.force,
      M = D.replace === !0,
      W = S(ye);
    if (W) return T(Wt(b(W), {
      state: typeof W == "object" ? Wt({}, fe, W.state) : fe,
      force: I,
      replace: M
    }), pe || ye);
    const O = ye;
    O.redirectedFrom = pe;
    let q;
    return !I && LC(r, Ae, ye) && (q = Ql(16, {
      to: O,
      from: Ae
    }), ke(Ae, Ae, !0, !1)), (q ? Promise.resolve(q) : N(O, Ae)).catch(he => ua(he) ? ua(he, 2) ? he : ae(he) : de(he, O, Ae)).then(he => {
      if (he) {
        if (ua(he, 2)) return T(Wt({
          replace: M
        }, b(he.to), {
          state: typeof he.to == "object" ? Wt({}, fe, he.to.state) : fe,
          force: I
        }), pe || O)
      } else he = Y(O, Ae, !0, M, fe);
      return ne(O, Ae, he), he
    })
  }

  function j(D, pe) {
    const ye = w(D, pe);
    return ye ? Promise.reject(ye) : Promise.resolve()
  }

  function P(D) {
    const pe = H.values().next().value;
    return pe && typeof pe.runWithContext == "function" ? pe.runWithContext(D) : D()
  }

  function N(D, pe) {
    let ye;
    const [Ae, fe, I] = _x(D, pe);
    ye = C1(Ae.reverse(), "beforeRouteLeave", D, pe);
    for (const W of Ae) W.leaveGuards.forEach(O => {
      ye.push(po(O, D, pe))
    });
    const M = j.bind(null, D, pe);
    return ye.push(M), Ce(ye).then(() => {
      ye = [];
      for (const W of a.list()) ye.push(po(W, D, pe));
      return ye.push(M), Ce(ye)
    }).then(() => {
      ye = C1(fe, "beforeRouteUpdate", D, pe);
      for (const W of fe) W.updateGuards.forEach(O => {
        ye.push(po(O, D, pe))
      });
      return ye.push(M), Ce(ye)
    }).then(() => {
      ye = [];
      for (const W of I)
        if (W.beforeEnter)
          if (ks(W.beforeEnter))
            for (const O of W.beforeEnter) ye.push(po(O, D, pe));
          else ye.push(po(W.beforeEnter, D, pe));
      return ye.push(M), Ce(ye)
    }).then(() => (D.matched.forEach(W => W.enterCallbacks = {}), ye = C1(I, "beforeRouteEnter", D, pe, P), ye.push(M), Ce(ye))).then(() => {
      ye = [];
      for (const W of o.list()) ye.push(po(W, D, pe));
      return ye.push(M), Ce(ye)
    }).catch(W => ua(W, 8) ? W : Promise.reject(W))
  }

  function ne(D, pe, ye) {
    i.list().forEach(Ae => P(() => Ae(D, pe, ye)))
  }

  function Y(D, pe, ye, Ae, fe) {
    const I = w(D, pe);
    if (I) return I;
    const M = pe === eo,
      W = ll ? history.state : {};
    ye && (Ae || M ? s.replace(D.fullPath, Wt({
      scroll: M && W && W.scroll
    }, fe)) : s.push(D.fullPath, fe)), l.value = D, ke(D, pe, ye, M), ae()
  }
  let _e;

  function Q() {
    _e || (_e = s.listen((D, pe, ye) => {
      if (!oe.listening) return;
      const Ae = y(D),
        fe = S(Ae);
      if (fe) {
        T(Wt(fe, {
          replace: !0,
          force: !0
        }), Ae).catch(ac);
        return
      }
      c = Ae;
      const I = l.value;
      ll && zC(Y2(I.fullPath, ye.delta), VC()), N(Ae, I).catch(M => ua(M, 12) ? M : ua(M, 2) ? (T(Wt(b(M.to), {
        force: !0
      }), Ae).then(W => {
        ua(W, 20) && !ye.delta && ye.type === kc.pop && s.go(-1, !1)
      }).catch(ac), Promise.reject()) : (ye.delta && s.go(-ye.delta, !1), de(M, Ae, I))).then(M => {
        M = M || Y(Ae, I, !1), M && (ye.delta && !ua(M, 8) ? s.go(-ye.delta, !1) : ye.type === kc.pop && ua(M, 20) && s.go(-1, !1)), ne(Ae, I, M)
      }).catch(ac)
    }))
  }
  let re = Bu(),
    J = Bu(),
    ee;

  function de(D, pe, ye) {
    ae(D);
    const Ae = J.list();
    return Ae.length ? Ae.forEach(fe => fe(D, pe, ye)) : console.error(D), Promise.reject(D)
  }

  function se() {
    return ee && l.value !== eo ? Promise.resolve() : new Promise((D, pe) => {
      re.add([D, pe])
    })
  }

  function ae(D) {
    return ee || (ee = !D, Q(), re.list().forEach(([pe, ye]) => D ? ye(D) : pe()), re.reset()), D
  }

  function ke(D, pe, ye, Ae) {
    const {
      scrollBehavior: fe
    } = e;
    if (!ll || !fe) return Promise.resolve();
    const I = !ye && YC(Y2(D.fullPath, 0)) || (Ae || !ye) && history.state && history.state.scroll || null;
    return Ot().then(() => fe(D, pe, I)).then(M => M && UC(M)).catch(M => de(M, D, pe))
  }
  const be = D => s.go(D);
  let ge;
  const H = new Set,
    oe = {
      currentRoute: l,
      listening: !0,
      addRoute: h,
      removeRoute: _,
      clearRoutes: t.clearRoutes,
      hasRoute: C,
      getRoutes: v,
      resolve: y,
      options: e,
      push: x,
      replace: E,
      go: be,
      back: () => be(-1),
      forward: () => be(1),
      beforeEach: a.add,
      beforeResolve: o.add,
      afterEach: i.add,
      onError: J.add,
      isReady: se,
      install(D) {
        const pe = this;
        D.component("RouterLink", fx), D.component("RouterView", gx), D.config.globalProperties.$router = pe, Object.defineProperty(D.config.globalProperties, "$route", {
          enumerable: !0,
          get: () => u(l)
        }), ll && !ge && l.value === eo && (ge = !0, x(s.location).catch(fe => {}));
        const ye = {};
        for (const fe in eo) Object.defineProperty(ye, fe, {
          get: () => l.value[fe],
          enumerable: !0
        });
        D.provide(b0, pe), D.provide(w0, mp(ye)), D.provide(kh, l);
        const Ae = D.unmount;
        H.add(D), D.unmount = function() {
          H.delete(D), H.size < 1 && (c = eo, _e && _e(), _e = null, l.value = eo, ge = !1, ee = !1), Ae()
        }
      }
    };

  function Ce(D) {
    return D.reduce((pe, ye) => pe.then(() => P(ye)), Promise.resolve())
  }
  return oe
}

function _x(e, t) {
  const n = [],
    r = [],
    s = [],
    a = Math.max(t.matched.length, e.matched.length);
  for (let o = 0; o < a; o++) {
    const i = t.matched[o];
    i && (e.matched.find(c => Gl(c, i)) ? r.push(i) : n.push(i));
    const l = e.matched[o];
    l && (t.matched.find(c => Gl(c, l)) || s.push(l))
  }
  return [n, r, s]
}

function Mr(e) {
  return Hn(w0)
}
var gu = class {
    constructor() {
      this.listeners = new Set, this.subscribe = this.subscribe.bind(this)
    }
    subscribe(e) {
      return this.listeners.add(e), this.onSubscribe(), () => {
        this.listeners.delete(e), this.onUnsubscribe()
      }
    }
    hasListeners() {
      return this.listeners.size > 0
    }
    onSubscribe() {}
    onUnsubscribe() {}
  },
  Oi = typeof window > "u" || "Deno" in globalThis;

function zr() {}

function yx(e, t) {
  return typeof e == "function" ? e(t) : e
}

function Sh(e) {
  return typeof e == "number" && e >= 0 && e !== 1 / 0
}

function cb(e, t) {
  return Math.max(e + (t || 0) - Date.now(), 0)
}

function Cl(e, t) {
  return typeof e == "function" ? e(t) : e
}

function fs(e, t) {
  return typeof e == "function" ? e(t) : e
}

function av(e, t) {
  const {
    type: n = "all",
    exact: r,
    fetchStatus: s,
    predicate: a,
    queryKey: o,
    stale: i
  } = e;
  if (o) {
    if (r) {
      if (t.queryHash !== C0(o, t.options)) return !1
    } else if (!Sc(t.queryKey, o)) return !1
  }
  if (n !== "all") {
    const l = t.isActive();
    if (n === "active" && !l || n === "inactive" && l) return !1
  }
  return !(typeof i == "boolean" && t.isStale() !== i || s && s !== t.state.fetchStatus || a && !a(t))
}

function ov(e, t) {
  const {
    exact: n,
    status: r,
    predicate: s,
    mutationKey: a
  } = e;
  if (a) {
    if (!t.options.mutationKey) return !1;
    if (n) {
      if (Di(t.options.mutationKey) !== Di(a)) return !1
    } else if (!Sc(t.options.mutationKey, a)) return !1
  }
  return !(r && t.state.status !== r || s && !s(t))
}

function C0(e, t) {
  return ((t == null ? void 0 : t.queryKeyHashFn) || Di)(e)
}

function Di(e) {
  return JSON.stringify(e, (t, n) => Eh(n) ? Object.keys(n).sort().reduce((r, s) => (r[s] = n[s], r), {}) : n)
}

function Sc(e, t) {
  return e === t ? !0 : typeof e != typeof t ? !1 : e && t && typeof e == "object" && typeof t == "object" ? Object.keys(t).every(n => Sc(e[n], t[n])) : !1
}

function db(e, t) {
  if (e === t) return e;
  const n = iv(e) && iv(t);
  if (n || Eh(e) && Eh(t)) {
    const r = n ? e : Object.keys(e),
      s = r.length,
      a = n ? t : Object.keys(t),
      o = a.length,
      i = n ? [] : {};
    let l = 0;
    for (let c = 0; c < o; c++) {
      const d = n ? c : a[c];
      (!n && r.includes(d) || n) && e[d] === void 0 && t[d] === void 0 ? (i[d] = void 0, l++) : (i[d] = db(e[d], t[d]), i[d] === e[d] && e[d] !== void 0 && l++)
    }
    return s === o && l === s ? e : i
  }
  return t
}

function Mf(e, t) {
  if (!t || Object.keys(e).length !== Object.keys(t).length) return !1;
  for (const n in e)
    if (e[n] !== t[n]) return !1;
  return !0
}

function iv(e) {
  return Array.isArray(e) && e.length === Object.keys(e).length
}

function Eh(e) {
  if (!lv(e)) return !1;
  const t = e.constructor;
  if (t === void 0) return !0;
  const n = t.prototype;
  return !(!lv(n) || !n.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(e) !== Object.prototype)
}

function lv(e) {
  return Object.prototype.toString.call(e) === "[object Object]"
}

function bx(e) {
  return new Promise(t => {
    setTimeout(t, e)
  })
}

function Th(e, t, n) {
  return typeof n.structuralSharing == "function" ? n.structuralSharing(e, t) : n.structuralSharing !== !1 ? db(e, t) : t
}

function ts(e) {
  return e
}

function wx(e, t, n = 0) {
  const r = [...e, t];
  return n && r.length > n ? r.slice(1) : r
}

function Cx(e, t, n = 0) {
  const r = [t, ...e];
  return n && r.length > n ? r.slice(0, -1) : r
}
var x0 = Symbol();

function fb(e, t) {
  return !e.queryFn && (t != null && t.initialPromise) ? () => t.initialPromise : !e.queryFn || e.queryFn === x0 ? () => Promise.reject(new Error(`Missing queryFn: '${e.queryHash}'`)) : e.queryFn
}

function Ah(e, t) {
  return typeof e == "function" ? e(...t) : !!e
}
var pi, _o, $l, b3, xx = (b3 = class extends gu {
    constructor() {
      super();
      Qe(this, pi);
      Qe(this, _o);
      Qe(this, $l);
      De(this, $l, t => {
        if (!Oi && window.addEventListener) {
          const n = () => t();
          return window.addEventListener("visibilitychange", n, !1), () => {
            window.removeEventListener("visibilitychange", n)
          }
        }
      })
    }
    onSubscribe() {
      Z(this, _o) || this.setEventListener(Z(this, $l))
    }
    onUnsubscribe() {
      var t;
      this.hasListeners() || ((t = Z(this, _o)) == null || t.call(this), De(this, _o, void 0))
    }
    setEventListener(t) {
      var n;
      De(this, $l, t), (n = Z(this, _o)) == null || n.call(this), De(this, _o, t(r => {
        typeof r == "boolean" ? this.setFocused(r) : this.onFocus()
      }))
    }
    setFocused(t) {
      Z(this, pi) !== t && (De(this, pi, t), this.onFocus())
    }
    onFocus() {
      const t = this.isFocused();
      this.listeners.forEach(n => {
        n(t)
      })
    }
    isFocused() {
      var t;
      return typeof Z(this, pi) == "boolean" ? Z(this, pi) : ((t = globalThis.document) == null ? void 0 : t.visibilityState) !== "hidden"
    }
  }, pi = new WeakMap, _o = new WeakMap, $l = new WeakMap, b3),
  k0 = new xx,
  Ml, yo, Ol, w3, kx = (w3 = class extends gu {
    constructor() {
      super();
      Qe(this, Ml, !0);
      Qe(this, yo);
      Qe(this, Ol);
      De(this, Ol, t => {
        if (!Oi && window.addEventListener) {
          const n = () => t(!0),
            r = () => t(!1);
          return window.addEventListener("online", n, !1), window.addEventListener("offline", r, !1), () => {
            window.removeEventListener("online", n), window.removeEventListener("offline", r)
          }
        }
      })
    }
    onSubscribe() {
      Z(this, yo) || this.setEventListener(Z(this, Ol))
    }
    onUnsubscribe() {
      var t;
      this.hasListeners() || ((t = Z(this, yo)) == null || t.call(this), De(this, yo, void 0))
    }
    setEventListener(t) {
      var n;
      De(this, Ol, t), (n = Z(this, yo)) == null || n.call(this), De(this, yo, t(this.setOnline.bind(this)))
    }
    setOnline(t) {
      Z(this, Ml) !== t && (De(this, Ml, t), this.listeners.forEach(r => {
        r(t)
      }))
    }
    isOnline() {
      return Z(this, Ml)
    }
  }, Ml = new WeakMap, yo = new WeakMap, Ol = new WeakMap, w3),
  Of = new kx;

function Ph() {
  let e, t;
  const n = new Promise((s, a) => {
    e = s, t = a
  });
  n.status = "pending", n.catch(() => {});

  function r(s) {
    Object.assign(n, s), delete n.resolve, delete n.reject
  }
  return n.resolve = s => {
    r({
      status: "fulfilled",
      value: s
    }), e(s)
  }, n.reject = s => {
    r({
      status: "rejected",
      reason: s
    }), t(s)
  }, n
}

function Sx(e) {
  return Math.min(1e3 * 2 ** e, 3e4)
}

function pb(e) {
  return (e ?? "online") === "online" ? Of.isOnline() : !0
}
var hb = class extends Error {
  constructor(e) {
    super("CancelledError"), this.revert = e == null ? void 0 : e.revert, this.silent = e == null ? void 0 : e.silent
  }
};

function x1(e) {
  return e instanceof hb
}

function mb(e) {
  let t = !1,
    n = 0,
    r = !1,
    s;
  const a = Ph(),
    o = v => {
      var C;
      r || (p(new hb(v)), (C = e.abort) == null || C.call(e))
    },
    i = () => {
      t = !0
    },
    l = () => {
      t = !1
    },
    c = () => k0.isFocused() && (e.networkMode === "always" || Of.isOnline()) && e.canRun(),
    d = () => pb(e.networkMode) && e.canRun(),
    f = v => {
      var C;
      r || (r = !0, (C = e.onSuccess) == null || C.call(e, v), s == null || s(), a.resolve(v))
    },
    p = v => {
      var C;
      r || (r = !0, (C = e.onError) == null || C.call(e, v), s == null || s(), a.reject(v))
    },
    h = () => new Promise(v => {
      var C;
      s = y => {
        (r || c()) && v(y)
      }, (C = e.onPause) == null || C.call(e)
    }).then(() => {
      var v;
      s = void 0, r || (v = e.onContinue) == null || v.call(e)
    }),
    _ = () => {
      if (r) return;
      let v;
      const C = n === 0 ? e.initialPromise : void 0;
      try {
        v = C ?? e.fn()
      } catch (y) {
        v = Promise.reject(y)
      }
      Promise.resolve(v).then(f).catch(y => {
        var S;
        if (r) return;
        const b = e.retry ?? (Oi ? 0 : 3),
          w = e.retryDelay ?? Sx,
          x = typeof w == "function" ? w(n, y) : w,
          E = b === !0 || typeof b == "number" && n < b || typeof b == "function" && b(n, y);
        if (t || !E) {
          p(y);
          return
        }
        n++, (S = e.onFail) == null || S.call(e, n, y), bx(x).then(() => c() ? void 0 : h()).then(() => {
          t ? p(y) : _()
        })
      })
    };
  return {
    promise: a,
    cancel: o,
    continue: () => (s == null || s(), a),
    cancelRetry: i,
    continueRetry: l,
    canStart: d,
    start: () => (d() ? _() : h().then(_), a)
  }
}
var Ex = e => setTimeout(e, 0);

function Tx() {
  let e = [],
    t = 0,
    n = i => {
      i()
    },
    r = i => {
      i()
    },
    s = Ex;
  const a = i => {
      t ? e.push(i) : s(() => {
        n(i)
      })
    },
    o = () => {
      const i = e;
      e = [], i.length && s(() => {
        r(() => {
          i.forEach(l => {
            n(l)
          })
        })
      })
    };
  return {
    batch: i => {
      let l;
      t++;
      try {
        l = i()
      } finally {
        t--, t || o()
      }
      return l
    },
    batchCalls: i => (...l) => {
      a(() => {
        i(...l)
      })
    },
    schedule: a,
    setNotifyFunction: i => {
      n = i
    },
    setBatchNotifyFunction: i => {
      r = i
    },
    setScheduler: i => {
      s = i
    }
  }
}
var Nn = Tx(),
  hi, C3, gb = (C3 = class {
    constructor() {
      Qe(this, hi)
    }
    destroy() {
      this.clearGcTimeout()
    }
    scheduleGc() {
      this.clearGcTimeout(), Sh(this.gcTime) && De(this, hi, setTimeout(() => {
        this.optionalRemove()
      }, this.gcTime))
    }
    updateGcTime(e) {
      this.gcTime = Math.max(this.gcTime || 0, e ?? (Oi ? 1 / 0 : 5 * 60 * 1e3))
    }
    clearGcTimeout() {
      Z(this, hi) && (clearTimeout(Z(this, hi)), De(this, hi, void 0))
    }
  }, hi = new WeakMap, C3),
  Dl, Ll, Ur, mi, Un, zc, gi, cs, fa, x3, Ax = (x3 = class extends gb {
    constructor(t) {
      super();
      Qe(this, cs);
      Qe(this, Dl);
      Qe(this, Ll);
      Qe(this, Ur);
      Qe(this, mi);
      Qe(this, Un);
      Qe(this, zc);
      Qe(this, gi);
      De(this, gi, !1), De(this, zc, t.defaultOptions), this.setOptions(t.options), this.observers = [], De(this, mi, t.client), De(this, Ur, Z(this, mi).getQueryCache()), this.queryKey = t.queryKey, this.queryHash = t.queryHash, De(this, Dl, Px(this.options)), this.state = t.state ?? Z(this, Dl), this.scheduleGc()
    }
    get meta() {
      return this.options.meta
    }
    get promise() {
      var t;
      return (t = Z(this, Un)) == null ? void 0 : t.promise
    }
    setOptions(t) {
      this.options = {
        ...Z(this, zc),
        ...t
      }, this.updateGcTime(this.options.gcTime)
    }
    optionalRemove() {
      !this.observers.length && this.state.fetchStatus === "idle" && Z(this, Ur).remove(this)
    }
    setData(t, n) {
      const r = Th(this.state.data, t, this.options);
      return lt(this, cs, fa).call(this, {
        data: r,
        type: "success",
        dataUpdatedAt: n == null ? void 0 : n.updatedAt,
        manual: n == null ? void 0 : n.manual
      }), r
    }
    setState(t, n) {
      lt(this, cs, fa).call(this, {
        type: "setState",
        state: t,
        setStateOptions: n
      })
    }
    cancel(t) {
      var r, s;
      const n = (r = Z(this, Un)) == null ? void 0 : r.promise;
      return (s = Z(this, Un)) == null || s.cancel(t), n ? n.then(zr).catch(zr) : Promise.resolve()
    }
    destroy() {
      super.destroy(), this.cancel({
        silent: !0
      })
    }
    reset() {
      this.destroy(), this.setState(Z(this, Dl))
    }
    isActive() {
      return this.observers.some(t => fs(t.options.enabled, this) !== !1)
    }
    isDisabled() {
      return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === x0 || this.state.dataUpdateCount + this.state.errorUpdateCount === 0
    }
    isStale() {
      return this.state.isInvalidated ? !0 : this.getObserversCount() > 0 ? this.observers.some(t => t.getCurrentResult().isStale) : this.state.data === void 0
    }
    isStaleByTime(t = 0) {
      return this.state.isInvalidated || this.state.data === void 0 || !cb(this.state.dataUpdatedAt, t)
    }
    onFocus() {
      var n;
      const t = this.observers.find(r => r.shouldFetchOnWindowFocus());
      t == null || t.refetch({
        cancelRefetch: !1
      }), (n = Z(this, Un)) == null || n.continue()
    }
    onOnline() {
      var n;
      const t = this.observers.find(r => r.shouldFetchOnReconnect());
      t == null || t.refetch({
        cancelRefetch: !1
      }), (n = Z(this, Un)) == null || n.continue()
    }
    addObserver(t) {
      this.observers.includes(t) || (this.observers.push(t), this.clearGcTimeout(), Z(this, Ur).notify({
        type: "observerAdded",
        query: this,
        observer: t
      }))
    }
    removeObserver(t) {
      this.observers.includes(t) && (this.observers = this.observers.filter(n => n !== t), this.observers.length || (Z(this, Un) && (Z(this, gi) ? Z(this, Un).cancel({
        revert: !0
      }) : Z(this, Un).cancelRetry()), this.scheduleGc()), Z(this, Ur).notify({
        type: "observerRemoved",
        query: this,
        observer: t
      }))
    }
    getObserversCount() {
      return this.observers.length
    }
    invalidate() {
      this.state.isInvalidated || lt(this, cs, fa).call(this, {
        type: "invalidate"
      })
    }
    fetch(t, n) {
      var l, c, d;
      if (this.state.fetchStatus !== "idle") {
        if (this.state.data !== void 0 && (n != null && n.cancelRefetch)) this.cancel({
          silent: !0
        });
        else if (Z(this, Un)) return Z(this, Un).continueRetry(), Z(this, Un).promise
      }
      if (t && this.setOptions(t), !this.options.queryFn) {
        const f = this.observers.find(p => p.options.queryFn);
        f && this.setOptions(f.options)
      }
      const r = new AbortController,
        s = f => {
          Object.defineProperty(f, "signal", {
            enumerable: !0,
            get: () => (De(this, gi, !0), r.signal)
          })
        },
        a = () => {
          const f = fb(this.options, n),
            p = {
              client: Z(this, mi),
              queryKey: this.queryKey,
              meta: this.meta
            };
          return s(p), De(this, gi, !1), this.options.persister ? this.options.persister(f, p, this) : f(p)
        },
        o = {
          fetchOptions: n,
          options: this.options,
          queryKey: this.queryKey,
          client: Z(this, mi),
          state: this.state,
          fetchFn: a
        };
      s(o), (l = this.options.behavior) == null || l.onFetch(o, this), De(this, Ll, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((c = o.fetchOptions) == null ? void 0 : c.meta)) && lt(this, cs, fa).call(this, {
        type: "fetch",
        meta: (d = o.fetchOptions) == null ? void 0 : d.meta
      });
      const i = f => {
        var p, h, _, v;
        x1(f) && f.silent || lt(this, cs, fa).call(this, {
          type: "error",
          error: f
        }), x1(f) || ((h = (p = Z(this, Ur).config).onError) == null || h.call(p, f, this), (v = (_ = Z(this, Ur).config).onSettled) == null || v.call(_, this.state.data, f, this)), this.scheduleGc()
      };
      return De(this, Un, mb({
        initialPromise: n == null ? void 0 : n.initialPromise,
        fn: o.fetchFn,
        abort: r.abort.bind(r),
        onSuccess: f => {
          var p, h, _, v;
          if (f === void 0) {
            i(new Error(`${this.queryHash} data is undefined`));
            return
          }
          try {
            this.setData(f)
          } catch (C) {
            i(C);
            return
          }(h = (p = Z(this, Ur).config).onSuccess) == null || h.call(p, f, this), (v = (_ = Z(this, Ur).config).onSettled) == null || v.call(_, f, this.state.error, this), this.scheduleGc()
        },
        onError: i,
        onFail: (f, p) => {
          lt(this, cs, fa).call(this, {
            type: "failed",
            failureCount: f,
            error: p
          })
        },
        onPause: () => {
          lt(this, cs, fa).call(this, {
            type: "pause"
          })
        },
        onContinue: () => {
          lt(this, cs, fa).call(this, {
            type: "continue"
          })
        },
        retry: o.options.retry,
        retryDelay: o.options.retryDelay,
        networkMode: o.options.networkMode,
        canRun: () => !0
      })), Z(this, Un).start()
    }
  }, Dl = new WeakMap, Ll = new WeakMap, Ur = new WeakMap, mi = new WeakMap, Un = new WeakMap, zc = new WeakMap, gi = new WeakMap, cs = new WeakSet, fa = function(t) {
    const n = r => {
      switch (t.type) {
        case "failed":
          return {
            ...r, fetchFailureCount: t.failureCount, fetchFailureReason: t.error
          };
        case "pause":
          return {
            ...r, fetchStatus: "paused"
          };
        case "continue":
          return {
            ...r, fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...r, ...vb(r.data, this.options), fetchMeta: t.meta ?? null
          };
        case "success":
          return {
            ...r, data: t.data, dataUpdateCount: r.dataUpdateCount + 1, dataUpdatedAt: t.dataUpdatedAt ?? Date.now(), error: null, isInvalidated: !1, status: "success", ...!t.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null
            }
          };
        case "error":
          const s = t.error;
          return x1(s) && s.revert && Z(this, Ll) ? {
            ...Z(this, Ll),
            fetchStatus: "idle"
          } : {
            ...r,
            error: s,
            errorUpdateCount: r.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: r.fetchFailureCount + 1,
            fetchFailureReason: s,
            fetchStatus: "idle",
            status: "error"
          };
        case "invalidate":
          return {
            ...r, isInvalidated: !0
          };
        case "setState":
          return {
            ...r, ...t.state
          }
      }
    };
    this.state = n(this.state), Nn.batch(() => {
      this.observers.forEach(r => {
        r.onQueryUpdate()
      }), Z(this, Ur).notify({
        query: this,
        type: "updated",
        action: t
      })
    })
  }, x3);

function vb(e, t) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: pb(t.networkMode) ? "fetching" : "paused",
    ...e === void 0 && {
      error: null,
      status: "pending"
    }
  }
}

function Px(e) {
  const t = typeof e.initialData == "function" ? e.initialData() : e.initialData,
    n = t !== void 0,
    r = n ? typeof e.initialDataUpdatedAt == "function" ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0;
  return {
    data: t,
    dataUpdateCount: 0,
    dataUpdatedAt: n ? r ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: n ? "success" : "pending",
    fetchStatus: "idle"
  }
}
var Rs, k3, _b = (k3 = class extends gu {
    constructor(n = {}) {
      super();
      Qe(this, Rs);
      this.config = n, De(this, Rs, new Map)
    }
    build(n, r, s) {
      const a = r.queryKey,
        o = r.queryHash ?? C0(a, r);
      let i = this.get(o);
      return i || (i = new Ax({
        client: n,
        queryKey: a,
        queryHash: o,
        options: n.defaultQueryOptions(r),
        state: s,
        defaultOptions: n.getQueryDefaults(a)
      }), this.add(i)), i
    }
    add(n) {
      Z(this, Rs).has(n.queryHash) || (Z(this, Rs).set(n.queryHash, n), this.notify({
        type: "added",
        query: n
      }))
    }
    remove(n) {
      const r = Z(this, Rs).get(n.queryHash);
      r && (n.destroy(), r === n && Z(this, Rs).delete(n.queryHash), this.notify({
        type: "removed",
        query: n
      }))
    }
    clear() {
      Nn.batch(() => {
        this.getAll().forEach(n => {
          this.remove(n)
        })
      })
    }
    get(n) {
      return Z(this, Rs).get(n)
    }
    getAll() {
      return [...Z(this, Rs).values()]
    }
    find(n) {
      const r = {
        exact: !0,
        ...n
      };
      return this.getAll().find(s => av(r, s))
    }
    findAll(n = {}) {
      const r = this.getAll();
      return Object.keys(n).length > 0 ? r.filter(s => av(n, s)) : r
    }
    notify(n) {
      Nn.batch(() => {
        this.listeners.forEach(r => {
          r(n)
        })
      })
    }
    onFocus() {
      Nn.batch(() => {
        this.getAll().forEach(n => {
          n.onFocus()
        })
      })
    }
    onOnline() {
      Nn.batch(() => {
        this.getAll().forEach(n => {
          n.onOnline()
        })
      })
    }
  }, Rs = new WeakMap, k3),
  Ns, rr, vi, Fs, oo, S3, Ix = (S3 = class extends gb {
    constructor(t) {
      super();
      Qe(this, Fs);
      Qe(this, Ns);
      Qe(this, rr);
      Qe(this, vi);
      this.mutationId = t.mutationId, De(this, rr, t.mutationCache), De(this, Ns, []), this.state = t.state || yb(), this.setOptions(t.options), this.scheduleGc()
    }
    setOptions(t) {
      this.options = t, this.updateGcTime(this.options.gcTime)
    }
    get meta() {
      return this.options.meta
    }
    addObserver(t) {
      Z(this, Ns).includes(t) || (Z(this, Ns).push(t), this.clearGcTimeout(), Z(this, rr).notify({
        type: "observerAdded",
        mutation: this,
        observer: t
      }))
    }
    removeObserver(t) {
      De(this, Ns, Z(this, Ns).filter(n => n !== t)), this.scheduleGc(), Z(this, rr).notify({
        type: "observerRemoved",
        mutation: this,
        observer: t
      })
    }
    optionalRemove() {
      Z(this, Ns).length || (this.state.status === "pending" ? this.scheduleGc() : Z(this, rr).remove(this))
    }
    continue () {
      var t;
      return ((t = Z(this, vi)) == null ? void 0 : t.continue()) ?? this.execute(this.state.variables)
    }
    async execute(t) {
      var a, o, i, l, c, d, f, p, h, _, v, C, y, b, w, x, E, S, T, j;
      const n = () => {
        lt(this, Fs, oo).call(this, {
          type: "continue"
        })
      };
      De(this, vi, mb({
        fn: () => this.options.mutationFn ? this.options.mutationFn(t) : Promise.reject(new Error("No mutationFn found")),
        onFail: (P, N) => {
          lt(this, Fs, oo).call(this, {
            type: "failed",
            failureCount: P,
            error: N
          })
        },
        onPause: () => {
          lt(this, Fs, oo).call(this, {
            type: "pause"
          })
        },
        onContinue: n,
        retry: this.options.retry ?? 0,
        retryDelay: this.options.retryDelay,
        networkMode: this.options.networkMode,
        canRun: () => Z(this, rr).canRun(this)
      }));
      const r = this.state.status === "pending",
        s = !Z(this, vi).canStart();
      try {
        if (r) n();
        else {
          lt(this, Fs, oo).call(this, {
            type: "pending",
            variables: t,
            isPaused: s
          }), await ((o = (a = Z(this, rr).config).onMutate) == null ? void 0 : o.call(a, t, this));
          const N = await ((l = (i = this.options).onMutate) == null ? void 0 : l.call(i, t));
          N !== this.state.context && lt(this, Fs, oo).call(this, {
            type: "pending",
            context: N,
            variables: t,
            isPaused: s
          })
        }
        const P = await Z(this, vi).start();
        return await ((d = (c = Z(this, rr).config).onSuccess) == null ? void 0 : d.call(c, P, t, this.state.context, this)), await ((p = (f = this.options).onSuccess) == null ? void 0 : p.call(f, P, t, this.state.context)), await ((_ = (h = Z(this, rr).config).onSettled) == null ? void 0 : _.call(h, P, null, this.state.variables, this.state.context, this)), await ((C = (v = this.options).onSettled) == null ? void 0 : C.call(v, P, null, t, this.state.context)), lt(this, Fs, oo).call(this, {
          type: "success",
          data: P
        }), P
      } catch (P) {
        try {
          throw await ((b = (y = Z(this, rr).config).onError) == null ? void 0 : b.call(y, P, t, this.state.context, this)), await ((x = (w = this.options).onError) == null ? void 0 : x.call(w, P, t, this.state.context)), await ((S = (E = Z(this, rr).config).onSettled) == null ? void 0 : S.call(E, void 0, P, this.state.variables, this.state.context, this)), await ((j = (T = this.options).onSettled) == null ? void 0 : j.call(T, void 0, P, t, this.state.context)), P
        } finally {
          lt(this, Fs, oo).call(this, {
            type: "error",
            error: P
          })
        }
      } finally {
        Z(this, rr).runNext(this)
      }
    }
  }, Ns = new WeakMap, rr = new WeakMap, vi = new WeakMap, Fs = new WeakSet, oo = function(t) {
    const n = r => {
      switch (t.type) {
        case "failed":
          return {
            ...r, failureCount: t.failureCount, failureReason: t.error
          };
        case "pause":
          return {
            ...r, isPaused: !0
          };
        case "continue":
          return {
            ...r, isPaused: !1
          };
        case "pending":
          return {
            ...r, context: t.context, data: void 0, failureCount: 0, failureReason: null, error: null, isPaused: t.isPaused, status: "pending", variables: t.variables, submittedAt: Date.now()
          };
        case "success":
          return {
            ...r, data: t.data, failureCount: 0, failureReason: null, error: null, status: "success", isPaused: !1
          };
        case "error":
          return {
            ...r, data: void 0, error: t.error, failureCount: r.failureCount + 1, failureReason: t.error, isPaused: !1, status: "error"
          }
      }
    };
    this.state = n(this.state), Nn.batch(() => {
      Z(this, Ns).forEach(r => {
        r.onMutationUpdate(t)
      }), Z(this, rr).notify({
        mutation: this,
        type: "updated",
        action: t
      })
    })
  }, S3);

function yb() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  }
}
var ya, ds, Yc, E3, bb = (E3 = class extends gu {
  constructor(n = {}) {
    super();
    Qe(this, ya);
    Qe(this, ds);
    Qe(this, Yc);
    this.config = n, De(this, ya, new Set), De(this, ds, new Map), De(this, Yc, 0)
  }
  build(n, r, s) {
    const a = new Ix({
      mutationCache: this,
      mutationId: ++Ed(this, Yc)._,
      options: n.defaultMutationOptions(r),
      state: s
    });
    return this.add(a), a
  }
  add(n) {
    Z(this, ya).add(n);
    const r = Md(n);
    if (typeof r == "string") {
      const s = Z(this, ds).get(r);
      s ? s.push(n) : Z(this, ds).set(r, [n])
    }
    this.notify({
      type: "added",
      mutation: n
    })
  }
  remove(n) {
    if (Z(this, ya).delete(n)) {
      const r = Md(n);
      if (typeof r == "string") {
        const s = Z(this, ds).get(r);
        if (s)
          if (s.length > 1) {
            const a = s.indexOf(n);
            a !== -1 && s.splice(a, 1)
          } else s[0] === n && Z(this, ds).delete(r)
      }
    }
    this.notify({
      type: "removed",
      mutation: n
    })
  }
  canRun(n) {
    const r = Md(n);
    if (typeof r == "string") {
      const s = Z(this, ds).get(r),
        a = s == null ? void 0 : s.find(o => o.state.status === "pending");
      return !a || a === n
    } else return !0
  }
  runNext(n) {
    var s;
    const r = Md(n);
    if (typeof r == "string") {
      const a = (s = Z(this, ds).get(r)) == null ? void 0 : s.find(o => o !== n && o.state.isPaused);
      return (a == null ? void 0 : a.continue()) ?? Promise.resolve()
    } else return Promise.resolve()
  }
  clear() {
    Nn.batch(() => {
      Z(this, ya).forEach(n => {
        this.notify({
          type: "removed",
          mutation: n
        })
      }), Z(this, ya).clear(), Z(this, ds).clear()
    })
  }
  getAll() {
    return Array.from(Z(this, ya))
  }
  find(n) {
    const r = {
      exact: !0,
      ...n
    };
    return this.getAll().find(s => ov(r, s))
  }
  findAll(n = {}) {
    return this.getAll().filter(r => ov(n, r))
  }
  notify(n) {
    Nn.batch(() => {
      this.listeners.forEach(r => {
        r(n)
      })
    })
  }
  resumePausedMutations() {
    const n = this.getAll().filter(r => r.state.isPaused);
    return Nn.batch(() => Promise.all(n.map(r => r.continue().catch(zr))))
  }
}, ya = new WeakMap, ds = new WeakMap, Yc = new WeakMap, E3);

function Md(e) {
  var t;
  return (t = e.options.scope) == null ? void 0 : t.id
}

function uv(e) {
  return {
    onFetch: (t, n) => {
      var d, f, p, h, _;
      const r = t.options,
        s = (p = (f = (d = t.fetchOptions) == null ? void 0 : d.meta) == null ? void 0 : f.fetchMore) == null ? void 0 : p.direction,
        a = ((h = t.state.data) == null ? void 0 : h.pages) || [],
        o = ((_ = t.state.data) == null ? void 0 : _.pageParams) || [];
      let i = {
          pages: [],
          pageParams: []
        },
        l = 0;
      const c = async () => {
        let v = !1;
        const C = w => {
            Object.defineProperty(w, "signal", {
              enumerable: !0,
              get: () => (t.signal.aborted ? v = !0 : t.signal.addEventListener("abort", () => {
                v = !0
              }), t.signal)
            })
          },
          y = fb(t.options, t.fetchOptions),
          b = async (w, x, E) => {
            if (v) return Promise.reject();
            if (x == null && w.pages.length) return Promise.resolve(w);
            const S = {
              client: t.client,
              queryKey: t.queryKey,
              pageParam: x,
              direction: E ? "backward" : "forward",
              meta: t.options.meta
            };
            C(S);
            const T = await y(S),
              {
                maxPages: j
              } = t.options,
              P = E ? Cx : wx;
            return {
              pages: P(w.pages, T, j),
              pageParams: P(w.pageParams, x, j)
            }
          };
        if (s && a.length) {
          const w = s === "backward",
            x = w ? $x : cv,
            E = {
              pages: a,
              pageParams: o
            },
            S = x(r, E);
          i = await b(E, S, w)
        } else {
          const w = e ?? a.length;
          do {
            const x = l === 0 ? o[0] ?? r.initialPageParam : cv(r, i);
            if (l > 0 && x == null) break;
            i = await b(i, x), l++
          } while (l < w)
        }
        return i
      };
      t.options.persister ? t.fetchFn = () => {
        var v, C;
        return (C = (v = t.options).persister) == null ? void 0 : C.call(v, c, {
          client: t.client,
          queryKey: t.queryKey,
          meta: t.options.meta,
          signal: t.signal
        }, n)
      } : t.fetchFn = c
    }
  }
}

function cv(e, {
  pages: t,
  pageParams: n
}) {
  const r = t.length - 1;
  return t.length > 0 ? e.getNextPageParam(t[r], t, n[r], n) : void 0
}

function $x(e, {
  pages: t,
  pageParams: n
}) {
  var r;
  return t.length > 0 ? (r = e.getPreviousPageParam) == null ? void 0 : r.call(e, t[0], t, n[0], n) : void 0
}
var an, bo, wo, Rl, Nl, Co, Fl, Bl, T3, Mx = (T3 = class {
    constructor(t = {}) {
      Qe(this, an);
      Qe(this, bo);
      Qe(this, wo);
      Qe(this, Rl);
      Qe(this, Nl);
      Qe(this, Co);
      Qe(this, Fl);
      Qe(this, Bl);
      De(this, an, t.queryCache || new _b), De(this, bo, t.mutationCache || new bb), De(this, wo, t.defaultOptions || {}), De(this, Rl, new Map), De(this, Nl, new Map), De(this, Co, 0)
    }
    mount() {
      Ed(this, Co)._++, Z(this, Co) === 1 && (De(this, Fl, k0.subscribe(async t => {
        t && (await this.resumePausedMutations(), Z(this, an).onFocus())
      })), De(this, Bl, Of.subscribe(async t => {
        t && (await this.resumePausedMutations(), Z(this, an).onOnline())
      })))
    }
    unmount() {
      var t, n;
      Ed(this, Co)._--, Z(this, Co) === 0 && ((t = Z(this, Fl)) == null || t.call(this), De(this, Fl, void 0), (n = Z(this, Bl)) == null || n.call(this), De(this, Bl, void 0))
    }
    isFetching(t) {
      return Z(this, an).findAll({
        ...t,
        fetchStatus: "fetching"
      }).length
    }
    isMutating(t) {
      return Z(this, bo).findAll({
        ...t,
        status: "pending"
      }).length
    }
    getQueryData(t) {
      var r;
      const n = this.defaultQueryOptions({
        queryKey: t
      });
      return (r = Z(this, an).get(n.queryHash)) == null ? void 0 : r.state.data
    }
    ensureQueryData(t) {
      const n = this.defaultQueryOptions(t),
        r = Z(this, an).build(this, n),
        s = r.state.data;
      return s === void 0 ? this.fetchQuery(t) : (t.revalidateIfStale && r.isStaleByTime(Cl(n.staleTime, r)) && this.prefetchQuery(n), Promise.resolve(s))
    }
    getQueriesData(t) {
      return Z(this, an).findAll(t).map(({
        queryKey: n,
        state: r
      }) => {
        const s = r.data;
        return [n, s]
      })
    }
    setQueryData(t, n, r) {
      const s = this.defaultQueryOptions({
          queryKey: t
        }),
        a = Z(this, an).get(s.queryHash),
        o = a == null ? void 0 : a.state.data,
        i = yx(n, o);
      if (i !== void 0) return Z(this, an).build(this, s).setData(i, {
        ...r,
        manual: !0
      })
    }
    setQueriesData(t, n, r) {
      return Nn.batch(() => Z(this, an).findAll(t).map(({
        queryKey: s
      }) => [s, this.setQueryData(s, n, r)]))
    }
    getQueryState(t) {
      var r;
      const n = this.defaultQueryOptions({
        queryKey: t
      });
      return (r = Z(this, an).get(n.queryHash)) == null ? void 0 : r.state
    }
    removeQueries(t) {
      const n = Z(this, an);
      Nn.batch(() => {
        n.findAll(t).forEach(r => {
          n.remove(r)
        })
      })
    }
    resetQueries(t, n) {
      const r = Z(this, an);
      return Nn.batch(() => (r.findAll(t).forEach(s => {
        s.reset()
      }), this.refetchQueries({
        type: "active",
        ...t
      }, n)))
    }
    cancelQueries(t, n = {}) {
      const r = {
          revert: !0,
          ...n
        },
        s = Nn.batch(() => Z(this, an).findAll(t).map(a => a.cancel(r)));
      return Promise.all(s).then(zr).catch(zr)
    }
    invalidateQueries(t, n = {}) {
      return Nn.batch(() => (Z(this, an).findAll(t).forEach(r => {
        r.invalidate()
      }), (t == null ? void 0 : t.refetchType) === "none" ? Promise.resolve() : this.refetchQueries({
        ...t,
        type: (t == null ? void 0 : t.refetchType) ?? (t == null ? void 0 : t.type) ?? "active"
      }, n)))
    }
    refetchQueries(t, n = {}) {
      const r = {
          ...n,
          cancelRefetch: n.cancelRefetch ?? !0
        },
        s = Nn.batch(() => Z(this, an).findAll(t).filter(a => !a.isDisabled()).map(a => {
          let o = a.fetch(void 0, r);
          return r.throwOnError || (o = o.catch(zr)), a.state.fetchStatus === "paused" ? Promise.resolve() : o
        }));
      return Promise.all(s).then(zr)
    }
    fetchQuery(t) {
      const n = this.defaultQueryOptions(t);
      n.retry === void 0 && (n.retry = !1);
      const r = Z(this, an).build(this, n);
      return r.isStaleByTime(Cl(n.staleTime, r)) ? r.fetch(n) : Promise.resolve(r.state.data)
    }
    prefetchQuery(t) {
      return this.fetchQuery(t).then(zr).catch(zr)
    }
    fetchInfiniteQuery(t) {
      return t.behavior = uv(t.pages), this.fetchQuery(t)
    }
    prefetchInfiniteQuery(t) {
      return this.fetchInfiniteQuery(t).then(zr).catch(zr)
    }
    ensureInfiniteQueryData(t) {
      return t.behavior = uv(t.pages), this.ensureQueryData(t)
    }
    resumePausedMutations() {
      return Of.isOnline() ? Z(this, bo).resumePausedMutations() : Promise.resolve()
    }
    getQueryCache() {
      return Z(this, an)
    }
    getMutationCache() {
      return Z(this, bo)
    }
    getDefaultOptions() {
      return Z(this, wo)
    }
    setDefaultOptions(t) {
      De(this, wo, t)
    }
    setQueryDefaults(t, n) {
      Z(this, Rl).set(Di(t), {
        queryKey: t,
        defaultOptions: n
      })
    }
    getQueryDefaults(t) {
      const n = [...Z(this, Rl).values()],
        r = {};
      return n.forEach(s => {
        Sc(t, s.queryKey) && Object.assign(r, s.defaultOptions)
      }), r
    }
    setMutationDefaults(t, n) {
      Z(this, Nl).set(Di(t), {
        mutationKey: t,
        defaultOptions: n
      })
    }
    getMutationDefaults(t) {
      const n = [...Z(this, Nl).values()],
        r = {};
      return n.forEach(s => {
        Sc(t, s.mutationKey) && Object.assign(r, s.defaultOptions)
      }), r
    }
    defaultQueryOptions(t) {
      if (t._defaulted) return t;
      const n = {
        ...Z(this, wo).queries,
        ...this.getQueryDefaults(t.queryKey),
        ...t,
        _defaulted: !0
      };
      return n.queryHash || (n.queryHash = C0(n.queryKey, n)), n.refetchOnReconnect === void 0 && (n.refetchOnReconnect = n.networkMode !== "always"), n.throwOnError === void 0 && (n.throwOnError = !!n.suspense), !n.networkMode && n.persister && (n.networkMode = "offlineFirst"), n.queryFn === x0 && (n.enabled = !1), n
    }
    defaultMutationOptions(t) {
      return t != null && t._defaulted ? t : {
        ...Z(this, wo).mutations,
        ...(t == null ? void 0 : t.mutationKey) && this.getMutationDefaults(t.mutationKey),
        ...t,
        _defaulted: !0
      }
    }
    clear() {
      Z(this, an).clear(), Z(this, bo).clear()
    }
  }, an = new WeakMap, bo = new WeakMap, wo = new WeakMap, Rl = new WeakMap, Nl = new WeakMap, Co = new WeakMap, Fl = new WeakMap, Bl = new WeakMap, T3),
  yr, gt, Wc, sr, _i, jl, xo, ko, Gc, Hl, Vl, yi, bi, So, Ul, At, qu, Ih, $h, Mh, Oh, Dh, Lh, Rh, wb, A3, Ox = (A3 = class extends gu {
    constructor(t, n) {
      super();
      Qe(this, At);
      Qe(this, yr);
      Qe(this, gt);
      Qe(this, Wc);
      Qe(this, sr);
      Qe(this, _i);
      Qe(this, jl);
      Qe(this, xo);
      Qe(this, ko);
      Qe(this, Gc);
      Qe(this, Hl);
      Qe(this, Vl);
      Qe(this, yi);
      Qe(this, bi);
      Qe(this, So);
      Qe(this, Ul, new Set);
      this.options = n, De(this, yr, t), De(this, ko, null), De(this, xo, Ph()), this.options.experimental_prefetchInRender || Z(this, xo).reject(new Error("experimental_prefetchInRender feature flag is not enabled")), this.bindMethods(), this.setOptions(n)
    }
    bindMethods() {
      this.refetch = this.refetch.bind(this)
    }
    onSubscribe() {
      this.listeners.size === 1 && (Z(this, gt).addObserver(this), dv(Z(this, gt), this.options) ? lt(this, At, qu).call(this) : this.updateResult(), lt(this, At, Oh).call(this))
    }
    onUnsubscribe() {
      this.hasListeners() || this.destroy()
    }
    shouldFetchOnReconnect() {
      return Nh(Z(this, gt), this.options, this.options.refetchOnReconnect)
    }
    shouldFetchOnWindowFocus() {
      return Nh(Z(this, gt), this.options, this.options.refetchOnWindowFocus)
    }
    destroy() {
      this.listeners = new Set, lt(this, At, Dh).call(this), lt(this, At, Lh).call(this), Z(this, gt).removeObserver(this)
    }
    setOptions(t) {
      const n = this.options,
        r = Z(this, gt);
      if (this.options = Z(this, yr).defaultQueryOptions(t), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof fs(this.options.enabled, Z(this, gt)) != "boolean") throw new Error("Expected enabled to be a boolean or a callback that returns a boolean");
      lt(this, At, Rh).call(this), Z(this, gt).setOptions(this.options), n._defaulted && !Mf(this.options, n) && Z(this, yr).getQueryCache().notify({
        type: "observerOptionsUpdated",
        query: Z(this, gt),
        observer: this
      });
      const s = this.hasListeners();
      s && fv(Z(this, gt), r, this.options, n) && lt(this, At, qu).call(this), this.updateResult(), s && (Z(this, gt) !== r || fs(this.options.enabled, Z(this, gt)) !== fs(n.enabled, Z(this, gt)) || Cl(this.options.staleTime, Z(this, gt)) !== Cl(n.staleTime, Z(this, gt))) && lt(this, At, Ih).call(this);
      const a = lt(this, At, $h).call(this);
      s && (Z(this, gt) !== r || fs(this.options.enabled, Z(this, gt)) !== fs(n.enabled, Z(this, gt)) || a !== Z(this, So)) && lt(this, At, Mh).call(this, a)
    }
    getOptimisticResult(t) {
      const n = Z(this, yr).getQueryCache().build(Z(this, yr), t),
        r = this.createResult(n, t);
      return Lx(this, r) && (De(this, sr, r), De(this, jl, this.options), De(this, _i, Z(this, gt).state)), r
    }
    getCurrentResult() {
      return Z(this, sr)
    }
    trackResult(t, n) {
      return new Proxy(t, {
        get: (r, s) => (this.trackProp(s), n == null || n(s), Reflect.get(r, s))
      })
    }
    trackProp(t) {
      Z(this, Ul).add(t)
    }
    getCurrentQuery() {
      return Z(this, gt)
    }
    refetch({
      ...t
    } = {}) {
      return this.fetch({
        ...t
      })
    }
    fetchOptimistic(t) {
      const n = Z(this, yr).defaultQueryOptions(t),
        r = Z(this, yr).getQueryCache().build(Z(this, yr), n);
      return r.fetch().then(() => this.createResult(r, n))
    }
    fetch(t) {
      return lt(this, At, qu).call(this, {
        ...t,
        cancelRefetch: t.cancelRefetch ?? !0
      }).then(() => (this.updateResult(), Z(this, sr)))
    }
    createResult(t, n) {
      var P;
      const r = Z(this, gt),
        s = this.options,
        a = Z(this, sr),
        o = Z(this, _i),
        i = Z(this, jl),
        c = t !== r ? t.state : Z(this, Wc),
        {
          state: d
        } = t;
      let f = {
          ...d
        },
        p = !1,
        h;
      if (n._optimisticResults) {
        const N = this.hasListeners(),
          ne = !N && dv(t, n),
          Y = N && fv(t, r, n, s);
        (ne || Y) && (f = {
          ...f,
          ...vb(d.data, t.options)
        }), n._optimisticResults === "isRestoring" && (f.fetchStatus = "idle")
      }
      let {
        error: _,
        errorUpdatedAt: v,
        status: C
      } = f;
      h = f.data;
      let y = !1;
      if (n.placeholderData !== void 0 && h === void 0 && C === "pending") {
        let N;
        a != null && a.isPlaceholderData && n.placeholderData === (i == null ? void 0 : i.placeholderData) ? (N = a.data, y = !0) : N = typeof n.placeholderData == "function" ? n.placeholderData((P = Z(this, Vl)) == null ? void 0 : P.state.data, Z(this, Vl)) : n.placeholderData, N !== void 0 && (C = "success", h = Th(a == null ? void 0 : a.data, N, n), p = !0)
      }
      if (n.select && h !== void 0 && !y)
        if (a && h === (o == null ? void 0 : o.data) && n.select === Z(this, Gc)) h = Z(this, Hl);
        else try {
          De(this, Gc, n.select), h = n.select(h), h = Th(a == null ? void 0 : a.data, h, n), De(this, Hl, h), De(this, ko, null)
        } catch (N) {
          De(this, ko, N)
        }
      Z(this, ko) && (_ = Z(this, ko), h = Z(this, Hl), v = Date.now(), C = "error");
      const b = f.fetchStatus === "fetching",
        w = C === "pending",
        x = C === "error",
        E = w && b,
        S = h !== void 0,
        j = {
          status: C,
          fetchStatus: f.fetchStatus,
          isPending: w,
          isSuccess: C === "success",
          isError: x,
          isInitialLoading: E,
          isLoading: E,
          data: h,
          dataUpdatedAt: f.dataUpdatedAt,
          error: _,
          errorUpdatedAt: v,
          failureCount: f.fetchFailureCount,
          failureReason: f.fetchFailureReason,
          errorUpdateCount: f.errorUpdateCount,
          isFetched: f.dataUpdateCount > 0 || f.errorUpdateCount > 0,
          isFetchedAfterMount: f.dataUpdateCount > c.dataUpdateCount || f.errorUpdateCount > c.errorUpdateCount,
          isFetching: b,
          isRefetching: b && !w,
          isLoadingError: x && !S,
          isPaused: f.fetchStatus === "paused",
          isPlaceholderData: p,
          isRefetchError: x && S,
          isStale: S0(t, n),
          refetch: this.refetch,
          promise: Z(this, xo)
        };
      if (this.options.experimental_prefetchInRender) {
        const N = _e => {
            j.status === "error" ? _e.reject(j.error) : j.data !== void 0 && _e.resolve(j.data)
          },
          ne = () => {
            const _e = De(this, xo, j.promise = Ph());
            N(_e)
          },
          Y = Z(this, xo);
        switch (Y.status) {
          case "pending":
            t.queryHash === r.queryHash && N(Y);
            break;
          case "fulfilled":
            (j.status === "error" || j.data !== Y.value) && ne();
            break;
          case "rejected":
            (j.status !== "error" || j.error !== Y.reason) && ne();
            break
        }
      }
      return j
    }
    updateResult() {
      const t = Z(this, sr),
        n = this.createResult(Z(this, gt), this.options);
      if (De(this, _i, Z(this, gt).state), De(this, jl, this.options), Z(this, _i).data !== void 0 && De(this, Vl, Z(this, gt)), Mf(n, t)) return;
      De(this, sr, n);
      const r = () => {
        if (!t) return !0;
        const {
          notifyOnChangeProps: s
        } = this.options, a = typeof s == "function" ? s() : s;
        if (a === "all" || !a && !Z(this, Ul).size) return !0;
        const o = new Set(a ?? Z(this, Ul));
        return this.options.throwOnError && o.add("error"), Object.keys(Z(this, sr)).some(i => {
          const l = i;
          return Z(this, sr)[l] !== t[l] && o.has(l)
        })
      };
      lt(this, At, wb).call(this, {
        listeners: r()
      })
    }
    onQueryUpdate() {
      this.updateResult(), this.hasListeners() && lt(this, At, Oh).call(this)
    }
  }, yr = new WeakMap, gt = new WeakMap, Wc = new WeakMap, sr = new WeakMap, _i = new WeakMap, jl = new WeakMap, xo = new WeakMap, ko = new WeakMap, Gc = new WeakMap, Hl = new WeakMap, Vl = new WeakMap, yi = new WeakMap, bi = new WeakMap, So = new WeakMap, Ul = new WeakMap, At = new WeakSet, qu = function(t) {
    lt(this, At, Rh).call(this);
    let n = Z(this, gt).fetch(this.options, t);
    return t != null && t.throwOnError || (n = n.catch(zr)), n
  }, Ih = function() {
    lt(this, At, Dh).call(this);
    const t = Cl(this.options.staleTime, Z(this, gt));
    if (Oi || Z(this, sr).isStale || !Sh(t)) return;
    const r = cb(Z(this, sr).dataUpdatedAt, t) + 1;
    De(this, yi, setTimeout(() => {
      Z(this, sr).isStale || this.updateResult()
    }, r))
  }, $h = function() {
    return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(Z(this, gt)) : this.options.refetchInterval) ?? !1
  }, Mh = function(t) {
    lt(this, At, Lh).call(this), De(this, So, t), !(Oi || fs(this.options.enabled, Z(this, gt)) === !1 || !Sh(Z(this, So)) || Z(this, So) === 0) && De(this, bi, setInterval(() => {
      (this.options.refetchIntervalInBackground || k0.isFocused()) && lt(this, At, qu).call(this)
    }, Z(this, So)))
  }, Oh = function() {
    lt(this, At, Ih).call(this), lt(this, At, Mh).call(this, lt(this, At, $h).call(this))
  }, Dh = function() {
    Z(this, yi) && (clearTimeout(Z(this, yi)), De(this, yi, void 0))
  }, Lh = function() {
    Z(this, bi) && (clearInterval(Z(this, bi)), De(this, bi, void 0))
  }, Rh = function() {
    const t = Z(this, yr).getQueryCache().build(Z(this, yr), this.options);
    if (t === Z(this, gt)) return;
    const n = Z(this, gt);
    De(this, gt, t), De(this, Wc, t.state), this.hasListeners() && (n == null || n.removeObserver(this), t.addObserver(this))
  }, wb = function(t) {
    Nn.batch(() => {
      t.listeners && this.listeners.forEach(n => {
        n(Z(this, sr))
      }), Z(this, yr).getQueryCache().notify({
        query: Z(this, gt),
        type: "observerResultsUpdated"
      })
    })
  }, A3);

function Dx(e, t) {
  return fs(t.enabled, e) !== !1 && e.state.data === void 0 && !(e.state.status === "error" && t.retryOnMount === !1)
}

function dv(e, t) {
  return Dx(e, t) || e.state.data !== void 0 && Nh(e, t, t.refetchOnMount)
}

function Nh(e, t, n) {
  if (fs(t.enabled, e) !== !1) {
    const r = typeof n == "function" ? n(e) : n;
    return r === "always" || r !== !1 && S0(e, t)
  }
  return !1
}

function fv(e, t, n, r) {
  return (e !== t || fs(r.enabled, e) === !1) && (!n.suspense || e.state.status !== "error") && S0(e, n)
}

function S0(e, t) {
  return fs(t.enabled, e) !== !1 && e.isStaleByTime(Cl(t.staleTime, e))
}

function Lx(e, t) {
  return !Mf(e.getCurrentResult(), t)
}
var Eo, To, br, ba, Oa, uf, Fh, P3, Rx = (P3 = class extends gu {
    constructor(n, r) {
      super();
      Qe(this, Oa);
      Qe(this, Eo);
      Qe(this, To);
      Qe(this, br);
      Qe(this, ba);
      De(this, Eo, n), this.setOptions(r), this.bindMethods(), lt(this, Oa, uf).call(this)
    }
    bindMethods() {
      this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this)
    }
    setOptions(n) {
      var s;
      const r = this.options;
      this.options = Z(this, Eo).defaultMutationOptions(n), Mf(this.options, r) || Z(this, Eo).getMutationCache().notify({
        type: "observerOptionsUpdated",
        mutation: Z(this, br),
        observer: this
      }), r != null && r.mutationKey && this.options.mutationKey && Di(r.mutationKey) !== Di(this.options.mutationKey) ? this.reset() : ((s = Z(this, br)) == null ? void 0 : s.state.status) === "pending" && Z(this, br).setOptions(this.options)
    }
    onUnsubscribe() {
      var n;
      this.hasListeners() || (n = Z(this, br)) == null || n.removeObserver(this)
    }
    onMutationUpdate(n) {
      lt(this, Oa, uf).call(this), lt(this, Oa, Fh).call(this, n)
    }
    getCurrentResult() {
      return Z(this, To)
    }
    reset() {
      var n;
      (n = Z(this, br)) == null || n.removeObserver(this), De(this, br, void 0), lt(this, Oa, uf).call(this), lt(this, Oa, Fh).call(this)
    }
    mutate(n, r) {
      var s;
      return De(this, ba, r), (s = Z(this, br)) == null || s.removeObserver(this), De(this, br, Z(this, Eo).getMutationCache().build(Z(this, Eo), this.options)), Z(this, br).addObserver(this), Z(this, br).execute(n)
    }
  }, Eo = new WeakMap, To = new WeakMap, br = new WeakMap, ba = new WeakMap, Oa = new WeakSet, uf = function() {
    var r;
    const n = ((r = Z(this, br)) == null ? void 0 : r.state) ?? yb();
    De(this, To, {
      ...n,
      isPending: n.status === "pending",
      isSuccess: n.status === "success",
      isError: n.status === "error",
      isIdle: n.status === "idle",
      mutate: this.mutate,
      reset: this.reset
    })
  }, Fh = function(n) {
    Nn.batch(() => {
      var r, s, a, o, i, l, c, d;
      if (Z(this, ba) && this.hasListeners()) {
        const f = Z(this, To).variables,
          p = Z(this, To).context;
        (n == null ? void 0 : n.type) === "success" ? ((s = (r = Z(this, ba)).onSuccess) == null || s.call(r, n.data, f, p), (o = (a = Z(this, ba)).onSettled) == null || o.call(a, n.data, null, f, p)) : (n == null ? void 0 : n.type) === "error" && ((l = (i = Z(this, ba)).onError) == null || l.call(i, n.error, f, p), (d = (c = Z(this, ba)).onSettled) == null || d.call(c, void 0, n.error, f, p))
      }
      this.listeners.forEach(f => {
        f(Z(this, To))
      })
    })
  }, P3),
  Nx = "VUE_QUERY_CLIENT";

function Cb(e) {
  const t = e ? `:${e}` : "";
  return `${Nx}${t}`
}

function Bh(e, t) {
  Object.keys(e).forEach(n => {
    e[n] = t[n]
  })
}

function jh(e, t, n = "", r = 0) {
  if (t) {
    const s = t(e, n, r);
    if (s === void 0 && Ht(e) || s !== void 0) return s
  }
  if (Array.isArray(e)) return e.map((s, a) => jh(s, t, String(a), r + 1));
  if (typeof e == "object" && Bx(e)) {
    const s = Object.entries(e).map(([a, o]) => [a, jh(o, t, a, r + 1)]);
    return Object.fromEntries(s)
  }
  return e
}

function Fx(e, t) {
  return jh(e, t)
}

function ct(e, t = !1) {
  return Fx(e, (n, r, s) => {
    if (s === 1 && r === "queryKey") return ct(n, !0);
    if (t && jx(n)) return ct(n(), t);
    if (Ht(n)) return ct(u(n), t)
  })
}

function Bx(e) {
  if (Object.prototype.toString.call(e) !== "[object Object]") return !1;
  const t = Object.getPrototypeOf(e);
  return t === null || t === Object.prototype
}

function jx(e) {
  return typeof e == "function"
}

function xb(e = "") {
  if (!ow()) throw new Error("vue-query hooks can only be used inside setup() function or functions that support injection context.");
  const t = Cb(e),
    n = Hn(t);
  if (!n) throw new Error("No 'queryClient' found in Vue context, use 'VueQueryPlugin' to properly initialize the library.");
  return n
}
var Hx = class extends _b {
    find(e) {
      return super.find(ct(e))
    }
    findAll(e = {}) {
      return super.findAll(ct(e))
    }
  },
  Vx = class extends bb {
    find(e) {
      return super.find(ct(e))
    }
    findAll(e = {}) {
      return super.findAll(ct(e))
    }
  },
  kb = class extends Mx {
    constructor(e = {}) {
      const t = {
        defaultOptions: e.defaultOptions,
        queryCache: e.queryCache || new Hx,
        mutationCache: e.mutationCache || new Vx
      };
      super(t), this.isRestoring = U(!1)
    }
    isFetching(e = {}) {
      return super.isFetching(ct(e))
    }
    isMutating(e = {}) {
      return super.isMutating(ct(e))
    }
    getQueryData(e) {
      return super.getQueryData(ct(e))
    }
    ensureQueryData(e) {
      return super.ensureQueryData(ct(e))
    }
    getQueriesData(e) {
      return super.getQueriesData(ct(e))
    }
    setQueryData(e, t, n = {}) {
      return super.setQueryData(ct(e), t, ct(n))
    }
    setQueriesData(e, t, n = {}) {
      return super.setQueriesData(ct(e), t, ct(n))
    }
    getQueryState(e) {
      return super.getQueryState(ct(e))
    }
    removeQueries(e = {}) {
      return super.removeQueries(ct(e))
    }
    resetQueries(e = {}, t = {}) {
      return super.resetQueries(ct(e), ct(t))
    }
    cancelQueries(e = {}, t = {}) {
      return super.cancelQueries(ct(e), ct(t))
    }
    invalidateQueries(e = {}, t = {}) {
      const n = ct(e),
        r = ct(t);
      if (super.invalidateQueries({
          ...n,
          refetchType: "none"
        }, r), n.refetchType === "none") return Promise.resolve();
      const s = {
        ...n,
        type: n.refetchType ?? n.type ?? "active"
      };
      return Ot().then(() => super.refetchQueries(s, r))
    }
    refetchQueries(e = {}, t = {}) {
      return super.refetchQueries(ct(e), ct(t))
    }
    fetchQuery(e) {
      return super.fetchQuery(ct(e))
    }
    prefetchQuery(e) {
      return super.prefetchQuery(ct(e))
    }
    fetchInfiniteQuery(e) {
      return super.fetchInfiniteQuery(ct(e))
    }
    prefetchInfiniteQuery(e) {
      return super.prefetchInfiniteQuery(ct(e))
    }
    setDefaultOptions(e) {
      super.setDefaultOptions(ct(e))
    }
    setQueryDefaults(e, t) {
      super.setQueryDefaults(ct(e), ct(t))
    }
    getQueryDefaults(e) {
      return super.getQueryDefaults(ct(e))
    }
    setMutationDefaults(e, t) {
      super.setMutationDefaults(ct(e), ct(t))
    }
    getMutationDefaults(e) {
      return super.getMutationDefaults(ct(e))
    }
  },
  Ux = {
    install: (e, t = {}) => {
      const n = Cb(t.queryClientKey);
      let r;
      if ("queryClient" in t && t.queryClient) r = t.queryClient;
      else {
        const o = "queryClientConfig" in t ? t.queryClientConfig : void 0;
        r = new kb(o)
      }
      Oi || r.mount();
      let s = () => {};
      if (t.clientPersister) {
        r.isRestoring.value = !0;
        const [o, i] = t.clientPersister(r);
        s = o, i.then(() => {
          var l;
          r.isRestoring.value = !1, (l = t.clientPersisterOnSuccess) == null || l.call(t, r)
        })
      }
      const a = () => {
        r.unmount(), s()
      };
      if (e.onUnmount) e.onUnmount(a);
      else {
        const o = e.unmount;
        e.unmount = function() {
          a(), o()
        }
      }
      e.provide(n, r)
    }
  };

function zx(e, t, n) {
  const r = xb(),
    s = L(() => {
      const h = ct(t);
      typeof h.enabled == "function" && (h.enabled = h.enabled());
      const _ = r.defaultQueryOptions(h);
      return _._optimisticResults = r.isRestoring.value ? "isRestoring" : "optimistic", _
    }),
    a = new e(r, s.value),
    o = s.value.shallow ? mp(a.getCurrentResult()) : xn(a.getCurrentResult());
  let i = () => {};
  Ne(r.isRestoring, h => {
    h || (i(), i = a.subscribe(_ => {
      Bh(o, _)
    }))
  }, {
    immediate: !0
  });
  const l = () => {
    a.setOptions(s.value), Bh(o, a.getCurrentResult())
  };
  Ne(s, l), hu(() => {
    i()
  });
  const c = (...h) => (l(), o.refetch(...h)),
    d = () => new Promise((h, _) => {
      let v = () => {};
      const C = () => {
        if (s.value.enabled !== !1) {
          a.setOptions(s.value);
          const y = a.getOptimisticResult(s.value);
          y.isStale ? (v(), a.fetchOptimistic(s.value).then(h, b => {
            Ah(s.value.throwOnError, [b, a.getCurrentQuery()]) ? _(b) : h(a.getCurrentResult())
          })) : (v(), h(y))
        }
      };
      C(), v = Ne(s, C)
    });
  Ne(() => o.error, h => {
    if (o.isError && !o.isFetching && Ah(s.value.throwOnError, [h, a.getCurrentQuery()])) throw h
  });
  const f = s.value.shallow ? lo(o) : Ui(o),
    p = Hr(f);
  for (const h in o) typeof o[h] == "function" && (p[h] = o[h]);
  return p.suspense = d, p.refetch = c, p
}

function ns(e, t) {
  return zx(Ox, e)
}

function E0(e, t) {
  const n = xb(),
    r = L(() => n.defaultMutationOptions(ct(e))),
    s = new Rx(n, r.value),
    a = r.value.shallow ? mp(s.getCurrentResult()) : xn(s.getCurrentResult()),
    o = s.subscribe(d => {
      Bh(a, d)
    }),
    i = (d, f) => {
      s.mutate(d, f).catch(() => {})
    };
  Ne(r, () => {
    s.setOptions(r.value)
  }), hu(() => {
    o()
  });
  const l = r.value.shallow ? lo(a) : Ui(a),
    c = Hr(l);
  return Ne(() => a.error, d => {
    if (d && Ah(r.value.throwOnError, [d])) throw d
  }), {
    ...c,
    mutate: i,
    mutateAsync: a.mutate,
    reset: a.reset
  }
}
const Li = {
    code: "",
    symbol: "",
    subunits: 0,
    exponent: 0
  },
  Kn = {
    locale: "",
    identifier: "",
    isMobile: !1,
    currency: "",
    lobby_launch_url: ""
  },
  Zr = {
    lobby_enabled: !1,
    lobby_fe_script_url: "",
    drops_enabled: !1,
    drops_token: "",
    drops_api_url: "",
    drops_fe_script_url: "",
    profile_enabled: !1,
    profile_api_url: "",
    profile_token: "",
    gamelist_enabled: !1,
    gamelist_api_url: "",
    gamelist_token: "",
    challenges_enabled: !1,
    challenges_api_url: "",
    challenges_token: "",
    challenges_fe_script_url: ""
  },
  Yx = e => {
    Object.assign(Kn, e)
  },
  Wx = e => {
    Object.assign(Zr, e)
  },
  Gx = e => {
    Object.assign(Li, e)
  },
  Hh = U(!1),
  $t = new kb,
  T0 = U(0),
  wn = U(null),
  pv = e => {
    T0.value = e ?? 0
  },
  Do = U(""),
  Qx = e => {
    const t = e.indexOf("/api/");
    return t !== -1 ? e.slice(0, t) : e
  },
  qx = () => Qx(Zr.drops_api_url),
  Kx = () => "/api/v1/lobby/",
  xp = () => {
    const e = Zr.drops_token;
    return e ? {
      headers: {
        Authorization: `Bearer ${e}`
      }
    } : {}
  },
  kp = e => `${qx()}${Kx()}${e}`,
  Zx = async () => await fetch(kp("drop_campaigns"), xp()).then(e => e.json()).then(e => e.data), Jx = async e => await fetch(kp(`drop_campaigns/${e}`), xp()).then(t => t.json()).then(t => t), Xx = async e => await fetch(kp(`drop_campaigns/${e}/join`), {
    method: "POST",
    body: JSON.stringify({
      id: e
    }),
    ...xp()
  }).then(async t => {
    const n = await t.json();
    if (t.ok) return n;
    throw {
      status: t.status,
      message: n.error || "Unknown error occurred",
      code: n.code
    }
  }).catch(t => {
    throw {
      status: t.status,
      message: t.message || "Network error occurred",
      code: t == null ? void 0 : t.code
    }
  }), ek = async () => await fetch(kp("drop_campaigns/exists_by_casino"), xp()).then(e => e.json()), tk = () => ns({
    queryKey: ["dropExist"],
    queryFn: () => ek(),
    refetchInterval: 30 * 60 * 1e3,
    placeholderData: ts,
    staleTime: 30 * 60 * 1e3
  }), nk = "en-SOCIAL", Vh = 100, hv = 10, xl = 10, rd = L(() => Kn.locale === nk);
let Ec;
const Uh = U(!1);

function rk(e) {
  Ec = e, Uh.value || (Uh.value = !0, Ec("inited"))
}
let k1 = !1;
const sk = () => {
    k1 || (k1 = !0, setTimeout(() => {
      k1 = !1, $t.invalidateQueries({
        queryKey: ["challenges"]
      }), $t.invalidateQueries({
        queryKey: ["challengeSearchPagination"]
      }), $t.invalidateQueries({
        queryKey: ["challengeFinishedSearchPagination"]
      }), $t.invalidateQueries({
        queryKey: ["challengeDetails"]
      })
    }, 5e3))
  },
  Cr = U(""),
  Sb = U(xl),
  Tc = () => {
    Cr.value = ""
  },
  zh = 2,
  Eb = () => {
    Ec("join_challenge_int")
  },
  ak = async e => {
    const t = await fetch(e).then(r => r.json()),
      n = await (t == null ? void 0 : t.game_page_url);
    Ec("open_game", {
      url: n
    })
  }, ps = () => {
    Ec("close_lobby")
  }, ok = () => {
    $t.invalidateQueries({
      queryKey: ["challenges"]
    }), $t.invalidateQueries({
      queryKey: ["challengeSearchPagination"]
    }), $t.invalidateQueries({
      queryKey: ["challengeFinishedSearchPagination"]
    }), $t.invalidateQueries({
      queryKey: ["challengeDetails"]
    }), $t.invalidateQueries({
      queryKey: ["challengeLeaderboard"]
    }), $t.invalidateQueries({
      queryKey: ["challengeLeaderboardFull"]
    }), $t.invalidateQueries({
      queryKey: ["challengePermissions"]
    }), $t.invalidateQueries({
      queryKey: ["challengeExist"]
    })
  }, Tb = () => Zr.challenges_api_url, Ab = (e = !1) => e ? "/api/v2/lobby/" : "/api/v1/lobby/", Yo = () => {
    const e = Zr.challenges_token;
    return e ? {
      headers: {
        Authorization: `Bearer ${e}`
      }
    } : {}
  }, vu = e => `${Tb()}${Ab()}${e}`, Pb = (e, t, n, r = !1) => `${Tb()}${Ab(r)}${e}?&page=${t}&per_page=${n}`, ik = async () => await fetch(vu("challenges"), Yo()).then(e => e.json().then(t => t.data)), lk = async ({
    id: e,
    page: t = 1,
    per_page: n = Vh
  }) => await fetch(Pb(`challenges/${e}/leaderboard`, t, n), Yo()).then(r => r.json().then(s => s.data)), uk = async e => await fetch(vu(`challenges/${e}`), Yo()).then(t => t.json()), ck = async (e, t, n) => await fetch(vu(`challenges/${e}/join`), {
    method: "POST",
    body: JSON.stringify({
      join_code: t,
      game_identifier: n
    }),
    ...Yo()
  }).then(async r => {
    const s = await r.json();
    if (r.ok) return s;
    throw {
      status: r.status,
      message: s.error || "Unknown error occurred",
      code: s.code
    }
  }).catch(r => {
    throw {
      status: r.status,
      message: r.message || "Network error occurred",
      code: r == null ? void 0 : r.code
    }
  }), dk = async e => await fetch(vu("challenges"), {
    method: "POST",
    body: JSON.stringify(e),
    ...Yo()
  }).then(async t => {
    const n = await t.json();
    if (t.ok) return n;
    throw n
  }).catch(t => {
    throw t
  }), fk = (e, t, n, r, s) => {
    const o = `${Pb(e,t,n,!0)}&status=${s}`;
    return r ? o + `&filter%5Bname%5D=${r}` : o
  }, Ib = async ({
    page: e = 1,
    per_page: t = xl,
    search: n = "",
    status: r = "active"
  }) => {
    const s = n && n.length > 2 ? n : "",
      a = fk("challenges", e, t, s, r);
    return await fetch(a, Yo()).then(o => o.json().then(i => (Sb.value = i.data.meta.total, i.data.scope)))
  }, pk = async () => await fetch(vu("challenges/permissions"), Yo()).then(e => e.json().then(t => t.p2p_creation_allowed ?? !1)), hk = async () => await fetch(vu("challenges/exists_by_casino"), Yo()).then(e => e.json()), mk = () => ns({
    queryKey: ["challengeExist"],
    queryFn: () => hk(),
    refetchInterval: 30 * 60 * 1e3,
    placeholderData: ts,
    staleTime: 30 * 60 * 1e3
  }), A0 = () => ns({
    queryKey: ["challengePermissions"],
    queryFn: () => pk(),
    refetchInterval: 30 * 60 * 1e3,
    placeholderData: ts,
    staleTime: 30 * 60 * 1e3
  }), $b = () => {
    const {
      data: e,
      isLoading: t
    } = tk(), {
      data: n,
      isLoading: r
    } = mk(), {
      data: s,
      isLoading: a
    } = A0(), o = L(() => e.value || !1), i = L(() => n.value || s.value || !1), l = L(() => Zr.gamelist_enabled), c = L(() => Zr.profile_enabled && !rd.value), d = L(() => t.value || r.value || a.value);
    return {
      isDropsTabVisible: o,
      isChallengesTabVisible: i,
      isGameListTabVisible: l,
      isProfileTabVisible: c,
      isDataLoading: d
    }
  };
let Df;
const Yh = U(!1);

function gk(e) {
  Df = e, Yh.value || (Yh.value = !0, Df("inited"))
}
let S1 = !1;
const vk = () => {
    S1 || (S1 = !0, setTimeout(() => {
      S1 = !1, $t.invalidateQueries({
        queryKey: ["drops"]
      }), $t.invalidateQueries({
        queryKey: ["dropDetails"]
      })
    }, 5e3))
  },
  Mb = async e => {
    const t = await fetch(e).then(r => r.json()),
      n = await (t == null ? void 0 : t.game_page_url);
    Df("open_game", {
      url: n
    })
  }, js = () => {
    Df("close_lobby")
  }, _k = () => {
    $t.invalidateQueries({
      queryKey: ["drops"]
    }), $t.invalidateQueries({
      queryKey: ["dropDetails"]
    }), $t.invalidateQueries({
      queryKey: ["dropExist"]
    })
  }, yk = te({
    __name: "RootPage",
    setup(e) {
      const {
        isDropsTabVisible: t,
        isChallengesTabVisible: n,
        isGameListTabVisible: r,
        isProfileTabVisible: s,
        isDataLoading: a
      } = $b();
      return gn(() => {
        a.value || (t.value ? Cn.push({
          name: "drop",
          params: {
            id: ""
          }
        }) : n.value ? Cn.push({
          name: "challenge",
          params: {
            id: ""
          }
        }) : r.value ? Cn.push({
          name: "games"
        }) : s.value ? Cn.push({
          name: "profile"
        }) : js())
      }), (o, i) => (g(), k("div"))
    }
  });

function bk(e) {
  return Kc() ? (hu(e), !0) : !1
}

function Wh(e) {
  return typeof e == "function" ? e() : u(e)
}
const wk = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const mv = () => {};

function Ck(e, t) {
  function n(...r) {
    return new Promise((s, a) => {
      Promise.resolve(e(() => t.apply(this, r), {
        fn: t,
        thisArg: this,
        args: r
      })).then(s).catch(a)
    })
  }
  return n
}

function xk(e, t = {}) {
  let n, r, s = mv;
  const a = i => {
    clearTimeout(i), s(), s = mv
  };
  return i => {
    const l = Wh(e),
      c = Wh(t.maxWait);
    return n && a(n), l <= 0 || c !== void 0 && c <= 0 ? (r && (a(r), r = null), Promise.resolve(i())) : new Promise((d, f) => {
      s = t.rejectOnCancel ? f : d, c && !r && (r = setTimeout(() => {
        n && a(n), r = null, d(i())
      }, c)), n = setTimeout(() => {
        r && a(r), r = null, d(i())
      }, l)
    })
  }
}

function kk(e, t = 200, n = {}) {
  return Ck(xk(t, n), e)
}

function Ob(e, t = 200, n = {}) {
  const r = U(e.value),
    s = kk(() => {
      r.value = e.value
    }, t, n);
  return Ne(e, () => s()), r
}
const Sk = wk ? window : void 0;

function Ek() {
  const e = U(!1),
    t = gr();
  return t && Ge(() => {
    e.value = !0
  }, t), e
}

function Tk(e) {
  const t = Ek();
  return L(() => (t.value, !!e()))
}

function Tr(e, t = {}) {
  const {
    window: n = Sk
  } = t, r = Tk(() => n && "matchMedia" in n && typeof n.matchMedia == "function");
  let s;
  const a = U(!1),
    o = c => {
      a.value = c.matches
    },
    i = () => {
      s && ("removeEventListener" in s ? s.removeEventListener("change", o) : s.removeListener(o))
    },
    l = gn(() => {
      r.value && (i(), s = n.matchMedia(Wh(e)), "addEventListener" in s ? s.addEventListener("change", o) : s.addListener(o), a.value = s.matches)
    });
  return bk(() => {
    l(), i(), s = void 0
  }), a
}

function Db(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object")
    if (Array.isArray(e)) {
      var s = e.length;
      for (t = 0; t < s; t++) e[t] && (n = Db(e[t])) && (r && (r += " "), r += n)
    } else
      for (n in e) e[n] && (r && (r += " "), r += n);
  return r
}

function Lb() {
  for (var e, t, n = 0, r = "", s = arguments.length; n < s; n++)(e = arguments[n]) && (t = Db(e)) && (r && (r += " "), r += t);
  return r
}
const gv = e => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e,
  vv = Lb,
  _u = (e, t) => n => {
    var r;
    if ((t == null ? void 0 : t.variants) == null) return vv(e, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
    const {
      variants: s,
      defaultVariants: a
    } = t, o = Object.keys(s).map(c => {
      const d = n == null ? void 0 : n[c],
        f = a == null ? void 0 : a[c];
      if (d === null) return null;
      const p = gv(d) || gv(f);
      return s[c][p]
    }), i = n && Object.entries(n).reduce((c, d) => {
      let [f, p] = d;
      return p === void 0 || (c[f] = p), c
    }, {}), l = t == null || (r = t.compoundVariants) === null || r === void 0 ? void 0 : r.reduce((c, d) => {
      let {
        class: f,
        className: p,
        ...h
      } = d;
      return Object.entries(h).every(_ => {
        let [v, C] = _;
        return Array.isArray(C) ? C.includes({
          ...a,
          ...i
        } [v]) : {
          ...a,
          ...i
        } [v] === C
      }) ? [...c, f, p] : c
    }, []);
    return vv(e, o, l, n == null ? void 0 : n.class, n == null ? void 0 : n.className)
  };
/*!
 * shared v10.0.7
 * (c) 2025 kazuya kawaguchi
 * Released under the MIT License.
 */
const Lf = typeof window < "u",
  Wo = (e, t = !1) => t ? Symbol.for(e) : Symbol(e),
  Ac = e => typeof e == "number" && isFinite(e),
  _v = e => Nb(e) === "[object RegExp]",
  Ak = e => hs(e) && Object.keys(e).length === 0,
  Ws = Object.assign,
  Pk = Object.create,
  kr = (e = null) => Pk(e);
let yv;
const Rb = () => yv || (yv = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : kr()),
  Ik = Object.prototype.hasOwnProperty;

function Rf(e, t) {
  return Ik.call(e, t)
}
const xa = Array.isArray,
  Od = e => typeof e == "function",
  vn = e => typeof e == "string",
  ha = e => typeof e == "boolean",
  Sr = e => e !== null && typeof e == "object",
  $k = Object.prototype.toString,
  Nb = e => $k.call(e),
  hs = e => Nb(e) === "[object Object]",
  Dd = e => !Sr(e) || xa(e);

function cf(e, t) {
  if (Dd(e) || Dd(t)) throw new Error("Invalid value");
  const n = [{
    src: e,
    des: t
  }];
  for (; n.length;) {
    const {
      src: r,
      des: s
    } = n.pop();
    Object.keys(r).forEach(a => {
      a !== "__proto__" && (Sr(r[a]) && !Sr(s[a]) && (s[a] = Array.isArray(r[a]) ? [] : kr()), Dd(s[a]) || Dd(r[a]) ? s[a] = r[a] : n.push({
        src: r[a],
        des: s[a]
      }))
    })
  }
}
/*!
 * shared v10.0.7
 * (c) 2025 kazuya kawaguchi
 * Released under the MIT License.
 */
const Mk = (e, t, n) => Ok({
    l: e,
    k: t,
    s: n
  }),
  Ok = e => JSON.stringify(e).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027"),
  lr = e => typeof e == "number" && isFinite(e),
  Dk = e => I0(e) === "[object Date]",
  bv = e => I0(e) === "[object RegExp]",
  P0 = e => Zt(e) && Object.keys(e).length === 0,
  Go = Object.assign,
  Lk = Object.create,
  fr = (e = null) => Lk(e);
let wv;
const Rk = () => wv || (wv = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : fr());

function Cv(e) {
  return e.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;")
}
const Nk = Object.prototype.hasOwnProperty;

function di(e, t) {
  return Nk.call(e, t)
}
const Gs = Array.isArray,
  kn = e => typeof e == "function",
  nt = e => typeof e == "string",
  xr = e => typeof e == "boolean",
  Bn = e => e !== null && typeof e == "object",
  Fk = e => Bn(e) && kn(e.then) && kn(e.catch),
  Fb = Object.prototype.toString,
  I0 = e => Fb.call(e),
  Zt = e => I0(e) === "[object Object]",
  Bk = e => e == null ? "" : Gs(e) || Zt(e) && e.toString === Fb ? JSON.stringify(e, null, 2) : String(e);

function $0(e, t = "") {
  return e.reduce((n, r, s) => s === 0 ? n + r : n + t + r, "")
}

function jk(e, t) {
  typeof console < "u" && (console.warn("[intlify] " + e), t && console.warn(t.stack))
}
/*!
 * message-compiler v10.0.7
 * (c) 2025 kazuya kawaguchi
 * Released under the MIT License.
 */
function Hk(e, t, n) {
  return {
    line: e,
    column: t,
    offset: n
  }
}

function Gh(e, t, n) {
  return {
    start: e,
    end: t
  }
}
const It = {
    EXPECTED_TOKEN: 1,
    INVALID_TOKEN_IN_PLACEHOLDER: 2,
    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
    UNKNOWN_ESCAPE_SEQUENCE: 4,
    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
    UNBALANCED_CLOSING_BRACE: 6,
    UNTERMINATED_CLOSING_BRACE: 7,
    EMPTY_PLACEHOLDER: 8,
    NOT_ALLOW_NEST_PLACEHOLDER: 9,
    INVALID_LINKED_FORMAT: 10,
    MUST_HAVE_MESSAGES_IN_PLURAL: 11,
    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
    UNEXPECTED_EMPTY_LINKED_KEY: 13,
    UNEXPECTED_LEXICAL_ANALYSIS: 14
  },
  Vk = 17;

function Sp(e, t, n = {}) {
  const {
    domain: r,
    messages: s,
    args: a
  } = n, o = e, i = new SyntaxError(String(o));
  return i.code = e, t && (i.location = t), i.domain = r, i
}

function Uk(e) {
  throw e
}
const ca = " ",
  zk = "\r",
  nr = `
`,
  Yk = "\u2028",
  Wk = "\u2029";

function Gk(e) {
  const t = e;
  let n = 0,
    r = 1,
    s = 1,
    a = 0;
  const o = T => t[T] === zk && t[T + 1] === nr,
    i = T => t[T] === nr,
    l = T => t[T] === Wk,
    c = T => t[T] === Yk,
    d = T => o(T) || i(T) || l(T) || c(T),
    f = () => n,
    p = () => r,
    h = () => s,
    _ = () => a,
    v = T => o(T) || l(T) || c(T) ? nr : t[T],
    C = () => v(n),
    y = () => v(n + a);

  function b() {
    return a = 0, d(n) && (r++, s = 0), o(n) && n++, n++, s++, t[n]
  }

  function w() {
    return o(n + a) && a++, a++, t[n + a]
  }

  function x() {
    n = 0, r = 1, s = 1, a = 0
  }

  function E(T = 0) {
    a = T
  }

  function S() {
    const T = n + a;
    for (; T !== n;) b();
    a = 0
  }
  return {
    index: f,
    line: p,
    column: h,
    peekOffset: _,
    charAt: v,
    currentChar: C,
    currentPeek: y,
    next: b,
    peek: w,
    reset: x,
    resetPeek: E,
    skipToPeek: S
  }
}
const to = void 0,
  Qk = ".",
  xv = "'",
  qk = "tokenizer";

function Kk(e, t = {}) {
  const n = t.location !== !1,
    r = Gk(e),
    s = () => r.index(),
    a = () => Hk(r.line(), r.column(), r.index()),
    o = a(),
    i = s(),
    l = {
      currentType: 13,
      offset: i,
      startLoc: o,
      endLoc: o,
      lastType: 13,
      lastOffset: i,
      lastStartLoc: o,
      lastEndLoc: o,
      braceNest: 0,
      inLinked: !1,
      text: ""
    },
    c = () => l,
    {
      onError: d
    } = t;

  function f(A, F, K, ...B) {
    const ce = c();
    if (F.column += K, F.offset += K, d) {
      const le = n ? Gh(ce.startLoc, F) : null,
        X = Sp(A, le, {
          domain: qk,
          args: B
        });
      d(X)
    }
  }

  function p(A, F, K) {
    A.endLoc = a(), A.currentType = F;
    const B = {
      type: F
    };
    return n && (B.loc = Gh(A.startLoc, A.endLoc)), K != null && (B.value = K), B
  }
  const h = A => p(A, 13);

  function _(A, F) {
    return A.currentChar() === F ? (A.next(), F) : (f(It.EXPECTED_TOKEN, a(), 0, F), "")
  }

  function v(A) {
    let F = "";
    for (; A.currentPeek() === ca || A.currentPeek() === nr;) F += A.currentPeek(), A.peek();
    return F
  }

  function C(A) {
    const F = v(A);
    return A.skipToPeek(), F
  }

  function y(A) {
    if (A === to) return !1;
    const F = A.charCodeAt(0);
    return F >= 97 && F <= 122 || F >= 65 && F <= 90 || F === 95
  }

  function b(A) {
    if (A === to) return !1;
    const F = A.charCodeAt(0);
    return F >= 48 && F <= 57
  }

  function w(A, F) {
    const {
      currentType: K
    } = F;
    if (K !== 2) return !1;
    v(A);
    const B = y(A.currentPeek());
    return A.resetPeek(), B
  }

  function x(A, F) {
    const {
      currentType: K
    } = F;
    if (K !== 2) return !1;
    v(A);
    const B = A.currentPeek() === "-" ? A.peek() : A.currentPeek(),
      ce = b(B);
    return A.resetPeek(), ce
  }

  function E(A, F) {
    const {
      currentType: K
    } = F;
    if (K !== 2) return !1;
    v(A);
    const B = A.currentPeek() === xv;
    return A.resetPeek(), B
  }

  function S(A, F) {
    const {
      currentType: K
    } = F;
    if (K !== 7) return !1;
    v(A);
    const B = A.currentPeek() === ".";
    return A.resetPeek(), B
  }

  function T(A, F) {
    const {
      currentType: K
    } = F;
    if (K !== 8) return !1;
    v(A);
    const B = y(A.currentPeek());
    return A.resetPeek(), B
  }

  function j(A, F) {
    const {
      currentType: K
    } = F;
    if (!(K === 7 || K === 11)) return !1;
    v(A);
    const B = A.currentPeek() === ":";
    return A.resetPeek(), B
  }

  function P(A, F) {
    const {
      currentType: K
    } = F;
    if (K !== 9) return !1;
    const B = () => {
        const le = A.currentPeek();
        return le === "{" ? y(A.peek()) : le === "@" || le === "|" || le === ":" || le === "." || le === ca || !le ? !1 : le === nr ? (A.peek(), B()) : ne(A, !1)
      },
      ce = B();
    return A.resetPeek(), ce
  }

  function N(A) {
    v(A);
    const F = A.currentPeek() === "|";
    return A.resetPeek(), F
  }

  function ne(A, F = !0) {
    const K = (ce = !1, le = "") => {
        const X = A.currentPeek();
        return X === "{" || X === "@" || !X ? ce : X === "|" ? !(le === ca || le === nr) : X === ca ? (A.peek(), K(!0, ca)) : X === nr ? (A.peek(), K(!0, nr)) : !0
      },
      B = K();
    return F && A.resetPeek(), B
  }

  function Y(A, F) {
    const K = A.currentChar();
    return K === to ? to : F(K) ? (A.next(), K) : null
  }

  function _e(A) {
    const F = A.charCodeAt(0);
    return F >= 97 && F <= 122 || F >= 65 && F <= 90 || F >= 48 && F <= 57 || F === 95 || F === 36
  }

  function Q(A) {
    return Y(A, _e)
  }

  function re(A) {
    const F = A.charCodeAt(0);
    return F >= 97 && F <= 122 || F >= 65 && F <= 90 || F >= 48 && F <= 57 || F === 95 || F === 36 || F === 45
  }

  function J(A) {
    return Y(A, re)
  }

  function ee(A) {
    const F = A.charCodeAt(0);
    return F >= 48 && F <= 57
  }

  function de(A) {
    return Y(A, ee)
  }

  function se(A) {
    const F = A.charCodeAt(0);
    return F >= 48 && F <= 57 || F >= 65 && F <= 70 || F >= 97 && F <= 102
  }

  function ae(A) {
    return Y(A, se)
  }

  function ke(A) {
    let F = "",
      K = "";
    for (; F = de(A);) K += F;
    return K
  }

  function be(A) {
    let F = "";
    for (;;) {
      const K = A.currentChar();
      if (K === "{" || K === "}" || K === "@" || K === "|" || !K) break;
      if (K === ca || K === nr)
        if (ne(A)) F += K, A.next();
        else {
          if (N(A)) break;
          F += K, A.next()
        }
      else F += K, A.next()
    }
    return F
  }

  function ge(A) {
    C(A);
    let F = "",
      K = "";
    for (; F = J(A);) K += F;
    return A.currentChar() === to && f(It.UNTERMINATED_CLOSING_BRACE, a(), 0), K
  }

  function H(A) {
    C(A);
    let F = "";
    return A.currentChar() === "-" ? (A.next(), F += `-${ke(A)}`) : F += ke(A), A.currentChar() === to && f(It.UNTERMINATED_CLOSING_BRACE, a(), 0), F
  }

  function oe(A) {
    return A !== xv && A !== nr
  }

  function Ce(A) {
    C(A), _(A, "'");
    let F = "",
      K = "";
    for (; F = Y(A, oe);) F === "\\" ? K += D(A) : K += F;
    const B = A.currentChar();
    return B === nr || B === to ? (f(It.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, a(), 0), B === nr && (A.next(), _(A, "'")), K) : (_(A, "'"), K)
  }

  function D(A) {
    const F = A.currentChar();
    switch (F) {
      case "\\":
      case "'":
        return A.next(), `\\${F}`;
      case "u":
        return pe(A, F, 4);
      case "U":
        return pe(A, F, 6);
      default:
        return f(It.UNKNOWN_ESCAPE_SEQUENCE, a(), 0, F), ""
    }
  }

  function pe(A, F, K) {
    _(A, F);
    let B = "";
    for (let ce = 0; ce < K; ce++) {
      const le = ae(A);
      if (!le) {
        f(It.INVALID_UNICODE_ESCAPE_SEQUENCE, a(), 0, `\\${F}${B}${A.currentChar()}`);
        break
      }
      B += le
    }
    return `\\${F}${B}`
  }

  function ye(A) {
    return A !== "{" && A !== "}" && A !== ca && A !== nr
  }

  function Ae(A) {
    C(A);
    let F = "",
      K = "";
    for (; F = Y(A, ye);) K += F;
    return K
  }

  function fe(A) {
    let F = "",
      K = "";
    for (; F = Q(A);) K += F;
    return K
  }

  function I(A) {
    const F = K => {
      const B = A.currentChar();
      return B === "{" || B === "@" || B === "|" || B === "(" || B === ")" || !B || B === ca ? K : (K += B, A.next(), F(K))
    };
    return F("")
  }

  function M(A) {
    C(A);
    const F = _(A, "|");
    return C(A), F
  }

  function W(A, F) {
    let K = null;
    switch (A.currentChar()) {
      case "{":
        return F.braceNest >= 1 && f(It.NOT_ALLOW_NEST_PLACEHOLDER, a(), 0), A.next(), K = p(F, 2, "{"), C(A), F.braceNest++, K;
      case "}":
        return F.braceNest > 0 && F.currentType === 2 && f(It.EMPTY_PLACEHOLDER, a(), 0), A.next(), K = p(F, 3, "}"), F.braceNest--, F.braceNest > 0 && C(A), F.inLinked && F.braceNest === 0 && (F.inLinked = !1), K;
      case "@":
        return F.braceNest > 0 && f(It.UNTERMINATED_CLOSING_BRACE, a(), 0), K = O(A, F) || h(F), F.braceNest = 0, K;
      default: {
        let ce = !0,
          le = !0,
          X = !0;
        if (N(A)) return F.braceNest > 0 && f(It.UNTERMINATED_CLOSING_BRACE, a(), 0), K = p(F, 1, M(A)), F.braceNest = 0, F.inLinked = !1, K;
        if (F.braceNest > 0 && (F.currentType === 4 || F.currentType === 5 || F.currentType === 6)) return f(It.UNTERMINATED_CLOSING_BRACE, a(), 0), F.braceNest = 0, q(A, F);
        if (ce = w(A, F)) return K = p(F, 4, ge(A)), C(A), K;
        if (le = x(A, F)) return K = p(F, 5, H(A)), C(A), K;
        if (X = E(A, F)) return K = p(F, 6, Ce(A)), C(A), K;
        if (!ce && !le && !X) return K = p(F, 12, Ae(A)), f(It.INVALID_TOKEN_IN_PLACEHOLDER, a(), 0, K.value), C(A), K;
        break
      }
    }
    return K
  }

  function O(A, F) {
    const {
      currentType: K
    } = F;
    let B = null;
    const ce = A.currentChar();
    switch ((K === 7 || K === 8 || K === 11 || K === 9) && (ce === nr || ce === ca) && f(It.INVALID_LINKED_FORMAT, a(), 0), ce) {
      case "@":
        return A.next(), B = p(F, 7, "@"), F.inLinked = !0, B;
      case ".":
        return C(A), A.next(), p(F, 8, ".");
      case ":":
        return C(A), A.next(), p(F, 9, ":");
      default:
        return N(A) ? (B = p(F, 1, M(A)), F.braceNest = 0, F.inLinked = !1, B) : S(A, F) || j(A, F) ? (C(A), O(A, F)) : T(A, F) ? (C(A), p(F, 11, fe(A))) : P(A, F) ? (C(A), ce === "{" ? W(A, F) || B : p(F, 10, I(A))) : (K === 7 && f(It.INVALID_LINKED_FORMAT, a(), 0), F.braceNest = 0, F.inLinked = !1, q(A, F))
    }
  }

  function q(A, F) {
    let K = {
      type: 13
    };
    if (F.braceNest > 0) return W(A, F) || h(F);
    if (F.inLinked) return O(A, F) || h(F);
    switch (A.currentChar()) {
      case "{":
        return W(A, F) || h(F);
      case "}":
        return f(It.UNBALANCED_CLOSING_BRACE, a(), 0), A.next(), p(F, 3, "}");
      case "@":
        return O(A, F) || h(F);
      default: {
        if (N(A)) return K = p(F, 1, M(A)), F.braceNest = 0, F.inLinked = !1, K;
        if (ne(A)) return p(F, 0, be(A));
        break
      }
    }
    return K
  }

  function he() {
    const {
      currentType: A,
      offset: F,
      startLoc: K,
      endLoc: B
    } = l;
    return l.lastType = A, l.lastOffset = F, l.lastStartLoc = K, l.lastEndLoc = B, l.offset = s(), l.startLoc = a(), r.currentChar() === to ? p(l, 13) : q(r, l)
  }
  return {
    nextToken: he,
    currentOffset: s,
    currentPosition: a,
    context: c
  }
}
const Zk = "parser",
  Jk = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;

function Xk(e, t, n) {
  switch (e) {
    case "\\\\":
      return "\\";
    case "\\'":
      return "'";
    default: {
      const r = parseInt(t || n, 16);
      return r <= 55295 || r >= 57344 ? String.fromCodePoint(r) : "�"
    }
  }
}

function eS(e = {}) {
  const t = e.location !== !1,
    {
      onError: n
    } = e;

  function r(y, b, w, x, ...E) {
    const S = y.currentPosition();
    if (S.offset += x, S.column += x, n) {
      const T = t ? Gh(w, S) : null,
        j = Sp(b, T, {
          domain: Zk,
          args: E
        });
      n(j)
    }
  }

  function s(y, b, w) {
    const x = {
      type: y
    };
    return t && (x.start = b, x.end = b, x.loc = {
      start: w,
      end: w
    }), x
  }

  function a(y, b, w, x) {
    t && (y.end = b, y.loc && (y.loc.end = w))
  }

  function o(y, b) {
    const w = y.context(),
      x = s(3, w.offset, w.startLoc);
    return x.value = b, a(x, y.currentOffset(), y.currentPosition()), x
  }

  function i(y, b) {
    const w = y.context(),
      {
        lastOffset: x,
        lastStartLoc: E
      } = w,
      S = s(5, x, E);
    return S.index = parseInt(b, 10), y.nextToken(), a(S, y.currentOffset(), y.currentPosition()), S
  }

  function l(y, b) {
    const w = y.context(),
      {
        lastOffset: x,
        lastStartLoc: E
      } = w,
      S = s(4, x, E);
    return S.key = b, y.nextToken(), a(S, y.currentOffset(), y.currentPosition()), S
  }

  function c(y, b) {
    const w = y.context(),
      {
        lastOffset: x,
        lastStartLoc: E
      } = w,
      S = s(9, x, E);
    return S.value = b.replace(Jk, Xk), y.nextToken(), a(S, y.currentOffset(), y.currentPosition()), S
  }

  function d(y) {
    const b = y.nextToken(),
      w = y.context(),
      {
        lastOffset: x,
        lastStartLoc: E
      } = w,
      S = s(8, x, E);
    return b.type !== 11 ? (r(y, It.UNEXPECTED_EMPTY_LINKED_MODIFIER, w.lastStartLoc, 0), S.value = "", a(S, x, E), {
      nextConsumeToken: b,
      node: S
    }) : (b.value == null && r(y, It.UNEXPECTED_LEXICAL_ANALYSIS, w.lastStartLoc, 0, Os(b)), S.value = b.value || "", a(S, y.currentOffset(), y.currentPosition()), {
      node: S
    })
  }

  function f(y, b) {
    const w = y.context(),
      x = s(7, w.offset, w.startLoc);
    return x.value = b, a(x, y.currentOffset(), y.currentPosition()), x
  }

  function p(y) {
    const b = y.context(),
      w = s(6, b.offset, b.startLoc);
    let x = y.nextToken();
    if (x.type === 8) {
      const E = d(y);
      w.modifier = E.node, x = E.nextConsumeToken || y.nextToken()
    }
    switch (x.type !== 9 && r(y, It.UNEXPECTED_LEXICAL_ANALYSIS, b.lastStartLoc, 0, Os(x)), x = y.nextToken(), x.type === 2 && (x = y.nextToken()), x.type) {
      case 10:
        x.value == null && r(y, It.UNEXPECTED_LEXICAL_ANALYSIS, b.lastStartLoc, 0, Os(x)), w.key = f(y, x.value || "");
        break;
      case 4:
        x.value == null && r(y, It.UNEXPECTED_LEXICAL_ANALYSIS, b.lastStartLoc, 0, Os(x)), w.key = l(y, x.value || "");
        break;
      case 5:
        x.value == null && r(y, It.UNEXPECTED_LEXICAL_ANALYSIS, b.lastStartLoc, 0, Os(x)), w.key = i(y, x.value || "");
        break;
      case 6:
        x.value == null && r(y, It.UNEXPECTED_LEXICAL_ANALYSIS, b.lastStartLoc, 0, Os(x)), w.key = c(y, x.value || "");
        break;
      default: {
        r(y, It.UNEXPECTED_EMPTY_LINKED_KEY, b.lastStartLoc, 0);
        const E = y.context(),
          S = s(7, E.offset, E.startLoc);
        return S.value = "", a(S, E.offset, E.startLoc), w.key = S, a(w, E.offset, E.startLoc), {
          nextConsumeToken: x,
          node: w
        }
      }
    }
    return a(w, y.currentOffset(), y.currentPosition()), {
      node: w
    }
  }

  function h(y) {
    const b = y.context(),
      w = b.currentType === 1 ? y.currentOffset() : b.offset,
      x = b.currentType === 1 ? b.endLoc : b.startLoc,
      E = s(2, w, x);
    E.items = [];
    let S = null;
    do {
      const P = S || y.nextToken();
      switch (S = null, P.type) {
        case 0:
          P.value == null && r(y, It.UNEXPECTED_LEXICAL_ANALYSIS, b.lastStartLoc, 0, Os(P)), E.items.push(o(y, P.value || ""));
          break;
        case 5:
          P.value == null && r(y, It.UNEXPECTED_LEXICAL_ANALYSIS, b.lastStartLoc, 0, Os(P)), E.items.push(i(y, P.value || ""));
          break;
        case 4:
          P.value == null && r(y, It.UNEXPECTED_LEXICAL_ANALYSIS, b.lastStartLoc, 0, Os(P)), E.items.push(l(y, P.value || ""));
          break;
        case 6:
          P.value == null && r(y, It.UNEXPECTED_LEXICAL_ANALYSIS, b.lastStartLoc, 0, Os(P)), E.items.push(c(y, P.value || ""));
          break;
        case 7: {
          const N = p(y);
          E.items.push(N.node), S = N.nextConsumeToken || null;
          break
        }
      }
    } while (b.currentType !== 13 && b.currentType !== 1);
    const T = b.currentType === 1 ? b.lastOffset : y.currentOffset(),
      j = b.currentType === 1 ? b.lastEndLoc : y.currentPosition();
    return a(E, T, j), E
  }

  function _(y, b, w, x) {
    const E = y.context();
    let S = x.items.length === 0;
    const T = s(1, b, w);
    T.cases = [], T.cases.push(x);
    do {
      const j = h(y);
      S || (S = j.items.length === 0), T.cases.push(j)
    } while (E.currentType !== 13);
    return S && r(y, It.MUST_HAVE_MESSAGES_IN_PLURAL, w, 0), a(T, y.currentOffset(), y.currentPosition()), T
  }

  function v(y) {
    const b = y.context(),
      {
        offset: w,
        startLoc: x
      } = b,
      E = h(y);
    return b.currentType === 13 ? E : _(y, w, x, E)
  }

  function C(y) {
    const b = Kk(y, Go({}, e)),
      w = b.context(),
      x = s(0, w.offset, w.startLoc);
    return t && x.loc && (x.loc.source = y), x.body = v(b), e.onCacheKey && (x.cacheKey = e.onCacheKey(y)), w.currentType !== 13 && r(b, It.UNEXPECTED_LEXICAL_ANALYSIS, w.lastStartLoc, 0, y[w.offset] || ""), a(x, b.currentOffset(), b.currentPosition()), x
  }
  return {
    parse: C
  }
}

function Os(e) {
  if (e.type === 13) return "EOF";
  const t = (e.value || "").replace(/\r?\n/gu, "\\n");
  return t.length > 10 ? t.slice(0, 9) + "…" : t
}

function tS(e, t = {}) {
  const n = {
    ast: e,
    helpers: new Set
  };
  return {
    context: () => n,
    helper: a => (n.helpers.add(a), a)
  }
}

function kv(e, t) {
  for (let n = 0; n < e.length; n++) M0(e[n], t)
}

function M0(e, t) {
  switch (e.type) {
    case 1:
      kv(e.cases, t), t.helper("plural");
      break;
    case 2:
      kv(e.items, t);
      break;
    case 6: {
      M0(e.key, t), t.helper("linked"), t.helper("type");
      break
    }
    case 5:
      t.helper("interpolate"), t.helper("list");
      break;
    case 4:
      t.helper("interpolate"), t.helper("named");
      break
  }
}

function nS(e, t = {}) {
  const n = tS(e);
  n.helper("normalize"), e.body && M0(e.body, n);
  const r = n.context();
  e.helpers = Array.from(r.helpers)
}

function rS(e) {
  const t = e.body;
  return t.type === 2 ? Sv(t) : t.cases.forEach(n => Sv(n)), e
}

function Sv(e) {
  if (e.items.length === 1) {
    const t = e.items[0];
    (t.type === 3 || t.type === 9) && (e.static = t.value, delete t.value)
  } else {
    const t = [];
    for (let n = 0; n < e.items.length; n++) {
      const r = e.items[n];
      if (!(r.type === 3 || r.type === 9) || r.value == null) break;
      t.push(r.value)
    }
    if (t.length === e.items.length) {
      e.static = $0(t);
      for (let n = 0; n < e.items.length; n++) {
        const r = e.items[n];
        (r.type === 3 || r.type === 9) && delete r.value
      }
    }
  }
}

function ul(e) {
  switch (e.t = e.type, e.type) {
    case 0: {
      const t = e;
      ul(t.body), t.b = t.body, delete t.body;
      break
    }
    case 1: {
      const t = e,
        n = t.cases;
      for (let r = 0; r < n.length; r++) ul(n[r]);
      t.c = n, delete t.cases;
      break
    }
    case 2: {
      const t = e,
        n = t.items;
      for (let r = 0; r < n.length; r++) ul(n[r]);
      t.i = n, delete t.items, t.static && (t.s = t.static, delete t.static);
      break
    }
    case 3:
    case 9:
    case 8:
    case 7: {
      const t = e;
      t.value && (t.v = t.value, delete t.value);
      break
    }
    case 6: {
      const t = e;
      ul(t.key), t.k = t.key, delete t.key, t.modifier && (ul(t.modifier), t.m = t.modifier, delete t.modifier);
      break
    }
    case 5: {
      const t = e;
      t.i = t.index, delete t.index;
      break
    }
    case 4: {
      const t = e;
      t.k = t.key, delete t.key;
      break
    }
  }
  delete e.type
}

function sS(e, t) {
  const {
    filename: n,
    breakLineCode: r,
    needIndent: s
  } = t, a = t.location !== !1, o = {
    filename: n,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: void 0,
    breakLineCode: r,
    needIndent: s,
    indentLevel: 0
  };
  a && e.loc && (o.source = e.loc.source);
  const i = () => o;

  function l(v, C) {
    o.code += v
  }

  function c(v, C = !0) {
    const y = C ? r : "";
    l(s ? y + "  ".repeat(v) : y)
  }

  function d(v = !0) {
    const C = ++o.indentLevel;
    v && c(C)
  }

  function f(v = !0) {
    const C = --o.indentLevel;
    v && c(C)
  }

  function p() {
    c(o.indentLevel)
  }
  return {
    context: i,
    push: l,
    indent: d,
    deindent: f,
    newline: p,
    helper: v => `_${v}`,
    needIndent: () => o.needIndent
  }
}

function aS(e, t) {
  const {
    helper: n
  } = e;
  e.push(`${n("linked")}(`), ql(e, t.key), t.modifier ? (e.push(", "), ql(e, t.modifier), e.push(", _type")) : e.push(", undefined, _type"), e.push(")")
}

function oS(e, t) {
  const {
    helper: n,
    needIndent: r
  } = e;
  e.push(`${n("normalize")}([`), e.indent(r());
  const s = t.items.length;
  for (let a = 0; a < s && (ql(e, t.items[a]), a !== s - 1); a++) e.push(", ");
  e.deindent(r()), e.push("])")
}

function iS(e, t) {
  const {
    helper: n,
    needIndent: r
  } = e;
  if (t.cases.length > 1) {
    e.push(`${n("plural")}([`), e.indent(r());
    const s = t.cases.length;
    for (let a = 0; a < s && (ql(e, t.cases[a]), a !== s - 1); a++) e.push(", ");
    e.deindent(r()), e.push("])")
  }
}

function lS(e, t) {
  t.body ? ql(e, t.body) : e.push("null")
}

function ql(e, t) {
  const {
    helper: n
  } = e;
  switch (t.type) {
    case 0:
      lS(e, t);
      break;
    case 1:
      iS(e, t);
      break;
    case 2:
      oS(e, t);
      break;
    case 6:
      aS(e, t);
      break;
    case 8:
      e.push(JSON.stringify(t.value), t);
      break;
    case 7:
      e.push(JSON.stringify(t.value), t);
      break;
    case 5:
      e.push(`${n("interpolate")}(${n("list")}(${t.index}))`, t);
      break;
    case 4:
      e.push(`${n("interpolate")}(${n("named")}(${JSON.stringify(t.key)}))`, t);
      break;
    case 9:
      e.push(JSON.stringify(t.value), t);
      break;
    case 3:
      e.push(JSON.stringify(t.value), t);
      break
  }
}
const uS = (e, t = {}) => {
  const n = nt(t.mode) ? t.mode : "normal",
    r = nt(t.filename) ? t.filename : "message.intl";
  t.sourceMap;
  const s = t.breakLineCode != null ? t.breakLineCode : n === "arrow" ? ";" : `
`,
    a = t.needIndent ? t.needIndent : n !== "arrow",
    o = e.helpers || [],
    i = sS(e, {
      filename: r,
      breakLineCode: s,
      needIndent: a
    });
  i.push(n === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"), i.indent(a), o.length > 0 && (i.push(`const { ${$0(o.map(d=>`${d}: _${d}`),", ")} } = ctx`), i.newline()), i.push("return "), ql(i, e), i.deindent(a), i.push("}"), delete e.helpers;
  const {
    code: l,
    map: c
  } = i.context();
  return {
    ast: e,
    code: l,
    map: c ? c.toJSON() : void 0
  }
};

function cS(e, t = {}) {
  const n = Go({}, t),
    r = !!n.jit,
    s = !!n.minify,
    a = n.optimize == null ? !0 : n.optimize,
    i = eS(n).parse(e);
  return r ? (a && rS(i), s && ul(i), {
    ast: i,
    code: ""
  }) : (nS(i, n), uS(i, n))
}
/*!
 * core-base v10.0.7
 * (c) 2025 kazuya kawaguchi
 * Released under the MIT License.
 */
function dS() {
  typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Rk().__INTLIFY_PROD_DEVTOOLS__ = !1)
}

function Qs(e) {
  return Bn(e) && O0(e) === 0 && (di(e, "b") || di(e, "body"))
}
const Bb = ["b", "body"];

function fS(e) {
  return Qo(e, Bb)
}
const jb = ["c", "cases"];

function pS(e) {
  return Qo(e, jb, [])
}
const Hb = ["s", "static"];

function hS(e) {
  return Qo(e, Hb)
}
const Vb = ["i", "items"];

function mS(e) {
  return Qo(e, Vb, [])
}
const Ub = ["t", "type"];

function O0(e) {
  return Qo(e, Ub)
}
const zb = ["v", "value"];

function Ld(e, t) {
  const n = Qo(e, zb);
  if (n != null) return n;
  throw Pc(t)
}
const Yb = ["m", "modifier"];

function gS(e) {
  return Qo(e, Yb)
}
const Wb = ["k", "key"];

function vS(e) {
  const t = Qo(e, Wb);
  if (t) return t;
  throw Pc(6)
}

function Qo(e, t, n) {
  for (let r = 0; r < t.length; r++) {
    const s = t[r];
    if (di(e, s) && e[s] != null) return e[s]
  }
  return n
}
const Gb = [...Bb, ...jb, ...Hb, ...Vb, ...Wb, ...Yb, ...zb, ...Ub];

function Pc(e) {
  return new Error(`unhandled node type: ${e}`)
}

function E1(e) {
  return n => _S(n, e)
}

function _S(e, t) {
  const n = fS(t);
  if (n == null) throw Pc(0);
  if (O0(n) === 1) {
    const a = pS(n);
    return e.plural(a.reduce((o, i) => [...o, Ev(e, i)], []))
  } else return Ev(e, n)
}

function Ev(e, t) {
  const n = hS(t);
  if (n != null) return e.type === "text" ? n : e.normalize([n]);
  {
    const r = mS(t).reduce((s, a) => [...s, Qh(e, a)], []);
    return e.normalize(r)
  }
}

function Qh(e, t) {
  const n = O0(t);
  switch (n) {
    case 3:
      return Ld(t, n);
    case 9:
      return Ld(t, n);
    case 4: {
      const r = t;
      if (di(r, "k") && r.k) return e.interpolate(e.named(r.k));
      if (di(r, "key") && r.key) return e.interpolate(e.named(r.key));
      throw Pc(n)
    }
    case 5: {
      const r = t;
      if (di(r, "i") && lr(r.i)) return e.interpolate(e.list(r.i));
      if (di(r, "index") && lr(r.index)) return e.interpolate(e.list(r.index));
      throw Pc(n)
    }
    case 6: {
      const r = t,
        s = gS(r),
        a = vS(r);
      return e.linked(Qh(e, a), s ? Qh(e, s) : void 0, e.type)
    }
    case 7:
      return Ld(t, n);
    case 8:
      return Ld(t, n);
    default:
      throw new Error(`unhandled node on format message part: ${n}`)
  }
}
const yS = e => e;
let Rd = fr();

function bS(e, t = {}) {
  let n = !1;
  const r = t.onError || Uk;
  return t.onError = s => {
    n = !0, r(s)
  }, {
    ...cS(e, t),
    detectError: n
  }
}

function wS(e, t) {
  if (nt(e)) {
    xr(t.warnHtmlMessage) && t.warnHtmlMessage;
    const r = (t.onCacheKey || yS)(e),
      s = Rd[r];
    if (s) return s;
    const {
      ast: a,
      detectError: o
    } = bS(e, {
      ...t,
      location: !1,
      jit: !0
    }), i = E1(a);
    return o ? i : Rd[r] = i
  } else {
    const n = e.cacheKey;
    if (n) {
      const r = Rd[n];
      return r || (Rd[n] = E1(e))
    } else return E1(e)
  }
}
let Ic = null;

function CS(e) {
  Ic = e
}

function xS(e, t, n) {
  Ic && Ic.emit("i18n:init", {
    timestamp: Date.now(),
    i18n: e,
    version: t,
    meta: n
  })
}
const kS = SS("function:translate");

function SS(e) {
  return t => Ic && Ic.emit(e, t)
}
const ka = {
    INVALID_ARGUMENT: Vk,
    INVALID_DATE_ARGUMENT: 18,
    INVALID_ISO_DATE_ARGUMENT: 19,
    NOT_SUPPORT_LOCALE_PROMISE_VALUE: 21,
    NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: 22,
    NOT_SUPPORT_LOCALE_TYPE: 23
  },
  ES = 24;

function Sa(e) {
  return Sp(e, null, void 0)
}

function D0(e, t) {
  return t.locale != null ? Tv(t.locale) : Tv(e.locale)
}
let T1;

function Tv(e) {
  if (nt(e)) return e;
  if (kn(e)) {
    if (e.resolvedOnce && T1 != null) return T1;
    if (e.constructor.name === "Function") {
      const t = e();
      if (Fk(t)) throw Sa(ka.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
      return T1 = t
    } else throw Sa(ka.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION)
  } else throw Sa(ka.NOT_SUPPORT_LOCALE_TYPE)
}

function TS(e, t, n) {
  return [...new Set([n, ...Gs(t) ? t : Bn(t) ? Object.keys(t) : nt(t) ? [t] : [n]])]
}

function Qb(e, t, n) {
  const r = nt(n) ? n : Nf,
    s = e;
  s.__localeChainCache || (s.__localeChainCache = new Map);
  let a = s.__localeChainCache.get(r);
  if (!a) {
    a = [];
    let o = [n];
    for (; Gs(o);) o = Av(a, o, t);
    const i = Gs(t) || !Zt(t) ? t : t.default ? t.default : null;
    o = nt(i) ? [i] : i, Gs(o) && Av(a, o, !1), s.__localeChainCache.set(r, a)
  }
  return a
}

function Av(e, t, n) {
  let r = !0;
  for (let s = 0; s < t.length && xr(r); s++) {
    const a = t[s];
    nt(a) && (r = AS(e, t[s], n))
  }
  return r
}

function AS(e, t, n) {
  let r;
  const s = t.split("-");
  do {
    const a = s.join("-");
    r = PS(e, a, n), s.splice(-1, 1)
  } while (s.length && r === !0);
  return r
}

function PS(e, t, n) {
  let r = !1;
  if (!e.includes(t) && (r = !0, t)) {
    r = t[t.length - 1] !== "!";
    const s = t.replace(/!/g, "");
    e.push(s), (Gs(n) || Zt(n)) && n[s] && (r = n[s])
  }
  return r
}
const qo = [];
qo[0] = {
  w: [0],
  i: [3, 0],
  "[": [4],
  o: [7]
};
qo[1] = {
  w: [1],
  ".": [2],
  "[": [4],
  o: [7]
};
qo[2] = {
  w: [2],
  i: [3, 0],
  0: [3, 0]
};
qo[3] = {
  i: [3, 0],
  0: [3, 0],
  w: [1, 1],
  ".": [2, 1],
  "[": [4, 1],
  o: [7, 1]
};
qo[4] = {
  "'": [5, 0],
  '"': [6, 0],
  "[": [4, 2],
  "]": [1, 3],
  o: 8,
  l: [4, 0]
};
qo[5] = {
  "'": [4, 0],
  o: 8,
  l: [5, 0]
};
qo[6] = {
  '"': [4, 0],
  o: 8,
  l: [6, 0]
};
const IS = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;

function $S(e) {
  return IS.test(e)
}

function MS(e) {
  const t = e.charCodeAt(0),
    n = e.charCodeAt(e.length - 1);
  return t === n && (t === 34 || t === 39) ? e.slice(1, -1) : e
}

function OS(e) {
  if (e == null) return "o";
  switch (e.charCodeAt(0)) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return e;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w"
  }
  return "i"
}

function DS(e) {
  const t = e.trim();
  return e.charAt(0) === "0" && isNaN(parseInt(e)) ? !1 : $S(t) ? MS(t) : "*" + t
}

function LS(e) {
  const t = [];
  let n = -1,
    r = 0,
    s = 0,
    a, o, i, l, c, d, f;
  const p = [];
  p[0] = () => {
    o === void 0 ? o = i : o += i
  }, p[1] = () => {
    o !== void 0 && (t.push(o), o = void 0)
  }, p[2] = () => {
    p[0](), s++
  }, p[3] = () => {
    if (s > 0) s--, r = 4, p[0]();
    else {
      if (s = 0, o === void 0 || (o = DS(o), o === !1)) return !1;
      p[1]()
    }
  };

  function h() {
    const _ = e[n + 1];
    if (r === 5 && _ === "'" || r === 6 && _ === '"') return n++, i = "\\" + _, p[0](), !0
  }
  for (; r !== null;)
    if (n++, a = e[n], !(a === "\\" && h())) {
      if (l = OS(a), f = qo[r], c = f[l] || f.l || 8, c === 8 || (r = c[0], c[1] !== void 0 && (d = p[c[1]], d && (i = a, d() === !1)))) return;
      if (r === 7) return t
    }
}
const Pv = new Map;

function RS(e, t) {
  return Bn(e) ? e[t] : null
}

function NS(e, t) {
  if (!Bn(e)) return null;
  let n = Pv.get(t);
  if (n || (n = LS(t), n && Pv.set(t, n)), !n) return null;
  const r = n.length;
  let s = e,
    a = 0;
  for (; a < r;) {
    const o = n[a];
    if (Gb.includes(o) && Qs(s)) return null;
    const i = s[o];
    if (i === void 0 || kn(s)) return null;
    s = i, a++
  }
  return s
}
const FS = "10.0.7",
  Ep = -1,
  Nf = "en-US",
  Iv = "",
  $v = e => `${e.charAt(0).toLocaleUpperCase()}${e.substr(1)}`;

function BS() {
  return {
    upper: (e, t) => t === "text" && nt(e) ? e.toUpperCase() : t === "vnode" && Bn(e) && "__v_isVNode" in e ? e.children.toUpperCase() : e,
    lower: (e, t) => t === "text" && nt(e) ? e.toLowerCase() : t === "vnode" && Bn(e) && "__v_isVNode" in e ? e.children.toLowerCase() : e,
    capitalize: (e, t) => t === "text" && nt(e) ? $v(e) : t === "vnode" && Bn(e) && "__v_isVNode" in e ? $v(e.children) : e
  }
}
let qb;

function jS(e) {
  qb = e
}
let Kb;

function HS(e) {
  Kb = e
}
let Zb;

function VS(e) {
  Zb = e
}
let Jb = null;
const US = e => {
    Jb = e
  },
  zS = () => Jb;
let Xb = null;
const Mv = e => {
    Xb = e
  },
  YS = () => Xb;
let Ov = 0;

function WS(e = {}) {
  const t = kn(e.onWarn) ? e.onWarn : jk,
    n = nt(e.version) ? e.version : FS,
    r = nt(e.locale) || kn(e.locale) ? e.locale : Nf,
    s = kn(r) ? Nf : r,
    a = Gs(e.fallbackLocale) || Zt(e.fallbackLocale) || nt(e.fallbackLocale) || e.fallbackLocale === !1 ? e.fallbackLocale : s,
    o = Zt(e.messages) ? e.messages : A1(s),
    i = Zt(e.datetimeFormats) ? e.datetimeFormats : A1(s),
    l = Zt(e.numberFormats) ? e.numberFormats : A1(s),
    c = Go(fr(), e.modifiers, BS()),
    d = e.pluralRules || fr(),
    f = kn(e.missing) ? e.missing : null,
    p = xr(e.missingWarn) || bv(e.missingWarn) ? e.missingWarn : !0,
    h = xr(e.fallbackWarn) || bv(e.fallbackWarn) ? e.fallbackWarn : !0,
    _ = !!e.fallbackFormat,
    v = !!e.unresolving,
    C = kn(e.postTranslation) ? e.postTranslation : null,
    y = Zt(e.processor) ? e.processor : null,
    b = xr(e.warnHtmlMessage) ? e.warnHtmlMessage : !0,
    w = !!e.escapeParameter,
    x = kn(e.messageCompiler) ? e.messageCompiler : qb,
    E = kn(e.messageResolver) ? e.messageResolver : Kb || RS,
    S = kn(e.localeFallbacker) ? e.localeFallbacker : Zb || TS,
    T = Bn(e.fallbackContext) ? e.fallbackContext : void 0,
    j = e,
    P = Bn(j.__datetimeFormatters) ? j.__datetimeFormatters : new Map,
    N = Bn(j.__numberFormatters) ? j.__numberFormatters : new Map,
    ne = Bn(j.__meta) ? j.__meta : {};
  Ov++;
  const Y = {
    version: n,
    cid: Ov,
    locale: r,
    fallbackLocale: a,
    messages: o,
    modifiers: c,
    pluralRules: d,
    missing: f,
    missingWarn: p,
    fallbackWarn: h,
    fallbackFormat: _,
    unresolving: v,
    postTranslation: C,
    processor: y,
    warnHtmlMessage: b,
    escapeParameter: w,
    messageCompiler: x,
    messageResolver: E,
    localeFallbacker: S,
    fallbackContext: T,
    onWarn: t,
    __meta: ne
  };
  return Y.datetimeFormats = i, Y.numberFormats = l, Y.__datetimeFormatters = P, Y.__numberFormatters = N, __INTLIFY_PROD_DEVTOOLS__ && xS(Y, n, ne), Y
}
const A1 = e => ({
  [e]: fr()
});

function L0(e, t, n, r, s) {
  const {
    missing: a,
    onWarn: o
  } = e;
  if (a !== null) {
    const i = a(e, n, t, s);
    return nt(i) ? i : t
  } else return t
}

function ju(e, t, n) {
  const r = e;
  r.__localeChainCache = new Map, e.localeFallbacker(e, n, t)
}

function GS(e, t) {
  return e === t ? !1 : e.split("-")[0] === t.split("-")[0]
}

function QS(e, t) {
  const n = t.indexOf(e);
  if (n === -1) return !1;
  for (let r = n + 1; r < t.length; r++)
    if (GS(e, t[r])) return !0;
  return !1
}

function Dv(e, ...t) {
  const {
    datetimeFormats: n,
    unresolving: r,
    fallbackLocale: s,
    onWarn: a,
    localeFallbacker: o
  } = e, {
    __datetimeFormatters: i
  } = e, [l, c, d, f] = qh(...t), p = xr(d.missingWarn) ? d.missingWarn : e.missingWarn;
  xr(d.fallbackWarn) ? d.fallbackWarn : e.fallbackWarn;
  const h = !!d.part,
    _ = D0(e, d),
    v = o(e, s, _);
  if (!nt(l) || l === "") return new Intl.DateTimeFormat(_, f).format(c);
  let C = {},
    y, b = null;
  const w = "datetime format";
  for (let S = 0; S < v.length && (y = v[S], C = n[y] || {}, b = C[l], !Zt(b)); S++) L0(e, l, y, p, w);
  if (!Zt(b) || !nt(y)) return r ? Ep : l;
  let x = `${y}__${l}`;
  P0(f) || (x = `${x}__${JSON.stringify(f)}`);
  let E = i.get(x);
  return E || (E = new Intl.DateTimeFormat(y, Go({}, b, f)), i.set(x, E)), h ? E.formatToParts(c) : E.format(c)
}
const e4 = ["localeMatcher", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "formatMatcher", "hour12", "timeZone", "dateStyle", "timeStyle", "calendar", "dayPeriod", "numberingSystem", "hourCycle", "fractionalSecondDigits"];

function qh(...e) {
  const [t, n, r, s] = e, a = fr();
  let o = fr(),
    i;
  if (nt(t)) {
    const l = t.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!l) throw Sa(ka.INVALID_ISO_DATE_ARGUMENT);
    const c = l[3] ? l[3].trim().startsWith("T") ? `${l[1].trim()}${l[3].trim()}` : `${l[1].trim()}T${l[3].trim()}` : l[1].trim();
    i = new Date(c);
    try {
      i.toISOString()
    } catch {
      throw Sa(ka.INVALID_ISO_DATE_ARGUMENT)
    }
  } else if (Dk(t)) {
    if (isNaN(t.getTime())) throw Sa(ka.INVALID_DATE_ARGUMENT);
    i = t
  } else if (lr(t)) i = t;
  else throw Sa(ka.INVALID_ARGUMENT);
  return nt(n) ? a.key = n : Zt(n) && Object.keys(n).forEach(l => {
    e4.includes(l) ? o[l] = n[l] : a[l] = n[l]
  }), nt(r) ? a.locale = r : Zt(r) && (o = r), Zt(s) && (o = s), [a.key || "", i, a, o]
}

function Lv(e, t, n) {
  const r = e;
  for (const s in n) {
    const a = `${t}__${s}`;
    r.__datetimeFormatters.has(a) && r.__datetimeFormatters.delete(a)
  }
}

function Rv(e, ...t) {
  const {
    numberFormats: n,
    unresolving: r,
    fallbackLocale: s,
    onWarn: a,
    localeFallbacker: o
  } = e, {
    __numberFormatters: i
  } = e, [l, c, d, f] = Kh(...t), p = xr(d.missingWarn) ? d.missingWarn : e.missingWarn;
  xr(d.fallbackWarn) ? d.fallbackWarn : e.fallbackWarn;
  const h = !!d.part,
    _ = D0(e, d),
    v = o(e, s, _);
  if (!nt(l) || l === "") return new Intl.NumberFormat(_, f).format(c);
  let C = {},
    y, b = null;
  const w = "number format";
  for (let S = 0; S < v.length && (y = v[S], C = n[y] || {}, b = C[l], !Zt(b)); S++) L0(e, l, y, p, w);
  if (!Zt(b) || !nt(y)) return r ? Ep : l;
  let x = `${y}__${l}`;
  P0(f) || (x = `${x}__${JSON.stringify(f)}`);
  let E = i.get(x);
  return E || (E = new Intl.NumberFormat(y, Go({}, b, f)), i.set(x, E)), h ? E.formatToParts(c) : E.format(c)
}
const t4 = ["localeMatcher", "style", "currency", "currencyDisplay", "currencySign", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits", "compactDisplay", "notation", "signDisplay", "unit", "unitDisplay", "roundingMode", "roundingPriority", "roundingIncrement", "trailingZeroDisplay"];

function Kh(...e) {
  const [t, n, r, s] = e, a = fr();
  let o = fr();
  if (!lr(t)) throw Sa(ka.INVALID_ARGUMENT);
  const i = t;
  return nt(n) ? a.key = n : Zt(n) && Object.keys(n).forEach(l => {
    t4.includes(l) ? o[l] = n[l] : a[l] = n[l]
  }), nt(r) ? a.locale = r : Zt(r) && (o = r), Zt(s) && (o = s), [a.key || "", i, a, o]
}

function Nv(e, t, n) {
  const r = e;
  for (const s in n) {
    const a = `${t}__${s}`;
    r.__numberFormatters.has(a) && r.__numberFormatters.delete(a)
  }
}
const qS = e => e,
  KS = e => "",
  ZS = "text",
  JS = e => e.length === 0 ? "" : $0(e),
  XS = Bk;

function Fv(e, t) {
  return e = Math.abs(e), t === 2 ? e ? e > 1 ? 1 : 0 : 1 : e ? Math.min(e, 2) : 0
}

function eE(e) {
  const t = lr(e.pluralIndex) ? e.pluralIndex : -1;
  return e.named && (lr(e.named.count) || lr(e.named.n)) ? lr(e.named.count) ? e.named.count : lr(e.named.n) ? e.named.n : t : t
}

function tE(e, t) {
  t.count || (t.count = e), t.n || (t.n = e)
}

function nE(e = {}) {
  const t = e.locale,
    n = eE(e),
    r = Bn(e.pluralRules) && nt(t) && kn(e.pluralRules[t]) ? e.pluralRules[t] : Fv,
    s = Bn(e.pluralRules) && nt(t) && kn(e.pluralRules[t]) ? Fv : void 0,
    a = y => y[r(n, y.length, s)],
    o = e.list || [],
    i = y => o[y],
    l = e.named || fr();
  lr(e.pluralIndex) && tE(n, l);
  const c = y => l[y];

  function d(y, b) {
    const w = kn(e.messages) ? e.messages(y, !!b) : Bn(e.messages) ? e.messages[y] : !1;
    return w || (e.parent ? e.parent.message(y) : KS)
  }
  const f = y => e.modifiers ? e.modifiers[y] : qS,
    p = Zt(e.processor) && kn(e.processor.normalize) ? e.processor.normalize : JS,
    h = Zt(e.processor) && kn(e.processor.interpolate) ? e.processor.interpolate : XS,
    _ = Zt(e.processor) && nt(e.processor.type) ? e.processor.type : ZS,
    C = {
      list: i,
      named: c,
      plural: a,
      linked: (y, ...b) => {
        const [w, x] = b;
        let E = "text",
          S = "";
        b.length === 1 ? Bn(w) ? (S = w.modifier || S, E = w.type || E) : nt(w) && (S = w || S) : b.length === 2 && (nt(w) && (S = w || S), nt(x) && (E = x || E));
        const T = d(y, !0)(C),
          j = E === "vnode" && Gs(T) && S ? T[0] : T;
        return S ? f(S)(j, E) : j
      },
      message: d,
      type: _,
      interpolate: h,
      normalize: p,
      values: Go(fr(), o, l)
    };
  return C
}
const Bv = () => "",
  Yr = e => kn(e);

function jv(e, ...t) {
  const {
    fallbackFormat: n,
    postTranslation: r,
    unresolving: s,
    messageCompiler: a,
    fallbackLocale: o,
    messages: i
  } = e, [l, c] = Zh(...t), d = xr(c.missingWarn) ? c.missingWarn : e.missingWarn, f = xr(c.fallbackWarn) ? c.fallbackWarn : e.fallbackWarn, p = xr(c.escapeParameter) ? c.escapeParameter : e.escapeParameter, h = !!c.resolvedMessage, _ = nt(c.default) || xr(c.default) ? xr(c.default) ? a ? l : () => l : c.default : n ? a ? l : () => l : null, v = n || _ != null && (nt(_) || kn(_)), C = D0(e, c);
  p && rE(c);
  let [y, b, w] = h ? [l, C, i[C] || fr()] : n4(e, l, C, o, f, d), x = y, E = l;
  if (!h && !(nt(x) || Qs(x) || Yr(x)) && v && (x = _, E = x), !h && (!(nt(x) || Qs(x) || Yr(x)) || !nt(b))) return s ? Ep : l;
  let S = !1;
  const T = () => {
      S = !0
    },
    j = Yr(x) ? x : r4(e, l, b, x, E, T);
  if (S) return x;
  const P = oE(e, b, w, c),
    N = nE(P),
    ne = sE(e, j, N),
    Y = r ? r(ne, l) : ne;
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const _e = {
      timestamp: Date.now(),
      key: nt(l) ? l : Yr(x) ? x.key : "",
      locale: b || (Yr(x) ? x.locale : ""),
      format: nt(x) ? x : Yr(x) ? x.source : "",
      message: Y
    };
    _e.meta = Go({}, e.__meta, zS() || {}), kS(_e)
  }
  return Y
}

function rE(e) {
  Gs(e.list) ? e.list = e.list.map(t => nt(t) ? Cv(t) : t) : Bn(e.named) && Object.keys(e.named).forEach(t => {
    nt(e.named[t]) && (e.named[t] = Cv(e.named[t]))
  })
}

function n4(e, t, n, r, s, a) {
  const {
    messages: o,
    onWarn: i,
    messageResolver: l,
    localeFallbacker: c
  } = e, d = c(e, r, n);
  let f = fr(),
    p, h = null;
  const _ = "translate";
  for (let v = 0; v < d.length && (p = d[v], f = o[p] || fr(), (h = l(f, t)) === null && (h = f[t]), !(nt(h) || Qs(h) || Yr(h))); v++)
    if (!QS(p, d)) {
      const C = L0(e, t, p, a, _);
      C !== t && (h = C)
    } return [h, p, f]
}

function r4(e, t, n, r, s, a) {
  const {
    messageCompiler: o,
    warnHtmlMessage: i
  } = e;
  if (Yr(r)) {
    const c = r;
    return c.locale = c.locale || n, c.key = c.key || t, c
  }
  if (o == null) {
    const c = () => r;
    return c.locale = n, c.key = t, c
  }
  const l = o(r, aE(e, n, s, r, i, a));
  return l.locale = n, l.key = t, l.source = r, l
}

function sE(e, t, n) {
  return t(n)
}

function Zh(...e) {
  const [t, n, r] = e, s = fr();
  if (!nt(t) && !lr(t) && !Yr(t) && !Qs(t)) throw Sa(ka.INVALID_ARGUMENT);
  const a = lr(t) ? String(t) : (Yr(t), t);
  return lr(n) ? s.plural = n : nt(n) ? s.default = n : Zt(n) && !P0(n) ? s.named = n : Gs(n) && (s.list = n), lr(r) ? s.plural = r : nt(r) ? s.default = r : Zt(r) && Go(s, r), [a, s]
}

function aE(e, t, n, r, s, a) {
  return {
    locale: t,
    key: n,
    warnHtmlMessage: s,
    onError: o => {
      throw a && a(o), o
    },
    onCacheKey: o => Mk(t, n, o)
  }
}

function oE(e, t, n, r) {
  const {
    modifiers: s,
    pluralRules: a,
    messageResolver: o,
    fallbackLocale: i,
    fallbackWarn: l,
    missingWarn: c,
    fallbackContext: d
  } = e, p = {
    locale: t,
    modifiers: s,
    pluralRules: a,
    messages: (h, _) => {
      let v = o(n, h);
      if (v == null && (d || _)) {
        const [, , C] = n4(d || e, h, t, i, l, c);
        v = o(C, h)
      }
      if (nt(v) || Qs(v)) {
        let C = !1;
        const b = r4(e, h, t, v, h, () => {
          C = !0
        });
        return C ? Bv : b
      } else return Yr(v) ? v : Bv
    }
  };
  return e.processor && (p.processor = e.processor), r.list && (p.list = r.list), r.named && (p.named = r.named), lr(r.plural) && (p.pluralIndex = r.plural), p
}
dS();
/*!
 * vue-i18n v10.0.7
 * (c) 2025 kazuya kawaguchi
 * Released under the MIT License.
 */
const iE = "10.0.7";

function lE() {
  typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Rb().__INTLIFY_PROD_DEVTOOLS__ = !1)
}
const Jr = {
  UNEXPECTED_RETURN_TYPE: ES,
  INVALID_ARGUMENT: 25,
  MUST_BE_CALL_SETUP_TOP: 26,
  NOT_INSTALLED: 27,
  REQUIRED_VALUE: 28,
  INVALID_VALUE: 29,
  NOT_INSTALLED_WITH_PROVIDE: 31,
  UNEXPECTED_ERROR: 32
};

function Ss(e, ...t) {
  return Sp(e, null, void 0)
}
const Jh = Wo("__translateVNode"),
  Xh = Wo("__datetimeParts"),
  em = Wo("__numberParts"),
  uE = Wo("__setPluralRules"),
  cE = Wo("__injectWithOption"),
  tm = Wo("__dispose");

function $c(e) {
  if (!Sr(e) || Qs(e)) return e;
  for (const t in e)
    if (Rf(e, t))
      if (!t.includes(".")) Sr(e[t]) && $c(e[t]);
      else {
        const n = t.split("."),
          r = n.length - 1;
        let s = e,
          a = !1;
        for (let o = 0; o < r; o++) {
          if (n[o] === "__proto__") throw new Error(`unsafe key: ${n[o]}`);
          if (n[o] in s || (s[n[o]] = kr()), !Sr(s[n[o]])) {
            a = !0;
            break
          }
          s = s[n[o]]
        }
        if (a || (Qs(s) ? Gb.includes(n[r]) || delete e[t] : (s[n[r]] = e[t], delete e[t])), !Qs(s)) {
          const o = s[n[r]];
          Sr(o) && $c(o)
        }
      } return e
}

function s4(e, t) {
  const {
    messages: n,
    __i18n: r,
    messageResolver: s,
    flatJson: a
  } = t, o = hs(n) ? n : xa(r) ? kr() : {
    [e]: kr()
  };
  if (xa(r) && r.forEach(i => {
      if ("locale" in i && "resource" in i) {
        const {
          locale: l,
          resource: c
        } = i;
        l ? (o[l] = o[l] || kr(), cf(c, o[l])) : cf(c, o)
      } else vn(i) && cf(JSON.parse(i), o)
    }), s == null && a)
    for (const i in o) Rf(o, i) && $c(o[i]);
  return o
}

function a4(e) {
  return e.type
}

function dE(e, t, n) {
  let r = Sr(t.messages) ? t.messages : kr();
  "__i18nGlobal" in n && (r = s4(e.locale.value, {
    messages: r,
    __i18n: n.__i18nGlobal
  }));
  const s = Object.keys(r);
  s.length && s.forEach(a => {
    e.mergeLocaleMessage(a, r[a])
  });
  {
    if (Sr(t.datetimeFormats)) {
      const a = Object.keys(t.datetimeFormats);
      a.length && a.forEach(o => {
        e.mergeDateTimeFormat(o, t.datetimeFormats[o])
      })
    }
    if (Sr(t.numberFormats)) {
      const a = Object.keys(t.numberFormats);
      a.length && a.forEach(o => {
        e.mergeNumberFormat(o, t.numberFormats[o])
      })
    }
  }
}

function Hv(e) {
  return $(td, null, e, 0)
}
const Vv = "__INTLIFY_META__",
  Uv = () => [],
  fE = () => !1;
let zv = 0;

function Yv(e) {
  return (t, n, r, s) => e(n, r, gr() || void 0, s)
}
const pE = () => {
  const e = gr();
  let t = null;
  return e && (t = a4(e)[Vv]) ? {
    [Vv]: t
  } : null
};

function o4(e = {}) {
  const {
    __root: t,
    __injectWithOption: n
  } = e, r = t === void 0, s = e.flatJson, a = Lf ? U : vp;
  let o = ha(e.inheritLocale) ? e.inheritLocale : !0;
  const i = a(t && o ? t.locale.value : vn(e.locale) ? e.locale : Nf),
    l = a(t && o ? t.fallbackLocale.value : vn(e.fallbackLocale) || xa(e.fallbackLocale) || hs(e.fallbackLocale) || e.fallbackLocale === !1 ? e.fallbackLocale : i.value),
    c = a(s4(i.value, e)),
    d = a(hs(e.datetimeFormats) ? e.datetimeFormats : {
      [i.value]: {}
    }),
    f = a(hs(e.numberFormats) ? e.numberFormats : {
      [i.value]: {}
    });
  let p = t ? t.missingWarn : ha(e.missingWarn) || _v(e.missingWarn) ? e.missingWarn : !0,
    h = t ? t.fallbackWarn : ha(e.fallbackWarn) || _v(e.fallbackWarn) ? e.fallbackWarn : !0,
    _ = t ? t.fallbackRoot : ha(e.fallbackRoot) ? e.fallbackRoot : !0,
    v = !!e.fallbackFormat,
    C = Od(e.missing) ? e.missing : null,
    y = Od(e.missing) ? Yv(e.missing) : null,
    b = Od(e.postTranslation) ? e.postTranslation : null,
    w = t ? t.warnHtmlMessage : ha(e.warnHtmlMessage) ? e.warnHtmlMessage : !0,
    x = !!e.escapeParameter;
  const E = t ? t.modifiers : hs(e.modifiers) ? e.modifiers : {};
  let S = e.pluralRules || t && t.pluralRules,
    T;
  T = (() => {
    r && Mv(null);
    const X = {
      version: iE,
      locale: i.value,
      fallbackLocale: l.value,
      messages: c.value,
      modifiers: E,
      pluralRules: S,
      missing: y === null ? void 0 : y,
      missingWarn: p,
      fallbackWarn: h,
      fallbackFormat: v,
      unresolving: !0,
      postTranslation: b === null ? void 0 : b,
      warnHtmlMessage: w,
      escapeParameter: x,
      messageResolver: e.messageResolver,
      messageCompiler: e.messageCompiler,
      __meta: {
        framework: "vue"
      }
    };
    X.datetimeFormats = d.value, X.numberFormats = f.value, X.__datetimeFormatters = hs(T) ? T.__datetimeFormatters : void 0, X.__numberFormatters = hs(T) ? T.__numberFormatters : void 0;
    const ve = WS(X);
    return r && Mv(ve), ve
  })(), ju(T, i.value, l.value);

  function P() {
    return [i.value, l.value, c.value, d.value, f.value]
  }
  const N = L({
      get: () => i.value,
      set: X => {
        i.value = X, T.locale = i.value
      }
    }),
    ne = L({
      get: () => l.value,
      set: X => {
        l.value = X, T.fallbackLocale = l.value, ju(T, i.value, X)
      }
    }),
    Y = L(() => c.value),
    _e = L(() => d.value),
    Q = L(() => f.value);

  function re() {
    return Od(b) ? b : null
  }

  function J(X) {
    b = X, T.postTranslation = X
  }

  function ee() {
    return C
  }

  function de(X) {
    X !== null && (y = Yv(X)), C = X, T.missing = y
  }
  const se = (X, ve, Se, He, Ve, sn) => {
    P();
    let Ut;
    try {
      __INTLIFY_PROD_DEVTOOLS__,
      r || (T.fallbackContext = t ? YS() : void 0),
      Ut = X(T)
    }
    finally {
      __INTLIFY_PROD_DEVTOOLS__,
      r || (T.fallbackContext = void 0)
    }
    if (Se !== "translate exists" && Ac(Ut) && Ut === Ep || Se === "translate exists" && !Ut) {
      const [On, Xn] = ve();
      return t && _ ? He(t) : Ve(On)
    } else {
      if (sn(Ut)) return Ut;
      throw Ss(Jr.UNEXPECTED_RETURN_TYPE)
    }
  };

  function ae(...X) {
    return se(ve => Reflect.apply(jv, null, [ve, ...X]), () => Zh(...X), "translate", ve => Reflect.apply(ve.t, ve, [...X]), ve => ve, ve => vn(ve))
  }

  function ke(...X) {
    const [ve, Se, He] = X;
    if (He && !Sr(He)) throw Ss(Jr.INVALID_ARGUMENT);
    return ae(ve, Se, Ws({
      resolvedMessage: !0
    }, He || {}))
  }

  function be(...X) {
    return se(ve => Reflect.apply(Dv, null, [ve, ...X]), () => qh(...X), "datetime format", ve => Reflect.apply(ve.d, ve, [...X]), () => Iv, ve => vn(ve))
  }

  function ge(...X) {
    return se(ve => Reflect.apply(Rv, null, [ve, ...X]), () => Kh(...X), "number format", ve => Reflect.apply(ve.n, ve, [...X]), () => Iv, ve => vn(ve))
  }

  function H(X) {
    return X.map(ve => vn(ve) || Ac(ve) || ha(ve) ? Hv(String(ve)) : ve)
  }
  const Ce = {
    normalize: H,
    interpolate: X => X,
    type: "vnode"
  };

  function D(...X) {
    return se(ve => {
      let Se;
      const He = ve;
      try {
        He.processor = Ce, Se = Reflect.apply(jv, null, [He, ...X])
      } finally {
        He.processor = null
      }
      return Se
    }, () => Zh(...X), "translate", ve => ve[Jh](...X), ve => [Hv(ve)], ve => xa(ve))
  }

  function pe(...X) {
    return se(ve => Reflect.apply(Rv, null, [ve, ...X]), () => Kh(...X), "number format", ve => ve[em](...X), Uv, ve => vn(ve) || xa(ve))
  }

  function ye(...X) {
    return se(ve => Reflect.apply(Dv, null, [ve, ...X]), () => qh(...X), "datetime format", ve => ve[Xh](...X), Uv, ve => vn(ve) || xa(ve))
  }

  function Ae(X) {
    S = X, T.pluralRules = S
  }

  function fe(X, ve) {
    return se(() => {
      if (!X) return !1;
      const Se = vn(ve) ? ve : i.value,
        He = W(Se),
        Ve = T.messageResolver(He, X);
      return Qs(Ve) || Yr(Ve) || vn(Ve)
    }, () => [X], "translate exists", Se => Reflect.apply(Se.te, Se, [X, ve]), fE, Se => ha(Se))
  }

  function I(X) {
    let ve = null;
    const Se = Qb(T, l.value, i.value);
    for (let He = 0; He < Se.length; He++) {
      const Ve = c.value[Se[He]] || {},
        sn = T.messageResolver(Ve, X);
      if (sn != null) {
        ve = sn;
        break
      }
    }
    return ve
  }

  function M(X) {
    const ve = I(X);
    return ve ?? (t ? t.tm(X) || {} : {})
  }

  function W(X) {
    return c.value[X] || {}
  }

  function O(X, ve) {
    if (s) {
      const Se = {
        [X]: ve
      };
      for (const He in Se) Rf(Se, He) && $c(Se[He]);
      ve = Se[X]
    }
    c.value[X] = ve, T.messages = c.value
  }

  function q(X, ve) {
    c.value[X] = c.value[X] || {};
    const Se = {
      [X]: ve
    };
    if (s)
      for (const He in Se) Rf(Se, He) && $c(Se[He]);
    ve = Se[X], cf(ve, c.value[X]), T.messages = c.value
  }

  function he(X) {
    return d.value[X] || {}
  }

  function A(X, ve) {
    d.value[X] = ve, T.datetimeFormats = d.value, Lv(T, X, ve)
  }

  function F(X, ve) {
    d.value[X] = Ws(d.value[X] || {}, ve), T.datetimeFormats = d.value, Lv(T, X, ve)
  }

  function K(X) {
    return f.value[X] || {}
  }

  function B(X, ve) {
    f.value[X] = ve, T.numberFormats = f.value, Nv(T, X, ve)
  }

  function ce(X, ve) {
    f.value[X] = Ws(f.value[X] || {}, ve), T.numberFormats = f.value, Nv(T, X, ve)
  }
  zv++, t && Lf && (Ne(t.locale, X => {
    o && (i.value = X, T.locale = X, ju(T, i.value, l.value))
  }), Ne(t.fallbackLocale, X => {
    o && (l.value = X, T.fallbackLocale = X, ju(T, i.value, l.value))
  }));
  const le = {
    id: zv,
    locale: N,
    fallbackLocale: ne,
    get inheritLocale() {
      return o
    },
    set inheritLocale(X) {
      o = X, X && t && (i.value = t.locale.value, l.value = t.fallbackLocale.value, ju(T, i.value, l.value))
    },
    get availableLocales() {
      return Object.keys(c.value).sort()
    },
    messages: Y,
    get modifiers() {
      return E
    },
    get pluralRules() {
      return S || {}
    },
    get isGlobal() {
      return r
    },
    get missingWarn() {
      return p
    },
    set missingWarn(X) {
      p = X, T.missingWarn = p
    },
    get fallbackWarn() {
      return h
    },
    set fallbackWarn(X) {
      h = X, T.fallbackWarn = h
    },
    get fallbackRoot() {
      return _
    },
    set fallbackRoot(X) {
      _ = X
    },
    get fallbackFormat() {
      return v
    },
    set fallbackFormat(X) {
      v = X, T.fallbackFormat = v
    },
    get warnHtmlMessage() {
      return w
    },
    set warnHtmlMessage(X) {
      w = X, T.warnHtmlMessage = X
    },
    get escapeParameter() {
      return x
    },
    set escapeParameter(X) {
      x = X, T.escapeParameter = X
    },
    t: ae,
    getLocaleMessage: W,
    setLocaleMessage: O,
    mergeLocaleMessage: q,
    getPostTranslationHandler: re,
    setPostTranslationHandler: J,
    getMissingHandler: ee,
    setMissingHandler: de,
    [uE]: Ae
  };
  return le.datetimeFormats = _e, le.numberFormats = Q, le.rt = ke, le.te = fe, le.tm = M, le.d = be, le.n = ge, le.getDateTimeFormat = he, le.setDateTimeFormat = A, le.mergeDateTimeFormat = F, le.getNumberFormat = K, le.setNumberFormat = B, le.mergeNumberFormat = ce, le[cE] = n, le[Jh] = D, le[Xh] = ye, le[em] = pe, le
}
const R0 = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    validator: e => e === "parent" || e === "global",
    default: "parent"
  },
  i18n: {
    type: Object
  }
};

function hE({
  slots: e
}, t) {
  return t.length === 1 && t[0] === "default" ? (e.default ? e.default() : []).reduce((r, s) => [...r, ...s.type === Ee ? s.children : [s]], []) : t.reduce((n, r) => {
    const s = e[r];
    return s && (n[r] = s()), n
  }, kr())
}

function i4() {
  return Ee
}
const mE = te({
    name: "i18n-t",
    props: Ws({
      keypath: {
        type: String,
        required: !0
      },
      plural: {
        type: [Number, String],
        validator: e => Ac(e) || !isNaN(e)
      }
    }, R0),
    setup(e, t) {
      const {
        slots: n,
        attrs: r
      } = t, s = e.i18n || Fe({
        useScope: e.scope,
        __useComponent: !0
      });
      return () => {
        const a = Object.keys(n).filter(f => f !== "_"),
          o = kr();
        e.locale && (o.locale = e.locale), e.plural !== void 0 && (o.plural = vn(e.plural) ? +e.plural : e.plural);
        const i = hE(t, a),
          l = s[Jh](e.keypath, i, o),
          c = Ws(kr(), r),
          d = vn(e.tag) || Sr(e.tag) ? e.tag : i4();
        return yn(d, c, l)
      }
    }
  }),
  Wv = mE;

function gE(e) {
  return xa(e) && !vn(e[0])
}

function l4(e, t, n, r) {
  const {
    slots: s,
    attrs: a
  } = t;
  return () => {
    const o = {
      part: !0
    };
    let i = kr();
    e.locale && (o.locale = e.locale), vn(e.format) ? o.key = e.format : Sr(e.format) && (vn(e.format.key) && (o.key = e.format.key), i = Object.keys(e.format).reduce((p, h) => n.includes(h) ? Ws(kr(), p, {
      [h]: e.format[h]
    }) : p, kr()));
    const l = r(e.value, o, i);
    let c = [o.key];
    xa(l) ? c = l.map((p, h) => {
      const _ = s[p.type],
        v = _ ? _({
          [p.type]: p.value,
          index: h,
          parts: l
        }) : [p.value];
      return gE(v) && (v[0].key = `${p.type}-${h}`), v
    }) : vn(l) && (c = [l]);
    const d = Ws(kr(), a),
      f = vn(e.tag) || Sr(e.tag) ? e.tag : i4();
    return yn(f, d, c)
  }
}
const vE = te({
    name: "i18n-n",
    props: Ws({
      value: {
        type: Number,
        required: !0
      },
      format: {
        type: [String, Object]
      }
    }, R0),
    setup(e, t) {
      const n = e.i18n || Fe({
        useScope: e.scope,
        __useComponent: !0
      });
      return l4(e, t, t4, (...r) => n[em](...r))
    }
  }),
  Gv = vE,
  _E = te({
    name: "i18n-d",
    props: Ws({
      value: {
        type: [Number, Date],
        required: !0
      },
      format: {
        type: [String, Object]
      }
    }, R0),
    setup(e, t) {
      const n = e.i18n || Fe({
        useScope: e.scope,
        __useComponent: !0
      });
      return l4(e, t, e4, (...r) => n[Xh](...r))
    }
  }),
  Qv = _E;

function yE(e, t) {
  const n = e;
  if (e.mode === "composition") return n.__getInstance(t) || e.global;
  {
    const r = n.__getInstance(t);
    return r != null ? r.__composer : e.global.__composer
  }
}

function bE(e) {
  const t = o => {
    const {
      instance: i,
      value: l
    } = o;
    if (!i || !i.$) throw Ss(Jr.UNEXPECTED_ERROR);
    const c = yE(e, i.$),
      d = qv(l);
    return [Reflect.apply(c.t, c, [...Kv(d)]), c]
  };
  return {
    created: (o, i) => {
      const [l, c] = t(i);
      Lf && e.global === c && (o.__i18nWatcher = Ne(c.locale, () => {
        i.instance && i.instance.$forceUpdate()
      })), o.__composer = c, o.textContent = l
    },
    unmounted: o => {
      Lf && o.__i18nWatcher && (o.__i18nWatcher(), o.__i18nWatcher = void 0, delete o.__i18nWatcher), o.__composer && (o.__composer = void 0, delete o.__composer)
    },
    beforeUpdate: (o, {
      value: i
    }) => {
      if (o.__composer) {
        const l = o.__composer,
          c = qv(i);
        o.textContent = Reflect.apply(l.t, l, [...Kv(c)])
      }
    },
    getSSRProps: o => {
      const [i] = t(o);
      return {
        textContent: i
      }
    }
  }
}

function qv(e) {
  if (vn(e)) return {
    path: e
  };
  if (hs(e)) {
    if (!("path" in e)) throw Ss(Jr.REQUIRED_VALUE, "path");
    return e
  } else throw Ss(Jr.INVALID_VALUE)
}

function Kv(e) {
  const {
    path: t,
    locale: n,
    args: r,
    choice: s,
    plural: a
  } = e, o = {}, i = r || {};
  return vn(n) && (o.locale = n), Ac(s) && (o.plural = s), Ac(a) && (o.plural = a), [t, i, o]
}

function wE(e, t, ...n) {
  const r = hs(n[0]) ? n[0] : {};
  (ha(r.globalInstall) ? r.globalInstall : !0) && ([Wv.name, "I18nT"].forEach(a => e.component(a, Wv)), [Gv.name, "I18nN"].forEach(a => e.component(a, Gv)), [Qv.name, "I18nD"].forEach(a => e.component(a, Qv))), e.directive("t", bE(t))
}
const CE = Wo("global-vue-i18n");

function xE(e = {}, t) {
  const n = ha(e.globalInjection) ? e.globalInjection : !0,
    r = new Map,
    [s, a] = kE(e),
    o = Wo("");

  function i(f) {
    return r.get(f) || null
  }

  function l(f, p) {
    r.set(f, p)
  }

  function c(f) {
    r.delete(f)
  }
  const d = {
    get mode() {
      return "composition"
    },
    async install(f, ...p) {
      if (f.__VUE_I18N_SYMBOL__ = o, f.provide(f.__VUE_I18N_SYMBOL__, d), hs(p[0])) {
        const v = p[0];
        d.__composerExtend = v.__composerExtend, d.__vueI18nExtend = v.__vueI18nExtend
      }
      let h = null;
      n && (h = ME(f, d.global)), wE(f, d, ...p);
      const _ = f.unmount;
      f.unmount = () => {
        h && h(), d.dispose(), _()
      }
    },
    get global() {
      return a
    },
    dispose() {
      s.stop()
    },
    __instances: r,
    __getInstance: i,
    __setInstance: l,
    __deleteInstance: c
  };
  return d
}

function Fe(e = {}) {
  const t = gr();
  if (t == null) throw Ss(Jr.MUST_BE_CALL_SETUP_TOP);
  if (!t.isCE && t.appContext.app != null && !t.appContext.app.__VUE_I18N_SYMBOL__) throw Ss(Jr.NOT_INSTALLED);
  const n = SE(t),
    r = TE(n),
    s = a4(t),
    a = EE(e, s);
  if (a === "global") return dE(r, e, s), r;
  if (a === "parent") {
    let l = AE(n, t, e.__useComponent);
    return l == null && (l = r), l
  }
  const o = n;
  let i = o.__getInstance(t);
  if (i == null) {
    const l = Ws({}, e);
    "__i18n" in s && (l.__i18n = s.__i18n), r && (l.__root = r), i = o4(l), o.__composerExtend && (i[tm] = o.__composerExtend(i)), IE(o, t, i), o.__setInstance(t, i)
  }
  return i
}

function kE(e, t, n) {
  const r = a0(),
    s = r.run(() => o4(e));
  if (s == null) throw Ss(Jr.UNEXPECTED_ERROR);
  return [r, s]
}

function SE(e) {
  const t = Hn(e.isCE ? CE : e.appContext.app.__VUE_I18N_SYMBOL__);
  if (!t) throw Ss(e.isCE ? Jr.NOT_INSTALLED_WITH_PROVIDE : Jr.UNEXPECTED_ERROR);
  return t
}

function EE(e, t) {
  return Ak(e) ? "__i18n" in t ? "local" : "global" : e.useScope ? e.useScope : "local"
}

function TE(e) {
  return e.mode === "composition" ? e.global : e.global.__composer
}

function AE(e, t, n = !1) {
  let r = null;
  const s = t.root;
  let a = PE(t, n);
  for (; a != null;) {
    const o = e;
    if (e.mode === "composition" && (r = o.__getInstance(a)), r != null || s === a) break;
    a = a.parent
  }
  return r
}

function PE(e, t = !1) {
  return e == null ? null : t && e.vnode.ctx || e.parent
}

function IE(e, t, n) {
  Ge(() => {}, t), en(() => {
    const r = n;
    e.__deleteInstance(t);
    const s = r[tm];
    s && (s(), delete r[tm])
  }, t)
}
const $E = ["locale", "fallbackLocale", "availableLocales"],
  Zv = ["t", "rt", "d", "n", "tm", "te"];

function ME(e, t) {
  const n = Object.create(null);
  return $E.forEach(s => {
    const a = Object.getOwnPropertyDescriptor(t, s);
    if (!a) throw Ss(Jr.UNEXPECTED_ERROR);
    const o = Ht(a.value) ? {
      get() {
        return a.value.value
      },
      set(i) {
        a.value.value = i
      }
    } : {
      get() {
        return a.get && a.get()
      }
    };
    Object.defineProperty(n, s, o)
  }), e.config.globalProperties.$i18n = n, Zv.forEach(s => {
    const a = Object.getOwnPropertyDescriptor(t, s);
    if (!a || !a.value) throw Ss(Jr.UNEXPECTED_ERROR);
    Object.defineProperty(e.config.globalProperties, `$${s}`, a)
  }), () => {
    delete e.config.globalProperties.$i18n, Zv.forEach(s => {
      delete e.config.globalProperties[`$${s}`]
    })
  }
}
lE();
jS(wS);
HS(NS);
VS(Qb);
if (__INTLIFY_PROD_DEVTOOLS__) {
  const e = Rb();
  e.__INTLIFY__ = !0, CS(e.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__)
}
const OE = ["top", "right", "bottom", "left"],
  Lo = Math.min,
  Lr = Math.max,
  Ff = Math.round,
  Nd = Math.floor,
  qs = e => ({
    x: e,
    y: e
  }),
  DE = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  },
  LE = {
    start: "end",
    end: "start"
  };

function nm(e, t, n) {
  return Lr(e, Lo(t, n))
}

function Na(e, t) {
  return typeof e == "function" ? e(t) : e
}

function Fa(e) {
  return e.split("-")[0]
}

function yu(e) {
  return e.split("-")[1]
}

function N0(e) {
  return e === "x" ? "y" : "x"
}

function F0(e) {
  return e === "y" ? "height" : "width"
}

function $a(e) {
  return ["top", "bottom"].includes(Fa(e)) ? "y" : "x"
}

function B0(e) {
  return N0($a(e))
}

function RE(e, t, n) {
  n === void 0 && (n = !1);
  const r = yu(e),
    s = B0(e),
    a = F0(s);
  let o = s === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[a] > t.floating[a] && (o = Bf(o)), [o, Bf(o)]
}

function NE(e) {
  const t = Bf(e);
  return [rm(e), t, rm(t)]
}

function rm(e) {
  return e.replace(/start|end/g, t => LE[t])
}

function FE(e, t, n) {
  const r = ["left", "right"],
    s = ["right", "left"],
    a = ["top", "bottom"],
    o = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? s : r : t ? r : s;
    case "left":
    case "right":
      return t ? a : o;
    default:
      return []
  }
}

function BE(e, t, n, r) {
  const s = yu(e);
  let a = FE(Fa(e), n === "start", r);
  return s && (a = a.map(o => o + "-" + s), t && (a = a.concat(a.map(rm)))), a
}

function Bf(e) {
  return e.replace(/left|right|bottom|top/g, t => DE[t])
}

function jE(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  }
}

function u4(e) {
  return typeof e != "number" ? jE(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  }
}

function jf(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: s
  } = e;
  return {
    width: r,
    height: s,
    top: n,
    left: t,
    right: t + r,
    bottom: n + s,
    x: t,
    y: n
  }
}

function Jv(e, t, n) {
  let {
    reference: r,
    floating: s
  } = e;
  const a = $a(t),
    o = B0(t),
    i = F0(o),
    l = Fa(t),
    c = a === "y",
    d = r.x + r.width / 2 - s.width / 2,
    f = r.y + r.height / 2 - s.height / 2,
    p = r[i] / 2 - s[i] / 2;
  let h;
  switch (l) {
    case "top":
      h = {
        x: d,
        y: r.y - s.height
      };
      break;
    case "bottom":
      h = {
        x: d,
        y: r.y + r.height
      };
      break;
    case "right":
      h = {
        x: r.x + r.width,
        y: f
      };
      break;
    case "left":
      h = {
        x: r.x - s.width,
        y: f
      };
      break;
    default:
      h = {
        x: r.x,
        y: r.y
      }
  }
  switch (yu(t)) {
    case "start":
      h[o] -= p * (n && c ? -1 : 1);
      break;
    case "end":
      h[o] += p * (n && c ? -1 : 1);
      break
  }
  return h
}
const HE = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: s = "absolute",
    middleware: a = [],
    platform: o
  } = n, i = a.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(t));
  let c = await o.getElementRects({
      reference: e,
      floating: t,
      strategy: s
    }),
    {
      x: d,
      y: f
    } = Jv(c, r, l),
    p = r,
    h = {},
    _ = 0;
  for (let v = 0; v < i.length; v++) {
    const {
      name: C,
      fn: y
    } = i[v], {
      x: b,
      y: w,
      data: x,
      reset: E
    } = await y({
      x: d,
      y: f,
      initialPlacement: r,
      placement: p,
      strategy: s,
      middlewareData: h,
      rects: c,
      platform: o,
      elements: {
        reference: e,
        floating: t
      }
    });
    d = b ?? d, f = w ?? f, h = {
      ...h,
      [C]: {
        ...h[C],
        ...x
      }
    }, E && _ <= 50 && (_++, typeof E == "object" && (E.placement && (p = E.placement), E.rects && (c = E.rects === !0 ? await o.getElementRects({
      reference: e,
      floating: t,
      strategy: s
    }) : E.rects), {
      x: d,
      y: f
    } = Jv(c, p, l)), v = -1)
  }
  return {
    x: d,
    y: f,
    placement: p,
    strategy: s,
    middlewareData: h
  }
};
async function Mc(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: s,
    platform: a,
    rects: o,
    elements: i,
    strategy: l
  } = e, {
    boundary: c = "clippingAncestors",
    rootBoundary: d = "viewport",
    elementContext: f = "floating",
    altBoundary: p = !1,
    padding: h = 0
  } = Na(t, e), _ = u4(h), C = i[p ? f === "floating" ? "reference" : "floating" : f], y = jf(await a.getClippingRect({
    element: (n = await (a.isElement == null ? void 0 : a.isElement(C))) == null || n ? C : C.contextElement || await (a.getDocumentElement == null ? void 0 : a.getDocumentElement(i.floating)),
    boundary: c,
    rootBoundary: d,
    strategy: l
  })), b = f === "floating" ? {
    x: r,
    y: s,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, w = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(i.floating)), x = await (a.isElement == null ? void 0 : a.isElement(w)) ? await (a.getScale == null ? void 0 : a.getScale(w)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, E = jf(a.convertOffsetParentRelativeRectToViewportRelativeRect ? await a.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: i,
    rect: b,
    offsetParent: w,
    strategy: l
  }) : b);
  return {
    top: (y.top - E.top + _.top) / x.y,
    bottom: (E.bottom - y.bottom + _.bottom) / x.y,
    left: (y.left - E.left + _.left) / x.x,
    right: (E.right - y.right + _.right) / x.x
  }
}
const VE = e => ({
    name: "arrow",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: s,
        rects: a,
        platform: o,
        elements: i,
        middlewareData: l
      } = t, {
        element: c,
        padding: d = 0
      } = Na(e, t) || {};
      if (c == null) return {};
      const f = u4(d),
        p = {
          x: n,
          y: r
        },
        h = B0(s),
        _ = F0(h),
        v = await o.getDimensions(c),
        C = h === "y",
        y = C ? "top" : "left",
        b = C ? "bottom" : "right",
        w = C ? "clientHeight" : "clientWidth",
        x = a.reference[_] + a.reference[h] - p[h] - a.floating[_],
        E = p[h] - a.reference[h],
        S = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(c));
      let T = S ? S[w] : 0;
      (!T || !await (o.isElement == null ? void 0 : o.isElement(S))) && (T = i.floating[w] || a.floating[_]);
      const j = x / 2 - E / 2,
        P = T / 2 - v[_] / 2 - 1,
        N = Lo(f[y], P),
        ne = Lo(f[b], P),
        Y = N,
        _e = T - v[_] - ne,
        Q = T / 2 - v[_] / 2 + j,
        re = nm(Y, Q, _e),
        J = !l.arrow && yu(s) != null && Q !== re && a.reference[_] / 2 - (Q < Y ? N : ne) - v[_] / 2 < 0,
        ee = J ? Q < Y ? Q - Y : Q - _e : 0;
      return {
        [h]: p[h] + ee,
        data: {
          [h]: re,
          centerOffset: Q - re - ee,
          ...J && {
            alignmentOffset: ee
          }
        },
        reset: J
      }
    }
  }),
  UE = function(e) {
    return e === void 0 && (e = {}), {
      name: "flip",
      options: e,
      async fn(t) {
        var n, r;
        const {
          placement: s,
          middlewareData: a,
          rects: o,
          initialPlacement: i,
          platform: l,
          elements: c
        } = t, {
          mainAxis: d = !0,
          crossAxis: f = !0,
          fallbackPlacements: p,
          fallbackStrategy: h = "bestFit",
          fallbackAxisSideDirection: _ = "none",
          flipAlignment: v = !0,
          ...C
        } = Na(e, t);
        if ((n = a.arrow) != null && n.alignmentOffset) return {};
        const y = Fa(s),
          b = $a(i),
          w = Fa(i) === i,
          x = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)),
          E = p || (w || !v ? [Bf(i)] : NE(i)),
          S = _ !== "none";
        !p && S && E.push(...BE(i, v, _, x));
        const T = [i, ...E],
          j = await Mc(t, C),
          P = [];
        let N = ((r = a.flip) == null ? void 0 : r.overflows) || [];
        if (d && P.push(j[y]), f) {
          const re = RE(s, o, x);
          P.push(j[re[0]], j[re[1]])
        }
        if (N = [...N, {
            placement: s,
            overflows: P
          }], !P.every(re => re <= 0)) {
          var ne, Y;
          const re = (((ne = a.flip) == null ? void 0 : ne.index) || 0) + 1,
            J = T[re];
          if (J) {
            var _e;
            const de = f === "alignment" ? b !== $a(J) : !1,
              se = ((_e = N[0]) == null ? void 0 : _e.overflows[0]) > 0;
            if (!de || se) return {
              data: {
                index: re,
                overflows: N
              },
              reset: {
                placement: J
              }
            }
          }
          let ee = (Y = N.filter(de => de.overflows[0] <= 0).sort((de, se) => de.overflows[1] - se.overflows[1])[0]) == null ? void 0 : Y.placement;
          if (!ee) switch (h) {
            case "bestFit": {
              var Q;
              const de = (Q = N.filter(se => {
                if (S) {
                  const ae = $a(se.placement);
                  return ae === b || ae === "y"
                }
                return !0
              }).map(se => [se.placement, se.overflows.filter(ae => ae > 0).reduce((ae, ke) => ae + ke, 0)]).sort((se, ae) => se[1] - ae[1])[0]) == null ? void 0 : Q[0];
              de && (ee = de);
              break
            }
            case "initialPlacement":
              ee = i;
              break
          }
          if (s !== ee) return {
            reset: {
              placement: ee
            }
          }
        }
        return {}
      }
    }
  };

function Xv(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  }
}

function e_(e) {
  return OE.some(t => e[t] >= 0)
}
const zE = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: r = "referenceHidden",
        ...s
      } = Na(e, t);
      switch (r) {
        case "referenceHidden": {
          const a = await Mc(t, {
              ...s,
              elementContext: "reference"
            }),
            o = Xv(a, n.reference);
          return {
            data: {
              referenceHiddenOffsets: o,
              referenceHidden: e_(o)
            }
          }
        }
        case "escaped": {
          const a = await Mc(t, {
              ...s,
              altBoundary: !0
            }),
            o = Xv(a, n.floating);
          return {
            data: {
              escapedOffsets: o,
              escaped: e_(o)
            }
          }
        }
        default:
          return {}
      }
    }
  }
};
async function YE(e, t) {
  const {
    placement: n,
    platform: r,
    elements: s
  } = e, a = await (r.isRTL == null ? void 0 : r.isRTL(s.floating)), o = Fa(n), i = yu(n), l = $a(n) === "y", c = ["left", "top"].includes(o) ? -1 : 1, d = a && l ? -1 : 1, f = Na(t, e);
  let {
    mainAxis: p,
    crossAxis: h,
    alignmentAxis: _
  } = typeof f == "number" ? {
    mainAxis: f,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: f.mainAxis || 0,
    crossAxis: f.crossAxis || 0,
    alignmentAxis: f.alignmentAxis
  };
  return i && typeof _ == "number" && (h = i === "end" ? _ * -1 : _), l ? {
    x: h * d,
    y: p * c
  } : {
    x: p * c,
    y: h * d
  }
}
const WE = function(e) {
    return e === void 0 && (e = 0), {
      name: "offset",
      options: e,
      async fn(t) {
        var n, r;
        const {
          x: s,
          y: a,
          placement: o,
          middlewareData: i
        } = t, l = await YE(t, e);
        return o === ((n = i.offset) == null ? void 0 : n.placement) && (r = i.arrow) != null && r.alignmentOffset ? {} : {
          x: s + l.x,
          y: a + l.y,
          data: {
            ...l,
            placement: o
          }
        }
      }
    }
  },
  GE = function(e) {
    return e === void 0 && (e = {}), {
      name: "shift",
      options: e,
      async fn(t) {
        const {
          x: n,
          y: r,
          placement: s
        } = t, {
          mainAxis: a = !0,
          crossAxis: o = !1,
          limiter: i = {
            fn: C => {
              let {
                x: y,
                y: b
              } = C;
              return {
                x: y,
                y: b
              }
            }
          },
          ...l
        } = Na(e, t), c = {
          x: n,
          y: r
        }, d = await Mc(t, l), f = $a(Fa(s)), p = N0(f);
        let h = c[p],
          _ = c[f];
        if (a) {
          const C = p === "y" ? "top" : "left",
            y = p === "y" ? "bottom" : "right",
            b = h + d[C],
            w = h - d[y];
          h = nm(b, h, w)
        }
        if (o) {
          const C = f === "y" ? "top" : "left",
            y = f === "y" ? "bottom" : "right",
            b = _ + d[C],
            w = _ - d[y];
          _ = nm(b, _, w)
        }
        const v = i.fn({
          ...t,
          [p]: h,
          [f]: _
        });
        return {
          ...v,
          data: {
            x: v.x - n,
            y: v.y - r,
            enabled: {
              [p]: a,
              [f]: o
            }
          }
        }
      }
    }
  },
  QE = function(e) {
    return e === void 0 && (e = {}), {
      options: e,
      fn(t) {
        const {
          x: n,
          y: r,
          placement: s,
          rects: a,
          middlewareData: o
        } = t, {
          offset: i = 0,
          mainAxis: l = !0,
          crossAxis: c = !0
        } = Na(e, t), d = {
          x: n,
          y: r
        }, f = $a(s), p = N0(f);
        let h = d[p],
          _ = d[f];
        const v = Na(i, t),
          C = typeof v == "number" ? {
            mainAxis: v,
            crossAxis: 0
          } : {
            mainAxis: 0,
            crossAxis: 0,
            ...v
          };
        if (l) {
          const w = p === "y" ? "height" : "width",
            x = a.reference[p] - a.floating[w] + C.mainAxis,
            E = a.reference[p] + a.reference[w] - C.mainAxis;
          h < x ? h = x : h > E && (h = E)
        }
        if (c) {
          var y, b;
          const w = p === "y" ? "width" : "height",
            x = ["top", "left"].includes(Fa(s)),
            E = a.reference[f] - a.floating[w] + (x && ((y = o.offset) == null ? void 0 : y[f]) || 0) + (x ? 0 : C.crossAxis),
            S = a.reference[f] + a.reference[w] + (x ? 0 : ((b = o.offset) == null ? void 0 : b[f]) || 0) - (x ? C.crossAxis : 0);
          _ < E ? _ = E : _ > S && (_ = S)
        }
        return {
          [p]: h,
          [f]: _
        }
      }
    }
  },
  qE = function(e) {
    return e === void 0 && (e = {}), {
      name: "size",
      options: e,
      async fn(t) {
        var n, r;
        const {
          placement: s,
          rects: a,
          platform: o,
          elements: i
        } = t, {
          apply: l = () => {},
          ...c
        } = Na(e, t), d = await Mc(t, c), f = Fa(s), p = yu(s), h = $a(s) === "y", {
          width: _,
          height: v
        } = a.floating;
        let C, y;
        f === "top" || f === "bottom" ? (C = f, y = p === (await (o.isRTL == null ? void 0 : o.isRTL(i.floating)) ? "start" : "end") ? "left" : "right") : (y = f, C = p === "end" ? "top" : "bottom");
        const b = v - d.top - d.bottom,
          w = _ - d.left - d.right,
          x = Lo(v - d[C], b),
          E = Lo(_ - d[y], w),
          S = !t.middlewareData.shift;
        let T = x,
          j = E;
        if ((n = t.middlewareData.shift) != null && n.enabled.x && (j = w), (r = t.middlewareData.shift) != null && r.enabled.y && (T = b), S && !p) {
          const N = Lr(d.left, 0),
            ne = Lr(d.right, 0),
            Y = Lr(d.top, 0),
            _e = Lr(d.bottom, 0);
          h ? j = _ - 2 * (N !== 0 || ne !== 0 ? N + ne : Lr(d.left, d.right)) : T = v - 2 * (Y !== 0 || _e !== 0 ? Y + _e : Lr(d.top, d.bottom))
        }
        await l({
          ...t,
          availableWidth: j,
          availableHeight: T
        });
        const P = await o.getDimensions(i.floating);
        return _ !== P.width || v !== P.height ? {
          reset: {
            rects: !0
          }
        } : {}
      }
    }
  };

function Tp() {
  return typeof window < "u"
}

function Yi(e) {
  return j0(e) ? (e.nodeName || "").toLowerCase() : "#document"
}

function Br(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window
}

function ra(e) {
  var t;
  return (t = (j0(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement
}

function j0(e) {
  return Tp() ? e instanceof Node || e instanceof Br(e).Node : !1
}

function Es(e) {
  return Tp() ? e instanceof Element || e instanceof Br(e).Element : !1
}

function Xs(e) {
  return Tp() ? e instanceof HTMLElement || e instanceof Br(e).HTMLElement : !1
}

function t_(e) {
  return !Tp() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof Br(e).ShadowRoot
}

function sd(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: s
  } = Ts(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(s)
}

function KE(e) {
  return ["table", "td", "th"].includes(Yi(e))
}

function Ap(e) {
  return [":popover-open", ":modal"].some(t => {
    try {
      return e.matches(t)
    } catch {
      return !1
    }
  })
}

function H0(e) {
  const t = V0(),
    n = Es(e) ? Ts(e) : e;
  return ["transform", "translate", "scale", "rotate", "perspective"].some(r => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some(r => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some(r => (n.contain || "").includes(r))
}

function ZE(e) {
  let t = Ro(e);
  for (; Xs(t) && !Kl(t);) {
    if (H0(t)) return t;
    if (Ap(t)) return null;
    t = Ro(t)
  }
  return null
}

function V0() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none")
}

function Kl(e) {
  return ["html", "body", "#document"].includes(Yi(e))
}

function Ts(e) {
  return Br(e).getComputedStyle(e)
}

function Pp(e) {
  return Es(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  }
}

function Ro(e) {
  if (Yi(e) === "html") return e;
  const t = e.assignedSlot || e.parentNode || t_(e) && e.host || ra(e);
  return t_(t) ? t.host : t
}

function c4(e) {
  const t = Ro(e);
  return Kl(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Xs(t) && sd(t) ? t : c4(t)
}

function Oc(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const s = c4(e),
    a = s === ((r = e.ownerDocument) == null ? void 0 : r.body),
    o = Br(s);
  if (a) {
    const i = sm(o);
    return t.concat(o, o.visualViewport || [], sd(s) ? s : [], i && n ? Oc(i) : [])
  }
  return t.concat(s, Oc(s, [], n))
}

function sm(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null
}

function d4(e) {
  const t = Ts(e);
  let n = parseFloat(t.width) || 0,
    r = parseFloat(t.height) || 0;
  const s = Xs(e),
    a = s ? e.offsetWidth : n,
    o = s ? e.offsetHeight : r,
    i = Ff(n) !== a || Ff(r) !== o;
  return i && (n = a, r = o), {
    width: n,
    height: r,
    $: i
  }
}

function U0(e) {
  return Es(e) ? e : e.contextElement
}

function kl(e) {
  const t = U0(e);
  if (!Xs(t)) return qs(1);
  const n = t.getBoundingClientRect(),
    {
      width: r,
      height: s,
      $: a
    } = d4(t);
  let o = (a ? Ff(n.width) : n.width) / r,
    i = (a ? Ff(n.height) : n.height) / s;
  return (!o || !Number.isFinite(o)) && (o = 1), (!i || !Number.isFinite(i)) && (i = 1), {
    x: o,
    y: i
  }
}
const JE = qs(0);

function f4(e) {
  const t = Br(e);
  return !V0() || !t.visualViewport ? JE : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  }
}

function XE(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== Br(e) ? !1 : t
}

function Ri(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const s = e.getBoundingClientRect(),
    a = U0(e);
  let o = qs(1);
  t && (r ? Es(r) && (o = kl(r)) : o = kl(e));
  const i = XE(a, n, r) ? f4(a) : qs(0);
  let l = (s.left + i.x) / o.x,
    c = (s.top + i.y) / o.y,
    d = s.width / o.x,
    f = s.height / o.y;
  if (a) {
    const p = Br(a),
      h = r && Es(r) ? Br(r) : r;
    let _ = p,
      v = sm(_);
    for (; v && r && h !== _;) {
      const C = kl(v),
        y = v.getBoundingClientRect(),
        b = Ts(v),
        w = y.left + (v.clientLeft + parseFloat(b.paddingLeft)) * C.x,
        x = y.top + (v.clientTop + parseFloat(b.paddingTop)) * C.y;
      l *= C.x, c *= C.y, d *= C.x, f *= C.y, l += w, c += x, _ = Br(v), v = sm(_)
    }
  }
  return jf({
    width: d,
    height: f,
    x: l,
    y: c
  })
}

function z0(e, t) {
  const n = Pp(e).scrollLeft;
  return t ? t.left + n : Ri(ra(e)).left + n
}

function p4(e, t, n) {
  n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(),
    s = r.left + t.scrollLeft - (n ? 0 : z0(e, r)),
    a = r.top + t.scrollTop;
  return {
    x: s,
    y: a
  }
}

function eT(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: s
  } = e;
  const a = s === "fixed",
    o = ra(r),
    i = t ? Ap(t.floating) : !1;
  if (r === o || i && a) return n;
  let l = {
      scrollLeft: 0,
      scrollTop: 0
    },
    c = qs(1);
  const d = qs(0),
    f = Xs(r);
  if ((f || !f && !a) && ((Yi(r) !== "body" || sd(o)) && (l = Pp(r)), Xs(r))) {
    const h = Ri(r);
    c = kl(r), d.x = h.x + r.clientLeft, d.y = h.y + r.clientTop
  }
  const p = o && !f && !a ? p4(o, l, !0) : qs(0);
  return {
    width: n.width * c.x,
    height: n.height * c.y,
    x: n.x * c.x - l.scrollLeft * c.x + d.x + p.x,
    y: n.y * c.y - l.scrollTop * c.y + d.y + p.y
  }
}

function tT(e) {
  return Array.from(e.getClientRects())
}

function nT(e) {
  const t = ra(e),
    n = Pp(e),
    r = e.ownerDocument.body,
    s = Lr(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth),
    a = Lr(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let o = -n.scrollLeft + z0(e);
  const i = -n.scrollTop;
  return Ts(r).direction === "rtl" && (o += Lr(t.clientWidth, r.clientWidth) - s), {
    width: s,
    height: a,
    x: o,
    y: i
  }
}

function rT(e, t) {
  const n = Br(e),
    r = ra(e),
    s = n.visualViewport;
  let a = r.clientWidth,
    o = r.clientHeight,
    i = 0,
    l = 0;
  if (s) {
    a = s.width, o = s.height;
    const c = V0();
    (!c || c && t === "fixed") && (i = s.offsetLeft, l = s.offsetTop)
  }
  return {
    width: a,
    height: o,
    x: i,
    y: l
  }
}

function sT(e, t) {
  const n = Ri(e, !0, t === "fixed"),
    r = n.top + e.clientTop,
    s = n.left + e.clientLeft,
    a = Xs(e) ? kl(e) : qs(1),
    o = e.clientWidth * a.x,
    i = e.clientHeight * a.y,
    l = s * a.x,
    c = r * a.y;
  return {
    width: o,
    height: i,
    x: l,
    y: c
  }
}

function n_(e, t, n) {
  let r;
  if (t === "viewport") r = rT(e, n);
  else if (t === "document") r = nT(ra(e));
  else if (Es(t)) r = sT(t, n);
  else {
    const s = f4(e);
    r = {
      x: t.x - s.x,
      y: t.y - s.y,
      width: t.width,
      height: t.height
    }
  }
  return jf(r)
}

function h4(e, t) {
  const n = Ro(e);
  return n === t || !Es(n) || Kl(n) ? !1 : Ts(n).position === "fixed" || h4(n, t)
}

function aT(e, t) {
  const n = t.get(e);
  if (n) return n;
  let r = Oc(e, [], !1).filter(i => Es(i) && Yi(i) !== "body"),
    s = null;
  const a = Ts(e).position === "fixed";
  let o = a ? Ro(e) : e;
  for (; Es(o) && !Kl(o);) {
    const i = Ts(o),
      l = H0(o);
    !l && i.position === "fixed" && (s = null), (a ? !l && !s : !l && i.position === "static" && !!s && ["absolute", "fixed"].includes(s.position) || sd(o) && !l && h4(e, o)) ? r = r.filter(d => d !== o) : s = i, o = Ro(o)
  }
  return t.set(e, r), r
}

function oT(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: s
  } = e;
  const o = [...n === "clippingAncestors" ? Ap(t) ? [] : aT(t, this._c) : [].concat(n), r],
    i = o[0],
    l = o.reduce((c, d) => {
      const f = n_(t, d, s);
      return c.top = Lr(f.top, c.top), c.right = Lo(f.right, c.right), c.bottom = Lo(f.bottom, c.bottom), c.left = Lr(f.left, c.left), c
    }, n_(t, i, s));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  }
}

function iT(e) {
  const {
    width: t,
    height: n
  } = d4(e);
  return {
    width: t,
    height: n
  }
}

function lT(e, t, n) {
  const r = Xs(t),
    s = ra(t),
    a = n === "fixed",
    o = Ri(e, !0, a, t);
  let i = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = qs(0);

  function c() {
    l.x = z0(s)
  }
  if (r || !r && !a)
    if ((Yi(t) !== "body" || sd(s)) && (i = Pp(t)), r) {
      const h = Ri(t, !0, a, t);
      l.x = h.x + t.clientLeft, l.y = h.y + t.clientTop
    } else s && c();
  a && !r && s && c();
  const d = s && !r && !a ? p4(s, i) : qs(0),
    f = o.left + i.scrollLeft - l.x - d.x,
    p = o.top + i.scrollTop - l.y - d.y;
  return {
    x: f,
    y: p,
    width: o.width,
    height: o.height
  }
}

function P1(e) {
  return Ts(e).position === "static"
}

function r_(e, t) {
  if (!Xs(e) || Ts(e).position === "fixed") return null;
  if (t) return t(e);
  let n = e.offsetParent;
  return ra(e) === n && (n = n.ownerDocument.body), n
}

function m4(e, t) {
  const n = Br(e);
  if (Ap(e)) return n;
  if (!Xs(e)) {
    let s = Ro(e);
    for (; s && !Kl(s);) {
      if (Es(s) && !P1(s)) return s;
      s = Ro(s)
    }
    return n
  }
  let r = r_(e, t);
  for (; r && KE(r) && P1(r);) r = r_(r, t);
  return r && Kl(r) && P1(r) && !H0(r) ? n : r || ZE(e) || n
}
const uT = async function(e) {
  const t = this.getOffsetParent || m4,
    n = this.getDimensions,
    r = await n(e.floating);
  return {
    reference: lT(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  }
};

function cT(e) {
  return Ts(e).direction === "rtl"
}
const dT = {
  convertOffsetParentRelativeRectToViewportRelativeRect: eT,
  getDocumentElement: ra,
  getClippingRect: oT,
  getOffsetParent: m4,
  getElementRects: uT,
  getClientRects: tT,
  getDimensions: iT,
  getScale: kl,
  isElement: Es,
  isRTL: cT
};

function g4(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height
}

function fT(e, t) {
  let n = null,
    r;
  const s = ra(e);

  function a() {
    var i;
    clearTimeout(r), (i = n) == null || i.disconnect(), n = null
  }

  function o(i, l) {
    i === void 0 && (i = !1), l === void 0 && (l = 1), a();
    const c = e.getBoundingClientRect(),
      {
        left: d,
        top: f,
        width: p,
        height: h
      } = c;
    if (i || t(), !p || !h) return;
    const _ = Nd(f),
      v = Nd(s.clientWidth - (d + p)),
      C = Nd(s.clientHeight - (f + h)),
      y = Nd(d),
      w = {
        rootMargin: -_ + "px " + -v + "px " + -C + "px " + -y + "px",
        threshold: Lr(0, Lo(1, l)) || 1
      };
    let x = !0;

    function E(S) {
      const T = S[0].intersectionRatio;
      if (T !== l) {
        if (!x) return o();
        T ? o(!1, T) : r = setTimeout(() => {
          o(!1, 1e-7)
        }, 1e3)
      }
      T === 1 && !g4(c, e.getBoundingClientRect()) && o(), x = !1
    }
    try {
      n = new IntersectionObserver(E, {
        ...w,
        root: s.ownerDocument
      })
    } catch {
      n = new IntersectionObserver(E, w)
    }
    n.observe(e)
  }
  return o(!0), a
}

function pT(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: s = !0,
    ancestorResize: a = !0,
    elementResize: o = typeof ResizeObserver == "function",
    layoutShift: i = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = r, c = U0(e), d = s || a ? [...c ? Oc(c) : [], ...Oc(t)] : [];
  d.forEach(y => {
    s && y.addEventListener("scroll", n, {
      passive: !0
    }), a && y.addEventListener("resize", n)
  });
  const f = c && i ? fT(c, n) : null;
  let p = -1,
    h = null;
  o && (h = new ResizeObserver(y => {
    let [b] = y;
    b && b.target === c && h && (h.unobserve(t), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      var w;
      (w = h) == null || w.observe(t)
    })), n()
  }), c && !l && h.observe(c), h.observe(t));
  let _, v = l ? Ri(e) : null;
  l && C();

  function C() {
    const y = Ri(e);
    v && !g4(v, y) && n(), v = y, _ = requestAnimationFrame(C)
  }
  return n(), () => {
    var y;
    d.forEach(b => {
      s && b.removeEventListener("scroll", n), a && b.removeEventListener("resize", n)
    }), f == null || f(), (y = h) == null || y.disconnect(), h = null, l && cancelAnimationFrame(_)
  }
}
const hT = WE,
  mT = GE,
  s_ = UE,
  gT = qE,
  vT = zE,
  _T = VE,
  yT = QE,
  bT = (e, t, n) => {
    const r = new Map,
      s = {
        platform: dT,
        ...n
      },
      a = {
        ...s.platform,
        _c: r
      };
    return HE(e, t, {
      ...s,
      platform: a
    })
  };

function wT(e) {
  return e != null && typeof e == "object" && "$el" in e
}

function am(e) {
  if (wT(e)) {
    const t = e.$el;
    return j0(t) && Yi(t) === "#comment" ? null : t
  }
  return e
}

function cl(e) {
  return typeof e == "function" ? e() : u(e)
}

function CT(e) {
  return {
    name: "arrow",
    options: e,
    fn(t) {
      const n = am(cl(e.element));
      return n == null ? {} : _T({
        element: n,
        padding: e.padding
      }).fn(t)
    }
  }
}

function v4(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1
}

function a_(e, t) {
  const n = v4(e);
  return Math.round(t * n) / n
}

function xT(e, t, n) {
  n === void 0 && (n = {});
  const r = n.whileElementsMounted,
    s = L(() => {
      var T;
      return (T = cl(n.open)) != null ? T : !0
    }),
    a = L(() => cl(n.middleware)),
    o = L(() => {
      var T;
      return (T = cl(n.placement)) != null ? T : "bottom"
    }),
    i = L(() => {
      var T;
      return (T = cl(n.strategy)) != null ? T : "absolute"
    }),
    l = L(() => {
      var T;
      return (T = cl(n.transform)) != null ? T : !0
    }),
    c = L(() => am(e.value)),
    d = L(() => am(t.value)),
    f = U(0),
    p = U(0),
    h = U(i.value),
    _ = U(o.value),
    v = vp({}),
    C = U(!1),
    y = L(() => {
      const T = {
        position: h.value,
        left: "0",
        top: "0"
      };
      if (!d.value) return T;
      const j = a_(d.value, f.value),
        P = a_(d.value, p.value);
      return l.value ? {
        ...T,
        transform: "translate(" + j + "px, " + P + "px)",
        ...v4(d.value) >= 1.5 && {
          willChange: "transform"
        }
      } : {
        position: h.value,
        left: j + "px",
        top: P + "px"
      }
    });
  let b;

  function w() {
    if (c.value == null || d.value == null) return;
    const T = s.value;
    bT(c.value, d.value, {
      middleware: a.value,
      placement: o.value,
      strategy: i.value
    }).then(j => {
      f.value = j.x, p.value = j.y, h.value = j.strategy, _.value = j.placement, v.value = j.middlewareData, C.value = T !== !1
    })
  }

  function x() {
    typeof b == "function" && (b(), b = void 0)
  }

  function E() {
    if (x(), r === void 0) {
      w();
      return
    }
    if (c.value != null && d.value != null) {
      b = r(c.value, d.value, w);
      return
    }
  }

  function S() {
    s.value || (C.value = !1)
  }
  return Ne([a, o, i, s], w, {
    flush: "sync"
  }), Ne([c, d], E, {
    flush: "sync"
  }), Ne(s, S, {
    flush: "sync"
  }), Kc() && hu(x), {
    x: lo(f),
    y: lo(p),
    strategy: lo(h),
    placement: lo(_),
    middlewareData: lo(v),
    isPositioned: lo(C),
    floatingStyles: y,
    update: w
  }
}

function Or(e, t) {
  const n = typeof e == "string" && !t ? `${e}Context` : t,
    r = Symbol(n);
  return [s => {
    const a = Hn(r, s);
    if (a || a === null) return a;
    throw new Error(`Injection \`${r.toString()}\` not found. Component must be used within ${Array.isArray(e)?`one of the following components: ${e.join(", ")}`:`\`${e}\``}`)
  }, s => (xi(r, s), s)]
}

function _4(e, t, n) {
  const r = n.originalEvent.target,
    s = new CustomEvent(e, {
      bubbles: !1,
      cancelable: !0,
      detail: n
    });
  t && r.addEventListener(e, t, {
    once: !0
  }), r.dispatchEvent(s)
}

function om(e, t = Number.NEGATIVE_INFINITY, n = Number.POSITIVE_INFINITY) {
  return Math.min(n, Math.max(t, e))
}

function kT(e) {
  return e == null
}

function ST(e, t) {
  var n;
  const r = vp();
  return gn(() => {
    r.value = e()
  }, {
    ...t,
    flush: (n = void 0) != null ? n : "sync"
  }), Ui(r)
}

function bu(e) {
  return Kc() ? (hu(e), !0) : !1
}

function ET(e) {
  let t = !1,
    n;
  const r = a0(!0);
  return (...s) => (t || (n = r.run(() => e(...s)), t = !0), n)
}

function TT(e) {
  let t = 0,
    n, r;
  const s = () => {
    t -= 1, r && t <= 0 && (r.stop(), n = void 0, r = void 0)
  };
  return (...a) => (t += 1, n || (r = a0(!0), n = r.run(() => e(...a))), bu(s), n)
}

function Ks(e) {
  return typeof e == "function" ? e() : u(e)
}
const sa = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const AT = e => typeof e < "u",
  PT = Object.prototype.toString,
  IT = e => PT.call(e) === "[object Object]",
  Hf = () => {},
  o_ = $T();

function $T() {
  var e, t;
  return sa && ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent))
}

function MT(e, t) {
  function n(...r) {
    return new Promise((s, a) => {
      Promise.resolve(e(() => t.apply(this, r), {
        fn: t,
        thisArg: this,
        args: r
      })).then(s).catch(a)
    })
  }
  return n
}

function OT(e, t = {}) {
  let n, r, s = Hf;
  const a = o => {
    clearTimeout(o), s(), s = Hf
  };
  return o => {
    const i = Ks(e),
      l = Ks(t.maxWait);
    return n && a(n), i <= 0 || l !== void 0 && l <= 0 ? (r && (a(r), r = null), Promise.resolve(o())) : new Promise((c, d) => {
      s = t.rejectOnCancel ? d : c, l && !r && (r = setTimeout(() => {
        n && a(n), r = null, c(o())
      }, l)), n = setTimeout(() => {
        r && a(r), r = null, c(o())
      }, i)
    })
  }
}

function DT(e) {
  return gr()
}

function LT(e, t = 1e4) {
  return n5((n, r) => {
    let s = Ks(e),
      a;
    const o = () => setTimeout(() => {
      s = Ks(e), r()
    }, Ks(t));
    return bu(() => {
      clearTimeout(a)
    }), {
      get() {
        return n(), s
      },
      set(i) {
        s = i, r(), clearTimeout(a), a = o()
      }
    }
  })
}

function y4(e, t = 200, n = {}) {
  return MT(OT(t, n), e)
}

function RT(e, t) {
  DT() && Xc(e, t)
}

function NT(e, t, n = {}) {
  const {
    immediate: r = !0
  } = n, s = U(!1);
  let a = null;

  function o() {
    a && (clearTimeout(a), a = null)
  }

  function i() {
    s.value = !1, o()
  }

  function l(...c) {
    o(), s.value = !0, a = setTimeout(() => {
      s.value = !1, a = null, e(...c)
    }, Ks(t))
  }
  return r && (s.value = !0, sa && l()), bu(i), {
    isPending: Ui(s),
    start: l,
    stop: i
  }
}

function FT(e = 1e3, t = {}) {
  const {
    controls: n = !1,
    callback: r
  } = t, s = NT(r ?? Hf, e, t), a = L(() => !s.isPending.value);
  return n ? {
    ready: a,
    ...s
  } : a
}

function BT(e, t, n) {
  const r = Ne(e, (...s) => (Ot(() => r()), t(...s)), n);
  return r
}

function Xr(e) {
  var t;
  const n = Ks(e);
  return (t = n == null ? void 0 : n.$el) != null ? t : n
}
const ad = sa ? window : void 0;

function b4(...e) {
  let t, n, r, s;
  if (typeof e[0] == "string" || Array.isArray(e[0]) ? ([n, r, s] = e, t = ad) : [t, n, r, s] = e, !t) return Hf;
  Array.isArray(n) || (n = [n]), Array.isArray(r) || (r = [r]);
  const a = [],
    o = () => {
      a.forEach(d => d()), a.length = 0
    },
    i = (d, f, p, h) => (d.addEventListener(f, p, h), () => d.removeEventListener(f, p, h)),
    l = Ne(() => [Xr(t), Ks(s)], ([d, f]) => {
      if (o(), !d) return;
      const p = IT(f) ? {
        ...f
      } : f;
      a.push(...n.flatMap(h => r.map(_ => i(d, h, _, p))))
    }, {
      immediate: !0,
      flush: "post"
    }),
    c = () => {
      l(), o()
    };
  return bu(c), c
}

function jT(e) {
  return typeof e == "function" ? e : typeof e == "string" ? t => t.key === e : Array.isArray(e) ? t => e.includes(t.key) : () => !0
}

function Y0(...e) {
  let t, n, r = {};
  e.length === 3 ? (t = e[0], n = e[1], r = e[2]) : e.length === 2 ? typeof e[1] == "object" ? (t = !0, n = e[0], r = e[1]) : (t = e[0], n = e[1]) : (t = !0, n = e[0]);
  const {
    target: s = ad,
    eventName: a = "keydown",
    passive: o = !1,
    dedupe: i = !1
  } = r, l = jT(t);
  return b4(s, a, c => {
    c.repeat && Ks(i) || l(c) && n(c)
  }, o)
}

function w4() {
  const e = U(!1),
    t = gr();
  return t && Ge(() => {
    e.value = !0
  }, t), e
}

function HT(e) {
  const t = w4();
  return L(() => (t.value, !!e()))
}

function C4(e, t = {}) {
  const {
    immediate: n = !0,
    fpsLimit: r = void 0,
    window: s = ad
  } = t, a = U(!1), o = r ? 1e3 / r : null;
  let i = 0,
    l = null;

  function c(p) {
    if (!a.value || !s) return;
    i || (i = p);
    const h = p - i;
    if (o && h < o) {
      l = s.requestAnimationFrame(c);
      return
    }
    i = p, e({
      delta: h,
      timestamp: p
    }), l = s.requestAnimationFrame(c)
  }

  function d() {
    !a.value && s && (a.value = !0, i = 0, l = s.requestAnimationFrame(c))
  }

  function f() {
    a.value = !1, l != null && s && (s.cancelAnimationFrame(l), l = null)
  }
  return n && d(), bu(f), {
    isActive: Ui(a),
    pause: f,
    resume: d
  }
}

function VT(e) {
  return JSON.parse(JSON.stringify(e))
}

function Vf(e, t, n = {}) {
  const {
    window: r = ad,
    ...s
  } = n;
  let a;
  const o = HT(() => r && "ResizeObserver" in r),
    i = () => {
      a && (a.disconnect(), a = void 0)
    },
    l = L(() => Array.isArray(e) ? e.map(f => Xr(f)) : [Xr(e)]),
    c = Ne(l, f => {
      if (i(), o.value && r) {
        a = new ResizeObserver(t);
        for (const p of f) p && a.observe(p, s)
      }
    }, {
      immediate: !0,
      flush: "post"
    }),
    d = () => {
      i(), c()
    };
  return bu(d), {
    isSupported: o,
    stop: d
  }
}

function Uf(e, t, n, r = {}) {
  var s, a, o;
  const {
    clone: i = !1,
    passive: l = !1,
    eventName: c,
    deep: d = !1,
    defaultValue: f,
    shouldEmit: p
  } = r, h = gr(), _ = n || (h == null ? void 0 : h.emit) || ((s = h == null ? void 0 : h.$emit) == null ? void 0 : s.bind(h)) || ((o = (a = h == null ? void 0 : h.proxy) == null ? void 0 : a.$emit) == null ? void 0 : o.bind(h == null ? void 0 : h.proxy));
  let v = c;
  t || (t = "modelValue"), v = v || `update:${t.toString()}`;
  const C = w => i ? typeof i == "function" ? i(w) : VT(w) : w,
    y = () => AT(e[t]) ? C(e[t]) : f,
    b = w => {
      p ? p(w) && _(v, w) : _(v, w)
    };
  if (l) {
    const w = y(),
      x = U(w);
    let E = !1;
    return Ne(() => e[t], S => {
      E || (E = !0, x.value = C(S), Ot(() => E = !1))
    }), Ne(x, S => {
      !E && (S !== e[t] || d) && b(S)
    }, {
      deep: d
    }), x
  } else return L({
    get() {
      return y()
    },
    set(w) {
      b(w)
    }
  })
}

function Ip(e) {
  return e ? e.flatMap(t => t.type === Ee ? Ip(t.children) : [t]) : []
}

function Ar() {
  let e = document.activeElement;
  if (e == null) return null;
  for (; e != null && e.shadowRoot != null && e.shadowRoot.activeElement != null;) e = e.shadowRoot.activeElement;
  return e
}

function I1(e) {
  if (e === null || typeof e != "object") return !1;
  const t = Object.getPrototypeOf(e);
  return t !== null && t !== Object.prototype && Object.getPrototypeOf(t) !== null || Symbol.iterator in e ? !1 : Symbol.toStringTag in e ? Object.prototype.toString.call(e) === "[object Module]" : !0
}

function im(e, t, n = ".", r) {
  if (!I1(t)) return im(e, {}, n);
  const s = Object.assign({}, t);
  for (const a in e) {
    if (a === "__proto__" || a === "constructor") continue;
    const o = e[a];
    o != null && (Array.isArray(o) && Array.isArray(s[a]) ? s[a] = [...o, ...s[a]] : I1(o) && I1(s[a]) ? s[a] = im(o, s[a], (n ? `${n}.` : "") + a.toString()) : s[a] = o)
  }
  return s
}

function UT(e) {
  return (...t) => t.reduce((n, r) => im(n, r, ""), {})
}
const zT = UT(),
  [$p, Jre] = Or("ConfigProvider");
let YT = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict",
  WT = (e = 21) => {
    let t = "",
      n = e;
    for (; n--;) t += YT[Math.random() * 64 | 0];
    return t
  };
const GT = TT(() => {
  const e = U(new Map),
    t = U(),
    n = L(() => {
      for (const o of e.value.values())
        if (o) return !0;
      return !1
    }),
    r = $p({
      scrollBody: U(!0)
    });
  let s = null;
  const a = () => {
    document.body.style.paddingRight = "", document.body.style.marginRight = "", document.body.style.pointerEvents = "", document.body.style.removeProperty("--scrollbar-width"), document.body.style.overflow = t.value ?? "", o_ && (s == null || s()), t.value = void 0
  };
  return Ne(n, (o, i) => {
    var l;
    if (!sa) return;
    if (!o) {
      i && a();
      return
    }
    t.value === void 0 && (t.value = document.body.style.overflow);
    const c = window.innerWidth - document.documentElement.clientWidth,
      d = {
        padding: c,
        margin: 0
      },
      f = (l = r.scrollBody) != null && l.value ? typeof r.scrollBody.value == "object" ? zT({
        padding: r.scrollBody.value.padding === !0 ? c : r.scrollBody.value.padding,
        margin: r.scrollBody.value.margin === !0 ? c : r.scrollBody.value.margin
      }, d) : d : {
        padding: 0,
        margin: 0
      };
    c > 0 && (document.body.style.paddingRight = typeof f.padding == "number" ? `${f.padding}px` : String(f.padding), document.body.style.marginRight = typeof f.margin == "number" ? `${f.margin}px` : String(f.margin), document.body.style.setProperty("--scrollbar-width", `${c}px`), document.body.style.overflow = "hidden"), o_ && (s = b4(document, "touchmove", p => QT(p), {
      passive: !1
    })), Ot(() => {
      document.body.style.pointerEvents = "none", document.body.style.overflow = "hidden"
    })
  }, {
    immediate: !0,
    flush: "sync"
  }), e
});

function x4(e) {
  const t = WT(6),
    n = GT();
  n.value.set(t, e ?? !1);
  const r = L({
    get: () => n.value.get(t) ?? !1,
    set: s => n.value.set(t, s)
  });
  return RT(() => {
    n.value.delete(t)
  }), r
}

function k4(e) {
  const t = window.getComputedStyle(e);
  if (t.overflowX === "scroll" || t.overflowY === "scroll" || t.overflowX === "auto" && e.clientWidth < e.scrollWidth || t.overflowY === "auto" && e.clientHeight < e.scrollHeight) return !0;
  {
    const n = e.parentNode;
    return !(n instanceof Element) || n.tagName === "BODY" ? !1 : k4(n)
  }
}

function QT(e) {
  const t = e || window.event,
    n = t.target;
  return n instanceof Element && k4(n) ? !1 : t.touches.length > 1 ? !0 : (t.preventDefault && t.cancelable && t.preventDefault(), !1)
}
const qT = "data-radix-vue-collection-item";

function od(e, t = qT) {
  const n = Symbol();
  return {
    createCollection: r => {
      const s = U([]);

      function a() {
        const o = Xr(r);
        return o ? s.value = Array.from(o.querySelectorAll(`[${t}]:not([data-disabled])`)) : s.value = []
      }
      return f0(() => {
        s.value = []
      }), Ge(a), b5(a), Ne(() => r == null ? void 0 : r.value, a, {
        immediate: !0
      }), xi(n, s), s
    },
    injectCollection: () => Hn(n, U([]))
  }
}

function S4(e) {
  const t = $p({
    dir: U("ltr")
  });
  return L(() => {
    var n;
    return (e == null ? void 0 : e.value) || ((n = t.dir) == null ? void 0 : n.value) || "ltr"
  })
}

function KT(e) {
  const t = gr(),
    n = t == null ? void 0 : t.type.emits,
    r = {};
  return n != null && n.length || console.warn(`No emitted event found. Please check component: ${t==null?void 0:t.type.__name}`), n == null || n.forEach(s => {
    r[nf(dr(s))] = (...a) => e(s, ...a)
  }), r
}
let $1 = 0;

function E4() {
  gn(e => {
    if (!sa) return;
    const t = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", t[0] ?? i_()), document.body.insertAdjacentElement("beforeend", t[1] ?? i_()), $1++, e(() => {
      $1 === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(n => n.remove()), $1--
    })
  })
}

function i_() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e
}

function ZT(e) {
  return L(() => {
    var t;
    return Ks(e) ? !!((t = Xr(e)) != null && t.closest("form")) : !0
  })
}

function Ko(e) {
  const t = gr(),
    n = Object.keys((t == null ? void 0 : t.type.props) ?? {}).reduce((s, a) => {
      const o = (t == null ? void 0 : t.type.props[a]).default;
      return o !== void 0 && (s[a] = o), s
    }, {}),
    r = zl(e);
  return L(() => {
    const s = {},
      a = (t == null ? void 0 : t.vnode.props) ?? {};
    return Object.keys(a).forEach(o => {
      s[dr(o)] = a[o]
    }), Object.keys({
      ...n,
      ...s
    }).reduce((o, i) => (r.value[i] !== void 0 && (o[i] = r.value[i]), o), {})
  })
}

function Ga(e, t) {
  const n = Ko(e),
    r = t ? KT(t) : {};
  return L(() => ({
    ...n.value,
    ...r
  }))
}

function dt() {
  const e = gr(),
    t = U(),
    n = L(() => {
      var o, i;
      return ["#text", "#comment"].includes((o = t.value) == null ? void 0 : o.$el.nodeName) ? (i = t.value) == null ? void 0 : i.$el.nextElementSibling : Xr(t)
    }),
    r = Object.assign({}, e.exposed),
    s = {};
  for (const o in e.props) Object.defineProperty(s, o, {
    enumerable: !0,
    configurable: !0,
    get: () => e.props[o]
  });
  if (Object.keys(r).length > 0)
    for (const o in r) Object.defineProperty(s, o, {
      enumerable: !0,
      configurable: !0,
      get: () => r[o]
    });
  Object.defineProperty(s, "$el", {
    enumerable: !0,
    configurable: !0,
    get: () => e.vnode.el
  }), e.exposed = s;

  function a(o) {
    t.value = o, o && (Object.defineProperty(s, "$el", {
      enumerable: !0,
      configurable: !0,
      get: () => o instanceof Element ? o : o.$el
    }), e.exposed = s)
  }
  return {
    forwardRef: a,
    currentRef: t,
    currentElement: n
  }
}
var JT = function(e) {
    if (typeof document > "u") return null;
    var t = Array.isArray(e) ? e[0] : e;
    return t.ownerDocument.body
  },
  rl = new WeakMap,
  Fd = new WeakMap,
  Bd = {},
  M1 = 0,
  T4 = function(e) {
    return e && (e.host || T4(e.parentNode))
  },
  XT = function(e, t) {
    return t.map(function(n) {
      if (e.contains(n)) return n;
      var r = T4(n);
      return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null)
    }).filter(function(n) {
      return !!n
    })
  },
  eA = function(e, t, n, r) {
    var s = XT(t, Array.isArray(e) ? e : [e]);
    Bd[n] || (Bd[n] = new WeakMap);
    var a = Bd[n],
      o = [],
      i = new Set,
      l = new Set(s),
      c = function(f) {
        !f || i.has(f) || (i.add(f), c(f.parentNode))
      };
    s.forEach(c);
    var d = function(f) {
      !f || l.has(f) || Array.prototype.forEach.call(f.children, function(p) {
        if (i.has(p)) d(p);
        else try {
          var h = p.getAttribute(r),
            _ = h !== null && h !== "false",
            v = (rl.get(p) || 0) + 1,
            C = (a.get(p) || 0) + 1;
          rl.set(p, v), a.set(p, C), o.push(p), v === 1 && _ && Fd.set(p, !0), C === 1 && p.setAttribute(n, "true"), _ || p.setAttribute(r, "true")
        } catch (y) {
          console.error("aria-hidden: cannot operate on ", p, y)
        }
      })
    };
    return d(t), i.clear(), M1++,
      function() {
        o.forEach(function(f) {
          var p = rl.get(f) - 1,
            h = a.get(f) - 1;
          rl.set(f, p), a.set(f, h), p || (Fd.has(f) || f.removeAttribute(r), Fd.delete(f)), h || f.removeAttribute(n)
        }), M1--, M1 || (rl = new WeakMap, rl = new WeakMap, Fd = new WeakMap, Bd = {})
      }
  },
  tA = function(e, t, n) {
    n === void 0 && (n = "data-aria-hidden");
    var r = Array.from(Array.isArray(e) ? e : [e]),
      s = JT(e);
    return s ? (r.push.apply(r, Array.from(s.querySelectorAll("[aria-live]"))), eA(r, s, n, "aria-hidden")) : function() {
      return null
    }
  };

function A4(e) {
  let t;
  Ne(() => Xr(e), n => {
    n ? t = tA(n) : t && t()
  }), en(() => {
    t && t()
  })
}
let nA = 0;

function W0(e, t = "radix") {
  const n = $p({
    useId: void 0
  });
  return c2 ? `${t}-${c2()}` : n.useId ? `${t}-${n.useId()}` : `${t}-${++nA}`
}

function rA(e) {
  const t = U(),
    n = L(() => {
      var s;
      return ((s = t.value) == null ? void 0 : s.width) ?? 0
    }),
    r = L(() => {
      var s;
      return ((s = t.value) == null ? void 0 : s.height) ?? 0
    });
  return Ge(() => {
    const s = Xr(e);
    if (s) {
      t.value = {
        width: s.offsetWidth,
        height: s.offsetHeight
      };
      const a = new ResizeObserver(o => {
        if (!Array.isArray(o) || !o.length) return;
        const i = o[0];
        let l, c;
        if ("borderBoxSize" in i) {
          const d = i.borderBoxSize,
            f = Array.isArray(d) ? d[0] : d;
          l = f.inlineSize, c = f.blockSize
        } else l = s.offsetWidth, c = s.offsetHeight;
        t.value = {
          width: l,
          height: c
        }
      });
      return a.observe(s, {
        box: "border-box"
      }), () => a.unobserve(s)
    } else t.value = void 0
  }), {
    width: n,
    height: r
  }
}

function P4(e, t) {
  const n = U(e);

  function r(s) {
    return t[n.value][s] ?? n.value
  }
  return {
    state: n,
    dispatch: s => {
      n.value = r(s)
    }
  }
}
const sA = "data-item-text";

function I4(e) {
  const t = LT("", 1e3);
  return {
    search: t,
    handleTypeaheadSearch: (n, r) => {
      if (!(e != null && e.value) && !r) return;
      t.value = t.value + n;
      const s = (e == null ? void 0 : e.value) ?? r,
        a = Ar(),
        o = s.map(f => {
          var p;
          return {
            ref: f,
            textValue: ((p = (f.querySelector(`[${sA}]`) ?? f).textContent) == null ? void 0 : p.trim()) ?? ""
          }
        }),
        i = o.find(f => f.ref === a),
        l = o.map(f => f.textValue),
        c = oA(l, t.value, i == null ? void 0 : i.textValue),
        d = o.find(f => f.textValue === c);
      return d && d.ref.focus(), d == null ? void 0 : d.ref
    },
    resetTypeahead: () => {
      t.value = ""
    }
  }
}

function aA(e, t) {
  return e.map((n, r) => e[(t + r) % e.length])
}

function oA(e, t, n) {
  const r = t.length > 1 && Array.from(t).every(i => i === t[0]) ? t[0] : t,
    s = n ? e.indexOf(n) : -1;
  let a = aA(e, Math.max(s, 0));
  r.length === 1 && (a = a.filter(i => i !== n));
  const o = a.find(i => i.toLowerCase().startsWith(r.toLowerCase()));
  return o !== n ? o : void 0
}
const iA = te({
    name: "PrimitiveSlot",
    inheritAttrs: !1,
    setup(e, {
      attrs: t,
      slots: n
    }) {
      return () => {
        var r, s;
        if (!n.default) return null;
        const a = Ip(n.default()),
          o = a.findIndex(d => d.type !== Fn);
        if (o === -1) return a;
        const i = a[o];
        (r = i.props) == null || delete r.ref;
        const l = i.props ? Le(t, i.props) : t;
        t.class && (s = i.props) != null && s.class && delete i.props.class;
        const c = Ra(i, l);
        for (const d in l) d.startsWith("on") && (c.props || (c.props = {}), c.props[d] = l[d]);
        return a.length === 1 ? c : (a[o] = c, a)
      }
    }
  }),
  xt = te({
    name: "Primitive",
    inheritAttrs: !1,
    props: {
      asChild: {
        type: Boolean,
        default: !1
      },
      as: {
        type: [String, Object],
        default: "div"
      }
    },
    setup(e, {
      attrs: t,
      slots: n
    }) {
      const r = e.asChild ? "template" : e.as;
      return typeof r == "string" && ["area", "img", "input"].includes(r) ? () => yn(r, t) : r !== "template" ? () => yn(e.as, t, {
        default: n.default
      }) : () => yn(iA, t, {
        default: n.default
      })
    }
  });

function lA(e, t) {
  var n;
  const r = U({}),
    s = U("none"),
    a = U(e),
    o = e.value ? "mounted" : "unmounted";
  let i;
  const l = ((n = t.value) == null ? void 0 : n.ownerDocument.defaultView) ?? ad,
    {
      state: c,
      dispatch: d
    } = P4(o, {
      mounted: {
        UNMOUNT: "unmounted",
        ANIMATION_OUT: "unmountSuspended"
      },
      unmountSuspended: {
        MOUNT: "mounted",
        ANIMATION_END: "unmounted"
      },
      unmounted: {
        MOUNT: "mounted"
      }
    }),
    f = C => {
      var y;
      if (sa) {
        const b = new CustomEvent(C, {
          bubbles: !1,
          cancelable: !1
        });
        (y = t.value) == null || y.dispatchEvent(b)
      }
    };
  Ne(e, async (C, y) => {
    var b;
    const w = y !== C;
    if (await Ot(), w) {
      const x = s.value,
        E = jd(t.value);
      C ? (d("MOUNT"), f("enter"), E === "none" && f("after-enter")) : E === "none" || ((b = r.value) == null ? void 0 : b.display) === "none" ? (d("UNMOUNT"), f("leave"), f("after-leave")) : y && x !== E ? (d("ANIMATION_OUT"), f("leave")) : (d("UNMOUNT"), f("after-leave"))
    }
  }, {
    immediate: !0
  });
  const p = C => {
      const y = jd(t.value),
        b = y.includes(C.animationName),
        w = c.value === "mounted" ? "enter" : "leave";
      if (C.target === t.value && b && (f(`after-${w}`), d("ANIMATION_END"), !a.value)) {
        const x = t.value.style.animationFillMode;
        t.value.style.animationFillMode = "forwards", i = l == null ? void 0 : l.setTimeout(() => {
          var E;
          ((E = t.value) == null ? void 0 : E.style.animationFillMode) === "forwards" && (t.value.style.animationFillMode = x)
        })
      }
      C.target === t.value && y === "none" && d("ANIMATION_END")
    },
    h = C => {
      C.target === t.value && (s.value = jd(t.value))
    },
    _ = Ne(t, (C, y) => {
      C ? (r.value = getComputedStyle(C), C.addEventListener("animationstart", h), C.addEventListener("animationcancel", p), C.addEventListener("animationend", p)) : (d("ANIMATION_END"), i !== void 0 && (l == null || l.clearTimeout(i)), y == null || y.removeEventListener("animationstart", h), y == null || y.removeEventListener("animationcancel", p), y == null || y.removeEventListener("animationend", p))
    }, {
      immediate: !0
    }),
    v = Ne(c, () => {
      const C = jd(t.value);
      s.value = c.value === "mounted" ? C : "none"
    });
  return en(() => {
    _(), v()
  }), {
    isPresent: L(() => ["mounted", "unmountSuspended"].includes(c.value))
  }
}

function jd(e) {
  return e && getComputedStyle(e).animationName || "none"
}
const wu = te({
    name: "Presence",
    props: {
      present: {
        type: Boolean,
        required: !0
      },
      forceMount: {
        type: Boolean
      }
    },
    slots: {},
    setup(e, {
      slots: t,
      expose: n
    }) {
      var r;
      const {
        present: s,
        forceMount: a
      } = Hr(e), o = U(), {
        isPresent: i
      } = lA(s, o);
      n({
        present: i
      });
      let l = t.default({
        present: i
      });
      l = Ip(l || []);
      const c = gr();
      if (l && (l == null ? void 0 : l.length) > 1) {
        const d = (r = c == null ? void 0 : c.parent) != null && r.type.name ? `<${c.parent.type.name} />` : "component";
        throw new Error([`Detected an invalid children for \`${d}\` for  \`Presence\` component.`, "", "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.", "You can apply a few solutions:", ["Provide a single child element so that `presence` directive attach correctly.", "Ensure the first child is an actual element instead of a raw text node or comment node."].map(f => `  - ${f}`).join(`
`)].join(`
`))
      }
      return () => a.value || s.value || i.value ? yn(t.default({
        present: i
      })[0], {
        ref: d => {
          const f = Xr(d);
          return typeof(f == null ? void 0 : f.hasAttribute) > "u" || (f != null && f.hasAttribute("data-radix-popper-content-wrapper") ? o.value = f.firstElementChild : o.value = f), f
        }
      }) : null
    }
  }),
  uA = te({
    __name: "Teleport",
    props: {
      to: {
        default: "body"
      },
      disabled: {
        type: Boolean
      },
      forceMount: {
        type: Boolean
      }
    },
    setup(e) {
      const t = w4();
      return (n, r) => u(t) || n.forceMount ? (g(), G(Jc, {
        key: 0,
        to: n.to,
        disabled: n.disabled
      }, [ie(n.$slots, "default")], 8, ["to", "disabled"])) : z("", !0)
    }
  }),
  cA = "dismissableLayer.pointerDownOutside",
  dA = "dismissableLayer.focusOutside";

function $4(e, t) {
  const n = t.closest("[data-dismissable-layer]"),
    r = e.dataset.dismissableLayer === "" ? e : e.querySelector("[data-dismissable-layer]"),
    s = Array.from(e.ownerDocument.querySelectorAll("[data-dismissable-layer]"));
  return !!(n && r === n || s.indexOf(r) < s.indexOf(n))
}

function fA(e, t) {
  var n;
  const r = ((n = t == null ? void 0 : t.value) == null ? void 0 : n.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document),
    s = U(!1),
    a = U(() => {});
  return gn(o => {
    if (!sa) return;
    const i = async c => {
      const d = c.target;
      if (t != null && t.value) {
        if ($4(t.value, d)) {
          s.value = !1;
          return
        }
        if (c.target && !s.value) {
          let f = function() {
            _4(cA, e, p)
          };
          const p = {
            originalEvent: c
          };
          c.pointerType === "touch" ? (r.removeEventListener("click", a.value), a.value = f, r.addEventListener("click", a.value, {
            once: !0
          })) : f()
        } else r.removeEventListener("click", a.value);
        s.value = !1
      }
    }, l = window.setTimeout(() => {
      r.addEventListener("pointerdown", i)
    }, 0);
    o(() => {
      window.clearTimeout(l), r.removeEventListener("pointerdown", i), r.removeEventListener("click", a.value)
    })
  }), {
    onPointerDownCapture: () => s.value = !0
  }
}

function pA(e, t) {
  var n;
  const r = ((n = t == null ? void 0 : t.value) == null ? void 0 : n.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document),
    s = U(!1);
  return gn(a => {
    if (!sa) return;
    const o = async i => {
      t != null && t.value && (await Ot(), !(!t.value || $4(t.value, i.target)) && i.target && !s.value && _4(dA, e, {
        originalEvent: i
      }))
    };
    r.addEventListener("focusin", o), a(() => r.removeEventListener("focusin", o))
  }), {
    onFocusCapture: () => s.value = !0,
    onBlurCapture: () => s.value = !1
  }
}
const ls = xn({
    layersRoot: new Set,
    layersWithOutsidePointerEventsDisabled: new Set,
    branches: new Set
  }),
  M4 = te({
    __name: "DismissableLayer",
    props: {
      disableOutsidePointerEvents: {
        type: Boolean,
        default: !1
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
    setup(e, {
      emit: t
    }) {
      const n = e,
        r = t,
        {
          forwardRef: s,
          currentElement: a
        } = dt(),
        o = L(() => {
          var _;
          return ((_ = a.value) == null ? void 0 : _.ownerDocument) ?? globalThis.document
        }),
        i = L(() => ls.layersRoot),
        l = L(() => a.value ? Array.from(i.value).indexOf(a.value) : -1),
        c = L(() => ls.layersWithOutsidePointerEventsDisabled.size > 0),
        d = L(() => {
          const _ = Array.from(i.value),
            [v] = [...ls.layersWithOutsidePointerEventsDisabled].slice(-1),
            C = _.indexOf(v);
          return l.value >= C
        }),
        f = fA(async _ => {
          const v = [...ls.branches].some(C => C == null ? void 0 : C.contains(_.target));
          !d.value || v || (r("pointerDownOutside", _), r("interactOutside", _), await Ot(), _.defaultPrevented || r("dismiss"))
        }, a),
        p = pA(_ => {
          [...ls.branches].some(v => v == null ? void 0 : v.contains(_.target)) || (r("focusOutside", _), r("interactOutside", _), _.defaultPrevented || r("dismiss"))
        }, a);
      Y0("Escape", _ => {
        l.value === i.value.size - 1 && (r("escapeKeyDown", _), _.defaultPrevented || r("dismiss"))
      });
      let h;
      return gn(_ => {
        a.value && (n.disableOutsidePointerEvents && (ls.layersWithOutsidePointerEventsDisabled.size === 0 && (h = o.value.body.style.pointerEvents, o.value.body.style.pointerEvents = "none"), ls.layersWithOutsidePointerEventsDisabled.add(a.value)), i.value.add(a.value), _(() => {
          n.disableOutsidePointerEvents && ls.layersWithOutsidePointerEventsDisabled.size === 1 && (o.value.body.style.pointerEvents = h)
        }))
      }), gn(_ => {
        _(() => {
          a.value && (i.value.delete(a.value), ls.layersWithOutsidePointerEventsDisabled.delete(a.value))
        })
      }), (_, v) => (g(), G(u(xt), {
        ref: u(s),
        "as-child": _.asChild,
        as: _.as,
        "data-dismissable-layer": "",
        style: Mt({
          pointerEvents: c.value ? d.value ? "auto" : "none" : void 0
        }),
        onFocusCapture: u(p).onFocusCapture,
        onBlurCapture: u(p).onBlurCapture,
        onPointerdownCapture: u(f).onPointerDownCapture
      }, {
        default: V(() => [ie(_.$slots, "default")]),
        _: 3
      }, 8, ["as-child", "as", "style", "onFocusCapture", "onBlurCapture", "onPointerdownCapture"]))
    }
  }),
  hA = te({
    __name: "DismissableLayerBranch",
    props: {
      asChild: {
        type: Boolean
      },
      as: {}
    },
    setup(e) {
      const t = e,
        {
          forwardRef: n,
          currentElement: r
        } = dt();
      return Ge(() => {
        ls.branches.add(r.value)
      }), en(() => {
        ls.branches.delete(r.value)
      }), (s, a) => (g(), G(u(xt), Le({
        ref: u(n)
      }, t), {
        default: V(() => [ie(s.$slots, "default")]),
        _: 3
      }, 16))
    }
  }),
  O1 = "focusScope.autoFocusOnMount",
  D1 = "focusScope.autoFocusOnUnmount",
  l_ = {
    bubbles: !1,
    cancelable: !0
  };

function df(e, {
  select: t = !1
} = {}) {
  const n = Ar();
  for (const r of e)
    if (io(r, {
        select: t
      }), Ar() !== n) return !0
}

function mA(e) {
  const t = G0(e),
    n = u_(t, e),
    r = u_(t.reverse(), e);
  return [n, r]
}

function G0(e) {
  const t = [],
    n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
      acceptNode: r => {
        const s = r.tagName === "INPUT" && r.type === "hidden";
        return r.disabled || r.hidden || s ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
      }
    });
  for (; n.nextNode();) t.push(n.currentNode);
  return t
}

function u_(e, t) {
  for (const n of e)
    if (!gA(n, {
        upTo: t
      })) return n
}

function gA(e, {
  upTo: t
}) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e;) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement
  }
  return !1
}

function vA(e) {
  return e instanceof HTMLInputElement && "select" in e
}

function io(e, {
  select: t = !1
} = {}) {
  if (e && e.focus) {
    const n = Ar();
    e.focus({
      preventScroll: !0
    }), e !== n && vA(e) && t && e.select()
  }
}
const _A = ET(() => U([]));

function yA() {
  const e = _A();
  return {
    add(t) {
      const n = e.value[0];
      t !== n && (n == null || n.pause()), e.value = c_(e.value, t), e.value.unshift(t)
    },
    remove(t) {
      var n;
      e.value = c_(e.value, t), (n = e.value[0]) == null || n.resume()
    }
  }
}

function c_(e, t) {
  const n = [...e],
    r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n
}

function bA(e) {
  return e.filter(t => t.tagName !== "A")
}
const O4 = te({
  __name: "FocusScope",
  props: {
    loop: {
      type: Boolean,
      default: !1
    },
    trapped: {
      type: Boolean,
      default: !1
    },
    asChild: {
      type: Boolean
    },
    as: {}
  },
  emits: ["mountAutoFocus", "unmountAutoFocus"],
  setup(e, {
    emit: t
  }) {
    const n = e,
      r = t,
      {
        currentRef: s,
        currentElement: a
      } = dt(),
      o = U(null),
      i = yA(),
      l = xn({
        paused: !1,
        pause() {
          this.paused = !0
        },
        resume() {
          this.paused = !1
        }
      });
    gn(d => {
      if (!sa) return;
      const f = a.value;
      if (!n.trapped) return;

      function p(C) {
        if (l.paused || !f) return;
        const y = C.target;
        f.contains(y) ? o.value = y : io(o.value, {
          select: !0
        })
      }

      function h(C) {
        if (l.paused || !f) return;
        const y = C.relatedTarget;
        y !== null && (f.contains(y) || io(o.value, {
          select: !0
        }))
      }

      function _(C) {
        f.contains(o.value) || io(f)
      }
      document.addEventListener("focusin", p), document.addEventListener("focusout", h);
      const v = new MutationObserver(_);
      f && v.observe(f, {
        childList: !0,
        subtree: !0
      }), d(() => {
        document.removeEventListener("focusin", p), document.removeEventListener("focusout", h), v.disconnect()
      })
    }), gn(async d => {
      const f = a.value;
      if (await Ot(), !f) return;
      i.add(l);
      const p = Ar();
      if (!f.contains(p)) {
        const h = new CustomEvent(O1, l_);
        f.addEventListener(O1, _ => r("mountAutoFocus", _)), f.dispatchEvent(h), h.defaultPrevented || (df(bA(G0(f)), {
          select: !0
        }), Ar() === p && io(f))
      }
      d(() => {
        f.removeEventListener(O1, v => r("mountAutoFocus", v));
        const h = new CustomEvent(D1, l_),
          _ = v => {
            r("unmountAutoFocus", v)
          };
        f.addEventListener(D1, _), f.dispatchEvent(h), setTimeout(() => {
          h.defaultPrevented || io(p ?? document.body, {
            select: !0
          }), f.removeEventListener(D1, _), i.remove(l)
        }, 0)
      })
    });

    function c(d) {
      if (!n.loop && !n.trapped || l.paused) return;
      const f = d.key === "Tab" && !d.altKey && !d.ctrlKey && !d.metaKey,
        p = Ar();
      if (f && p) {
        const h = d.currentTarget,
          [_, v] = mA(h);
        _ && v ? !d.shiftKey && p === v ? (d.preventDefault(), n.loop && io(_, {
          select: !0
        })) : d.shiftKey && p === _ && (d.preventDefault(), n.loop && io(v, {
          select: !0
        })) : p === h && d.preventDefault()
      }
    }
    return (d, f) => (g(), G(u(xt), {
      ref_key: "currentRef",
      ref: s,
      tabindex: "-1",
      "as-child": d.asChild,
      as: d.as,
      onKeydown: c
    }, {
      default: V(() => [ie(d.$slots, "default")]),
      _: 3
    }, 8, ["as-child", "as"]))
  }
});

function d_(e) {
  const t = Ar();
  for (const n of e)
    if (n === t || (n.focus(), Ar() !== t)) return
}
const [D4, wA] = Or("PopperRoot"), L4 = te({
  inheritAttrs: !1,
  __name: "PopperRoot",
  setup(e) {
    const t = U();
    return wA({
      anchor: t,
      onAnchorChange: n => t.value = n
    }), (n, r) => ie(n.$slots, "default")
  }
}), Q0 = te({
  __name: "PopperAnchor",
  props: {
    element: {},
    asChild: {
      type: Boolean
    },
    as: {}
  },
  setup(e) {
    const t = e,
      {
        forwardRef: n,
        currentElement: r
      } = dt(),
      s = D4();
    return gn(() => {
      s.onAnchorChange(t.element ?? r.value)
    }), (a, o) => (g(), G(u(xt), {
      ref: u(n),
      as: a.as,
      "as-child": a.asChild
    }, {
      default: V(() => [ie(a.$slots, "default")]),
      _: 3
    }, 8, ["as", "as-child"]))
  }
});

function CA(e) {
  return e !== null
}

function xA(e) {
  return {
    name: "transformOrigin",
    options: e,
    fn(t) {
      var n, r, s;
      const {
        placement: a,
        rects: o,
        middlewareData: i
      } = t, l = ((n = i.arrow) == null ? void 0 : n.centerOffset) !== 0, c = l ? 0 : e.arrowWidth, d = l ? 0 : e.arrowHeight, [f, p] = lm(a), h = {
        start: "0%",
        center: "50%",
        end: "100%"
      } [p], _ = (((r = i.arrow) == null ? void 0 : r.x) ?? 0) + c / 2, v = (((s = i.arrow) == null ? void 0 : s.y) ?? 0) + d / 2;
      let C = "",
        y = "";
      return f === "bottom" ? (C = l ? h : `${_}px`, y = `${-d}px`) : f === "top" ? (C = l ? h : `${_}px`, y = `${o.floating.height+d}px`) : f === "right" ? (C = `${-d}px`, y = l ? h : `${v}px`) : f === "left" && (C = `${o.floating.width+d}px`, y = l ? h : `${v}px`), {
        data: {
          x: C,
          y
        }
      }
    }
  }
}

function lm(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n]
}
const kA = {
    side: "bottom",
    sideOffset: 0,
    align: "center",
    alignOffset: 0,
    arrowPadding: 0,
    avoidCollisions: !0,
    collisionBoundary: () => [],
    collisionPadding: 0,
    sticky: "partial",
    hideWhenDetached: !1,
    updatePositionStrategy: "optimized",
    prioritizePosition: !1
  },
  [SA, EA] = Or("PopperContent"),
  R4 = te({
    inheritAttrs: !1,
    __name: "PopperContent",
    props: Z6({
      side: {},
      sideOffset: {},
      align: {},
      alignOffset: {},
      avoidCollisions: {
        type: Boolean
      },
      collisionBoundary: {},
      collisionPadding: {},
      arrowPadding: {},
      sticky: {},
      hideWhenDetached: {
        type: Boolean
      },
      updatePositionStrategy: {},
      prioritizePosition: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    }, {
      ...kA
    }),
    emits: ["placed"],
    setup(e, {
      emit: t
    }) {
      const n = e,
        r = t,
        s = D4(),
        {
          forwardRef: a,
          currentElement: o
        } = dt(),
        i = U(),
        l = U(),
        {
          width: c,
          height: d
        } = rA(l),
        f = L(() => n.side + (n.align !== "center" ? `-${n.align}` : "")),
        p = L(() => typeof n.collisionPadding == "number" ? n.collisionPadding : {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0,
          ...n.collisionPadding
        }),
        h = L(() => Array.isArray(n.collisionBoundary) ? n.collisionBoundary : [n.collisionBoundary]),
        _ = L(() => ({
          padding: p.value,
          boundary: h.value.filter(CA),
          altBoundary: h.value.length > 0
        })),
        v = ST(() => [hT({
          mainAxis: n.sideOffset + d.value,
          alignmentAxis: n.alignOffset
        }), n.prioritizePosition && n.avoidCollisions && s_({
          ..._.value
        }), n.avoidCollisions && mT({
          mainAxis: !0,
          crossAxis: !!n.prioritizePosition,
          limiter: n.sticky === "partial" ? yT() : void 0,
          ..._.value
        }), !n.prioritizePosition && n.avoidCollisions && s_({
          ..._.value
        }), gT({
          ..._.value,
          apply: ({
            elements: N,
            rects: ne,
            availableWidth: Y,
            availableHeight: _e
          }) => {
            const {
              width: Q,
              height: re
            } = ne.reference, J = N.floating.style;
            J.setProperty("--radix-popper-available-width", `${Y}px`), J.setProperty("--radix-popper-available-height", `${_e}px`), J.setProperty("--radix-popper-anchor-width", `${Q}px`), J.setProperty("--radix-popper-anchor-height", `${re}px`)
          }
        }), l.value && CT({
          element: l.value,
          padding: n.arrowPadding
        }), xA({
          arrowWidth: c.value,
          arrowHeight: d.value
        }), n.hideWhenDetached && vT({
          strategy: "referenceHidden",
          ..._.value
        })]),
        {
          floatingStyles: C,
          placement: y,
          isPositioned: b,
          middlewareData: w
        } = xT(s.anchor, i, {
          strategy: "fixed",
          placement: f,
          whileElementsMounted: (...N) => pT(...N, {
            animationFrame: n.updatePositionStrategy === "always"
          }),
          middleware: v
        }),
        x = L(() => lm(y.value)[0]),
        E = L(() => lm(y.value)[1]);
      yw(() => {
        b.value && r("placed")
      });
      const S = L(() => {
          var N;
          return ((N = w.value.arrow) == null ? void 0 : N.centerOffset) !== 0
        }),
        T = U("");
      gn(() => {
        o.value && (T.value = window.getComputedStyle(o.value).zIndex)
      });
      const j = L(() => {
          var N;
          return ((N = w.value.arrow) == null ? void 0 : N.x) ?? 0
        }),
        P = L(() => {
          var N;
          return ((N = w.value.arrow) == null ? void 0 : N.y) ?? 0
        });
      return EA({
        placedSide: x,
        onArrowChange: N => l.value = N,
        arrowX: j,
        arrowY: P,
        shouldHideArrow: S
      }), (N, ne) => {
        var Y, _e, Q;
        return g(), k("div", {
          ref_key: "floatingRef",
          ref: i,
          "data-radix-popper-content-wrapper": "",
          style: Mt({
            ...u(C),
            transform: u(b) ? u(C).transform : "translate(0, -200%)",
            minWidth: "max-content",
            zIndex: T.value,
            "--radix-popper-transform-origin": [(Y = u(w).transformOrigin) == null ? void 0 : Y.x, (_e = u(w).transformOrigin) == null ? void 0 : _e.y].join(" "),
            ...((Q = u(w).hide) == null ? void 0 : Q.referenceHidden) && {
              visibility: "hidden",
              pointerEvents: "none"
            }
          })
        }, [$(u(xt), Le({
          ref: u(a)
        }, N.$attrs, {
          "as-child": n.asChild,
          as: N.as,
          "data-side": x.value,
          "data-align": E.value,
          style: {
            animation: u(b) ? void 0 : "none"
          }
        }), {
          default: V(() => [ie(N.$slots, "default")]),
          _: 3
        }, 16, ["as-child", "as", "data-side", "data-align", "style"])], 4)
      }
    }
  }),
  TA = m("polygon", {
    points: "0,0 30,0 15,10"
  }, null, -1),
  AA = te({
    __name: "Arrow",
    props: {
      width: {
        default: 10
      },
      height: {
        default: 5
      },
      asChild: {
        type: Boolean
      },
      as: {
        default: "svg"
      }
    },
    setup(e) {
      const t = e;
      return dt(), (n, r) => (g(), G(u(xt), Le(t, {
        width: n.width,
        height: n.height,
        viewBox: n.asChild ? void 0 : "0 0 30 10",
        preserveAspectRatio: n.asChild ? void 0 : "none"
      }), {
        default: V(() => [ie(n.$slots, "default", {}, () => [TA])]),
        _: 3
      }, 16, ["width", "height", "viewBox", "preserveAspectRatio"]))
    }
  }),
  PA = {
    top: "bottom",
    right: "left",
    bottom: "top",
    left: "right"
  },
  IA = te({
    inheritAttrs: !1,
    __name: "PopperArrow",
    props: {
      width: {},
      height: {},
      asChild: {
        type: Boolean
      },
      as: {
        default: "svg"
      }
    },
    setup(e) {
      const {
        forwardRef: t
      } = dt(), n = SA(), r = L(() => PA[n.placedSide.value]);
      return (s, a) => {
        var o, i, l, c;
        return g(), k("span", {
          ref: d => {
            u(n).onArrowChange(d)
          },
          style: Mt({
            position: "absolute",
            left: (o = u(n).arrowX) != null && o.value ? `${(i=u(n).arrowX)==null?void 0:i.value}px` : void 0,
            top: (l = u(n).arrowY) != null && l.value ? `${(c=u(n).arrowY)==null?void 0:c.value}px` : void 0,
            [r.value]: 0,
            transformOrigin: {
              top: "",
              right: "0 0",
              bottom: "center 0",
              left: "100% 0"
            } [u(n).placedSide.value],
            transform: {
              top: "translateY(100%)",
              right: "translateY(50%) rotate(90deg) translateX(-50%)",
              bottom: "rotate(180deg)",
              left: "translateY(50%) rotate(-90deg) translateX(50%)"
            } [u(n).placedSide.value],
            visibility: u(n).shouldHideArrow.value ? "hidden" : void 0
          })
        }, [$(AA, Le(s.$attrs, {
          ref: u(t),
          style: {
            display: "block"
          },
          as: s.as,
          "as-child": s.asChild,
          width: s.width,
          height: s.height
        }), {
          default: V(() => [ie(s.$slots, "default")]),
          _: 3
        }, 16, ["as", "as-child", "width", "height"])], 4)
      }
    }
  }),
  q0 = te({
    __name: "VisuallyHidden",
    props: {
      asChild: {
        type: Boolean
      },
      as: {
        default: "span"
      }
    },
    setup(e) {
      return dt(), (t, n) => (g(), G(u(xt), {
        as: t.as,
        "as-child": t.asChild,
        style: {
          position: "absolute",
          border: 0,
          width: "1px",
          display: "inline-block",
          height: "1px",
          padding: 0,
          margin: "-1px",
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          wordWrap: "normal"
        }
      }, {
        default: V(() => [ie(t.$slots, "default")]),
        _: 3
      }, 8, ["as", "as-child"]))
    }
  });

function N4(e) {
  const t = $p({
    nonce: U()
  });
  return L(() => {
    var n;
    return (e == null ? void 0 : e.value) || ((n = t.nonce) == null ? void 0 : n.value)
  })
}
const [Cu, $A] = Or("PopoverRoot"), MA = te({
  __name: "PopoverRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      default: !1
    },
    open: {
      type: Boolean,
      default: void 0
    },
    modal: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["update:open"],
  setup(e, {
    emit: t
  }) {
    const n = e,
      r = t,
      {
        modal: s
      } = Hr(n),
      a = Uf(n, "open", r, {
        defaultValue: n.defaultOpen,
        passive: n.open === void 0
      }),
      o = U(),
      i = U(!1);
    return $A({
      contentId: "",
      modal: s,
      open: a,
      onOpenChange: l => {
        a.value = l
      },
      onOpenToggle: () => {
        a.value = !a.value
      },
      triggerElement: o,
      hasCustomAnchor: i
    }), (l, c) => (g(), G(u(L4), null, {
      default: V(() => [ie(l.$slots, "default", {
        open: u(a)
      })]),
      _: 3
    }))
  }
}), OA = te({
  __name: "PopoverTrigger",
  props: {
    asChild: {
      type: Boolean
    },
    as: {
      default: "button"
    }
  },
  setup(e) {
    const t = e,
      n = Cu(),
      {
        forwardRef: r,
        currentElement: s
      } = dt();
    return Ge(() => {
      n.triggerElement.value = s.value
    }), (a, o) => (g(), G(Kr(u(n).hasCustomAnchor.value ? u(xt) : u(Q0)), {
      "as-child": ""
    }, {
      default: V(() => [$(u(xt), {
        ref: u(r),
        type: a.as === "button" ? "button" : void 0,
        "aria-haspopup": "dialog",
        "aria-expanded": u(n).open.value,
        "aria-controls": u(n).contentId,
        "data-state": u(n).open.value ? "open" : "closed",
        as: a.as,
        "as-child": t.asChild,
        onClick: u(n).onOpenToggle
      }, {
        default: V(() => [ie(a.$slots, "default")]),
        _: 3
      }, 8, ["type", "aria-expanded", "aria-controls", "data-state", "as", "as-child", "onClick"])]),
      _: 3
    }))
  }
}), F4 = te({
  __name: "PopoverContentImpl",
  props: {
    trapFocus: {
      type: Boolean
    },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: {
      type: Boolean
    },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: {
      type: Boolean
    },
    updatePositionStrategy: {},
    prioritizePosition: {
      type: Boolean
    },
    asChild: {
      type: Boolean
    },
    as: {},
    disableOutsidePointerEvents: {
      type: Boolean
    }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, {
    emit: t
  }) {
    const n = e,
      r = t,
      s = Ko(n),
      {
        forwardRef: a
      } = dt(),
      o = Cu();
    return E4(), (i, l) => (g(), G(u(O4), {
      "as-child": "",
      loop: "",
      trapped: i.trapFocus,
      onMountAutoFocus: l[5] || (l[5] = c => r("openAutoFocus", c)),
      onUnmountAutoFocus: l[6] || (l[6] = c => r("closeAutoFocus", c))
    }, {
      default: V(() => [$(u(M4), {
        "as-child": "",
        "disable-outside-pointer-events": i.disableOutsidePointerEvents,
        onPointerDownOutside: l[0] || (l[0] = c => r("pointerDownOutside", c)),
        onInteractOutside: l[1] || (l[1] = c => r("interactOutside", c)),
        onEscapeKeyDown: l[2] || (l[2] = c => r("escapeKeyDown", c)),
        onFocusOutside: l[3] || (l[3] = c => r("focusOutside", c)),
        onDismiss: l[4] || (l[4] = c => u(o).onOpenChange(!1))
      }, {
        default: V(() => [$(u(R4), Le(u(s), {
          id: u(o).contentId,
          ref: u(a),
          "data-state": u(o).open.value ? "open" : "closed",
          role: "dialog",
          style: {
            "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
            "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
            "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }), {
          default: V(() => [ie(i.$slots, "default")]),
          _: 3
        }, 16, ["id", "data-state"])]),
        _: 3
      }, 8, ["disable-outside-pointer-events"])]),
      _: 3
    }, 8, ["trapped"]))
  }
}), DA = te({
  __name: "PopoverContentModal",
  props: {
    trapFocus: {
      type: Boolean
    },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: {
      type: Boolean
    },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: {
      type: Boolean
    },
    updatePositionStrategy: {},
    prioritizePosition: {
      type: Boolean
    },
    asChild: {
      type: Boolean
    },
    as: {},
    disableOutsidePointerEvents: {
      type: Boolean
    }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, {
    emit: t
  }) {
    const n = e,
      r = t,
      s = Cu(),
      a = U(!1);
    x4(!0);
    const o = Ga(n, r),
      {
        forwardRef: i,
        currentElement: l
      } = dt();
    return A4(l), (c, d) => (g(), G(F4, Le(u(o), {
      ref: u(i),
      "trap-focus": u(s).open.value,
      "disable-outside-pointer-events": "",
      onCloseAutoFocus: d[0] || (d[0] = Er(f => {
        var p;
        r("closeAutoFocus", f), a.value || (p = u(s).triggerElement.value) == null || p.focus()
      }, ["prevent"])),
      onPointerDownOutside: d[1] || (d[1] = f => {
        r("pointerDownOutside", f);
        const p = f.detail.originalEvent,
          h = p.button === 0 && p.ctrlKey === !0,
          _ = p.button === 2 || h;
        a.value = _
      }),
      onFocusOutside: d[2] || (d[2] = Er(() => {}, ["prevent"]))
    }), {
      default: V(() => [ie(c.$slots, "default")]),
      _: 3
    }, 16, ["trap-focus"]))
  }
}), LA = te({
  __name: "PopoverContentNonModal",
  props: {
    trapFocus: {
      type: Boolean
    },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: {
      type: Boolean
    },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: {
      type: Boolean
    },
    updatePositionStrategy: {},
    prioritizePosition: {
      type: Boolean
    },
    asChild: {
      type: Boolean
    },
    as: {},
    disableOutsidePointerEvents: {
      type: Boolean
    }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, {
    emit: t
  }) {
    const n = e,
      r = t,
      s = Cu(),
      a = U(!1),
      o = U(!1),
      i = Ga(n, r);
    return (l, c) => (g(), G(F4, Le(u(i), {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      onCloseAutoFocus: c[0] || (c[0] = d => {
        var f;
        r("closeAutoFocus", d), d.defaultPrevented || (a.value || (f = u(s).triggerElement.value) == null || f.focus(), d.preventDefault()), a.value = !1, o.value = !1
      }),
      onInteractOutside: c[1] || (c[1] = async d => {
        var f;
        r("interactOutside", d), d.defaultPrevented || (a.value = !0, d.detail.originalEvent.type === "pointerdown" && (o.value = !0));
        const p = d.target;
        (f = u(s).triggerElement.value) != null && f.contains(p) && d.preventDefault(), d.detail.originalEvent.type === "focusin" && o.value && d.preventDefault()
      })
    }), {
      default: V(() => [ie(l.$slots, "default")]),
      _: 3
    }, 16))
  }
}), RA = te({
  __name: "PopoverContent",
  props: {
    forceMount: {
      type: Boolean
    },
    trapFocus: {
      type: Boolean
    },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: {
      type: Boolean
    },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: {
      type: Boolean
    },
    updatePositionStrategy: {},
    prioritizePosition: {
      type: Boolean
    },
    asChild: {
      type: Boolean
    },
    as: {},
    disableOutsidePointerEvents: {
      type: Boolean
    }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, {
    emit: t
  }) {
    const n = e,
      r = t,
      s = Cu(),
      a = Ga(n, r),
      {
        forwardRef: o
      } = dt();
    return s.contentId || (s.contentId = W0(void 0, "radix-vue-popover-content")), (i, l) => (g(), G(u(wu), {
      present: i.forceMount || u(s).open.value
    }, {
      default: V(() => [u(s).modal.value ? (g(), G(DA, Le({
        key: 0
      }, u(a), {
        ref: u(o)
      }), {
        default: V(() => [ie(i.$slots, "default")]),
        _: 3
      }, 16)) : (g(), G(LA, Le({
        key: 1
      }, u(a), {
        ref: u(o)
      }), {
        default: V(() => [ie(i.$slots, "default")]),
        _: 3
      }, 16))]),
      _: 3
    }, 8, ["present"]))
  }
}), NA = te({
  __name: "PopoverArrow",
  props: {
    width: {
      default: 10
    },
    height: {
      default: 5
    },
    asChild: {
      type: Boolean
    },
    as: {
      default: "svg"
    }
  },
  setup(e) {
    const t = e;
    return dt(), (n, r) => (g(), G(u(IA), Nt(Qt(t)), {
      default: V(() => [ie(n.$slots, "default")]),
      _: 3
    }, 16))
  }
}), FA = te({
  __name: "PopoverAnchor",
  props: {
    element: {},
    asChild: {
      type: Boolean
    },
    as: {}
  },
  setup(e) {
    const t = e;
    dt();
    const n = Cu();
    return d0(() => {
      n.hasCustomAnchor.value = !0
    }), en(() => {
      n.hasCustomAnchor.value = !1
    }), (r, s) => (g(), G(u(Q0), Nt(Qt(t)), {
      default: V(() => [ie(r.$slots, "default")]),
      _: 3
    }, 16))
  }
}), [aa, BA] = Or("ScrollAreaRoot"), jA = te({
  __name: "ScrollAreaRoot",
  props: {
    type: {
      default: "hover"
    },
    dir: {},
    scrollHideDelay: {
      default: 600
    },
    asChild: {
      type: Boolean
    },
    as: {}
  },
  setup(e, {
    expose: t
  }) {
    const n = e,
      r = U(0),
      s = U(0),
      a = U(),
      o = U(),
      i = U(),
      l = U(),
      c = U(!1),
      d = U(!1),
      {
        type: f,
        dir: p,
        scrollHideDelay: h
      } = Hr(n),
      _ = S4(p);

    function v() {
      var w;
      (w = a.value) == null || w.scrollTo({
        top: 0
      })
    }

    function C() {
      var w;
      (w = a.value) == null || w.scrollTo({
        top: 0,
        left: 0
      })
    }
    t({
      viewport: a,
      scrollTop: v,
      scrollTopLeft: C
    });
    const {
      forwardRef: y,
      currentElement: b
    } = dt();
    return BA({
      type: f,
      dir: _,
      scrollHideDelay: h,
      scrollArea: b,
      viewport: a,
      onViewportChange: w => {
        a.value = w || void 0
      },
      content: o,
      onContentChange: w => {
        o.value = w
      },
      scrollbarX: i,
      scrollbarXEnabled: c,
      scrollbarY: l,
      scrollbarYEnabled: d,
      onScrollbarXChange: w => {
        i.value = w || void 0
      },
      onScrollbarYChange: w => {
        l.value = w || void 0
      },
      onScrollbarXEnabledChange: w => {
        c.value = w
      },
      onScrollbarYEnabledChange: w => {
        d.value = w
      },
      onCornerWidthChange: w => {
        r.value = w
      },
      onCornerHeightChange: w => {
        s.value = w
      }
    }), (w, x) => (g(), G(u(xt), {
      ref: u(y),
      "as-child": n.asChild,
      as: w.as,
      dir: u(_),
      style: Mt({
        position: "relative",
        "--radix-scroll-area-corner-width": `${r.value}px`,
        "--radix-scroll-area-corner-height": `${s.value}px`
      })
    }, {
      default: V(() => [ie(w.$slots, "default")]),
      _: 3
    }, 8, ["as-child", "as", "dir", "style"]))
  }
}), HA = te({
  inheritAttrs: !1,
  __name: "ScrollAreaViewport",
  props: {
    nonce: {},
    asChild: {
      type: Boolean
    },
    as: {}
  },
  setup(e, {
    expose: t
  }) {
    const n = e,
      {
        nonce: r
      } = Hr(n),
      s = N4(r),
      a = aa(),
      o = U();
    Ge(() => {
      a.onViewportChange(o.value), a.onContentChange(l.value)
    }), t({
      viewportElement: o
    });
    const {
      forwardRef: i,
      currentElement: l
    } = dt();
    return (c, d) => (g(), k(Ee, null, [m("div", Le({
      ref_key: "viewportElement",
      ref: o,
      "data-radix-scroll-area-viewport": "",
      style: {
        overflowX: u(a).scrollbarXEnabled.value ? "scroll" : "hidden",
        overflowY: u(a).scrollbarYEnabled.value ? "scroll" : "hidden"
      }
    }, c.$attrs, {
      tabindex: 0
    }), [$(u(xt), {
      ref: u(i),
      style: Mt({
        minWidth: u(a).scrollbarXEnabled.value ? "fit-content" : void 0
      }),
      "as-child": n.asChild,
      as: c.as
    }, {
      default: V(() => [ie(c.$slots, "default")]),
      _: 3
    }, 8, ["style", "as-child", "as"])], 16), $(u(xt), {
      as: "style",
      nonce: u(s)
    }, {
      default: V(() => [Ye(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-scroll-area-viewport] { scrollbar-width:none; -ms-overflow-style:none; -webkit-overflow-scrolling:touch; } [data-radix-scroll-area-viewport]::-webkit-scrollbar { display:none; } ")]),
      _: 1
    }, 8, ["nonce"])], 64))
  }
});

function B4(e, t) {
  return n => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const r = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + r * (n - e[0])
  }
}

function Mp(e) {
  const t = j4(e.viewport, e.content),
    n = e.scrollbar.paddingStart + e.scrollbar.paddingEnd,
    r = (e.scrollbar.size - n) * t;
  return Math.max(r, 18)
}

function j4(e, t) {
  const n = e / t;
  return Number.isNaN(n) ? 0 : n
}

function VA(e, t = () => {}) {
  let n = {
      left: e.scrollLeft,
      top: e.scrollTop
    },
    r = 0;
  return function s() {
    const a = {
        left: e.scrollLeft,
        top: e.scrollTop
      },
      o = n.left !== a.left,
      i = n.top !== a.top;
    (o || i) && t(), n = a, r = window.requestAnimationFrame(s)
  }(), () => window.cancelAnimationFrame(r)
}

function f_(e, t, n = "ltr") {
  const r = Mp(t),
    s = t.scrollbar.paddingStart + t.scrollbar.paddingEnd,
    a = t.scrollbar.size - s,
    o = t.content - t.viewport,
    i = a - r,
    l = n === "ltr" ? [0, o] : [o * -1, 0],
    c = om(e, l[0], l[1]);
  return B4([0, o], [0, i])(c)
}

function Hd(e) {
  return e ? Number.parseInt(e, 10) : 0
}

function UA(e, t, n, r = "ltr") {
  const s = Mp(n),
    a = s / 2,
    o = t || a,
    i = s - o,
    l = n.scrollbar.paddingStart + o,
    c = n.scrollbar.size - n.scrollbar.paddingEnd - i,
    d = n.content - n.viewport,
    f = r === "ltr" ? [0, d] : [d * -1, 0];
  return B4([l, c], f)(e)
}

function p_(e, t) {
  return e > 0 && e < t
}
const H4 = te({
    __name: "ScrollAreaScrollbarImpl",
    props: {
      isHorizontal: {
        type: Boolean
      }
    },
    emits: ["onDragScroll", "onWheelScroll", "onThumbPointerDown"],
    setup(e, {
      emit: t
    }) {
      const n = e,
        r = t,
        s = aa(),
        a = Op(),
        o = Dp(),
        {
          forwardRef: i,
          currentElement: l
        } = dt(),
        c = U(""),
        d = U();

      function f(y) {
        var b, w;
        if (d.value) {
          const x = y.clientX - ((b = d.value) == null ? void 0 : b.left),
            E = y.clientY - ((w = d.value) == null ? void 0 : w.top);
          r("onDragScroll", {
            x,
            y: E
          })
        }
      }

      function p(y) {
        y.button === 0 && (y.target.setPointerCapture(y.pointerId), d.value = l.value.getBoundingClientRect(), c.value = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", s.viewport && (s.viewport.value.style.scrollBehavior = "auto"), f(y))
      }

      function h(y) {
        f(y)
      }

      function _(y) {
        const b = y.target;
        b.hasPointerCapture(y.pointerId) && b.releasePointerCapture(y.pointerId), document.body.style.webkitUserSelect = c.value, s.viewport && (s.viewport.value.style.scrollBehavior = ""), d.value = void 0
      }

      function v(y) {
        var b;
        const w = y.target,
          x = (b = l.value) == null ? void 0 : b.contains(w),
          E = a.sizes.value.content - a.sizes.value.viewport;
        x && a.handleWheelScroll(y, E)
      }
      Ge(() => {
        document.addEventListener("wheel", v, {
          passive: !1
        })
      }), en(() => {
        document.removeEventListener("wheel", v)
      });

      function C() {
        var y, b, w, x, E;
        l.value && (n.isHorizontal ? a.handleSizeChange({
          content: ((y = s.viewport.value) == null ? void 0 : y.scrollWidth) ?? 0,
          viewport: ((b = s.viewport.value) == null ? void 0 : b.offsetWidth) ?? 0,
          scrollbar: {
            size: l.value.clientWidth ?? 0,
            paddingStart: Hd(getComputedStyle(l.value).paddingLeft),
            paddingEnd: Hd(getComputedStyle(l.value).paddingRight)
          }
        }) : a.handleSizeChange({
          content: ((w = s.viewport.value) == null ? void 0 : w.scrollHeight) ?? 0,
          viewport: ((x = s.viewport.value) == null ? void 0 : x.offsetHeight) ?? 0,
          scrollbar: {
            size: ((E = l.value) == null ? void 0 : E.clientHeight) ?? 0,
            paddingStart: Hd(getComputedStyle(l.value).paddingLeft),
            paddingEnd: Hd(getComputedStyle(l.value).paddingRight)
          }
        }))
      }
      return Vf(l, C), Vf(s.content, C), (y, b) => (g(), G(u(xt), {
        ref: u(i),
        style: {
          position: "absolute"
        },
        "data-scrollbarimpl": "",
        as: u(o).as.value,
        "as-child": u(o).asChild.value,
        onPointerdown: p,
        onPointermove: h,
        onPointerup: _
      }, {
        default: V(() => [ie(y.$slots, "default")]),
        _: 3
      }, 8, ["as", "as-child"]))
    }
  }),
  zA = te({
    __name: "ScrollAreaScrollbarX",
    setup(e) {
      const t = aa(),
        n = Op(),
        {
          forwardRef: r,
          currentElement: s
        } = dt();
      Ge(() => {
        s.value && t.onScrollbarXChange(s.value)
      });
      const a = L(() => n.sizes.value);
      return (o, i) => (g(), G(H4, {
        ref: u(r),
        "is-horizontal": !0,
        "data-orientation": "horizontal",
        style: Mt({
          bottom: 0,
          left: u(t).dir.value === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
          right: u(t).dir.value === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
          "--radix-scroll-area-thumb-width": a.value ? `${u(Mp)(a.value)}px` : void 0
        }),
        onOnDragScroll: i[0] || (i[0] = l => u(n).onDragScroll(l.x))
      }, {
        default: V(() => [ie(o.$slots, "default")]),
        _: 3
      }, 8, ["style"]))
    }
  }),
  YA = te({
    __name: "ScrollAreaScrollbarY",
    setup(e) {
      const t = aa(),
        n = Op(),
        {
          forwardRef: r,
          currentElement: s
        } = dt();
      Ge(() => {
        s.value && t.onScrollbarYChange(s.value)
      });
      const a = L(() => n.sizes.value);
      return (o, i) => (g(), G(H4, {
        ref: u(r),
        "is-horizontal": !1,
        "data-orientation": "vertical",
        style: Mt({
          top: 0,
          right: u(t).dir.value === "ltr" ? 0 : void 0,
          left: u(t).dir.value === "rtl" ? 0 : void 0,
          bottom: "var(--radix-scroll-area-corner-height)",
          "--radix-scroll-area-thumb-height": a.value ? `${u(Mp)(a.value)}px` : void 0
        }),
        onOnDragScroll: i[0] || (i[0] = l => u(n).onDragScroll(l.y))
      }, {
        default: V(() => [ie(o.$slots, "default")]),
        _: 3
      }, 8, ["style"]))
    }
  }),
  [Op, WA] = Or("ScrollAreaScrollbarVisible"),
  K0 = te({
    __name: "ScrollAreaScrollbarVisible",
    setup(e) {
      const t = aa(),
        n = Dp(),
        {
          forwardRef: r
        } = dt(),
        s = U({
          content: 0,
          viewport: 0,
          scrollbar: {
            size: 0,
            paddingStart: 0,
            paddingEnd: 0
          }
        }),
        a = L(() => {
          const y = j4(s.value.viewport, s.value.content);
          return y > 0 && y < 1
        }),
        o = U(),
        i = U(0);

      function l(y, b) {
        if (h.value) {
          const w = t.viewport.value.scrollLeft + y.deltaY;
          t.viewport.value.scrollLeft = w, p_(w, b) && y.preventDefault()
        } else {
          const w = t.viewport.value.scrollTop + y.deltaY;
          t.viewport.value.scrollTop = w, p_(w, b) && y.preventDefault()
        }
      }

      function c(y, b) {
        h.value ? i.value = b.x : i.value = b.y
      }

      function d(y) {
        i.value = 0
      }

      function f(y) {
        s.value = y
      }

      function p(y, b) {
        return UA(y, i.value, s.value, b)
      }
      const h = L(() => n.isHorizontal.value);

      function _(y) {
        h.value ? t.viewport.value.scrollLeft = p(y, t.dir.value) : t.viewport.value.scrollTop = p(y)
      }

      function v() {
        if (h.value) {
          if (t.viewport.value && o.value) {
            const y = t.viewport.value.scrollLeft,
              b = f_(y, s.value, t.dir.value);
            o.value.style.transform = `translate3d(${b}px, 0, 0)`
          }
        } else if (t.viewport.value && o.value) {
          const y = t.viewport.value.scrollTop,
            b = f_(y, s.value);
          o.value.style.transform = `translate3d(0, ${b}px, 0)`
        }
      }

      function C(y) {
        o.value = y
      }
      return WA({
        sizes: s,
        hasThumb: a,
        handleWheelScroll: l,
        handleThumbDown: c,
        handleThumbUp: d,
        handleSizeChange: f,
        onThumbPositionChange: v,
        onThumbChange: C,
        onDragScroll: _
      }), (y, b) => h.value ? (g(), G(zA, Le({
        key: 0
      }, y.$attrs, {
        ref: u(r)
      }), {
        default: V(() => [ie(y.$slots, "default")]),
        _: 3
      }, 16)) : (g(), G(YA, Le({
        key: 1
      }, y.$attrs, {
        ref: u(r)
      }), {
        default: V(() => [ie(y.$slots, "default")]),
        _: 3
      }, 16))
    }
  }),
  V4 = te({
    __name: "ScrollAreaScrollbarAuto",
    props: {
      forceMount: {
        type: Boolean
      }
    },
    setup(e) {
      const t = aa(),
        n = Dp(),
        {
          forwardRef: r
        } = dt(),
        s = U(!1),
        a = y4(() => {
          if (t.viewport.value) {
            const o = t.viewport.value.offsetWidth < t.viewport.value.scrollWidth,
              i = t.viewport.value.offsetHeight < t.viewport.value.scrollHeight;
            s.value = n.isHorizontal.value ? o : i
          }
        }, 10);
      return Ge(() => a()), Vf(t.viewport, a), Vf(t.content, a), (o, i) => (g(), G(u(wu), {
        present: o.forceMount || s.value
      }, {
        default: V(() => [$(K0, Le(o.$attrs, {
          ref: u(r),
          "data-state": s.value ? "visible" : "hidden"
        }), {
          default: V(() => [ie(o.$slots, "default")]),
          _: 3
        }, 16, ["data-state"])]),
        _: 3
      }, 8, ["present"]))
    }
  }),
  GA = te({
    inheritAttrs: !1,
    __name: "ScrollAreaScrollbarHover",
    props: {
      forceMount: {
        type: Boolean
      }
    },
    setup(e) {
      const t = aa(),
        {
          forwardRef: n
        } = dt();
      let r;
      const s = U(!1);

      function a() {
        window.clearTimeout(r), s.value = !0
      }

      function o() {
        r = window.setTimeout(() => {
          s.value = !1
        }, t.scrollHideDelay.value)
      }
      return Ge(() => {
        const i = t.scrollArea.value;
        i && (i.addEventListener("pointerenter", a), i.addEventListener("pointerleave", o))
      }), en(() => {
        const i = t.scrollArea.value;
        i && (window.clearTimeout(r), i.removeEventListener("pointerenter", a), i.removeEventListener("pointerleave", o))
      }), (i, l) => (g(), G(u(wu), {
        present: i.forceMount || s.value
      }, {
        default: V(() => [$(V4, Le(i.$attrs, {
          ref: u(n),
          "data-state": s.value ? "visible" : "hidden"
        }), {
          default: V(() => [ie(i.$slots, "default")]),
          _: 3
        }, 16, ["data-state"])]),
        _: 3
      }, 8, ["present"]))
    }
  }),
  QA = te({
    __name: "ScrollAreaScrollbarScroll",
    props: {
      forceMount: {
        type: Boolean
      }
    },
    setup(e) {
      const t = aa(),
        n = Dp(),
        {
          forwardRef: r
        } = dt(),
        {
          state: s,
          dispatch: a
        } = P4("hidden", {
          hidden: {
            SCROLL: "scrolling"
          },
          scrolling: {
            SCROLL_END: "idle",
            POINTER_ENTER: "interacting"
          },
          interacting: {
            SCROLL: "interacting",
            POINTER_LEAVE: "idle"
          },
          idle: {
            HIDE: "hidden",
            SCROLL: "scrolling",
            POINTER_ENTER: "interacting"
          }
        });
      gn(i => {
        if (s.value === "idle") {
          const l = window.setTimeout(() => a("HIDE"), t.scrollHideDelay.value);
          i(() => {
            window.clearTimeout(l)
          })
        }
      });
      const o = y4(() => a("SCROLL_END"), 100);
      return gn(i => {
        const l = t.viewport.value,
          c = n.isHorizontal.value ? "scrollLeft" : "scrollTop";
        if (l) {
          let d = l[c];
          const f = () => {
            const p = l[c];
            d !== p && (a("SCROLL"), o()), d = p
          };
          l.addEventListener("scroll", f), i(() => {
            l.removeEventListener("scroll", f)
          })
        }
      }), (i, l) => (g(), G(u(wu), {
        present: i.forceMount || u(s) !== "hidden"
      }, {
        default: V(() => [$(K0, Le(i.$attrs, {
          ref: u(r)
        }), {
          default: V(() => [ie(i.$slots, "default")]),
          _: 3
        }, 16)]),
        _: 3
      }, 8, ["present"]))
    }
  }),
  [Dp, qA] = Or("ScrollAreaScrollbar"),
  h_ = te({
    inheritAttrs: !1,
    __name: "ScrollAreaScrollbar",
    props: {
      orientation: {
        default: "vertical"
      },
      forceMount: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {
        default: "div"
      }
    },
    setup(e) {
      const t = e,
        {
          forwardRef: n
        } = dt(),
        r = aa(),
        s = L(() => t.orientation === "horizontal");
      Ne(s, () => {
        s.value ? r.onScrollbarXEnabledChange(!0) : r.onScrollbarYEnabledChange(!0)
      }, {
        immediate: !0
      }), en(() => {
        r.onScrollbarXEnabledChange(!1), r.onScrollbarYEnabledChange(!1)
      });
      const {
        orientation: a,
        forceMount: o,
        asChild: i,
        as: l
      } = Hr(t);
      return qA({
        orientation: a,
        forceMount: o,
        isHorizontal: s,
        as: l,
        asChild: i
      }), (c, d) => u(r).type.value === "hover" ? (g(), G(GA, Le({
        key: 0
      }, c.$attrs, {
        ref: u(n),
        "force-mount": u(o)
      }), {
        default: V(() => [ie(c.$slots, "default")]),
        _: 3
      }, 16, ["force-mount"])) : u(r).type.value === "scroll" ? (g(), G(QA, Le({
        key: 1
      }, c.$attrs, {
        ref: u(n),
        "force-mount": u(o)
      }), {
        default: V(() => [ie(c.$slots, "default")]),
        _: 3
      }, 16, ["force-mount"])) : u(r).type.value === "auto" ? (g(), G(V4, Le({
        key: 2
      }, c.$attrs, {
        ref: u(n),
        "force-mount": u(o)
      }), {
        default: V(() => [ie(c.$slots, "default")]),
        _: 3
      }, 16, ["force-mount"])) : u(r).type.value === "always" ? (g(), G(K0, Le({
        key: 3
      }, c.$attrs, {
        ref: u(n),
        "data-state": "visible"
      }), {
        default: V(() => [ie(c.$slots, "default")]),
        _: 3
      }, 16)) : z("", !0)
    }
  }),
  m_ = te({
    __name: "ScrollAreaThumb",
    props: {
      asChild: {
        type: Boolean
      },
      as: {}
    },
    setup(e) {
      const t = e,
        n = aa(),
        r = Op();

      function s(p) {
        const h = p.target.getBoundingClientRect(),
          _ = p.clientX - h.left,
          v = p.clientY - h.top;
        r.handleThumbDown(p, {
          x: _,
          y: v
        })
      }

      function a(p) {
        r.handleThumbUp(p)
      }
      const {
        forwardRef: o,
        currentElement: i
      } = dt(), l = U(), c = L(() => n.viewport.value);

      function d() {
        if (!l.value) {
          const p = VA(c.value, r.onThumbPositionChange);
          l.value = p, r.onThumbPositionChange()
        }
      }
      const f = L(() => r.sizes.value);
      return BT(f, () => {
        r.onThumbChange(i.value), c.value && (r.onThumbPositionChange(), c.value.addEventListener("scroll", d))
      }), en(() => {
        var p;
        c.value.removeEventListener("scroll", d), (p = n.viewport.value) == null || p.removeEventListener("scroll", d)
      }), (p, h) => (g(), G(u(xt), {
        ref: u(o),
        "data-state": u(r).hasThumb ? "visible" : "hidden",
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)"
        },
        "as-child": t.asChild,
        as: p.as,
        onPointerdown: s,
        onPointerup: a
      }, {
        default: V(() => [ie(p.$slots, "default")]),
        _: 3
      }, 8, ["data-state", "as-child", "as"]))
    }
  }),
  KA = ["default-value"],
  ZA = te({
    __name: "BubbleSelect",
    props: {
      autocomplete: {},
      autofocus: {
        type: Boolean
      },
      disabled: {
        type: Boolean
      },
      form: {},
      multiple: {
        type: Boolean
      },
      name: {},
      required: {
        type: Boolean
      },
      size: {},
      value: {}
    },
    setup(e) {
      const t = e,
        {
          value: n
        } = Hr(t),
        r = U();
      return (s, a) => (g(), G(u(q0), {
        "as-child": ""
      }, {
        default: V(() => [Tn(m("select", Le({
          ref_key: "selectElement",
          ref: r
        }, t, {
          "onUpdate:modelValue": a[0] || (a[0] = o => Ht(n) ? n.value = o : null),
          "default-value": u(n)
        }), [ie(s.$slots, "default")], 16, KA), [
          [cC, u(n)]
        ])]),
        _: 3
      }))
    }
  }),
  JA = {
    key: 0,
    value: ""
  },
  [Wi, U4] = Or("SelectRoot"),
  [XA, eP] = Or("SelectRoot"),
  tP = te({
    __name: "SelectRoot",
    props: {
      open: {
        type: Boolean,
        default: void 0
      },
      defaultOpen: {
        type: Boolean
      },
      defaultValue: {
        default: ""
      },
      modelValue: {
        default: void 0
      },
      dir: {},
      name: {},
      autocomplete: {},
      disabled: {
        type: Boolean
      },
      required: {
        type: Boolean
      }
    },
    emits: ["update:modelValue", "update:open"],
    setup(e, {
      emit: t
    }) {
      const n = e,
        r = t,
        s = Uf(n, "modelValue", r, {
          defaultValue: n.defaultValue,
          passive: n.modelValue === void 0
        }),
        a = Uf(n, "open", r, {
          defaultValue: n.defaultOpen,
          passive: n.open === void 0
        }),
        o = U(),
        i = U(),
        l = U({
          x: 0,
          y: 0
        }),
        c = U(!1),
        {
          required: d,
          disabled: f,
          dir: p
        } = Hr(n),
        h = S4(p);
      U4({
        triggerElement: o,
        onTriggerChange: y => {
          o.value = y
        },
        valueElement: i,
        onValueElementChange: y => {
          i.value = y
        },
        valueElementHasChildren: c,
        onValueElementHasChildrenChange: y => {
          c.value = y
        },
        contentId: "",
        modelValue: s,
        onValueChange: y => {
          s.value = y
        },
        open: a,
        required: d,
        onOpenChange: y => {
          a.value = y
        },
        dir: h,
        triggerPointerDownPosRef: l,
        disabled: f
      });
      const _ = ZT(o),
        v = U(new Set),
        C = L(() => Array.from(v.value).map(y => {
          var b;
          return (b = y.props) == null ? void 0 : b.value
        }).join(";"));
      return eP({
        onNativeOptionAdd: y => {
          v.value.add(y)
        },
        onNativeOptionRemove: y => {
          v.value.delete(y)
        }
      }), (y, b) => (g(), G(u(L4), null, {
        default: V(() => [ie(y.$slots, "default", {
          modelValue: u(s),
          open: u(a)
        }), u(_) ? (g(), G(ZA, Le({
          key: C.value
        }, y.$attrs, {
          "aria-hidden": "true",
          tabindex: "-1",
          required: u(d),
          name: y.name,
          autocomplete: y.autocomplete,
          disabled: u(f),
          value: u(s),
          onChange: b[0] || (b[0] = w => s.value = w.target.value)
        }), {
          default: V(() => [u(s) === void 0 ? (g(), k("option", JA)) : z("", !0), (g(!0), k(Ee, null, Je(Array.from(v.value), w => (g(), G(Kr(w), Le({
            ref_for: !0
          }, w.props, {
            key: w.key ?? ""
          }), null, 16))), 128))]),
          _: 1
        }, 16, ["required", "name", "autocomplete", "disabled", "value"])) : z("", !0)]),
        _: 3
      }))
    }
  }),
  nP = [" ", "Enter", "ArrowUp", "ArrowDown"],
  rP = [" ", "Enter"],
  us = 10;

function z4(e) {
  return e === "" || kT(e)
}
const sP = te({
    __name: "SelectTrigger",
    props: {
      disabled: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {
        default: "button"
      }
    },
    setup(e) {
      const t = e,
        n = Wi(),
        r = L(() => {
          var h;
          return ((h = n.disabled) == null ? void 0 : h.value) || t.disabled
        }),
        {
          forwardRef: s,
          currentElement: a
        } = dt();
      n.contentId || (n.contentId = W0(void 0, "radix-vue-select-content")), Ge(() => {
        n.triggerElement = a
      });
      const {
        injectCollection: o
      } = od(), i = o(), {
        search: l,
        handleTypeaheadSearch: c,
        resetTypeahead: d
      } = I4(i);

      function f() {
        r.value || (n.onOpenChange(!0), d())
      }

      function p(h) {
        f(), n.triggerPointerDownPosRef.value = {
          x: Math.round(h.pageX),
          y: Math.round(h.pageY)
        }
      }
      return (h, _) => (g(), G(u(Q0), {
        "as-child": ""
      }, {
        default: V(() => {
          var v, C, y, b;
          return [$(u(xt), {
            ref: u(s),
            role: "combobox",
            type: h.as === "button" ? "button" : void 0,
            "aria-controls": u(n).contentId,
            "aria-expanded": u(n).open.value || !1,
            "aria-required": (v = u(n).required) == null ? void 0 : v.value,
            "aria-autocomplete": "none",
            disabled: r.value,
            dir: (C = u(n)) == null ? void 0 : C.dir.value,
            "data-state": (y = u(n)) != null && y.open.value ? "open" : "closed",
            "data-disabled": r.value ? "" : void 0,
            "data-placeholder": u(z4)((b = u(n).modelValue) == null ? void 0 : b.value) ? "" : void 0,
            "as-child": h.asChild,
            as: h.as,
            onClick: _[0] || (_[0] = w => {
              var x;
              (x = w == null ? void 0 : w.currentTarget) == null || x.focus()
            }),
            onPointerdown: _[1] || (_[1] = w => {
              if (w.pointerType === "touch") return w.preventDefault();
              const x = w.target;
              x.hasPointerCapture(w.pointerId) && x.releasePointerCapture(w.pointerId), w.button === 0 && w.ctrlKey === !1 && (p(w), w.preventDefault())
            }),
            onPointerup: _[2] || (_[2] = Er(w => {
              w.pointerType === "touch" && p(w)
            }, ["prevent"])),
            onKeydown: _[3] || (_[3] = w => {
              const x = u(l) !== "";
              !(w.ctrlKey || w.altKey || w.metaKey) && w.key.length === 1 && x && w.key === " " || (u(c)(w.key), u(nP).includes(w.key) && (f(), w.preventDefault()))
            })
          }, {
            default: V(() => [ie(h.$slots, "default")]),
            _: 3
          }, 8, ["type", "aria-controls", "aria-expanded", "aria-required", "disabled", "dir", "data-state", "data-disabled", "data-placeholder", "as-child", "as"])]
        }),
        _: 3
      }))
    }
  }),
  aP = te({
    __name: "SelectPortal",
    props: {
      to: {},
      disabled: {
        type: Boolean
      },
      forceMount: {
        type: Boolean
      }
    },
    setup(e) {
      const t = e;
      return (n, r) => (g(), G(u(uA), Nt(Qt(t)), {
        default: V(() => [ie(n.$slots, "default")]),
        _: 3
      }, 16))
    }
  }),
  [Z0, oP] = Or("SelectItemAlignedPosition"),
  iP = te({
    inheritAttrs: !1,
    __name: "SelectItemAlignedPosition",
    props: {
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: ["placed"],
    setup(e, {
      emit: t
    }) {
      const n = e,
        r = t,
        {
          injectCollection: s
        } = od(),
        a = Wi(),
        o = Gi(),
        i = s(),
        l = U(!1),
        c = U(!0),
        d = U(),
        {
          forwardRef: f,
          currentElement: p
        } = dt(),
        {
          viewport: h,
          selectedItem: _,
          selectedItemText: v,
          focusSelectedItem: C
        } = o;

      function y() {
        if (a.triggerElement.value && a.valueElement.value && d.value && p.value && h != null && h.value && _ != null && _.value && v != null && v.value) {
          const x = a.triggerElement.value.getBoundingClientRect(),
            E = p.value.getBoundingClientRect(),
            S = a.valueElement.value.getBoundingClientRect(),
            T = v.value.getBoundingClientRect();
          if (a.dir.value !== "rtl") {
            const D = T.left - E.left,
              pe = S.left - D,
              ye = x.left - pe,
              Ae = x.width + ye,
              fe = Math.max(Ae, E.width),
              I = window.innerWidth - us,
              M = om(pe, us, Math.max(us, I - fe));
            d.value.style.minWidth = `${Ae}px`, d.value.style.left = `${M}px`
          } else {
            const D = E.right - T.right,
              pe = window.innerWidth - S.right - D,
              ye = window.innerWidth - x.right - pe,
              Ae = x.width + ye,
              fe = Math.max(Ae, E.width),
              I = window.innerWidth - us,
              M = om(pe, us, Math.max(us, I - fe));
            d.value.style.minWidth = `${Ae}px`, d.value.style.right = `${M}px`
          }
          const j = i.value,
            P = window.innerHeight - us * 2,
            N = h.value.scrollHeight,
            ne = window.getComputedStyle(p.value),
            Y = Number.parseInt(ne.borderTopWidth, 10),
            _e = Number.parseInt(ne.paddingTop, 10),
            Q = Number.parseInt(ne.borderBottomWidth, 10),
            re = Number.parseInt(ne.paddingBottom, 10),
            J = Y + _e + N + re + Q,
            ee = Math.min(_.value.offsetHeight * 5, J),
            de = window.getComputedStyle(h.value),
            se = Number.parseInt(de.paddingTop, 10),
            ae = Number.parseInt(de.paddingBottom, 10),
            ke = x.top + x.height / 2 - us,
            be = P - ke,
            ge = _.value.offsetHeight / 2,
            H = _.value.offsetTop + ge,
            oe = Y + _e + H,
            Ce = J - oe;
          if (oe <= ke) {
            const D = _.value === j[j.length - 1];
            d.value.style.bottom = "0px";
            const pe = p.value.clientHeight - h.value.offsetTop - h.value.offsetHeight,
              ye = Math.max(be, ge + (D ? ae : 0) + pe + Q),
              Ae = oe + ye;
            d.value.style.height = `${Ae}px`
          } else {
            const D = _.value === j[0];
            d.value.style.top = "0px";
            const pe = Math.max(ke, Y + h.value.offsetTop + (D ? se : 0) + ge) + Ce;
            d.value.style.height = `${pe}px`, h.value.scrollTop = oe - ke + h.value.offsetTop
          }
          d.value.style.margin = `${us}px 0`, d.value.style.minHeight = `${ee}px`, d.value.style.maxHeight = `${P}px`, r("placed"), requestAnimationFrame(() => l.value = !0)
        }
      }
      const b = U("");
      Ge(async () => {
        await Ot(), y(), p.value && (b.value = window.getComputedStyle(p.value).zIndex)
      });

      function w(x) {
        x && c.value === !0 && (y(), C == null || C(), c.value = !1)
      }
      return oP({
        contentWrapper: d,
        shouldExpandOnScrollRef: l,
        onScrollButtonChange: w
      }), (x, E) => (g(), k("div", {
        ref_key: "contentWrapperElement",
        ref: d,
        style: Mt({
          display: "flex",
          flexDirection: "column",
          position: "fixed",
          zIndex: b.value
        })
      }, [$(u(xt), Le({
        ref: u(f),
        style: {
          boxSizing: "border-box",
          maxHeight: "100%"
        }
      }, {
        ...x.$attrs,
        ...n
      }), {
        default: V(() => [ie(x.$slots, "default")]),
        _: 3
      }, 16)], 4))
    }
  }),
  lP = te({
    __name: "SelectPopperPosition",
    props: {
      side: {},
      sideOffset: {},
      align: {
        default: "start"
      },
      alignOffset: {},
      avoidCollisions: {
        type: Boolean
      },
      collisionBoundary: {},
      collisionPadding: {
        default: us
      },
      arrowPadding: {},
      sticky: {},
      hideWhenDetached: {
        type: Boolean
      },
      updatePositionStrategy: {},
      prioritizePosition: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    setup(e) {
      const t = Ko(e);
      return (n, r) => (g(), G(u(R4), Le(u(t), {
        style: {
          boxSizing: "border-box",
          "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-select-content-available-width": "var(--radix-popper-available-width)",
          "--radix-select-content-available-height": "var(--radix-popper-available-height)",
          "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }), {
        default: V(() => [ie(n.$slots, "default")]),
        _: 3
      }, 16))
    }
  }),
  xu = {
    onViewportChange: () => {},
    itemTextRefCallback: () => {},
    itemRefCallback: () => {}
  },
  [Gi, uP] = Or("SelectContent"),
  cP = te({
    __name: "SelectContentImpl",
    props: {
      position: {
        default: "item-aligned"
      },
      bodyLock: {
        type: Boolean,
        default: !0
      },
      side: {},
      sideOffset: {},
      align: {
        default: "start"
      },
      alignOffset: {},
      avoidCollisions: {
        type: Boolean
      },
      collisionBoundary: {},
      collisionPadding: {},
      arrowPadding: {},
      sticky: {},
      hideWhenDetached: {
        type: Boolean
      },
      updatePositionStrategy: {},
      prioritizePosition: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
    setup(e, {
      emit: t
    }) {
      const n = e,
        r = t,
        s = Wi();
      E4(), x4(n.bodyLock);
      const {
        createCollection: a
      } = od(), o = U();
      A4(o);
      const i = a(o),
        {
          search: l,
          handleTypeaheadSearch: c
        } = I4(i),
        d = U(),
        f = U(),
        p = U(),
        h = U(!1),
        _ = U(!1);

      function v() {
        f.value && o.value && d_([f.value, o.value])
      }
      Ne(h, () => {
        v()
      });
      const {
        onOpenChange: C,
        triggerPointerDownPosRef: y
      } = s;
      gn(E => {
        if (!o.value) return;
        let S = {
          x: 0,
          y: 0
        };
        const T = P => {
            var N, ne;
            S = {
              x: Math.abs(Math.round(P.pageX) - (((N = y.value) == null ? void 0 : N.x) ?? 0)),
              y: Math.abs(Math.round(P.pageY) - (((ne = y.value) == null ? void 0 : ne.y) ?? 0))
            }
          },
          j = P => {
            var N;
            P.pointerType !== "touch" && (S.x <= 10 && S.y <= 10 ? P.preventDefault() : (N = o.value) != null && N.contains(P.target) || C(!1), document.removeEventListener("pointermove", T), y.value = null)
          };
        y.value !== null && (document.addEventListener("pointermove", T), document.addEventListener("pointerup", j, {
          capture: !0,
          once: !0
        })), E(() => {
          document.removeEventListener("pointermove", T), document.removeEventListener("pointerup", j, {
            capture: !0
          })
        })
      });

      function b(E) {
        const S = E.ctrlKey || E.altKey || E.metaKey;
        if (E.key === "Tab" && E.preventDefault(), !S && E.key.length === 1 && c(E.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(E.key)) {
          let T = i.value;
          if (["ArrowUp", "End"].includes(E.key) && (T = T.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(E.key)) {
            const j = E.target,
              P = T.indexOf(j);
            T = T.slice(P + 1)
          }
          setTimeout(() => d_(T)), E.preventDefault()
        }
      }
      const w = L(() => n.position === "popper" ? n : {}),
        x = Ko(w.value);
      return uP({
        content: o,
        viewport: d,
        onViewportChange: E => {
          d.value = E
        },
        itemRefCallback: (E, S, T) => {
          var j, P;
          const N = !_.value && !T;
          (((j = s.modelValue) == null ? void 0 : j.value) !== void 0 && ((P = s.modelValue) == null ? void 0 : P.value) === S || N) && (f.value = E, N && (_.value = !0))
        },
        selectedItem: f,
        selectedItemText: p,
        onItemLeave: () => {
          var E;
          (E = o.value) == null || E.focus()
        },
        itemTextRefCallback: (E, S, T) => {
          var j, P;
          const N = !_.value && !T;
          (((j = s.modelValue) == null ? void 0 : j.value) !== void 0 && ((P = s.modelValue) == null ? void 0 : P.value) === S || N) && (p.value = E)
        },
        focusSelectedItem: v,
        position: n.position,
        isPositioned: h,
        searchRef: l
      }), (E, S) => (g(), G(u(O4), {
        "as-child": "",
        onMountAutoFocus: S[6] || (S[6] = Er(() => {}, ["prevent"])),
        onUnmountAutoFocus: S[7] || (S[7] = T => {
          var j;
          r("closeAutoFocus", T), !T.defaultPrevented && ((j = u(s).triggerElement.value) == null || j.focus({
            preventScroll: !0
          }), T.preventDefault())
        })
      }, {
        default: V(() => [$(u(M4), {
          "as-child": "",
          "disable-outside-pointer-events": "",
          onFocusOutside: S[2] || (S[2] = Er(() => {}, ["prevent"])),
          onDismiss: S[3] || (S[3] = T => u(s).onOpenChange(!1)),
          onEscapeKeyDown: S[4] || (S[4] = T => r("escapeKeyDown", T)),
          onPointerDownOutside: S[5] || (S[5] = T => r("pointerDownOutside", T))
        }, {
          default: V(() => [(g(), G(Kr(E.position === "popper" ? lP : iP), Le({
            ...E.$attrs,
            ...u(x)
          }, {
            id: u(s).contentId,
            ref: T => {
              o.value = u(Xr)(T)
            },
            role: "listbox",
            "data-state": u(s).open.value ? "open" : "closed",
            dir: u(s).dir.value,
            style: {
              display: "flex",
              flexDirection: "column",
              outline: "none"
            },
            onContextmenu: S[0] || (S[0] = Er(() => {}, ["prevent"])),
            onPlaced: S[1] || (S[1] = T => h.value = !0),
            onKeydown: b
          }), {
            default: V(() => [ie(E.$slots, "default")]),
            _: 3
          }, 16, ["id", "data-state", "dir", "onKeydown"]))]),
          _: 3
        })]),
        _: 3
      }))
    }
  }),
  dP = te({
    inheritAttrs: !1,
    __name: "SelectProvider",
    props: {
      context: {}
    },
    setup(e) {
      return U4(e.context), (t, n) => ie(t.$slots, "default")
    }
  }),
  fP = {
    key: 1
  },
  pP = te({
    inheritAttrs: !1,
    __name: "SelectContent",
    props: {
      forceMount: {
        type: Boolean
      },
      position: {},
      bodyLock: {
        type: Boolean
      },
      side: {},
      sideOffset: {},
      align: {},
      alignOffset: {},
      avoidCollisions: {
        type: Boolean
      },
      collisionBoundary: {},
      collisionPadding: {},
      arrowPadding: {},
      sticky: {},
      hideWhenDetached: {
        type: Boolean
      },
      updatePositionStrategy: {},
      prioritizePosition: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
    setup(e, {
      emit: t
    }) {
      const n = e,
        r = Ga(n, t),
        s = Wi(),
        a = U();
      Ge(() => {
        a.value = new DocumentFragment
      });
      const o = U(),
        i = L(() => n.forceMount || s.open.value);
      return (l, c) => {
        var d;
        return i.value ? (g(), G(u(wu), {
          key: 0,
          ref_key: "presenceRef",
          ref: o,
          present: !0
        }, {
          default: V(() => [$(cP, Nt(Qt({
            ...u(r),
            ...l.$attrs
          })), {
            default: V(() => [ie(l.$slots, "default")]),
            _: 3
          }, 16)]),
          _: 3
        }, 512)) : !((d = o.value) != null && d.present) && a.value ? (g(), k("div", fP, [(g(), G(Jc, {
          to: a.value
        }, [$(dP, {
          context: u(s)
        }, {
          default: V(() => [ie(l.$slots, "default")]),
          _: 3
        }, 8, ["context"])], 8, ["to"]))])) : z("", !0)
      }
    }
  }),
  [Y4, hP] = Or("SelectItem"),
  mP = te({
    __name: "SelectItem",
    props: {
      value: {},
      disabled: {
        type: Boolean
      },
      textValue: {},
      asChild: {
        type: Boolean
      },
      as: {}
    },
    setup(e) {
      const t = e,
        {
          disabled: n
        } = Hr(t),
        r = Wi(),
        s = Gi(xu),
        {
          forwardRef: a,
          currentElement: o
        } = dt(),
        i = L(() => {
          var v;
          return ((v = r.modelValue) == null ? void 0 : v.value) === t.value
        }),
        l = U(!1),
        c = U(t.textValue ?? ""),
        d = W0(void 0, "radix-vue-select-item-text");
      async function f(v) {
        await Ot(), !(v != null && v.defaultPrevented) && (n.value || (r.onValueChange(t.value), r.onOpenChange(!1)))
      }
      async function p(v) {
        var C;
        await Ot(), !v.defaultPrevented && (n.value ? (C = s.onItemLeave) == null || C.call(s) : v.currentTarget.focus({
          preventScroll: !0
        }))
      }
      async function h(v) {
        var C;
        await Ot(), !v.defaultPrevented && v.currentTarget === Ar() && ((C = s.onItemLeave) == null || C.call(s))
      }
      async function _(v) {
        var C;
        await Ot(), !(v.defaultPrevented || ((C = s.searchRef) == null ? void 0 : C.value) !== "" && v.key === " ") && (rP.includes(v.key) && f(), v.key === " " && v.preventDefault())
      }
      if (t.value === "") throw new Error("A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.");
      return Ge(() => {
        o.value && s.itemRefCallback(o.value, t.value, t.disabled)
      }), hP({
        value: t.value,
        disabled: n,
        textId: d,
        isSelected: i,
        onItemTextChange: v => {
          c.value = ((c.value || (v == null ? void 0 : v.textContent)) ?? "").trim()
        }
      }), (v, C) => (g(), G(u(xt), {
        ref: u(a),
        role: "option",
        "data-radix-vue-collection-item": "",
        "aria-labelledby": u(d),
        "data-highlighted": l.value ? "" : void 0,
        "aria-selected": i.value,
        "data-state": i.value ? "checked" : "unchecked",
        "aria-disabled": u(n) || void 0,
        "data-disabled": u(n) ? "" : void 0,
        tabindex: u(n) ? void 0 : -1,
        as: v.as,
        "as-child": v.asChild,
        onFocus: C[0] || (C[0] = y => l.value = !0),
        onBlur: C[1] || (C[1] = y => l.value = !1),
        onPointerup: f,
        onPointerdown: C[2] || (C[2] = y => {
          y.currentTarget.focus({
            preventScroll: !0
          })
        }),
        onTouchend: C[3] || (C[3] = Er(() => {}, ["prevent", "stop"])),
        onPointermove: p,
        onPointerleave: h,
        onKeydown: _
      }, {
        default: V(() => [ie(v.$slots, "default")]),
        _: 3
      }, 8, ["aria-labelledby", "data-highlighted", "aria-selected", "data-state", "aria-disabled", "data-disabled", "tabindex", "as", "as-child"]))
    }
  }),
  gP = te({
    __name: "SelectItemIndicator",
    props: {
      asChild: {
        type: Boolean
      },
      as: {
        default: "span"
      }
    },
    setup(e) {
      const t = e,
        n = Y4();
      return (r, s) => u(n).isSelected.value ? (g(), G(u(xt), Le({
        key: 0,
        "aria-hidden": "true"
      }, t), {
        default: V(() => [ie(r.$slots, "default")]),
        _: 3
      }, 16)) : z("", !0)
    }
  }),
  vP = te({
    inheritAttrs: !1,
    __name: "SelectItemText",
    props: {
      asChild: {
        type: Boolean
      },
      as: {
        default: "span"
      }
    },
    setup(e) {
      const t = e,
        n = Wi(),
        r = Gi(xu),
        s = XA(),
        a = Y4(),
        {
          forwardRef: o,
          currentElement: i
        } = dt(),
        l = L(() => {
          var c;
          return yn("option", {
            key: a.value,
            value: a.value,
            disabled: a.disabled.value,
            textContent: (c = i.value) == null ? void 0 : c.textContent
          })
        });
      return Ge(() => {
        i.value && (a.onItemTextChange(i.value), r.itemTextRefCallback(i.value, a.value, a.disabled.value), s.onNativeOptionAdd(l.value))
      }), Xc(() => {
        s.onNativeOptionRemove(l.value)
      }), (c, d) => (g(), k(Ee, null, [$(u(xt), Le({
        id: u(a).textId,
        ref: u(o)
      }, {
        ...t,
        ...c.$attrs
      }, {
        "data-item-text": ""
      }), {
        default: V(() => [ie(c.$slots, "default")]),
        _: 3
      }, 16, ["id"]), u(a).isSelected.value && u(n).valueElement.value && !u(n).valueElementHasChildren.value ? (g(), G(Jc, {
        key: 0,
        to: u(n).valueElement.value
      }, [ie(c.$slots, "default")], 8, ["to"])) : z("", !0)], 64))
    }
  }),
  _P = te({
    __name: "SelectViewport",
    props: {
      nonce: {},
      asChild: {
        type: Boolean
      },
      as: {}
    },
    setup(e) {
      const t = e,
        {
          nonce: n
        } = Hr(t),
        r = N4(n),
        s = Gi(xu),
        a = s.position === "item-aligned" ? Z0() : void 0,
        {
          forwardRef: o,
          currentElement: i
        } = dt();
      Ge(() => {
        s == null || s.onViewportChange(i.value)
      });
      const l = U(0);

      function c(d) {
        const f = d.currentTarget,
          {
            shouldExpandOnScrollRef: p,
            contentWrapper: h
          } = a ?? {};
        if (p != null && p.value && h != null && h.value) {
          const _ = Math.abs(l.value - f.scrollTop);
          if (_ > 0) {
            const v = window.innerHeight - us * 2,
              C = Number.parseFloat(h.value.style.minHeight),
              y = Number.parseFloat(h.value.style.height),
              b = Math.max(C, y);
            if (b < v) {
              const w = b + _,
                x = Math.min(v, w),
                E = w - x;
              h.value.style.height = `${x}px`, h.value.style.bottom === "0px" && (f.scrollTop = E > 0 ? E : 0, h.value.style.justifyContent = "flex-end")
            }
          }
        }
        l.value = f.scrollTop
      }
      return (d, f) => (g(), k(Ee, null, [$(u(xt), Le({
        ref: u(o),
        "data-radix-select-viewport": "",
        role: "presentation"
      }, {
        ...d.$attrs,
        ...t
      }, {
        style: {
          position: "relative",
          flex: 1,
          overflow: "hidden auto"
        },
        onScroll: c
      }), {
        default: V(() => [ie(d.$slots, "default")]),
        _: 3
      }, 16), $(u(xt), {
        as: "style",
        nonce: u(r)
      }, {
        default: V(() => [Ye(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-select-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-radix-select-viewport]::-webkit-scrollbar { display: none; } ")]),
        _: 1
      }, 8, ["nonce"])], 64))
    }
  }),
  W4 = te({
    __name: "SelectScrollButtonImpl",
    emits: ["autoScroll"],
    setup(e, {
      emit: t
    }) {
      const n = t,
        {
          injectCollection: r
        } = od(),
        s = r(),
        a = Gi(xu),
        o = U(null);

      function i() {
        o.value !== null && (window.clearInterval(o.value), o.value = null)
      }
      gn(() => {
        const d = s.value.find(f => f === Ar());
        d == null || d.scrollIntoView({
          block: "nearest"
        })
      });

      function l() {
        o.value === null && (o.value = window.setInterval(() => {
          n("autoScroll")
        }, 50))
      }

      function c() {
        var d;
        (d = a.onItemLeave) == null || d.call(a), o.value === null && (o.value = window.setInterval(() => {
          n("autoScroll")
        }, 50))
      }
      return Xc(() => i()), (d, f) => {
        var p;
        return g(), G(u(xt), Le({
          "aria-hidden": "true",
          style: {
            flexShrink: 0
          }
        }, (p = d.$parent) == null ? void 0 : p.$props, {
          onPointerdown: l,
          onPointermove: c,
          onPointerleave: f[0] || (f[0] = () => {
            i()
          })
        }), {
          default: V(() => [ie(d.$slots, "default")]),
          _: 3
        }, 16)
      }
    }
  }),
  yP = te({
    __name: "SelectScrollUpButton",
    props: {
      asChild: {
        type: Boolean
      },
      as: {}
    },
    setup(e) {
      const t = Gi(xu),
        n = t.position === "item-aligned" ? Z0() : void 0,
        {
          forwardRef: r,
          currentElement: s
        } = dt(),
        a = U(!1);
      return gn(o => {
        var i, l;
        if ((i = t.viewport) != null && i.value && (l = t.isPositioned) != null && l.value) {
          let c = function() {
            a.value = d.scrollTop > 0
          };
          const d = t.viewport.value;
          c(), d.addEventListener("scroll", c), o(() => d.removeEventListener("scroll", c))
        }
      }), Ne(s, () => {
        s.value && (n == null || n.onScrollButtonChange(s.value))
      }), (o, i) => a.value ? (g(), G(W4, {
        key: 0,
        ref: u(r),
        onAutoScroll: i[0] || (i[0] = () => {
          const {
            viewport: l,
            selectedItem: c
          } = u(t);
          l != null && l.value && c != null && c.value && (l.value.scrollTop = l.value.scrollTop - c.value.offsetHeight)
        })
      }, {
        default: V(() => [ie(o.$slots, "default")]),
        _: 3
      }, 512)) : z("", !0)
    }
  }),
  bP = te({
    __name: "SelectScrollDownButton",
    props: {
      asChild: {
        type: Boolean
      },
      as: {}
    },
    setup(e) {
      const t = Gi(xu),
        n = t.position === "item-aligned" ? Z0() : void 0,
        {
          forwardRef: r,
          currentElement: s
        } = dt(),
        a = U(!1);
      return gn(o => {
        var i, l;
        if ((i = t.viewport) != null && i.value && (l = t.isPositioned) != null && l.value) {
          let c = function() {
            const f = d.scrollHeight - d.clientHeight;
            a.value = Math.ceil(d.scrollTop) < f
          };
          const d = t.viewport.value;
          c(), d.addEventListener("scroll", c), o(() => d.removeEventListener("scroll", c))
        }
      }), Ne(s, () => {
        s.value && (n == null || n.onScrollButtonChange(s.value))
      }), (o, i) => a.value ? (g(), G(W4, {
        key: 0,
        ref: u(r),
        onAutoScroll: i[0] || (i[0] = () => {
          const {
            viewport: l,
            selectedItem: c
          } = u(t);
          l != null && l.value && c != null && c.value && (l.value.scrollTop = l.value.scrollTop + c.value.offsetHeight)
        })
      }, {
        default: V(() => [ie(o.$slots, "default")]),
        _: 3
      }, 512)) : z("", !0)
    }
  }),
  wP = te({
    __name: "SelectValue",
    props: {
      placeholder: {
        default: ""
      },
      asChild: {
        type: Boolean
      },
      as: {
        default: "span"
      }
    },
    setup(e) {
      const {
        forwardRef: t,
        currentElement: n
      } = dt(), r = Wi(), s = zo();
      return d0(() => {
        var a;
        const o = !!Ip((a = s == null ? void 0 : s.default) == null ? void 0 : a.call(s)).length;
        r.onValueElementHasChildrenChange(o)
      }), Ge(() => {
        r.valueElement = n
      }), (a, o) => (g(), G(u(xt), {
        ref: u(t),
        as: a.as,
        "as-child": a.asChild,
        style: {
          pointerEvents: "none"
        }
      }, {
        default: V(() => {
          var i;
          return [u(z4)((i = u(r).modelValue) == null ? void 0 : i.value) ? (g(), k(Ee, {
            key: 0
          }, [Ye(R(a.placeholder), 1)], 64)) : ie(a.$slots, "default", {
            key: 1
          })]
        }),
        _: 3
      }, 8, ["as", "as-child"]))
    }
  }),
  CP = te({
    __name: "SelectIcon",
    props: {
      asChild: {
        type: Boolean
      },
      as: {
        default: "span"
      }
    },
    setup(e) {
      return (t, n) => (g(), G(u(xt), {
        "aria-hidden": "true",
        as: t.as,
        "as-child": t.asChild
      }, {
        default: V(() => [ie(t.$slots, "default", {}, () => [Ye("▼")])]),
        _: 3
      }, 8, ["as", "as-child"]))
    }
  });

function xP() {
  if (typeof matchMedia == "function") return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine"
}
xP();
const [Lp, kP] = Or("ToastProvider"), SP = te({
  inheritAttrs: !1,
  __name: "ToastProvider",
  props: {
    label: {
      default: "Notification"
    },
    duration: {
      default: 5e3
    },
    swipeDirection: {
      default: "right"
    },
    swipeThreshold: {
      default: 50
    }
  },
  setup(e) {
    const t = e,
      {
        label: n,
        duration: r,
        swipeDirection: s,
        swipeThreshold: a
      } = Hr(t),
      o = U(),
      i = U(0),
      l = U(!1),
      c = U(!1);
    if (t.label && typeof t.label == "string" && !t.label.trim()) {
      const d = "Invalid prop `label` supplied to `ToastProvider`. Expected non-empty `string`.";
      throw new Error(d)
    }
    return kP({
      label: n,
      duration: r,
      swipeDirection: s,
      swipeThreshold: a,
      toastCount: i,
      viewport: o,
      onViewportChange(d) {
        o.value = d
      },
      onToastAdd() {
        i.value++
      },
      onToastRemove() {
        i.value--
      },
      isFocusedToastEscapeKeyDownRef: l,
      isClosePausedRef: c
    }), (d, f) => ie(d.$slots, "default")
  }
}), EP = "toast.swipeStart", TP = "toast.swipeMove", AP = "toast.swipeCancel", PP = "toast.swipeEnd", um = "toast.viewportPause", cm = "toast.viewportResume";

function Vd(e, t, n) {
  const r = n.originalEvent.currentTarget,
    s = new CustomEvent(e, {
      bubbles: !1,
      cancelable: !0,
      detail: n
    });
  t && r.addEventListener(e, t, {
    once: !0
  }), r.dispatchEvent(s)
}

function g_(e, t, n = 0) {
  const r = Math.abs(e.x),
    s = Math.abs(e.y),
    a = r > s;
  return t === "left" || t === "right" ? a && r > n : !a && s > n
}

function IP(e) {
  return e.nodeType === e.ELEMENT_NODE
}

function G4(e) {
  const t = [];
  return Array.from(e.childNodes).forEach(n => {
    if (n.nodeType === n.TEXT_NODE && n.textContent && t.push(n.textContent), IP(n)) {
      const r = n.ariaHidden || n.hidden || n.style.display === "none",
        s = n.dataset.radixToastAnnounceExclude === "";
      if (!r)
        if (s) {
          const a = n.dataset.radixToastAnnounceAlt;
          a && t.push(a)
        } else t.push(...G4(n))
    }
  }), t
}
const $P = te({
    __name: "ToastAnnounce",
    setup(e) {
      const t = Lp(),
        n = FT(1e3),
        r = U(!1);
      return C4(() => {
        r.value = !0
      }), (s, a) => u(n) || r.value ? (g(), G(u(q0), {
        key: 0
      }, {
        default: V(() => [Ye(R(u(t).label.value) + " ", 1), ie(s.$slots, "default")]),
        _: 3
      })) : z("", !0)
    }
  }),
  [MP, OP] = Or("ToastRoot"),
  DP = te({
    inheritAttrs: !1,
    __name: "ToastRootImpl",
    props: {
      type: {},
      open: {
        type: Boolean,
        default: !1
      },
      duration: {},
      asChild: {
        type: Boolean
      },
      as: {
        default: "li"
      }
    },
    emits: ["close", "escapeKeyDown", "pause", "resume", "swipeStart", "swipeMove", "swipeCancel", "swipeEnd"],
    setup(e, {
      emit: t
    }) {
      const n = e,
        r = t,
        {
          forwardRef: s,
          currentElement: a
        } = dt(),
        o = Lp(),
        i = U(null),
        l = U(null),
        c = L(() => typeof n.duration == "number" ? n.duration : o.duration.value),
        d = U(0),
        f = U(c.value),
        p = U(0),
        h = U(c.value),
        _ = C4(() => {
          const b = new Date().getTime() - d.value;
          h.value = Math.max(f.value - b, 0)
        }, {
          fpsLimit: 60
        });

      function v(b) {
        b <= 0 || b === Number.POSITIVE_INFINITY || sa && (window.clearTimeout(p.value), d.value = new Date().getTime(), p.value = window.setTimeout(C, b))
      }

      function C() {
        var b, w;
        (b = a.value) != null && b.contains(Ar()) && ((w = o.viewport.value) == null || w.focus()), o.isClosePausedRef.value = !1, r("close")
      }
      const y = L(() => a.value ? G4(a.value) : null);
      if (n.type && !["foreground", "background"].includes(n.type)) {
        const b = "Invalid prop `type` supplied to `Toast`. Expected `foreground | background`.";
        throw new Error(b)
      }
      return gn(b => {
        const w = o.viewport.value;
        if (w) {
          const x = () => {
              v(f.value), _.resume(), r("resume")
            },
            E = () => {
              const S = new Date().getTime() - d.value;
              f.value = f.value - S, window.clearTimeout(p.value), _.pause(), r("pause")
            };
          return w.addEventListener(um, E), w.addEventListener(cm, x), () => {
            w.removeEventListener(um, E), w.removeEventListener(cm, x)
          }
        }
      }), Ne(() => [n.open, c.value], () => {
        f.value = c.value, n.open && !o.isClosePausedRef.value && v(c.value)
      }, {
        immediate: !0
      }), Y0("Escape", b => {
        r("escapeKeyDown", b), b.defaultPrevented || (o.isFocusedToastEscapeKeyDownRef.value = !0, C())
      }), Ge(() => {
        o.onToastAdd()
      }), en(() => {
        o.onToastRemove()
      }), OP({
        onClose: C
      }), (b, w) => (g(), k(Ee, null, [y.value ? (g(), G($P, {
        key: 0,
        role: "alert",
        "aria-live": b.type === "foreground" ? "assertive" : "polite",
        "aria-atomic": "true"
      }, {
        default: V(() => [Ye(R(y.value), 1)]),
        _: 1
      }, 8, ["aria-live"])) : z("", !0), u(o).viewport.value ? (g(), G(Jc, {
        key: 1,
        to: u(o).viewport.value
      }, [$(u(xt), Le({
        ref: u(s),
        role: "alert",
        "aria-live": "off",
        "aria-atomic": "true",
        tabindex: "0",
        "data-radix-vue-collection-item": ""
      }, b.$attrs, {
        as: b.as,
        "as-child": b.asChild,
        "data-state": b.open ? "open" : "closed",
        "data-swipe-direction": u(o).swipeDirection.value,
        style: {
          userSelect: "none",
          touchAction: "none"
        },
        onPointerdown: w[0] || (w[0] = Er(x => {
          i.value = {
            x: x.clientX,
            y: x.clientY
          }
        }, ["left"])),
        onPointermove: w[1] || (w[1] = x => {
          if (!i.value) return;
          const E = x.clientX - i.value.x,
            S = x.clientY - i.value.y,
            T = !!l.value,
            j = ["left", "right"].includes(u(o).swipeDirection.value),
            P = ["left", "up"].includes(u(o).swipeDirection.value) ? Math.min : Math.max,
            N = j ? P(0, E) : 0,
            ne = j ? 0 : P(0, S),
            Y = x.pointerType === "touch" ? 10 : 2,
            _e = {
              x: N,
              y: ne
            },
            Q = {
              originalEvent: x,
              delta: _e
            };
          T ? (l.value = _e, u(Vd)(u(TP), re => r("swipeMove", re), Q)) : u(g_)(_e, u(o).swipeDirection.value, Y) ? (l.value = _e, u(Vd)(u(EP), re => r("swipeStart", re), Q), x.target.setPointerCapture(x.pointerId)) : (Math.abs(E) > Y || Math.abs(S) > Y) && (i.value = null)
        }),
        onPointerup: w[2] || (w[2] = x => {
          const E = l.value,
            S = x.target;
          if (S.hasPointerCapture(x.pointerId) && S.releasePointerCapture(x.pointerId), l.value = null, i.value = null, E) {
            const T = x.currentTarget,
              j = {
                originalEvent: x,
                delta: E
              };
            u(g_)(E, u(o).swipeDirection.value, u(o).swipeThreshold.value) ? u(Vd)(u(PP), P => r("swipeEnd", P), j) : u(Vd)(u(AP), P => r("swipeCancel", P), j), T == null || T.addEventListener("click", P => P.preventDefault(), {
              once: !0
            })
          }
        })
      }), {
        default: V(() => [ie(b.$slots, "default", {
          remaining: h.value,
          duration: c.value
        })]),
        _: 3
      }, 16, ["as", "as-child", "data-state", "data-swipe-direction"])], 8, ["to"])) : z("", !0)], 64))
    }
  }),
  LP = te({
    __name: "ToastRoot",
    props: {
      defaultOpen: {
        type: Boolean,
        default: !0
      },
      forceMount: {
        type: Boolean
      },
      type: {
        default: "foreground"
      },
      open: {
        type: Boolean,
        default: void 0
      },
      duration: {},
      asChild: {
        type: Boolean
      },
      as: {
        default: "li"
      }
    },
    emits: ["escapeKeyDown", "pause", "resume", "swipeStart", "swipeMove", "swipeCancel", "swipeEnd", "update:open"],
    setup(e, {
      emit: t
    }) {
      const n = e,
        r = t,
        {
          forwardRef: s
        } = dt(),
        a = Uf(n, "open", r, {
          defaultValue: n.defaultOpen,
          passive: n.open === void 0
        });
      return (o, i) => (g(), G(u(wu), {
        present: o.forceMount || u(a)
      }, {
        default: V(() => [$(DP, Le({
          ref: u(s),
          open: u(a),
          type: o.type,
          as: o.as,
          "as-child": o.asChild,
          duration: o.duration
        }, o.$attrs, {
          onClose: i[0] || (i[0] = l => a.value = !1),
          onPause: i[1] || (i[1] = l => r("pause")),
          onResume: i[2] || (i[2] = l => r("resume")),
          onEscapeKeyDown: i[3] || (i[3] = l => r("escapeKeyDown", l)),
          onSwipeStart: i[4] || (i[4] = l => {
            r("swipeStart", l), l.currentTarget.setAttribute("data-swipe", "start")
          }),
          onSwipeMove: i[5] || (i[5] = l => {
            const {
              x: c,
              y: d
            } = l.detail.delta, f = l.currentTarget;
            f.setAttribute("data-swipe", "move"), f.style.setProperty("--radix-toast-swipe-move-x", `${c}px`), f.style.setProperty("--radix-toast-swipe-move-y", `${d}px`)
          }),
          onSwipeCancel: i[6] || (i[6] = l => {
            const c = l.currentTarget;
            c.setAttribute("data-swipe", "cancel"), c.style.removeProperty("--radix-toast-swipe-move-x"), c.style.removeProperty("--radix-toast-swipe-move-y"), c.style.removeProperty("--radix-toast-swipe-end-x"), c.style.removeProperty("--radix-toast-swipe-end-y")
          }),
          onSwipeEnd: i[7] || (i[7] = l => {
            const {
              x: c,
              y: d
            } = l.detail.delta, f = l.currentTarget;
            f.setAttribute("data-swipe", "end"), f.style.removeProperty("--radix-toast-swipe-move-x"), f.style.removeProperty("--radix-toast-swipe-move-y"), f.style.setProperty("--radix-toast-swipe-end-x", `${c}px`), f.style.setProperty("--radix-toast-swipe-end-y", `${d}px`), a.value = !1
          })
        }), {
          default: V(({
            remaining: l,
            duration: c
          }) => [ie(o.$slots, "default", {
            remaining: l,
            duration: c,
            open: u(a)
          })]),
          _: 3
        }, 16, ["open", "type", "as", "as-child", "duration"])]),
        _: 3
      }, 8, ["present"]))
    }
  }),
  RP = te({
    __name: "ToastAnnounceExclude",
    props: {
      altText: {},
      asChild: {
        type: Boolean
      },
      as: {}
    },
    setup(e) {
      return (t, n) => (g(), G(u(xt), {
        as: t.as,
        "as-child": t.asChild,
        "data-radix-toast-announce-exclude": "",
        "data-radix-toast-announce-alt": t.altText || void 0
      }, {
        default: V(() => [ie(t.$slots, "default")]),
        _: 3
      }, 8, ["as", "as-child", "data-radix-toast-announce-alt"]))
    }
  }),
  NP = te({
    __name: "ToastClose",
    props: {
      asChild: {
        type: Boolean
      },
      as: {
        default: "button"
      }
    },
    setup(e) {
      const t = e,
        n = MP(),
        {
          forwardRef: r
        } = dt();
      return (s, a) => (g(), G(RP, {
        "as-child": ""
      }, {
        default: V(() => [$(u(xt), Le(t, {
          ref: u(r),
          type: s.as === "button" ? "button" : void 0,
          onClick: a[0] || (a[0] = o => u(n).onClose())
        }), {
          default: V(() => [ie(s.$slots, "default")]),
          _: 3
        }, 16, ["type"])]),
        _: 3
      }))
    }
  }),
  v_ = te({
    __name: "FocusProxy",
    emits: ["focusFromOutsideViewport"],
    setup(e, {
      emit: t
    }) {
      const n = t,
        r = Lp();
      return (s, a) => (g(), G(u(q0), {
        "aria-hidden": "true",
        tabindex: "0",
        style: {
          position: "fixed"
        },
        onFocus: a[0] || (a[0] = o => {
          var i;
          const l = o.relatedTarget;
          !((i = u(r).viewport.value) != null && i.contains(l)) && n("focusFromOutsideViewport")
        })
      }, {
        default: V(() => [ie(s.$slots, "default")]),
        _: 3
      }))
    }
  }),
  FP = te({
    inheritAttrs: !1,
    __name: "ToastViewport",
    props: {
      hotkey: {
        default: () => ["F8"]
      },
      label: {
        type: [String, Function],
        default: "Notifications ({hotkey})"
      },
      asChild: {
        type: Boolean
      },
      as: {
        default: "ol"
      }
    },
    setup(e) {
      const t = e,
        {
          hotkey: n,
          label: r
        } = Hr(t),
        {
          forwardRef: s,
          currentElement: a
        } = dt(),
        {
          createCollection: o
        } = od(),
        i = o(a),
        l = Lp(),
        c = L(() => l.toastCount.value > 0),
        d = U(),
        f = U(),
        p = L(() => n.value.join("+").replace(/Key/g, "").replace(/Digit/g, ""));
      Y0(n.value, () => {
        a.value.focus()
      }), Ge(() => {
        l.onViewportChange(a.value)
      }), gn(_ => {
        const v = a.value;
        if (c.value && v) {
          const C = () => {
              if (!l.isClosePausedRef.value) {
                const E = new CustomEvent(um);
                v.dispatchEvent(E), l.isClosePausedRef.value = !0
              }
            },
            y = () => {
              if (l.isClosePausedRef.value) {
                const E = new CustomEvent(cm);
                v.dispatchEvent(E), l.isClosePausedRef.value = !1
              }
            },
            b = E => {
              !v.contains(E.relatedTarget) && y()
            },
            w = () => {
              v.contains(Ar()) || y()
            },
            x = E => {
              var S, T, j;
              const P = E.altKey || E.ctrlKey || E.metaKey;
              if (E.key === "Tab" && !P) {
                const N = Ar(),
                  ne = E.shiftKey;
                if (E.target === v && ne) {
                  (S = d.value) == null || S.focus();
                  return
                }
                const Y = h({
                    tabbingDirection: ne ? "backwards" : "forwards"
                  }),
                  _e = Y.findIndex(Q => Q === N);
                df(Y.slice(_e + 1)) ? E.preventDefault() : ne ? (T = d.value) == null || T.focus() : (j = f.value) == null || j.focus()
              }
            };
          v.addEventListener("focusin", C), v.addEventListener("focusout", b), v.addEventListener("pointermove", C), v.addEventListener("pointerleave", w), v.addEventListener("keydown", x), window.addEventListener("blur", C), window.addEventListener("focus", y), _(() => {
            v.removeEventListener("focusin", C), v.removeEventListener("focusout", b), v.removeEventListener("pointermove", C), v.removeEventListener("pointerleave", w), v.removeEventListener("keydown", x), window.removeEventListener("blur", C), window.removeEventListener("focus", y)
          })
        }
      });

      function h({
        tabbingDirection: _
      }) {
        const v = i.value.map(C => {
          const y = [C, ...G0(C)];
          return _ === "forwards" ? y : y.reverse()
        });
        return (_ === "forwards" ? v.reverse() : v).flat()
      }
      return (_, v) => (g(), G(u(hA), {
        role: "region",
        "aria-label": typeof u(r) == "string" ? u(r).replace("{hotkey}", p.value) : u(r)(p.value),
        tabindex: "-1",
        style: Mt({
          pointerEvents: c.value ? void 0 : "none"
        })
      }, {
        default: V(() => [c.value ? (g(), G(v_, {
          key: 0,
          ref: C => {
            d.value = u(Xr)(C)
          },
          onFocusFromOutsideViewport: v[0] || (v[0] = () => {
            const C = h({
              tabbingDirection: "forwards"
            });
            u(df)(C)
          })
        }, null, 512)) : z("", !0), $(u(xt), Le({
          ref: u(s),
          tabindex: "-1",
          as: _.as,
          "as-child": _.asChild
        }, _.$attrs), {
          default: V(() => [ie(_.$slots, "default")]),
          _: 3
        }, 16, ["as", "as-child"]), c.value ? (g(), G(v_, {
          key: 1,
          ref: C => {
            f.value = u(Xr)(C)
          },
          onFocusFromOutsideViewport: v[1] || (v[1] = () => {
            const C = h({
              tabbingDirection: "backwards"
            });
            u(df)(C)
          })
        }, null, 512)) : z("", !0)]),
        _: 3
      }, 8, ["aria-label", "style"]))
    }
  }),
  BP = te({
    __name: "ToastTitle",
    props: {
      asChild: {
        type: Boolean
      },
      as: {}
    },
    setup(e) {
      const t = e;
      return dt(), (n, r) => (g(), G(u(xt), Nt(Qt(t)), {
        default: V(() => [ie(n.$slots, "default")]),
        _: 3
      }, 16))
    }
  }),
  jP = te({
    __name: "ToastDescription",
    props: {
      asChild: {
        type: Boolean
      },
      as: {}
    },
    setup(e) {
      const t = e;
      return dt(), (n, r) => (g(), G(u(xt), Nt(Qt(t)), {
        default: V(() => [ie(n.$slots, "default")]),
        _: 3
      }, 16))
    }
  }),
  J0 = "-",
  HP = e => {
    const t = UP(e),
      {
        conflictingClassGroups: n,
        conflictingClassGroupModifiers: r
      } = e;
    return {
      getClassGroupId: o => {
        const i = o.split(J0);
        return i[0] === "" && i.length !== 1 && i.shift(), Q4(i, t) || VP(o)
      },
      getConflictingClassGroupIds: (o, i) => {
        const l = n[o] || [];
        return i && r[o] ? [...l, ...r[o]] : l
      }
    }
  },
  Q4 = (e, t) => {
    var o;
    if (e.length === 0) return t.classGroupId;
    const n = e[0],
      r = t.nextPart.get(n),
      s = r ? Q4(e.slice(1), r) : void 0;
    if (s) return s;
    if (t.validators.length === 0) return;
    const a = e.join(J0);
    return (o = t.validators.find(({
      validator: i
    }) => i(a))) == null ? void 0 : o.classGroupId
  },
  __ = /^\[(.+)\]$/,
  VP = e => {
    if (__.test(e)) {
      const t = __.exec(e)[1],
        n = t == null ? void 0 : t.substring(0, t.indexOf(":"));
      if (n) return "arbitrary.." + n
    }
  },
  UP = e => {
    const {
      theme: t,
      prefix: n
    } = e, r = {
      nextPart: new Map,
      validators: []
    };
    return YP(Object.entries(e.classGroups), n).forEach(([a, o]) => {
      dm(o, r, a, t)
    }), r
  },
  dm = (e, t, n, r) => {
    e.forEach(s => {
      if (typeof s == "string") {
        const a = s === "" ? t : y_(t, s);
        a.classGroupId = n;
        return
      }
      if (typeof s == "function") {
        if (zP(s)) {
          dm(s(r), t, n, r);
          return
        }
        t.validators.push({
          validator: s,
          classGroupId: n
        });
        return
      }
      Object.entries(s).forEach(([a, o]) => {
        dm(o, y_(t, a), n, r)
      })
    })
  },
  y_ = (e, t) => {
    let n = e;
    return t.split(J0).forEach(r => {
      n.nextPart.has(r) || n.nextPart.set(r, {
        nextPart: new Map,
        validators: []
      }), n = n.nextPart.get(r)
    }), n
  },
  zP = e => e.isThemeGetter,
  YP = (e, t) => t ? e.map(([n, r]) => {
    const s = r.map(a => typeof a == "string" ? t + a : typeof a == "object" ? Object.fromEntries(Object.entries(a).map(([o, i]) => [t + o, i])) : a);
    return [n, s]
  }) : e,
  WP = e => {
    if (e < 1) return {
      get: () => {},
      set: () => {}
    };
    let t = 0,
      n = new Map,
      r = new Map;
    const s = (a, o) => {
      n.set(a, o), t++, t > e && (t = 0, r = n, n = new Map)
    };
    return {
      get(a) {
        let o = n.get(a);
        if (o !== void 0) return o;
        if ((o = r.get(a)) !== void 0) return s(a, o), o
      },
      set(a, o) {
        n.has(a) ? n.set(a, o) : s(a, o)
      }
    }
  },
  q4 = "!",
  GP = e => {
    const {
      separator: t,
      experimentalParseClassName: n
    } = e, r = t.length === 1, s = t[0], a = t.length, o = i => {
      const l = [];
      let c = 0,
        d = 0,
        f;
      for (let C = 0; C < i.length; C++) {
        let y = i[C];
        if (c === 0) {
          if (y === s && (r || i.slice(C, C + a) === t)) {
            l.push(i.slice(d, C)), d = C + a;
            continue
          }
          if (y === "/") {
            f = C;
            continue
          }
        }
        y === "[" ? c++ : y === "]" && c--
      }
      const p = l.length === 0 ? i : i.substring(d),
        h = p.startsWith(q4),
        _ = h ? p.substring(1) : p,
        v = f && f > d ? f - d : void 0;
      return {
        modifiers: l,
        hasImportantModifier: h,
        baseClassName: _,
        maybePostfixModifierPosition: v
      }
    };
    return n ? i => n({
      className: i,
      parseClassName: o
    }) : o
  },
  QP = e => {
    if (e.length <= 1) return e;
    const t = [];
    let n = [];
    return e.forEach(r => {
      r[0] === "[" ? (t.push(...n.sort(), r), n = []) : n.push(r)
    }), t.push(...n.sort()), t
  },
  qP = e => ({
    cache: WP(e.cacheSize),
    parseClassName: GP(e),
    ...HP(e)
  }),
  KP = /\s+/,
  ZP = (e, t) => {
    const {
      parseClassName: n,
      getClassGroupId: r,
      getConflictingClassGroupIds: s
    } = t, a = [], o = e.trim().split(KP);
    let i = "";
    for (let l = o.length - 1; l >= 0; l -= 1) {
      const c = o[l],
        {
          modifiers: d,
          hasImportantModifier: f,
          baseClassName: p,
          maybePostfixModifierPosition: h
        } = n(c);
      let _ = !!h,
        v = r(_ ? p.substring(0, h) : p);
      if (!v) {
        if (!_) {
          i = c + (i.length > 0 ? " " + i : i);
          continue
        }
        if (v = r(p), !v) {
          i = c + (i.length > 0 ? " " + i : i);
          continue
        }
        _ = !1
      }
      const C = QP(d).join(":"),
        y = f ? C + q4 : C,
        b = y + v;
      if (a.includes(b)) continue;
      a.push(b);
      const w = s(v, _);
      for (let x = 0; x < w.length; ++x) {
        const E = w[x];
        a.push(y + E)
      }
      i = c + (i.length > 0 ? " " + i : i)
    }
    return i
  };

function JP() {
  let e = 0,
    t, n, r = "";
  for (; e < arguments.length;)(t = arguments[e++]) && (n = K4(t)) && (r && (r += " "), r += n);
  return r
}
const K4 = e => {
  if (typeof e == "string") return e;
  let t, n = "";
  for (let r = 0; r < e.length; r++) e[r] && (t = K4(e[r])) && (n && (n += " "), n += t);
  return n
};

function XP(e, ...t) {
  let n, r, s, a = o;

  function o(l) {
    const c = t.reduce((d, f) => f(d), e());
    return n = qP(c), r = n.cache.get, s = n.cache.set, a = i, i(l)
  }

  function i(l) {
    const c = r(l);
    if (c) return c;
    const d = ZP(l, n);
    return s(l, d), d
  }
  return function() {
    return a(JP.apply(null, arguments))
  }
}
const zt = e => {
    const t = n => n[e] || [];
    return t.isThemeGetter = !0, t
  },
  Z4 = /^\[(?:([a-z-]+):)?(.+)\]$/i,
  eI = /^\d+\/\d+$/,
  tI = new Set(["px", "full", "screen"]),
  nI = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/,
  rI = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/,
  sI = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/,
  aI = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/,
  oI = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/,
  da = e => Sl(e) || tI.has(e) || eI.test(e),
  no = e => ku(e, "length", hI),
  Sl = e => !!e && !Number.isNaN(Number(e)),
  L1 = e => ku(e, "number", Sl),
  Hu = e => !!e && Number.isInteger(Number(e)),
  iI = e => e.endsWith("%") && Sl(e.slice(0, -1)),
  it = e => Z4.test(e),
  ro = e => nI.test(e),
  lI = new Set(["length", "size", "percentage"]),
  uI = e => ku(e, lI, J4),
  cI = e => ku(e, "position", J4),
  dI = new Set(["image", "url"]),
  fI = e => ku(e, dI, gI),
  pI = e => ku(e, "", mI),
  Vu = () => !0,
  ku = (e, t, n) => {
    const r = Z4.exec(e);
    return r ? r[1] ? typeof t == "string" ? r[1] === t : t.has(r[1]) : n(r[2]) : !1
  },
  hI = e => rI.test(e) && !sI.test(e),
  J4 = () => !1,
  mI = e => aI.test(e),
  gI = e => oI.test(e),
  vI = () => {
    const e = zt("colors"),
      t = zt("spacing"),
      n = zt("blur"),
      r = zt("brightness"),
      s = zt("borderColor"),
      a = zt("borderRadius"),
      o = zt("borderSpacing"),
      i = zt("borderWidth"),
      l = zt("contrast"),
      c = zt("grayscale"),
      d = zt("hueRotate"),
      f = zt("invert"),
      p = zt("gap"),
      h = zt("gradientColorStops"),
      _ = zt("gradientColorStopPositions"),
      v = zt("inset"),
      C = zt("margin"),
      y = zt("opacity"),
      b = zt("padding"),
      w = zt("saturate"),
      x = zt("scale"),
      E = zt("sepia"),
      S = zt("skew"),
      T = zt("space"),
      j = zt("translate"),
      P = () => ["auto", "contain", "none"],
      N = () => ["auto", "hidden", "clip", "visible", "scroll"],
      ne = () => ["auto", it, t],
      Y = () => [it, t],
      _e = () => ["", da, no],
      Q = () => ["auto", Sl, it],
      re = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"],
      J = () => ["solid", "dashed", "dotted", "double", "none"],
      ee = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"],
      de = () => ["start", "end", "center", "between", "around", "evenly", "stretch"],
      se = () => ["", "0", it],
      ae = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"],
      ke = () => [Sl, it];
    return {
      cacheSize: 500,
      separator: ":",
      theme: {
        colors: [Vu],
        spacing: [da, no],
        blur: ["none", "", ro, it],
        brightness: ke(),
        borderColor: [e],
        borderRadius: ["none", "", "full", ro, it],
        borderSpacing: Y(),
        borderWidth: _e(),
        contrast: ke(),
        grayscale: se(),
        hueRotate: ke(),
        invert: se(),
        gap: Y(),
        gradientColorStops: [e],
        gradientColorStopPositions: [iI, no],
        inset: ne(),
        margin: ne(),
        opacity: ke(),
        padding: Y(),
        saturate: ke(),
        scale: ke(),
        sepia: se(),
        skew: ke(),
        space: Y(),
        translate: Y()
      },
      classGroups: {
        aspect: [{
          aspect: ["auto", "square", "video", it]
        }],
        container: ["container"],
        columns: [{
          columns: [ro]
        }],
        "break-after": [{
          "break-after": ae()
        }],
        "break-before": [{
          "break-before": ae()
        }],
        "break-inside": [{
          "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
        }],
        "box-decoration": [{
          "box-decoration": ["slice", "clone"]
        }],
        box: [{
          box: ["border", "content"]
        }],
        display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
        float: [{
          float: ["right", "left", "none", "start", "end"]
        }],
        clear: [{
          clear: ["left", "right", "both", "none", "start", "end"]
        }],
        isolation: ["isolate", "isolation-auto"],
        "object-fit": [{
          object: ["contain", "cover", "fill", "none", "scale-down"]
        }],
        "object-position": [{
          object: [...re(), it]
        }],
        overflow: [{
          overflow: N()
        }],
        "overflow-x": [{
          "overflow-x": N()
        }],
        "overflow-y": [{
          "overflow-y": N()
        }],
        overscroll: [{
          overscroll: P()
        }],
        "overscroll-x": [{
          "overscroll-x": P()
        }],
        "overscroll-y": [{
          "overscroll-y": P()
        }],
        position: ["static", "fixed", "absolute", "relative", "sticky"],
        inset: [{
          inset: [v]
        }],
        "inset-x": [{
          "inset-x": [v]
        }],
        "inset-y": [{
          "inset-y": [v]
        }],
        start: [{
          start: [v]
        }],
        end: [{
          end: [v]
        }],
        top: [{
          top: [v]
        }],
        right: [{
          right: [v]
        }],
        bottom: [{
          bottom: [v]
        }],
        left: [{
          left: [v]
        }],
        visibility: ["visible", "invisible", "collapse"],
        z: [{
          z: ["auto", Hu, it]
        }],
        basis: [{
          basis: ne()
        }],
        "flex-direction": [{
          flex: ["row", "row-reverse", "col", "col-reverse"]
        }],
        "flex-wrap": [{
          flex: ["wrap", "wrap-reverse", "nowrap"]
        }],
        flex: [{
          flex: ["1", "auto", "initial", "none", it]
        }],
        grow: [{
          grow: se()
        }],
        shrink: [{
          shrink: se()
        }],
        order: [{
          order: ["first", "last", "none", Hu, it]
        }],
        "grid-cols": [{
          "grid-cols": [Vu]
        }],
        "col-start-end": [{
          col: ["auto", {
            span: ["full", Hu, it]
          }, it]
        }],
        "col-start": [{
          "col-start": Q()
        }],
        "col-end": [{
          "col-end": Q()
        }],
        "grid-rows": [{
          "grid-rows": [Vu]
        }],
        "row-start-end": [{
          row: ["auto", {
            span: [Hu, it]
          }, it]
        }],
        "row-start": [{
          "row-start": Q()
        }],
        "row-end": [{
          "row-end": Q()
        }],
        "grid-flow": [{
          "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
        }],
        "auto-cols": [{
          "auto-cols": ["auto", "min", "max", "fr", it]
        }],
        "auto-rows": [{
          "auto-rows": ["auto", "min", "max", "fr", it]
        }],
        gap: [{
          gap: [p]
        }],
        "gap-x": [{
          "gap-x": [p]
        }],
        "gap-y": [{
          "gap-y": [p]
        }],
        "justify-content": [{
          justify: ["normal", ...de()]
        }],
        "justify-items": [{
          "justify-items": ["start", "end", "center", "stretch"]
        }],
        "justify-self": [{
          "justify-self": ["auto", "start", "end", "center", "stretch"]
        }],
        "align-content": [{
          content: ["normal", ...de(), "baseline"]
        }],
        "align-items": [{
          items: ["start", "end", "center", "baseline", "stretch"]
        }],
        "align-self": [{
          self: ["auto", "start", "end", "center", "stretch", "baseline"]
        }],
        "place-content": [{
          "place-content": [...de(), "baseline"]
        }],
        "place-items": [{
          "place-items": ["start", "end", "center", "baseline", "stretch"]
        }],
        "place-self": [{
          "place-self": ["auto", "start", "end", "center", "stretch"]
        }],
        p: [{
          p: [b]
        }],
        px: [{
          px: [b]
        }],
        py: [{
          py: [b]
        }],
        ps: [{
          ps: [b]
        }],
        pe: [{
          pe: [b]
        }],
        pt: [{
          pt: [b]
        }],
        pr: [{
          pr: [b]
        }],
        pb: [{
          pb: [b]
        }],
        pl: [{
          pl: [b]
        }],
        m: [{
          m: [C]
        }],
        mx: [{
          mx: [C]
        }],
        my: [{
          my: [C]
        }],
        ms: [{
          ms: [C]
        }],
        me: [{
          me: [C]
        }],
        mt: [{
          mt: [C]
        }],
        mr: [{
          mr: [C]
        }],
        mb: [{
          mb: [C]
        }],
        ml: [{
          ml: [C]
        }],
        "space-x": [{
          "space-x": [T]
        }],
        "space-x-reverse": ["space-x-reverse"],
        "space-y": [{
          "space-y": [T]
        }],
        "space-y-reverse": ["space-y-reverse"],
        w: [{
          w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", it, t]
        }],
        "min-w": [{
          "min-w": [it, t, "min", "max", "fit"]
        }],
        "max-w": [{
          "max-w": [it, t, "none", "full", "min", "max", "fit", "prose", {
            screen: [ro]
          }, ro]
        }],
        h: [{
          h: [it, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
        }],
        "min-h": [{
          "min-h": [it, t, "min", "max", "fit", "svh", "lvh", "dvh"]
        }],
        "max-h": [{
          "max-h": [it, t, "min", "max", "fit", "svh", "lvh", "dvh"]
        }],
        size: [{
          size: [it, t, "auto", "min", "max", "fit"]
        }],
        "font-size": [{
          text: ["base", ro, no]
        }],
        "font-smoothing": ["antialiased", "subpixel-antialiased"],
        "font-style": ["italic", "not-italic"],
        "font-weight": [{
          font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", L1]
        }],
        "font-family": [{
          font: [Vu]
        }],
        "fvn-normal": ["normal-nums"],
        "fvn-ordinal": ["ordinal"],
        "fvn-slashed-zero": ["slashed-zero"],
        "fvn-figure": ["lining-nums", "oldstyle-nums"],
        "fvn-spacing": ["proportional-nums", "tabular-nums"],
        "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
        tracking: [{
          tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", it]
        }],
        "line-clamp": [{
          "line-clamp": ["none", Sl, L1]
        }],
        leading: [{
          leading: ["none", "tight", "snug", "normal", "relaxed", "loose", da, it]
        }],
        "list-image": [{
          "list-image": ["none", it]
        }],
        "list-style-type": [{
          list: ["none", "disc", "decimal", it]
        }],
        "list-style-position": [{
          list: ["inside", "outside"]
        }],
        "placeholder-color": [{
          placeholder: [e]
        }],
        "placeholder-opacity": [{
          "placeholder-opacity": [y]
        }],
        "text-alignment": [{
          text: ["left", "center", "right", "justify", "start", "end"]
        }],
        "text-color": [{
          text: [e]
        }],
        "text-opacity": [{
          "text-opacity": [y]
        }],
        "text-decoration": ["underline", "overline", "line-through", "no-underline"],
        "text-decoration-style": [{
          decoration: [...J(), "wavy"]
        }],
        "text-decoration-thickness": [{
          decoration: ["auto", "from-font", da, no]
        }],
        "underline-offset": [{
          "underline-offset": ["auto", da, it]
        }],
        "text-decoration-color": [{
          decoration: [e]
        }],
        "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
        "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
        "text-wrap": [{
          text: ["wrap", "nowrap", "balance", "pretty"]
        }],
        indent: [{
          indent: Y()
        }],
        "vertical-align": [{
          align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", it]
        }],
        whitespace: [{
          whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
        }],
        break: [{
          break: ["normal", "words", "all", "keep"]
        }],
        hyphens: [{
          hyphens: ["none", "manual", "auto"]
        }],
        content: [{
          content: ["none", it]
        }],
        "bg-attachment": [{
          bg: ["fixed", "local", "scroll"]
        }],
        "bg-clip": [{
          "bg-clip": ["border", "padding", "content", "text"]
        }],
        "bg-opacity": [{
          "bg-opacity": [y]
        }],
        "bg-origin": [{
          "bg-origin": ["border", "padding", "content"]
        }],
        "bg-position": [{
          bg: [...re(), cI]
        }],
        "bg-repeat": [{
          bg: ["no-repeat", {
            repeat: ["", "x", "y", "round", "space"]
          }]
        }],
        "bg-size": [{
          bg: ["auto", "cover", "contain", uI]
        }],
        "bg-image": [{
          bg: ["none", {
            "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, fI]
        }],
        "bg-color": [{
          bg: [e]
        }],
        "gradient-from-pos": [{
          from: [_]
        }],
        "gradient-via-pos": [{
          via: [_]
        }],
        "gradient-to-pos": [{
          to: [_]
        }],
        "gradient-from": [{
          from: [h]
        }],
        "gradient-via": [{
          via: [h]
        }],
        "gradient-to": [{
          to: [h]
        }],
        rounded: [{
          rounded: [a]
        }],
        "rounded-s": [{
          "rounded-s": [a]
        }],
        "rounded-e": [{
          "rounded-e": [a]
        }],
        "rounded-t": [{
          "rounded-t": [a]
        }],
        "rounded-r": [{
          "rounded-r": [a]
        }],
        "rounded-b": [{
          "rounded-b": [a]
        }],
        "rounded-l": [{
          "rounded-l": [a]
        }],
        "rounded-ss": [{
          "rounded-ss": [a]
        }],
        "rounded-se": [{
          "rounded-se": [a]
        }],
        "rounded-ee": [{
          "rounded-ee": [a]
        }],
        "rounded-es": [{
          "rounded-es": [a]
        }],
        "rounded-tl": [{
          "rounded-tl": [a]
        }],
        "rounded-tr": [{
          "rounded-tr": [a]
        }],
        "rounded-br": [{
          "rounded-br": [a]
        }],
        "rounded-bl": [{
          "rounded-bl": [a]
        }],
        "border-w": [{
          border: [i]
        }],
        "border-w-x": [{
          "border-x": [i]
        }],
        "border-w-y": [{
          "border-y": [i]
        }],
        "border-w-s": [{
          "border-s": [i]
        }],
        "border-w-e": [{
          "border-e": [i]
        }],
        "border-w-t": [{
          "border-t": [i]
        }],
        "border-w-r": [{
          "border-r": [i]
        }],
        "border-w-b": [{
          "border-b": [i]
        }],
        "border-w-l": [{
          "border-l": [i]
        }],
        "border-opacity": [{
          "border-opacity": [y]
        }],
        "border-style": [{
          border: [...J(), "hidden"]
        }],
        "divide-x": [{
          "divide-x": [i]
        }],
        "divide-x-reverse": ["divide-x-reverse"],
        "divide-y": [{
          "divide-y": [i]
        }],
        "divide-y-reverse": ["divide-y-reverse"],
        "divide-opacity": [{
          "divide-opacity": [y]
        }],
        "divide-style": [{
          divide: J()
        }],
        "border-color": [{
          border: [s]
        }],
        "border-color-x": [{
          "border-x": [s]
        }],
        "border-color-y": [{
          "border-y": [s]
        }],
        "border-color-s": [{
          "border-s": [s]
        }],
        "border-color-e": [{
          "border-e": [s]
        }],
        "border-color-t": [{
          "border-t": [s]
        }],
        "border-color-r": [{
          "border-r": [s]
        }],
        "border-color-b": [{
          "border-b": [s]
        }],
        "border-color-l": [{
          "border-l": [s]
        }],
        "divide-color": [{
          divide: [s]
        }],
        "outline-style": [{
          outline: ["", ...J()]
        }],
        "outline-offset": [{
          "outline-offset": [da, it]
        }],
        "outline-w": [{
          outline: [da, no]
        }],
        "outline-color": [{
          outline: [e]
        }],
        "ring-w": [{
          ring: _e()
        }],
        "ring-w-inset": ["ring-inset"],
        "ring-color": [{
          ring: [e]
        }],
        "ring-opacity": [{
          "ring-opacity": [y]
        }],
        "ring-offset-w": [{
          "ring-offset": [da, no]
        }],
        "ring-offset-color": [{
          "ring-offset": [e]
        }],
        shadow: [{
          shadow: ["", "inner", "none", ro, pI]
        }],
        "shadow-color": [{
          shadow: [Vu]
        }],
        opacity: [{
          opacity: [y]
        }],
        "mix-blend": [{
          "mix-blend": [...ee(), "plus-lighter", "plus-darker"]
        }],
        "bg-blend": [{
          "bg-blend": ee()
        }],
        filter: [{
          filter: ["", "none"]
        }],
        blur: [{
          blur: [n]
        }],
        brightness: [{
          brightness: [r]
        }],
        contrast: [{
          contrast: [l]
        }],
        "drop-shadow": [{
          "drop-shadow": ["", "none", ro, it]
        }],
        grayscale: [{
          grayscale: [c]
        }],
        "hue-rotate": [{
          "hue-rotate": [d]
        }],
        invert: [{
          invert: [f]
        }],
        saturate: [{
          saturate: [w]
        }],
        sepia: [{
          sepia: [E]
        }],
        "backdrop-filter": [{
          "backdrop-filter": ["", "none"]
        }],
        "backdrop-blur": [{
          "backdrop-blur": [n]
        }],
        "backdrop-brightness": [{
          "backdrop-brightness": [r]
        }],
        "backdrop-contrast": [{
          "backdrop-contrast": [l]
        }],
        "backdrop-grayscale": [{
          "backdrop-grayscale": [c]
        }],
        "backdrop-hue-rotate": [{
          "backdrop-hue-rotate": [d]
        }],
        "backdrop-invert": [{
          "backdrop-invert": [f]
        }],
        "backdrop-opacity": [{
          "backdrop-opacity": [y]
        }],
        "backdrop-saturate": [{
          "backdrop-saturate": [w]
        }],
        "backdrop-sepia": [{
          "backdrop-sepia": [E]
        }],
        "border-collapse": [{
          border: ["collapse", "separate"]
        }],
        "border-spacing": [{
          "border-spacing": [o]
        }],
        "border-spacing-x": [{
          "border-spacing-x": [o]
        }],
        "border-spacing-y": [{
          "border-spacing-y": [o]
        }],
        "table-layout": [{
          table: ["auto", "fixed"]
        }],
        caption: [{
          caption: ["top", "bottom"]
        }],
        transition: [{
          transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", it]
        }],
        duration: [{
          duration: ke()
        }],
        ease: [{
          ease: ["linear", "in", "out", "in-out", it]
        }],
        delay: [{
          delay: ke()
        }],
        animate: [{
          animate: ["none", "spin", "ping", "pulse", "bounce", it]
        }],
        transform: [{
          transform: ["", "gpu", "none"]
        }],
        scale: [{
          scale: [x]
        }],
        "scale-x": [{
          "scale-x": [x]
        }],
        "scale-y": [{
          "scale-y": [x]
        }],
        rotate: [{
          rotate: [Hu, it]
        }],
        "translate-x": [{
          "translate-x": [j]
        }],
        "translate-y": [{
          "translate-y": [j]
        }],
        "skew-x": [{
          "skew-x": [S]
        }],
        "skew-y": [{
          "skew-y": [S]
        }],
        "transform-origin": [{
          origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", it]
        }],
        accent: [{
          accent: ["auto", e]
        }],
        appearance: [{
          appearance: ["none", "auto"]
        }],
        cursor: [{
          cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", it]
        }],
        "caret-color": [{
          caret: [e]
        }],
        "pointer-events": [{
          "pointer-events": ["none", "auto"]
        }],
        resize: [{
          resize: ["none", "y", "x", ""]
        }],
        "scroll-behavior": [{
          scroll: ["auto", "smooth"]
        }],
        "scroll-m": [{
          "scroll-m": Y()
        }],
        "scroll-mx": [{
          "scroll-mx": Y()
        }],
        "scroll-my": [{
          "scroll-my": Y()
        }],
        "scroll-ms": [{
          "scroll-ms": Y()
        }],
        "scroll-me": [{
          "scroll-me": Y()
        }],
        "scroll-mt": [{
          "scroll-mt": Y()
        }],
        "scroll-mr": [{
          "scroll-mr": Y()
        }],
        "scroll-mb": [{
          "scroll-mb": Y()
        }],
        "scroll-ml": [{
          "scroll-ml": Y()
        }],
        "scroll-p": [{
          "scroll-p": Y()
        }],
        "scroll-px": [{
          "scroll-px": Y()
        }],
        "scroll-py": [{
          "scroll-py": Y()
        }],
        "scroll-ps": [{
          "scroll-ps": Y()
        }],
        "scroll-pe": [{
          "scroll-pe": Y()
        }],
        "scroll-pt": [{
          "scroll-pt": Y()
        }],
        "scroll-pr": [{
          "scroll-pr": Y()
        }],
        "scroll-pb": [{
          "scroll-pb": Y()
        }],
        "scroll-pl": [{
          "scroll-pl": Y()
        }],
        "snap-align": [{
          snap: ["start", "end", "center", "align-none"]
        }],
        "snap-stop": [{
          snap: ["normal", "always"]
        }],
        "snap-type": [{
          snap: ["none", "x", "y", "both"]
        }],
        "snap-strictness": [{
          snap: ["mandatory", "proximity"]
        }],
        touch: [{
          touch: ["auto", "none", "manipulation"]
        }],
        "touch-x": [{
          "touch-pan": ["x", "left", "right"]
        }],
        "touch-y": [{
          "touch-pan": ["y", "up", "down"]
        }],
        "touch-pz": ["touch-pinch-zoom"],
        select: [{
          select: ["none", "text", "all", "auto"]
        }],
        "will-change": [{
          "will-change": ["auto", "scroll", "contents", "transform", it]
        }],
        fill: [{
          fill: [e, "none"]
        }],
        "stroke-w": [{
          stroke: [da, no, L1]
        }],
        stroke: [{
          stroke: [e, "none"]
        }],
        sr: ["sr-only", "not-sr-only"],
        "forced-color-adjust": [{
          "forced-color-adjust": ["auto", "none"]
        }]
      },
      conflictingClassGroups: {
        overflow: ["overflow-x", "overflow-y"],
        overscroll: ["overscroll-x", "overscroll-y"],
        inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
        "inset-x": ["right", "left"],
        "inset-y": ["top", "bottom"],
        flex: ["basis", "grow", "shrink"],
        gap: ["gap-x", "gap-y"],
        p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
        px: ["pr", "pl"],
        py: ["pt", "pb"],
        m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
        mx: ["mr", "ml"],
        my: ["mt", "mb"],
        size: ["w", "h"],
        "font-size": ["leading"],
        "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
        "fvn-ordinal": ["fvn-normal"],
        "fvn-slashed-zero": ["fvn-normal"],
        "fvn-figure": ["fvn-normal"],
        "fvn-spacing": ["fvn-normal"],
        "fvn-fraction": ["fvn-normal"],
        "line-clamp": ["display", "overflow"],
        rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
        "rounded-s": ["rounded-ss", "rounded-es"],
        "rounded-e": ["rounded-se", "rounded-ee"],
        "rounded-t": ["rounded-tl", "rounded-tr"],
        "rounded-r": ["rounded-tr", "rounded-br"],
        "rounded-b": ["rounded-br", "rounded-bl"],
        "rounded-l": ["rounded-tl", "rounded-bl"],
        "border-spacing": ["border-spacing-x", "border-spacing-y"],
        "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
        "border-w-x": ["border-w-r", "border-w-l"],
        "border-w-y": ["border-w-t", "border-w-b"],
        "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
        "border-color-x": ["border-color-r", "border-color-l"],
        "border-color-y": ["border-color-t", "border-color-b"],
        "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
        "scroll-mx": ["scroll-mr", "scroll-ml"],
        "scroll-my": ["scroll-mt", "scroll-mb"],
        "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
        "scroll-px": ["scroll-pr", "scroll-pl"],
        "scroll-py": ["scroll-pt", "scroll-pb"],
        touch: ["touch-x", "touch-y", "touch-pz"],
        "touch-x": ["touch"],
        "touch-y": ["touch"],
        "touch-pz": ["touch"]
      },
      conflictingClassGroupModifiers: {
        "font-size": ["leading"]
      }
    }
  },
  _I = XP(vI);

function rn(...e) {
  return _I(Lb(e))
}
const at = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__,
  ki = "8.55.0",
  Ct = globalThis;

function Rp(e, t, n) {
  const r = n || Ct,
    s = r.__SENTRY__ = r.__SENTRY__ || {},
    a = s[ki] = s[ki] || {};
  return a[e] || (a[e] = t())
}
const Zo = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__,
  yI = "Sentry Logger ",
  fm = ["debug", "info", "warn", "error", "log", "assert", "trace"],
  zf = {};

function Qi(e) {
  if (!("console" in Ct)) return e();
  const t = Ct.console,
    n = {},
    r = Object.keys(zf);
  r.forEach(s => {
    const a = zf[s];
    n[s] = t[s], t[s] = a
  });
  try {
    return e()
  } finally {
    r.forEach(s => {
      t[s] = n[s]
    })
  }
}

function bI() {
  let e = !1;
  const t = {
    enable: () => {
      e = !0
    },
    disable: () => {
      e = !1
    },
    isEnabled: () => e
  };
  return Zo ? fm.forEach(n => {
    t[n] = (...r) => {
      e && Qi(() => {
        Ct.console[n](`${yI}[${n}]:`, ...r)
      })
    }
  }) : fm.forEach(n => {
    t[n] = () => {}
  }), t
}
const Me = Rp("logger", bI),
  X4 = 50,
  Ni = "?",
  b_ = /\(error: (.*)\)/,
  w_ = /captureMessage|captureException/;

function e8(...e) {
  const t = e.sort((n, r) => n[0] - r[0]).map(n => n[1]);
  return (n, r = 0, s = 0) => {
    const a = [],
      o = n.split(`
`);
    for (let i = r; i < o.length; i++) {
      const l = o[i];
      if (l.length > 1024) continue;
      const c = b_.test(l) ? l.replace(b_, "$1") : l;
      if (!c.match(/\S*Error: /)) {
        for (const d of t) {
          const f = d(c);
          if (f) {
            a.push(f);
            break
          }
        }
        if (a.length >= X4 + s) break
      }
    }
    return CI(a.slice(s))
  }
}

function wI(e) {
  return Array.isArray(e) ? e8(...e) : e
}

function CI(e) {
  if (!e.length) return [];
  const t = Array.from(e);
  return /sentryWrapped/.test(Ud(t).function || "") && t.pop(), t.reverse(), w_.test(Ud(t).function || "") && (t.pop(), w_.test(Ud(t).function || "") && t.pop()), t.slice(0, X4).map(n => ({
    ...n,
    filename: n.filename || Ud(t).filename,
    function: n.function || Ni
  }))
}

function Ud(e) {
  return e[e.length - 1] || {}
}
const R1 = "<anonymous>";

function Ba(e) {
  try {
    return !e || typeof e != "function" ? R1 : e.name || R1
  } catch {
    return R1
  }
}

function C_(e) {
  const t = e.exception;
  if (t) {
    const n = [];
    try {
      return t.values.forEach(r => {
        r.stacktrace.frames && n.push(...r.stacktrace.frames)
      }), n
    } catch {
      return
    }
  }
}
const ff = {},
  x_ = {};

function Jo(e, t) {
  ff[e] = ff[e] || [], ff[e].push(t)
}

function Xo(e, t) {
  if (!x_[e]) {
    x_[e] = !0;
    try {
      t()
    } catch (n) {
      Zo && Me.error(`Error while instrumenting ${e}`, n)
    }
  }
}

function Qr(e, t) {
  const n = e && ff[e];
  if (n)
    for (const r of n) try {
      r(t)
    } catch (s) {
      Zo && Me.error(`Error while triggering instrumentation handler.
Type: ${e}
Name: ${Ba(r)}
Error:`, s)
    }
}
let N1 = null;

function t8(e) {
  const t = "error";
  Jo(t, e), Xo(t, xI)
}

function xI() {
  N1 = Ct.onerror, Ct.onerror = function(e, t, n, r, s) {
    return Qr("error", {
      column: r,
      error: s,
      line: n,
      msg: e,
      url: t
    }), N1 ? N1.apply(this, arguments) : !1
  }, Ct.onerror.__SENTRY_INSTRUMENTED__ = !0
}
let F1 = null;

function n8(e) {
  const t = "unhandledrejection";
  Jo(t, e), Xo(t, kI)
}

function kI() {
  F1 = Ct.onunhandledrejection, Ct.onunhandledrejection = function(e) {
    return Qr("unhandledrejection", e), F1 ? F1.apply(this, arguments) : !0
  }, Ct.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0
}

function qi() {
  return X0(Ct), Ct
}

function X0(e) {
  const t = e.__SENTRY__ = e.__SENTRY__ || {};
  return t.version = t.version || ki, t[ki] = t[ki] || {}
}
const r8 = Object.prototype.toString;

function eg(e) {
  switch (r8.call(e)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
    case "[object WebAssembly.Exception]":
      return !0;
    default:
      return ja(e, Error)
  }
}

function Su(e, t) {
  return r8.call(e) === `[object ${t}]`
}

function s8(e) {
  return Su(e, "ErrorEvent")
}

function k_(e) {
  return Su(e, "DOMError")
}

function SI(e) {
  return Su(e, "DOMException")
}

function Ma(e) {
  return Su(e, "String")
}

function tg(e) {
  return typeof e == "object" && e !== null && "__sentry_template_string__" in e && "__sentry_template_values__" in e
}

function ng(e) {
  return e === null || tg(e) || typeof e != "object" && typeof e != "function"
}

function Zl(e) {
  return Su(e, "Object")
}

function Np(e) {
  return typeof Event < "u" && ja(e, Event)
}

function EI(e) {
  return typeof Element < "u" && ja(e, Element)
}

function TI(e) {
  return Su(e, "RegExp")
}

function Fp(e) {
  return !!(e && e.then && typeof e.then == "function")
}

function AI(e) {
  return Zl(e) && "nativeEvent" in e && "preventDefault" in e && "stopPropagation" in e
}

function ja(e, t) {
  try {
    return e instanceof t
  } catch {
    return !1
  }
}

function a8(e) {
  return !!(typeof e == "object" && e !== null && (e.__isVue || e._isVue))
}
const El = Ct,
  PI = 80;

function Fi(e, t = {}) {
  if (!e) return "<unknown>";
  try {
    let n = e;
    const r = 5,
      s = [];
    let a = 0,
      o = 0;
    const i = " > ",
      l = i.length;
    let c;
    const d = Array.isArray(t) ? t : t.keyAttrs,
      f = !Array.isArray(t) && t.maxStringLength || PI;
    for (; n && a++ < r && (c = II(n, d), !(c === "html" || a > 1 && o + s.length * l + c.length >= f));) s.push(c), o += c.length, n = n.parentNode;
    return s.reverse().join(i)
  } catch {
    return "<unknown>"
  }
}

function II(e, t) {
  const n = e,
    r = [];
  if (!n || !n.tagName) return "";
  if (El.HTMLElement && n instanceof HTMLElement && n.dataset) {
    if (n.dataset.sentryComponent) return n.dataset.sentryComponent;
    if (n.dataset.sentryElement) return n.dataset.sentryElement
  }
  r.push(n.tagName.toLowerCase());
  const s = t && t.length ? t.filter(o => n.getAttribute(o)).map(o => [o, n.getAttribute(o)]) : null;
  if (s && s.length) s.forEach(o => {
    r.push(`[${o[0]}="${o[1]}"]`)
  });
  else {
    n.id && r.push(`#${n.id}`);
    const o = n.className;
    if (o && Ma(o)) {
      const i = o.split(/\s+/);
      for (const l of i) r.push(`.${l}`)
    }
  }
  const a = ["aria-label", "type", "name", "title", "alt"];
  for (const o of a) {
    const i = n.getAttribute(o);
    i && r.push(`[${o}="${i}"]`)
  }
  return r.join("")
}

function $I() {
  try {
    return El.document.location.href
  } catch {
    return ""
  }
}

function MI(e) {
  return El.document && El.document.querySelector ? El.document.querySelector(e) : null
}

function o8(e) {
  if (!El.HTMLElement) return null;
  let t = e;
  const n = 5;
  for (let r = 0; r < n; r++) {
    if (!t) return null;
    if (t instanceof HTMLElement) {
      if (t.dataset.sentryComponent) return t.dataset.sentryComponent;
      if (t.dataset.sentryElement) return t.dataset.sentryElement
    }
    t = t.parentNode
  }
  return null
}

function Tl(e, t = 0) {
  return typeof e != "string" || t === 0 || e.length <= t ? e : `${e.slice(0,t)}...`
}

function S_(e, t) {
  if (!Array.isArray(e)) return "";
  const n = [];
  for (let r = 0; r < e.length; r++) {
    const s = e[r];
    try {
      a8(s) ? n.push("[VueViewModel]") : n.push(String(s))
    } catch {
      n.push("[value cannot be serialized]")
    }
  }
  return n.join(t)
}

function OI(e, t, n = !1) {
  return Ma(e) ? TI(t) ? t.test(e) : Ma(t) ? n ? e === t : e.includes(t) : !1 : !1
}

function Si(e, t = [], n = !1) {
  return t.some(r => OI(e, r, n))
}

function Nr(e, t, n) {
  if (!(t in e)) return;
  const r = e[t],
    s = n(r);
  typeof s == "function" && i8(s, r);
  try {
    e[t] = s
  } catch {
    Zo && Me.log(`Failed to replace method "${t}" in object`, e)
  }
}

function es(e, t, n) {
  try {
    Object.defineProperty(e, t, {
      value: n,
      writable: !0,
      configurable: !0
    })
  } catch {
    Zo && Me.log(`Failed to add non-enumerable property "${t}" to object`, e)
  }
}

function i8(e, t) {
  try {
    const n = t.prototype || {};
    e.prototype = t.prototype = n, es(e, "__sentry_original__", t)
  } catch {}
}

function rg(e) {
  return e.__sentry_original__
}

function l8(e) {
  if (eg(e)) return {
    message: e.message,
    name: e.name,
    stack: e.stack,
    ...T_(e)
  };
  if (Np(e)) {
    const t = {
      type: e.type,
      target: E_(e.target),
      currentTarget: E_(e.currentTarget),
      ...T_(e)
    };
    return typeof CustomEvent < "u" && ja(e, CustomEvent) && (t.detail = e.detail), t
  } else return e
}

function E_(e) {
  try {
    return EI(e) ? Fi(e) : Object.prototype.toString.call(e)
  } catch {
    return "<unknown>"
  }
}

function T_(e) {
  if (typeof e == "object" && e !== null) {
    const t = {};
    for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
    return t
  } else return {}
}

function DI(e, t = 40) {
  const n = Object.keys(l8(e));
  n.sort();
  const r = n[0];
  if (!r) return "[object has no keys]";
  if (r.length >= t) return Tl(r, t);
  for (let s = n.length; s > 0; s--) {
    const a = n.slice(0, s).join(", ");
    if (!(a.length > t)) return s === n.length ? a : Tl(a, t)
  }
  return ""
}

function jn(e) {
  return pm(e, new Map)
}

function pm(e, t) {
  if (LI(e)) {
    const n = t.get(e);
    if (n !== void 0) return n;
    const r = {};
    t.set(e, r);
    for (const s of Object.getOwnPropertyNames(e)) typeof e[s] < "u" && (r[s] = pm(e[s], t));
    return r
  }
  if (Array.isArray(e)) {
    const n = t.get(e);
    if (n !== void 0) return n;
    const r = [];
    return t.set(e, r), e.forEach(s => {
      r.push(pm(s, t))
    }), r
  }
  return e
}

function LI(e) {
  if (!Zl(e)) return !1;
  try {
    const t = Object.getPrototypeOf(e).constructor.name;
    return !t || t === "Object"
  } catch {
    return !0
  }
}
const u8 = 1e3;

function id() {
  return Date.now() / u8
}

function RI() {
  const {
    performance: e
  } = Ct;
  if (!e || !e.now) return id;
  const t = Date.now() - e.now(),
    n = e.timeOrigin == null ? t : e.timeOrigin;
  return () => (n + e.now()) / u8
}
const cr = RI(),
  $r = (() => {
    const {
      performance: e
    } = Ct;
    if (!e || !e.now) return;
    const t = 3600 * 1e3,
      n = e.now(),
      r = Date.now(),
      s = e.timeOrigin ? Math.abs(e.timeOrigin + n - r) : t,
      a = s < t,
      o = e.timing && e.timing.navigationStart,
      l = typeof o == "number" ? Math.abs(o + n - r) : t,
      c = l < t;
    return a || c ? s <= l ? e.timeOrigin : o : r
  })();

function qr() {
  const e = Ct,
    t = e.crypto || e.msCrypto;
  let n = () => Math.random() * 16;
  try {
    if (t && t.randomUUID) return t.randomUUID().replace(/-/g, "");
    t && t.getRandomValues && (n = () => {
      const r = new Uint8Array(1);
      return t.getRandomValues(r), r[0]
    })
  } catch {}
  return ("10000000100040008000" + 1e11).replace(/[018]/g, r => (r ^ (n() & 15) >> r / 4).toString(16))
}

function c8(e) {
  return e.exception && e.exception.values ? e.exception.values[0] : void 0
}

function ho(e) {
  const {
    message: t,
    event_id: n
  } = e;
  if (t) return t;
  const r = c8(e);
  return r ? r.type && r.value ? `${r.type}: ${r.value}` : r.type || r.value || n || "<unknown>" : n || "<unknown>"
}

function hm(e, t, n) {
  const r = e.exception = e.exception || {},
    s = r.values = r.values || [],
    a = s[0] = s[0] || {};
  a.value || (a.value = t || ""), a.type || (a.type = "Error")
}

function Jl(e, t) {
  const n = c8(e);
  if (!n) return;
  const r = {
      type: "generic",
      handled: !0
    },
    s = n.mechanism;
  if (n.mechanism = {
      ...r,
      ...s,
      ...t
    }, t && "data" in t) {
    const a = {
      ...s && s.data,
      ...t.data
    };
    n.mechanism.data = a
  }
}

function A_(e) {
  if (NI(e)) return !0;
  try {
    es(e, "__sentry_captured__", !0)
  } catch {}
  return !1
}

function NI(e) {
  try {
    return e.__sentry_captured__
  } catch {}
}
var ma;
(function(e) {
  e[e.PENDING = 0] = "PENDING";
  const n = 1;
  e[e.RESOLVED = n] = "RESOLVED";
  const r = 2;
  e[e.REJECTED = r] = "REJECTED"
})(ma || (ma = {}));

function Bi(e) {
  return new Wr(t => {
    t(e)
  })
}

function Yf(e) {
  return new Wr((t, n) => {
    n(e)
  })
}
class Wr {
  constructor(t) {
    Wr.prototype.__init.call(this), Wr.prototype.__init2.call(this), Wr.prototype.__init3.call(this), Wr.prototype.__init4.call(this), this._state = ma.PENDING, this._handlers = [];
    try {
      t(this._resolve, this._reject)
    } catch (n) {
      this._reject(n)
    }
  }
  then(t, n) {
    return new Wr((r, s) => {
      this._handlers.push([!1, a => {
        if (!t) r(a);
        else try {
          r(t(a))
        } catch (o) {
          s(o)
        }
      }, a => {
        if (!n) s(a);
        else try {
          r(n(a))
        } catch (o) {
          s(o)
        }
      }]), this._executeHandlers()
    })
  } catch (t) {
    return this.then(n => n, t)
  } finally(t) {
    return new Wr((n, r) => {
      let s, a;
      return this.then(o => {
        a = !1, s = o, t && t()
      }, o => {
        a = !0, s = o, t && t()
      }).then(() => {
        if (a) {
          r(s);
          return
        }
        n(s)
      })
    })
  }
  __init() {
    this._resolve = t => {
      this._setResult(ma.RESOLVED, t)
    }
  }
  __init2() {
    this._reject = t => {
      this._setResult(ma.REJECTED, t)
    }
  }
  __init3() {
    this._setResult = (t, n) => {
      if (this._state === ma.PENDING) {
        if (Fp(n)) {
          n.then(this._resolve, this._reject);
          return
        }
        this._state = t, this._value = n, this._executeHandlers()
      }
    }
  }
  __init4() {
    this._executeHandlers = () => {
      if (this._state === ma.PENDING) return;
      const t = this._handlers.slice();
      this._handlers = [], t.forEach(n => {
        n[0] || (this._state === ma.RESOLVED && n[1](this._value), this._state === ma.REJECTED && n[2](this._value), n[0] = !0)
      })
    }
  }
}

function FI(e) {
  const t = cr(),
    n = {
      sid: qr(),
      init: !0,
      timestamp: t,
      started: t,
      duration: 0,
      status: "ok",
      errors: 0,
      ignoreDuration: !1,
      toJSON: () => jI(n)
    };
  return e && Xl(n, e), n
}

function Xl(e, t = {}) {
  if (t.user && (!e.ipAddress && t.user.ip_address && (e.ipAddress = t.user.ip_address), !e.did && !t.did && (e.did = t.user.id || t.user.email || t.user.username)), e.timestamp = t.timestamp || cr(), t.abnormal_mechanism && (e.abnormal_mechanism = t.abnormal_mechanism), t.ignoreDuration && (e.ignoreDuration = t.ignoreDuration), t.sid && (e.sid = t.sid.length === 32 ? t.sid : qr()), t.init !== void 0 && (e.init = t.init), !e.did && t.did && (e.did = `${t.did}`), typeof t.started == "number" && (e.started = t.started), e.ignoreDuration) e.duration = void 0;
  else if (typeof t.duration == "number") e.duration = t.duration;
  else {
    const n = e.timestamp - e.started;
    e.duration = n >= 0 ? n : 0
  }
  t.release && (e.release = t.release), t.environment && (e.environment = t.environment), !e.ipAddress && t.ipAddress && (e.ipAddress = t.ipAddress), !e.userAgent && t.userAgent && (e.userAgent = t.userAgent), typeof t.errors == "number" && (e.errors = t.errors), t.status && (e.status = t.status)
}

function BI(e, t) {
  let n = {};
  e.status === "ok" && (n = {
    status: "exited"
  }), Xl(e, n)
}

function jI(e) {
  return jn({
    sid: `${e.sid}`,
    init: e.init,
    started: new Date(e.started * 1e3).toISOString(),
    timestamp: new Date(e.timestamp * 1e3).toISOString(),
    status: e.status,
    errors: e.errors,
    did: typeof e.did == "number" || typeof e.did == "string" ? `${e.did}` : void 0,
    duration: e.duration,
    abnormal_mechanism: e.abnormal_mechanism,
    attrs: {
      release: e.release,
      environment: e.environment,
      ip_address: e.ipAddress,
      user_agent: e.userAgent
    }
  })
}

function No() {
  return qr()
}

function Fo() {
  return qr().substring(16)
}

function Bp(e, t, n = 2) {
  if (!t || typeof t != "object" || n <= 0) return t;
  if (e && t && Object.keys(t).length === 0) return e;
  const r = {
    ...e
  };
  for (const s in t) Object.prototype.hasOwnProperty.call(t, s) && (r[s] = Bp(r[s], t[s], n - 1));
  return r
}
const mm = "_sentrySpan";

function Dc(e, t) {
  t ? es(e, mm, t) : delete e[mm]
}

function Wf(e) {
  return e[mm]
}
const HI = 100;
class sg {
  constructor() {
    this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}, this._propagationContext = {
      traceId: No(),
      spanId: Fo()
    }
  }
  clone() {
    const t = new sg;
    return t._breadcrumbs = [...this._breadcrumbs], t._tags = {
      ...this._tags
    }, t._extra = {
      ...this._extra
    }, t._contexts = {
      ...this._contexts
    }, this._contexts.flags && (t._contexts.flags = {
      values: [...this._contexts.flags.values]
    }), t._user = this._user, t._level = this._level, t._session = this._session, t._transactionName = this._transactionName, t._fingerprint = this._fingerprint, t._eventProcessors = [...this._eventProcessors], t._requestSession = this._requestSession, t._attachments = [...this._attachments], t._sdkProcessingMetadata = {
      ...this._sdkProcessingMetadata
    }, t._propagationContext = {
      ...this._propagationContext
    }, t._client = this._client, t._lastEventId = this._lastEventId, Dc(t, Wf(this)), t
  }
  setClient(t) {
    this._client = t
  }
  setLastEventId(t) {
    this._lastEventId = t
  }
  getClient() {
    return this._client
  }
  lastEventId() {
    return this._lastEventId
  }
  addScopeListener(t) {
    this._scopeListeners.push(t)
  }
  addEventProcessor(t) {
    return this._eventProcessors.push(t), this
  }
  setUser(t) {
    return this._user = t || {
      email: void 0,
      id: void 0,
      ip_address: void 0,
      username: void 0
    }, this._session && Xl(this._session, {
      user: t
    }), this._notifyScopeListeners(), this
  }
  getUser() {
    return this._user
  }
  getRequestSession() {
    return this._requestSession
  }
  setRequestSession(t) {
    return this._requestSession = t, this
  }
  setTags(t) {
    return this._tags = {
      ...this._tags,
      ...t
    }, this._notifyScopeListeners(), this
  }
  setTag(t, n) {
    return this._tags = {
      ...this._tags,
      [t]: n
    }, this._notifyScopeListeners(), this
  }
  setExtras(t) {
    return this._extra = {
      ...this._extra,
      ...t
    }, this._notifyScopeListeners(), this
  }
  setExtra(t, n) {
    return this._extra = {
      ...this._extra,
      [t]: n
    }, this._notifyScopeListeners(), this
  }
  setFingerprint(t) {
    return this._fingerprint = t, this._notifyScopeListeners(), this
  }
  setLevel(t) {
    return this._level = t, this._notifyScopeListeners(), this
  }
  setTransactionName(t) {
    return this._transactionName = t, this._notifyScopeListeners(), this
  }
  setContext(t, n) {
    return n === null ? delete this._contexts[t] : this._contexts[t] = n, this._notifyScopeListeners(), this
  }
  setSession(t) {
    return t ? this._session = t : delete this._session, this._notifyScopeListeners(), this
  }
  getSession() {
    return this._session
  }
  update(t) {
    if (!t) return this;
    const n = typeof t == "function" ? t(this) : t,
      [r, s] = n instanceof ji ? [n.getScopeData(), n.getRequestSession()] : Zl(n) ? [t, t.requestSession] : [],
      {
        tags: a,
        extra: o,
        user: i,
        contexts: l,
        level: c,
        fingerprint: d = [],
        propagationContext: f
      } = r || {};
    return this._tags = {
      ...this._tags,
      ...a
    }, this._extra = {
      ...this._extra,
      ...o
    }, this._contexts = {
      ...this._contexts,
      ...l
    }, i && Object.keys(i).length && (this._user = i), c && (this._level = c), d.length && (this._fingerprint = d), f && (this._propagationContext = f), s && (this._requestSession = s), this
  }
  clear() {
    return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._session = void 0, Dc(this, void 0), this._attachments = [], this.setPropagationContext({
      traceId: No()
    }), this._notifyScopeListeners(), this
  }
  addBreadcrumb(t, n) {
    const r = typeof n == "number" ? n : HI;
    if (r <= 0) return this;
    const s = {
      timestamp: id(),
      ...t
    };
    return this._breadcrumbs.push(s), this._breadcrumbs.length > r && (this._breadcrumbs = this._breadcrumbs.slice(-r), this._client && this._client.recordDroppedEvent("buffer_overflow", "log_item")), this._notifyScopeListeners(), this
  }
  getLastBreadcrumb() {
    return this._breadcrumbs[this._breadcrumbs.length - 1]
  }
  clearBreadcrumbs() {
    return this._breadcrumbs = [], this._notifyScopeListeners(), this
  }
  addAttachment(t) {
    return this._attachments.push(t), this
  }
  clearAttachments() {
    return this._attachments = [], this
  }
  getScopeData() {
    return {
      breadcrumbs: this._breadcrumbs,
      attachments: this._attachments,
      contexts: this._contexts,
      tags: this._tags,
      extra: this._extra,
      user: this._user,
      level: this._level,
      fingerprint: this._fingerprint || [],
      eventProcessors: this._eventProcessors,
      propagationContext: this._propagationContext,
      sdkProcessingMetadata: this._sdkProcessingMetadata,
      transactionName: this._transactionName,
      span: Wf(this)
    }
  }
  setSDKProcessingMetadata(t) {
    return this._sdkProcessingMetadata = Bp(this._sdkProcessingMetadata, t, 2), this
  }
  setPropagationContext(t) {
    return this._propagationContext = {
      spanId: Fo(),
      ...t
    }, this
  }
  getPropagationContext() {
    return this._propagationContext
  }
  captureException(t, n) {
    const r = n && n.event_id ? n.event_id : qr();
    if (!this._client) return Me.warn("No client configured on scope - will not capture exception!"), r;
    const s = new Error("Sentry syntheticException");
    return this._client.captureException(t, {
      originalException: t,
      syntheticException: s,
      ...n,
      event_id: r
    }, this), r
  }
  captureMessage(t, n, r) {
    const s = r && r.event_id ? r.event_id : qr();
    if (!this._client) return Me.warn("No client configured on scope - will not capture message!"), s;
    const a = new Error(t);
    return this._client.captureMessage(t, n, {
      originalException: t,
      syntheticException: a,
      ...r,
      event_id: s
    }, this), s
  }
  captureEvent(t, n) {
    const r = n && n.event_id ? n.event_id : qr();
    return this._client ? (this._client.captureEvent(t, {
      ...n,
      event_id: r
    }, this), r) : (Me.warn("No client configured on scope - will not capture event!"), r)
  }
  _notifyScopeListeners() {
    this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach(t => {
      t(this)
    }), this._notifyingListeners = !1)
  }
}
const ji = sg;

function VI() {
  return Rp("defaultCurrentScope", () => new ji)
}

function UI() {
  return Rp("defaultIsolationScope", () => new ji)
}
class zI {
  constructor(t, n) {
    let r;
    t ? r = t : r = new ji;
    let s;
    n ? s = n : s = new ji, this._stack = [{
      scope: r
    }], this._isolationScope = s
  }
  withScope(t) {
    const n = this._pushScope();
    let r;
    try {
      r = t(n)
    } catch (s) {
      throw this._popScope(), s
    }
    return Fp(r) ? r.then(s => (this._popScope(), s), s => {
      throw this._popScope(), s
    }) : (this._popScope(), r)
  }
  getClient() {
    return this.getStackTop().client
  }
  getScope() {
    return this.getStackTop().scope
  }
  getIsolationScope() {
    return this._isolationScope
  }
  getStackTop() {
    return this._stack[this._stack.length - 1]
  }
  _pushScope() {
    const t = this.getScope().clone();
    return this._stack.push({
      client: this.getClient(),
      scope: t
    }), t
  }
  _popScope() {
    return this._stack.length <= 1 ? !1 : !!this._stack.pop()
  }
}

function eu() {
  const e = qi(),
    t = X0(e);
  return t.stack = t.stack || new zI(VI(), UI())
}

function YI(e) {
  return eu().withScope(e)
}

function WI(e, t) {
  const n = eu();
  return n.withScope(() => (n.getStackTop().scope = e, t(e)))
}

function P_(e) {
  return eu().withScope(() => e(eu().getIsolationScope()))
}

function GI() {
  return {
    withIsolationScope: P_,
    withScope: YI,
    withSetScope: WI,
    withSetIsolationScope: (e, t) => P_(t),
    getCurrentScope: () => eu().getScope(),
    getIsolationScope: () => eu().getIsolationScope()
  }
}

function Eu(e) {
  const t = X0(e);
  return t.acs ? t.acs : GI()
}

function Kt() {
  const e = qi();
  return Eu(e).getCurrentScope()
}

function Qa() {
  const e = qi();
  return Eu(e).getIsolationScope()
}

function QI() {
  return Rp("globalScope", () => new ji)
}

function ag(...e) {
  const t = qi(),
    n = Eu(t);
  if (e.length === 2) {
    const [r, s] = e;
    return r ? n.withSetScope(r, s) : n.withScope(s)
  }
  return n.withScope(e[0])
}

function Dt() {
  return Kt().getClient()
}

function qI(e) {
  const t = e.getPropagationContext(),
    {
      traceId: n,
      spanId: r,
      parentSpanId: s
    } = t;
  return jn({
    trace_id: n,
    span_id: r,
    parent_span_id: s
  })
}
const KI = "_sentryMetrics";

function gm(e) {
  const t = e[KI];
  if (!t) return;
  const n = {};
  for (const [, [r, s]] of t)(n[r] || (n[r] = [])).push(jn(s));
  return n
}
const Ea = "sentry.source",
  d8 = "sentry.sample_rate",
  Hi = "sentry.op",
  Mn = "sentry.origin",
  vm = "sentry.idle_span_finish_reason",
  jp = "sentry.measurement_unit",
  Hp = "sentry.measurement_value",
  I_ = "sentry.custom_span_name",
  ZI = "sentry.profile_id",
  og = "sentry.exclusive_time",
  JI = 0,
  f8 = 1,
  In = 2;

function XI(e) {
  if (e < 400 && e >= 100) return {
    code: f8
  };
  if (e >= 400 && e < 500) switch (e) {
    case 401:
      return {
        code: In, message: "unauthenticated"
      };
    case 403:
      return {
        code: In, message: "permission_denied"
      };
    case 404:
      return {
        code: In, message: "not_found"
      };
    case 409:
      return {
        code: In, message: "already_exists"
      };
    case 413:
      return {
        code: In, message: "failed_precondition"
      };
    case 429:
      return {
        code: In, message: "resource_exhausted"
      };
    case 499:
      return {
        code: In, message: "cancelled"
      };
    default:
      return {
        code: In, message: "invalid_argument"
      }
  }
  if (e >= 500 && e < 600) switch (e) {
    case 501:
      return {
        code: In, message: "unimplemented"
      };
    case 503:
      return {
        code: In, message: "unavailable"
      };
    case 504:
      return {
        code: In, message: "deadline_exceeded"
      };
    default:
      return {
        code: In, message: "internal_error"
      }
  }
  return {
    code: In,
    message: "unknown_error"
  }
}

function p8(e, t) {
  e.setAttribute("http.response.status_code", t);
  const n = XI(t);
  n.message !== "unknown_error" && e.setStatus(n)
}
const ig = "sentry-",
  e$ = /^sentry-/,
  t$ = 8192;

function h8(e) {
  const t = r$(e);
  if (!t) return;
  const n = Object.entries(t).reduce((r, [s, a]) => {
    if (s.match(e$)) {
      const o = s.slice(ig.length);
      r[o] = a
    }
    return r
  }, {});
  if (Object.keys(n).length > 0) return n
}

function n$(e) {
  if (!e) return;
  const t = Object.entries(e).reduce((n, [r, s]) => (s && (n[`${ig}${r}`] = s), n), {});
  return s$(t)
}

function r$(e) {
  if (!(!e || !Ma(e) && !Array.isArray(e))) return Array.isArray(e) ? e.reduce((t, n) => {
    const r = $_(n);
    return Object.entries(r).forEach(([s, a]) => {
      t[s] = a
    }), t
  }, {}) : $_(e)
}

function $_(e) {
  return e.split(",").map(t => t.split("=").map(n => decodeURIComponent(n.trim()))).reduce((t, [n, r]) => (n && r && (t[n] = r), t), {})
}

function s$(e) {
  if (Object.keys(e).length !== 0) return Object.entries(e).reduce((t, [n, r], s) => {
    const a = `${encodeURIComponent(n)}=${encodeURIComponent(r)}`,
      o = s === 0 ? a : `${t},${a}`;
    return o.length > t$ ? (Zo && Me.warn(`Not adding key: ${n} with val: ${r} to baggage header due to exceeding baggage size limits.`), t) : o
  }, "")
}
const m8 = new RegExp("^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$");

function a$(e) {
  if (!e) return;
  const t = e.match(m8);
  if (!t) return;
  let n;
  return t[3] === "1" ? n = !0 : t[3] === "0" && (n = !1), {
    traceId: t[1],
    parentSampled: n,
    parentSpanId: t[2]
  }
}

function o$(e, t) {
  const n = a$(e),
    r = h8(t);
  if (!n || !n.traceId) return {
    traceId: No(),
    spanId: Fo()
  };
  const {
    traceId: s,
    parentSpanId: a,
    parentSampled: o
  } = n, i = Fo();
  return {
    traceId: s,
    parentSpanId: a,
    spanId: i,
    sampled: o,
    dsc: r || {}
  }
}

function g8(e = No(), t = Fo(), n) {
  let r = "";
  return n !== void 0 && (r = n ? "-1" : "-0"), `${e}-${t}${r}`
}
const v8 = 0,
  _8 = 1;
let M_ = !1;

function i$(e) {
  const {
    spanId: t,
    traceId: n
  } = e.spanContext(), {
    data: r,
    op: s,
    parent_span_id: a,
    status: o,
    origin: i
  } = Tt(e);
  return jn({
    parent_span_id: a,
    span_id: t,
    trace_id: n,
    data: r,
    op: s,
    status: o,
    origin: i
  })
}

function l$(e) {
  const {
    spanId: t,
    traceId: n,
    isRemote: r
  } = e.spanContext(), s = r ? t : Tt(e).parent_span_id, a = r ? Fo() : t;
  return jn({
    parent_span_id: s,
    span_id: a,
    trace_id: n
  })
}

function u$(e) {
  const {
    traceId: t,
    spanId: n
  } = e.spanContext(), r = Ki(e);
  return g8(t, n, r)
}

function Ei(e) {
  return typeof e == "number" ? O_(e) : Array.isArray(e) ? e[0] + e[1] / 1e9 : e instanceof Date ? O_(e.getTime()) : cr()
}

function O_(e) {
  return e > 9999999999 ? e / 1e3 : e
}

function Tt(e) {
  if (d$(e)) return e.getSpanJSON();
  try {
    const {
      spanId: t,
      traceId: n
    } = e.spanContext();
    if (c$(e)) {
      const {
        attributes: r,
        startTime: s,
        name: a,
        endTime: o,
        parentSpanId: i,
        status: l
      } = e;
      return jn({
        span_id: t,
        trace_id: n,
        data: r,
        description: a,
        parent_span_id: i,
        start_timestamp: Ei(s),
        timestamp: Ei(o) || void 0,
        status: y8(l),
        op: r[Hi],
        origin: r[Mn],
        _metrics_summary: gm(e)
      })
    }
    return {
      span_id: t,
      trace_id: n
    }
  } catch {
    return {}
  }
}

function c$(e) {
  const t = e;
  return !!t.attributes && !!t.startTime && !!t.name && !!t.endTime && !!t.status
}

function d$(e) {
  return typeof e.getSpanJSON == "function"
}

function Ki(e) {
  const {
    traceFlags: t
  } = e.spanContext();
  return t === _8
}

function y8(e) {
  if (!(!e || e.code === JI)) return e.code === f8 ? "ok" : e.message || "unknown_error"
}
const Ti = "_sentryChildSpans",
  _m = "_sentryRootSpan";

function b8(e, t) {
  const n = e[_m] || e;
  es(t, _m, n), e[Ti] ? e[Ti].add(t) : es(e, Ti, new Set([t]))
}

function f$(e, t) {
  e[Ti] && e[Ti].delete(t)
}

function pf(e) {
  const t = new Set;

  function n(r) {
    if (!t.has(r) && Ki(r)) {
      t.add(r);
      const s = r[Ti] ? Array.from(r[Ti]) : [];
      for (const a of s) n(a)
    }
  }
  return n(e), Array.from(t)
}

function qn(e) {
  return e[_m] || e
}

function Zn() {
  const e = qi(),
    t = Eu(e);
  return t.getActiveSpan ? t.getActiveSpan() : Wf(Kt())
}

function w8() {
  M_ || (Qi(() => {
    console.warn("[Sentry] Deprecation warning: Returning null from `beforeSendSpan` will be disallowed from SDK version 9.0.0 onwards. The callback will only support mutating spans. To drop certain spans, configure the respective integrations directly.")
  }), M_ = !0)
}
let D_ = !1;

function p$() {
  D_ || (D_ = !0, t8(ym), n8(ym))
}

function ym() {
  const e = Zn(),
    t = e && qn(e);
  if (t) {
    const n = "internal_error";
    at && Me.log(`[Tracing] Root span: ${n} -> Global error occurred`), t.setStatus({
      code: In,
      message: n
    })
  }
}
ym.tag = "sentry_tracingErrorCallback";
const C8 = "_sentryScope",
  x8 = "_sentryIsolationScope";

function h$(e, t, n) {
  e && (es(e, x8, n), es(e, C8, t))
}

function L_(e) {
  return {
    scope: e[C8],
    isolationScope: e[x8]
  }
}

function Bo(e) {
  if (typeof __SENTRY_TRACING__ == "boolean" && !__SENTRY_TRACING__) return !1;
  const t = Dt(),
    n = e || t && t.getOptions();
  return !!n && (n.enableTracing || "tracesSampleRate" in n || "tracesSampler" in n)
}
class Tu {
  constructor(t = {}) {
    this._traceId = t.traceId || No(), this._spanId = t.spanId || Fo()
  }
  spanContext() {
    return {
      spanId: this._spanId,
      traceId: this._traceId,
      traceFlags: v8
    }
  }
  end(t) {}
  setAttribute(t, n) {
    return this
  }
  setAttributes(t) {
    return this
  }
  setStatus(t) {
    return this
  }
  updateName(t) {
    return this
  }
  isRecording() {
    return !1
  }
  addEvent(t, n, r) {
    return this
  }
  addLink(t) {
    return this
  }
  addLinks(t) {
    return this
  }
  recordException(t, n) {}
}
const lg = "production",
  k8 = "_frozenDsc";

function R_(e, t) {
  es(e, k8, t)
}

function S8(e, t) {
  const n = t.getOptions(),
    {
      publicKey: r
    } = t.getDsn() || {},
    s = jn({
      environment: n.environment || lg,
      release: n.release,
      public_key: r,
      trace_id: e
    });
  return t.emit("createDsc", s), s
}

function E8(e, t) {
  const n = t.getPropagationContext();
  return n.dsc || S8(n.traceId, e)
}

function Au(e) {
  const t = Dt();
  if (!t) return {};
  const n = qn(e),
    r = n[k8];
  if (r) return r;
  const s = n.spanContext().traceState,
    a = s && s.get("sentry.dsc"),
    o = a && h8(a);
  if (o) return o;
  const i = S8(e.spanContext().traceId, t),
    l = Tt(n),
    c = l.data || {},
    d = c[d8];
  d != null && (i.sample_rate = `${d}`);
  const f = c[Ea],
    p = l.description;
  return f !== "url" && p && (i.transaction = p), Bo() && (i.sampled = String(Ki(n))), t.emit("createDsc", i, n), i
}

function m$(e) {
  if (!at) return;
  const {
    description: t = "< unknown name >",
    op: n = "< unknown op >",
    parent_span_id: r
  } = Tt(e), {
    spanId: s
  } = e.spanContext(), a = Ki(e), o = qn(e), i = o === e, l = `[Tracing] Starting ${a?"sampled":"unsampled"} ${i?"root ":""}span`, c = [`op: ${n}`, `name: ${t}`, `ID: ${s}`];
  if (r && c.push(`parent ID: ${r}`), !i) {
    const {
      op: d,
      description: f
    } = Tt(o);
    c.push(`root ID: ${o.spanContext().spanId}`), d && c.push(`root op: ${d}`), f && c.push(`root description: ${f}`)
  }
  Me.log(`${l}
  ${c.join(`
  `)}`)
}

function g$(e) {
  if (!at) return;
  const {
    description: t = "< unknown name >",
    op: n = "< unknown op >"
  } = Tt(e), {
    spanId: r
  } = e.spanContext(), a = qn(e) === e, o = `[Tracing] Finishing "${n}" ${a?"root ":""}span "${t}" with ID ${r}`;
  Me.log(o)
}

function T8(e) {
  if (typeof e == "boolean") return Number(e);
  const t = typeof e == "string" ? parseFloat(e) : e;
  if (typeof t != "number" || isNaN(t) || t < 0 || t > 1) {
    at && Me.warn(`[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(e)} of type ${JSON.stringify(typeof e)}.`);
    return
  }
  return t
}

function v$(e, t) {
  if (!Bo(e)) return [!1];
  const n = Qa().getScopeData().sdkProcessingMetadata.normalizedRequest,
    r = {
      ...t,
      normalizedRequest: t.normalizedRequest || n
    };
  let s;
  typeof e.tracesSampler == "function" ? s = e.tracesSampler(r) : r.parentSampled !== void 0 ? s = r.parentSampled : typeof e.tracesSampleRate < "u" ? s = e.tracesSampleRate : s = 1;
  const a = T8(s);
  return a === void 0 ? (at && Me.warn("[Tracing] Discarding transaction because of invalid sample rate."), [!1]) : a ? Math.random() < a ? [!0, a] : (at && Me.log(`[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(s)})`), [!1, a]) : (at && Me.log(`[Tracing] Discarding transaction because ${typeof e.tracesSampler=="function"?"tracesSampler returned 0 or false":"a negative sampling decision was inherited or tracesSampleRate is set to 0"}`), [!1, a])
}
const _$ = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;

function y$(e) {
  return e === "http" || e === "https"
}

function ld(e, t = !1) {
  const {
    host: n,
    path: r,
    pass: s,
    port: a,
    projectId: o,
    protocol: i,
    publicKey: l
  } = e;
  return `${i}://${l}${t&&s?`:${s}`:""}@${n}${a?`:${a}`:""}/${r&&`${r}/`}${o}`
}

function b$(e) {
  const t = _$.exec(e);
  if (!t) {
    Qi(() => {
      console.error(`Invalid Sentry Dsn: ${e}`)
    });
    return
  }
  const [n, r, s = "", a = "", o = "", i = ""] = t.slice(1);
  let l = "",
    c = i;
  const d = c.split("/");
  if (d.length > 1 && (l = d.slice(0, -1).join("/"), c = d.pop()), c) {
    const f = c.match(/^\d+/);
    f && (c = f[0])
  }
  return A8({
    host: a,
    pass: s,
    path: l,
    projectId: c,
    port: o,
    protocol: n,
    publicKey: r
  })
}

function A8(e) {
  return {
    protocol: e.protocol,
    publicKey: e.publicKey || "",
    pass: e.pass || "",
    host: e.host,
    port: e.port || "",
    path: e.path || "",
    projectId: e.projectId
  }
}

function w$(e) {
  if (!Zo) return !0;
  const {
    port: t,
    projectId: n,
    protocol: r
  } = e;
  return ["protocol", "publicKey", "host", "projectId"].find(o => e[o] ? !1 : (Me.error(`Invalid Sentry Dsn: ${o} missing`), !0)) ? !1 : n.match(/^\d+$/) ? y$(r) ? t && isNaN(parseInt(t, 10)) ? (Me.error(`Invalid Sentry Dsn: Invalid port ${t}`), !1) : !0 : (Me.error(`Invalid Sentry Dsn: Invalid protocol ${r}`), !1) : (Me.error(`Invalid Sentry Dsn: Invalid projectId ${n}`), !1)
}

function C$(e) {
  const t = typeof e == "string" ? b$(e) : A8(e);
  if (!(!t || !w$(t))) return t
}

function x$() {
  const e = typeof WeakSet == "function",
    t = e ? new WeakSet : [];

  function n(s) {
    if (e) return t.has(s) ? !0 : (t.add(s), !1);
    for (let a = 0; a < t.length; a++)
      if (t[a] === s) return !0;
    return t.push(s), !1
  }

  function r(s) {
    if (e) t.delete(s);
    else
      for (let a = 0; a < t.length; a++)
        if (t[a] === s) {
          t.splice(a, 1);
          break
        }
  }
  return [n, r]
}

function ga(e, t = 100, n = 1 / 0) {
  try {
    return bm("", e, t, n)
  } catch (r) {
    return {
      ERROR: `**non-serializable** (${r})`
    }
  }
}

function P8(e, t = 3, n = 100 * 1024) {
  const r = ga(e, t);
  return T$(r) > n ? P8(e, t - 1, n) : r
}

function bm(e, t, n = 1 / 0, r = 1 / 0, s = x$()) {
  const [a, o] = s;
  if (t == null || ["boolean", "string"].includes(typeof t) || typeof t == "number" && Number.isFinite(t)) return t;
  const i = k$(e, t);
  if (!i.startsWith("[object ")) return i;
  if (t.__sentry_skip_normalization__) return t;
  const l = typeof t.__sentry_override_normalization_depth__ == "number" ? t.__sentry_override_normalization_depth__ : n;
  if (l === 0) return i.replace("object ", "");
  if (a(t)) return "[Circular ~]";
  const c = t;
  if (c && typeof c.toJSON == "function") try {
    const h = c.toJSON();
    return bm("", h, l - 1, r, s)
  } catch {}
  const d = Array.isArray(t) ? [] : {};
  let f = 0;
  const p = l8(t);
  for (const h in p) {
    if (!Object.prototype.hasOwnProperty.call(p, h)) continue;
    if (f >= r) {
      d[h] = "[MaxProperties ~]";
      break
    }
    const _ = p[h];
    d[h] = bm(h, _, l - 1, r, s), f++
  }
  return o(t), d
}

function k$(e, t) {
  try {
    if (e === "domain" && t && typeof t == "object" && t._events) return "[Domain]";
    if (e === "domainEmitter") return "[DomainEmitter]";
    if (typeof global < "u" && t === global) return "[Global]";
    if (typeof window < "u" && t === window) return "[Window]";
    if (typeof document < "u" && t === document) return "[Document]";
    if (a8(t)) return "[VueViewModel]";
    if (AI(t)) return "[SyntheticEvent]";
    if (typeof t == "number" && !Number.isFinite(t)) return `[${t}]`;
    if (typeof t == "function") return `[Function: ${Ba(t)}]`;
    if (typeof t == "symbol") return `[${String(t)}]`;
    if (typeof t == "bigint") return `[BigInt: ${String(t)}]`;
    const n = S$(t);
    return /^HTML(\w*)Element$/.test(n) ? `[HTMLElement: ${n}]` : `[object ${n}]`
  } catch (n) {
    return `**non-serializable** (${n})`
  }
}

function S$(e) {
  const t = Object.getPrototypeOf(e);
  return t ? t.constructor.name : "null prototype"
}

function E$(e) {
  return ~-encodeURI(e).split(/%..|./).length
}

function T$(e) {
  return E$(JSON.stringify(e))
}

function Pu(e, t = []) {
  return [e, t]
}

function A$(e, t) {
  const [n, r] = e;
  return [n, [...r, t]]
}

function N_(e, t) {
  const n = e[1];
  for (const r of n) {
    const s = r[0].type;
    if (t(r, s)) return !0
  }
  return !1
}

function wm(e) {
  return Ct.__SENTRY__ && Ct.__SENTRY__.encodePolyfill ? Ct.__SENTRY__.encodePolyfill(e) : new TextEncoder().encode(e)
}

function P$(e) {
  const [t, n] = e;
  let r = JSON.stringify(t);

  function s(a) {
    typeof r == "string" ? r = typeof a == "string" ? r + a : [wm(r), a] : r.push(typeof a == "string" ? wm(a) : a)
  }
  for (const a of n) {
    const [o, i] = a;
    if (s(`
${JSON.stringify(o)}
`), typeof i == "string" || i instanceof Uint8Array) s(i);
    else {
      let l;
      try {
        l = JSON.stringify(i)
      } catch {
        l = JSON.stringify(ga(i))
      }
      s(l)
    }
  }
  return typeof r == "string" ? r : I$(r)
}

function I$(e) {
  const t = e.reduce((s, a) => s + a.length, 0),
    n = new Uint8Array(t);
  let r = 0;
  for (const s of e) n.set(s, r), r += s.length;
  return n
}

function $$(e) {
  return [{
    type: "span"
  }, e]
}

function M$(e) {
  const t = typeof e.data == "string" ? wm(e.data) : e.data;
  return [jn({
    type: "attachment",
    length: t.length,
    filename: e.filename,
    content_type: e.contentType,
    attachment_type: e.attachmentType
  }), t]
}
const O$ = {
  session: "session",
  sessions: "session",
  attachment: "attachment",
  transaction: "transaction",
  event: "error",
  client_report: "internal",
  user_report: "default",
  profile: "profile",
  profile_chunk: "profile",
  replay_event: "replay",
  replay_recording: "replay",
  check_in: "monitor",
  feedback: "feedback",
  span: "span",
  statsd: "metric_bucket",
  raw_security: "security"
};

function F_(e) {
  return O$[e]
}

function I8(e) {
  if (!e || !e.sdk) return;
  const {
    name: t,
    version: n
  } = e.sdk;
  return {
    name: t,
    version: n
  }
}

function D$(e, t, n, r) {
  const s = e.sdkProcessingMetadata && e.sdkProcessingMetadata.dynamicSamplingContext;
  return {
    event_id: e.event_id,
    sent_at: new Date().toISOString(),
    ...t && {
      sdk: t
    },
    ...!!n && r && {
      dsn: ld(r)
    },
    ...s && {
      trace: jn({
        ...s
      })
    }
  }
}

function L$(e, t) {
  return t && (e.sdk = e.sdk || {}, e.sdk.name = e.sdk.name || t.name, e.sdk.version = e.sdk.version || t.version, e.sdk.integrations = [...e.sdk.integrations || [], ...t.integrations || []], e.sdk.packages = [...e.sdk.packages || [], ...t.packages || []]), e
}

function R$(e, t, n, r) {
  const s = I8(n),
    a = {
      sent_at: new Date().toISOString(),
      ...s && {
        sdk: s
      },
      ...!!r && t && {
        dsn: ld(t)
      }
    },
    o = "aggregates" in e ? [{
      type: "sessions"
    }, e] : [{
      type: "session"
    }, e.toJSON()];
  return Pu(a, [o])
}

function N$(e, t, n, r) {
  const s = I8(n),
    a = e.type && e.type !== "replay_event" ? e.type : "event";
  L$(e, n && n.sdk);
  const o = D$(e, s, r, t);
  return delete e.sdkProcessingMetadata, Pu(o, [
    [{
      type: a
    }, e]
  ])
}

function F$(e, t) {
  function n(d) {
    return !!d.trace_id && !!d.public_key
  }
  const r = Au(e[0]),
    s = t && t.getDsn(),
    a = t && t.getOptions().tunnel,
    o = {
      sent_at: new Date().toISOString(),
      ...n(r) && {
        trace: r
      },
      ...!!a && s && {
        dsn: ld(s)
      }
    },
    i = t && t.getOptions().beforeSendSpan,
    l = i ? d => {
      const f = i(Tt(d));
      return f || w8(), f
    } : d => Tt(d),
    c = [];
  for (const d of e) {
    const f = l(d);
    f && c.push($$(f))
  }
  return Pu(o, c)
}

function B$(e, t, n, r = Zn()) {
  const s = r && qn(r);
  s && (at && Me.log(`[Measurement] Setting measurement on root span: ${e} = ${t} ${n}`), s.addEvent(e, {
    [Hp]: t,
    [jp]: n
  }))
}

function B_(e) {
  if (!e || e.length === 0) return;
  const t = {};
  return e.forEach(n => {
    const r = n.attributes || {},
      s = r[jp],
      a = r[Hp];
    typeof s == "string" && typeof a == "number" && (t[n.name] = {
      value: a,
      unit: s
    })
  }), t
}
const j_ = 1e3;
class ug {
  constructor(t = {}) {
    this._traceId = t.traceId || No(), this._spanId = t.spanId || Fo(), this._startTime = t.startTimestamp || cr(), this._attributes = {}, this.setAttributes({
      [Mn]: "manual",
      [Hi]: t.op,
      ...t.attributes
    }), this._name = t.name, t.parentSpanId && (this._parentSpanId = t.parentSpanId), "sampled" in t && (this._sampled = t.sampled), t.endTimestamp && (this._endTime = t.endTimestamp), this._events = [], this._isStandaloneSpan = t.isStandalone, this._endTime && this._onSpanEnded()
  }
  addLink(t) {
    return this
  }
  addLinks(t) {
    return this
  }
  recordException(t, n) {}
  spanContext() {
    const {
      _spanId: t,
      _traceId: n,
      _sampled: r
    } = this;
    return {
      spanId: t,
      traceId: n,
      traceFlags: r ? _8 : v8
    }
  }
  setAttribute(t, n) {
    return n === void 0 ? delete this._attributes[t] : this._attributes[t] = n, this
  }
  setAttributes(t) {
    return Object.keys(t).forEach(n => this.setAttribute(n, t[n])), this
  }
  updateStartTime(t) {
    this._startTime = Ei(t)
  }
  setStatus(t) {
    return this._status = t, this
  }
  updateName(t) {
    return this._name = t, this.setAttribute(Ea, "custom"), this
  }
  end(t) {
    this._endTime || (this._endTime = Ei(t), g$(this), this._onSpanEnded())
  }
  getSpanJSON() {
    return jn({
      data: this._attributes,
      description: this._name,
      op: this._attributes[Hi],
      parent_span_id: this._parentSpanId,
      span_id: this._spanId,
      start_timestamp: this._startTime,
      status: y8(this._status),
      timestamp: this._endTime,
      trace_id: this._traceId,
      origin: this._attributes[Mn],
      _metrics_summary: gm(this),
      profile_id: this._attributes[ZI],
      exclusive_time: this._attributes[og],
      measurements: B_(this._events),
      is_segment: this._isStandaloneSpan && qn(this) === this || void 0,
      segment_id: this._isStandaloneSpan ? qn(this).spanContext().spanId : void 0
    })
  }
  isRecording() {
    return !this._endTime && !!this._sampled
  }
  addEvent(t, n, r) {
    at && Me.log("[Tracing] Adding an event to span:", t);
    const s = H_(n) ? n : r || cr(),
      a = H_(n) ? {} : n || {},
      o = {
        name: t,
        time: Ei(s),
        attributes: a
      };
    return this._events.push(o), this
  }
  isStandaloneSpan() {
    return !!this._isStandaloneSpan
  }
  _onSpanEnded() {
    const t = Dt();
    if (t && t.emit("spanEnd", this), !(this._isStandaloneSpan || this === qn(this))) return;
    if (this._isStandaloneSpan) {
      this._sampled ? H$(F$([this], t)) : (at && Me.log("[Tracing] Discarding standalone span because its trace was not chosen to be sampled."), t && t.recordDroppedEvent("sample_rate", "span"));
      return
    }
    const r = this._convertSpanToTransaction();
    r && (L_(this).scope || Kt()).captureEvent(r)
  }
  _convertSpanToTransaction() {
    if (!V_(Tt(this))) return;
    this._name || (at && Me.warn("Transaction has no name, falling back to `<unlabeled transaction>`."), this._name = "<unlabeled transaction>");
    const {
      scope: t,
      isolationScope: n
    } = L_(this), s = (t || Kt()).getClient() || Dt();
    if (this._sampled !== !0) {
      at && Me.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled."), s && s.recordDroppedEvent("sample_rate", "transaction");
      return
    }
    const o = pf(this).filter(f => f !== this && !j$(f)).map(f => Tt(f)).filter(V_),
      i = this._attributes[Ea];
    delete this._attributes[I_], o.forEach(f => {
      f.data && delete f.data[I_]
    });
    const l = {
        contexts: {
          trace: i$(this)
        },
        spans: o.length > j_ ? o.sort((f, p) => f.start_timestamp - p.start_timestamp).slice(0, j_) : o,
        start_timestamp: this._startTime,
        timestamp: this._endTime,
        transaction: this._name,
        type: "transaction",
        sdkProcessingMetadata: {
          capturedSpanScope: t,
          capturedSpanIsolationScope: n,
          ...jn({
            dynamicSamplingContext: Au(this)
          })
        },
        _metrics_summary: gm(this),
        ...i && {
          transaction_info: {
            source: i
          }
        }
      },
      c = B_(this._events);
    return c && Object.keys(c).length && (at && Me.log("[Measurements] Adding measurements to transaction event", JSON.stringify(c, void 0, 2)), l.measurements = c), l
  }
}

function H_(e) {
  return e && typeof e == "number" || e instanceof Date || Array.isArray(e)
}

function V_(e) {
  return !!e.start_timestamp && !!e.timestamp && !!e.span_id && !!e.trace_id
}

function j$(e) {
  return e instanceof ug && e.isStandaloneSpan()
}

function H$(e) {
  const t = Dt();
  if (!t) return;
  const n = e[1];
  if (!n || n.length === 0) {
    t.recordDroppedEvent("before_send", "span");
    return
  }
  t.sendEnvelope(e)
}
const $8 = "__SENTRY_SUPPRESS_TRACING__";

function ud(e) {
  const t = O8();
  if (t.startInactiveSpan) return t.startInactiveSpan(e);
  const n = U$(e),
    {
      forceTransaction: r,
      parentSpan: s
    } = e;
  return (e.scope ? o => ag(e.scope, o) : s !== void 0 ? o => M8(s, o) : o => o())(() => {
    const o = Kt(),
      i = Y$(o);
    return e.onlyIfParent && !i ? new Tu : V$({
      parentSpan: i,
      spanArguments: n,
      forceTransaction: r,
      scope: o
    })
  })
}

function M8(e, t) {
  const n = O8();
  return n.withActiveSpan ? n.withActiveSpan(e, t) : ag(r => (Dc(r, e || void 0), t(r)))
}

function V$({
  parentSpan: e,
  spanArguments: t,
  forceTransaction: n,
  scope: r
}) {
  if (!Bo()) return new Tu;
  const s = Qa();
  let a;
  if (e && !n) a = z$(e, r, t), b8(e, a);
  else if (e) {
    const o = Au(e),
      {
        traceId: i,
        spanId: l
      } = e.spanContext(),
      c = Ki(e);
    a = U_({
      traceId: i,
      parentSpanId: l,
      ...t
    }, r, c), R_(a, o)
  } else {
    const {
      traceId: o,
      dsc: i,
      parentSpanId: l,
      sampled: c
    } = {
      ...s.getPropagationContext(),
      ...r.getPropagationContext()
    };
    a = U_({
      traceId: o,
      parentSpanId: l,
      ...t
    }, r, c), i && R_(a, i)
  }
  return m$(a), h$(a, r, s), a
}

function U$(e) {
  const n = {
    isStandalone: (e.experimental || {}).standalone,
    ...e
  };
  if (e.startTime) {
    const r = {
      ...n
    };
    return r.startTimestamp = Ei(e.startTime), delete r.startTime, r
  }
  return n
}

function O8() {
  const e = qi();
  return Eu(e)
}

function U_(e, t, n) {
  const r = Dt(),
    s = r && r.getOptions() || {},
    {
      name: a = "",
      attributes: o
    } = e,
    [i, l] = t.getScopeData().sdkProcessingMetadata[$8] ? [!1] : v$(s, {
      name: a,
      parentSampled: n,
      attributes: o,
      transactionContext: {
        name: a,
        parentSampled: n
      }
    }),
    c = new ug({
      ...e,
      attributes: {
        [Ea]: "custom",
        ...e.attributes
      },
      sampled: i
    });
  return l !== void 0 && c.setAttribute(d8, l), r && r.emit("spanStart", c), c
}

function z$(e, t, n) {
  const {
    spanId: r,
    traceId: s
  } = e.spanContext(), a = t.getScopeData().sdkProcessingMetadata[$8] ? !1 : Ki(e), o = a ? new ug({
    ...n,
    parentSpanId: r,
    traceId: s,
    sampled: a
  }) : new Tu({
    traceId: s
  });
  b8(e, o);
  const i = Dt();
  return i && (i.emit("spanStart", o), n.endTimestamp && i.emit("spanEnd", o)), o
}

function Y$(e) {
  const t = Wf(e);
  if (!t) return;
  const n = Dt();
  return (n ? n.getOptions() : {}).parentSpanIsAlwaysRootSpan ? qn(t) : t
}
const hf = {
    idleTimeout: 1e3,
    finalTimeout: 3e4,
    childSpanTimeout: 15e3
  },
  W$ = "heartbeatFailed",
  G$ = "idleTimeout",
  Q$ = "finalTimeout",
  q$ = "externalFinish";

function D8(e, t = {}) {
  const n = new Map;
  let r = !1,
    s, a = q$,
    o = !t.disableAutoFinish;
  const i = [],
    {
      idleTimeout: l = hf.idleTimeout,
      finalTimeout: c = hf.finalTimeout,
      childSpanTimeout: d = hf.childSpanTimeout,
      beforeSpanEnd: f
    } = t,
    p = Dt();
  if (!p || !Bo()) return new Tu;
  const h = Kt(),
    _ = Zn(),
    v = K$(e);
  v.end = new Proxy(v.end, {
    apply(S, T, j) {
      f && f(v);
      const [P, ...N] = j, ne = P || cr(), Y = Ei(ne), _e = pf(v).filter(de => de !== v);
      if (!_e.length) return E(Y), Reflect.apply(S, T, [Y, ...N]);
      const Q = _e.map(de => Tt(de).timestamp).filter(de => !!de),
        re = Q.length ? Math.max(...Q) : void 0,
        J = Tt(v).start_timestamp,
        ee = Math.min(J ? J + c / 1e3 : 1 / 0, Math.max(J || -1 / 0, Math.min(Y, re || 1 / 0)));
      return E(ee), Reflect.apply(S, T, [ee, ...N])
    }
  });

  function C() {
    s && (clearTimeout(s), s = void 0)
  }

  function y(S) {
    C(), s = setTimeout(() => {
      !r && n.size === 0 && o && (a = G$, v.end(S))
    }, l)
  }

  function b(S) {
    s = setTimeout(() => {
      !r && o && (a = W$, v.end(S))
    }, d)
  }

  function w(S) {
    C(), n.set(S, !0);
    const T = cr();
    b(T + d / 1e3)
  }

  function x(S) {
    if (n.has(S) && n.delete(S), n.size === 0) {
      const T = cr();
      y(T + l / 1e3)
    }
  }

  function E(S) {
    r = !0, n.clear(), i.forEach(Y => Y()), Dc(h, _);
    const T = Tt(v),
      {
        start_timestamp: j
      } = T;
    if (!j) return;
    (T.data || {})[vm] || v.setAttribute(vm, a), Me.log(`[Tracing] Idle span "${T.op}" finished`);
    const N = pf(v).filter(Y => Y !== v);
    let ne = 0;
    N.forEach(Y => {
      Y.isRecording() && (Y.setStatus({
        code: In,
        message: "cancelled"
      }), Y.end(S), at && Me.log("[Tracing] Cancelling span since span ended early", JSON.stringify(Y, void 0, 2)));
      const _e = Tt(Y),
        {
          timestamp: Q = 0,
          start_timestamp: re = 0
        } = _e,
        J = re <= S,
        ee = (c + l) / 1e3,
        de = Q - re <= ee;
      if (at) {
        const se = JSON.stringify(Y, void 0, 2);
        J ? de || Me.log("[Tracing] Discarding span since it finished after idle span final timeout", se) : Me.log("[Tracing] Discarding span since it happened after idle span was finished", se)
      }(!de || !J) && (f$(v, Y), ne++)
    }), ne > 0 && v.setAttribute("sentry.idle_span_discarded_spans", ne)
  }
  return i.push(p.on("spanStart", S => {
    if (r || S === v || Tt(S).timestamp) return;
    pf(v).includes(S) && w(S.spanContext().spanId)
  })), i.push(p.on("spanEnd", S => {
    r || x(S.spanContext().spanId)
  })), i.push(p.on("idleSpanEnableAutoFinish", S => {
    S === v && (o = !0, y(), n.size && b())
  })), t.disableAutoFinish || y(), setTimeout(() => {
    r || (v.setStatus({
      code: In,
      message: "deadline_exceeded"
    }), a = Q$, v.end())
  }, c), v
}

function K$(e) {
  const t = ud(e);
  return Dc(Kt(), t), at && Me.log("[Tracing] Started span is an idle span"), t
}

function Cm(e, t, n, r = 0) {
  return new Wr((s, a) => {
    const o = e[r];
    if (t === null || typeof o != "function") s(t);
    else {
      const i = o({
        ...t
      }, n);
      at && o.id && i === null && Me.log(`Event processor "${o.id}" dropped event`), Fp(i) ? i.then(l => Cm(e, l, n, r + 1).then(s)).then(null, a) : Cm(e, i, n, r + 1).then(s).then(null, a)
    }
  })
}
let zd, z_, Yd;

function Z$(e) {
  const t = Ct._sentryDebugIds;
  if (!t) return {};
  const n = Object.keys(t);
  return Yd && n.length === z_ || (z_ = n.length, Yd = n.reduce((r, s) => {
    zd || (zd = {});
    const a = zd[s];
    if (a) r[a[0]] = a[1];
    else {
      const o = e(s);
      for (let i = o.length - 1; i >= 0; i--) {
        const l = o[i],
          c = l && l.filename,
          d = t[s];
        if (c && d) {
          r[c] = d, zd[s] = [c, d];
          break
        }
      }
    }
    return r
  }, {})), Yd
}

function J$(e, t) {
  const {
    fingerprint: n,
    span: r,
    breadcrumbs: s,
    sdkProcessingMetadata: a
  } = t;
  X$(e, t), r && nM(e, r), rM(e, n), eM(e, s), tM(e, a)
}

function Y_(e, t) {
  const {
    extra: n,
    tags: r,
    user: s,
    contexts: a,
    level: o,
    sdkProcessingMetadata: i,
    breadcrumbs: l,
    fingerprint: c,
    eventProcessors: d,
    attachments: f,
    propagationContext: p,
    transactionName: h,
    span: _
  } = t;
  Wd(e, "extra", n), Wd(e, "tags", r), Wd(e, "user", s), Wd(e, "contexts", a), e.sdkProcessingMetadata = Bp(e.sdkProcessingMetadata, i, 2), o && (e.level = o), h && (e.transactionName = h), _ && (e.span = _), l.length && (e.breadcrumbs = [...e.breadcrumbs, ...l]), c.length && (e.fingerprint = [...e.fingerprint, ...c]), d.length && (e.eventProcessors = [...e.eventProcessors, ...d]), f.length && (e.attachments = [...e.attachments, ...f]), e.propagationContext = {
    ...e.propagationContext,
    ...p
  }
}

function Wd(e, t, n) {
  e[t] = Bp(e[t], n, 1)
}

function X$(e, t) {
  const {
    extra: n,
    tags: r,
    user: s,
    contexts: a,
    level: o,
    transactionName: i
  } = t, l = jn(n);
  l && Object.keys(l).length && (e.extra = {
    ...l,
    ...e.extra
  });
  const c = jn(r);
  c && Object.keys(c).length && (e.tags = {
    ...c,
    ...e.tags
  });
  const d = jn(s);
  d && Object.keys(d).length && (e.user = {
    ...d,
    ...e.user
  });
  const f = jn(a);
  f && Object.keys(f).length && (e.contexts = {
    ...f,
    ...e.contexts
  }), o && (e.level = o), i && e.type !== "transaction" && (e.transaction = i)
}

function eM(e, t) {
  const n = [...e.breadcrumbs || [], ...t];
  e.breadcrumbs = n.length ? n : void 0
}

function tM(e, t) {
  e.sdkProcessingMetadata = {
    ...e.sdkProcessingMetadata,
    ...t
  }
}

function nM(e, t) {
  e.contexts = {
    trace: l$(t),
    ...e.contexts
  }, e.sdkProcessingMetadata = {
    dynamicSamplingContext: Au(t),
    ...e.sdkProcessingMetadata
  };
  const n = qn(t),
    r = Tt(n).description;
  r && !e.transaction && e.type === "transaction" && (e.transaction = r)
}

function rM(e, t) {
  e.fingerprint = e.fingerprint ? Array.isArray(e.fingerprint) ? e.fingerprint : [e.fingerprint] : [], t && (e.fingerprint = e.fingerprint.concat(t)), e.fingerprint && !e.fingerprint.length && delete e.fingerprint
}

function sM(e, t, n, r, s, a) {
  const {
    normalizeDepth: o = 3,
    normalizeMaxBreadth: i = 1e3
  } = e, l = {
    ...t,
    event_id: t.event_id || n.event_id || qr(),
    timestamp: t.timestamp || id()
  }, c = n.integrations || e.integrations.map(C => C.name);
  aM(l, e), lM(l, c), s && s.emit("applyFrameMetadata", t), t.type === void 0 && oM(l, e.stackParser);
  const d = cM(r, n.captureContext);
  n.mechanism && Jl(l, n.mechanism);
  const f = s ? s.getEventProcessors() : [],
    p = QI().getScopeData();
  if (a) {
    const C = a.getScopeData();
    Y_(p, C)
  }
  if (d) {
    const C = d.getScopeData();
    Y_(p, C)
  }
  const h = [...n.attachments || [], ...p.attachments];
  h.length && (n.attachments = h), J$(l, p);
  const _ = [...f, ...p.eventProcessors];
  return Cm(_, l, n).then(C => (C && iM(C), typeof o == "number" && o > 0 ? uM(C, o, i) : C))
}

function aM(e, t) {
  const {
    environment: n,
    release: r,
    dist: s,
    maxValueLength: a = 250
  } = t;
  e.environment = e.environment || n || lg, !e.release && r && (e.release = r), !e.dist && s && (e.dist = s), e.message && (e.message = Tl(e.message, a));
  const o = e.exception && e.exception.values && e.exception.values[0];
  o && o.value && (o.value = Tl(o.value, a));
  const i = e.request;
  i && i.url && (i.url = Tl(i.url, a))
}

function oM(e, t) {
  const n = Z$(t);
  try {
    e.exception.values.forEach(r => {
      r.stacktrace.frames.forEach(s => {
        n && s.filename && (s.debug_id = n[s.filename])
      })
    })
  } catch {}
}

function iM(e) {
  const t = {};
  try {
    e.exception.values.forEach(r => {
      r.stacktrace.frames.forEach(s => {
        s.debug_id && (s.abs_path ? t[s.abs_path] = s.debug_id : s.filename && (t[s.filename] = s.debug_id), delete s.debug_id)
      })
    })
  } catch {}
  if (Object.keys(t).length === 0) return;
  e.debug_meta = e.debug_meta || {}, e.debug_meta.images = e.debug_meta.images || [];
  const n = e.debug_meta.images;
  Object.entries(t).forEach(([r, s]) => {
    n.push({
      type: "sourcemap",
      code_file: r,
      debug_id: s
    })
  })
}

function lM(e, t) {
  t.length > 0 && (e.sdk = e.sdk || {}, e.sdk.integrations = [...e.sdk.integrations || [], ...t])
}

function uM(e, t, n) {
  if (!e) return null;
  const r = {
    ...e,
    ...e.breadcrumbs && {
      breadcrumbs: e.breadcrumbs.map(s => ({
        ...s,
        ...s.data && {
          data: ga(s.data, t, n)
        }
      }))
    },
    ...e.user && {
      user: ga(e.user, t, n)
    },
    ...e.contexts && {
      contexts: ga(e.contexts, t, n)
    },
    ...e.extra && {
      extra: ga(e.extra, t, n)
    }
  };
  return e.contexts && e.contexts.trace && r.contexts && (r.contexts.trace = e.contexts.trace, e.contexts.trace.data && (r.contexts.trace.data = ga(e.contexts.trace.data, t, n))), e.spans && (r.spans = e.spans.map(s => ({
    ...s,
    ...s.data && {
      data: ga(s.data, t, n)
    }
  }))), e.contexts && e.contexts.flags && r.contexts && (r.contexts.flags = ga(e.contexts.flags, 3, n)), r
}

function cM(e, t) {
  if (!t) return e;
  const n = e ? e.clone() : new ji;
  return n.update(t), n
}

function L8(e, t) {
  return Kt().captureException(e, void 0)
}

function dM(e, t) {
  const r = {
    captureContext: t
  };
  return Kt().captureMessage(e, void 0, r)
}

function R8(e, t) {
  return Kt().captureEvent(e, t)
}

function fM(e) {
  Qa().setTags(e)
}

function pM() {
  const e = Dt();
  return !!e && e.getOptions().enabled !== !1 && !!e.getTransport()
}

function W_(e) {
  const t = Dt(),
    n = Qa(),
    r = Kt(),
    {
      release: s,
      environment: a = lg
    } = t && t.getOptions() || {},
    {
      userAgent: o
    } = Ct.navigator || {},
    i = FI({
      release: s,
      environment: a,
      user: r.getUser() || n.getUser(),
      ...o && {
        userAgent: o
      },
      ...e
    }),
    l = n.getSession();
  return l && l.status === "ok" && Xl(l, {
    status: "exited"
  }), N8(), n.setSession(i), r.setSession(i), i
}

function N8() {
  const e = Qa(),
    t = Kt(),
    n = t.getSession() || e.getSession();
  n && BI(n), F8(), e.setSession(), t.setSession()
}

function F8() {
  const e = Qa(),
    t = Kt(),
    n = Dt(),
    r = t.getSession() || e.getSession();
  r && n && n.captureSession(r)
}

function G_(e = !1) {
  if (e) {
    N8();
    return
  }
  F8()
}
const hM = "7";

function mM(e) {
  const t = e.protocol ? `${e.protocol}:` : "",
    n = e.port ? `:${e.port}` : "";
  return `${t}//${e.host}${n}${e.path?`/${e.path}`:""}/api/`
}

function gM(e) {
  return `${mM(e)}${e.projectId}/envelope/`
}

function vM(e, t) {
  const n = {
    sentry_version: hM
  };
  return e.publicKey && (n.sentry_key = e.publicKey), t && (n.sentry_client = `${t.name}/${t.version}`), new URLSearchParams(n).toString()
}

function _M(e, t, n) {
  return t || `${gM(e)}?${vM(e,n)}`
}
const Q_ = [];

function yM(e) {
  const t = {};
  return e.forEach(n => {
    const {
      name: r
    } = n, s = t[r];
    s && !s.isDefaultInstance && n.isDefaultInstance || (t[r] = n)
  }), Object.values(t)
}

function bM(e) {
  const t = e.defaultIntegrations || [],
    n = e.integrations;
  t.forEach(o => {
    o.isDefaultInstance = !0
  });
  let r;
  if (Array.isArray(n)) r = [...t, ...n];
  else if (typeof n == "function") {
    const o = n(t);
    r = Array.isArray(o) ? o : [o]
  } else r = t;
  const s = yM(r),
    a = s.findIndex(o => o.name === "Debug");
  if (a > -1) {
    const [o] = s.splice(a, 1);
    s.push(o)
  }
  return s
}

function wM(e, t) {
  const n = {};
  return t.forEach(r => {
    r && B8(e, r, n)
  }), n
}

function q_(e, t) {
  for (const n of t) n && n.afterAllSetup && n.afterAllSetup(e)
}

function B8(e, t, n) {
  if (n[t.name]) {
    at && Me.log(`Integration skipped because it was already installed: ${t.name}`);
    return
  }
  if (n[t.name] = t, Q_.indexOf(t.name) === -1 && typeof t.setupOnce == "function" && (t.setupOnce(), Q_.push(t.name)), t.setup && typeof t.setup == "function" && t.setup(e), typeof t.preprocessEvent == "function") {
    const r = t.preprocessEvent.bind(t);
    e.on("preprocessEvent", (s, a) => r(s, a, e))
  }
  if (typeof t.processEvent == "function") {
    const r = t.processEvent.bind(t),
      s = Object.assign((a, o) => r(a, o, e), {
        id: t.name
      });
    e.addEventProcessor(s)
  }
  at && Me.log(`Integration installed: ${t.name}`)
}

function CM(e, t, n) {
  const r = [{
    type: "client_report"
  }, {
    timestamp: id(),
    discarded_events: e
  }];
  return Pu(t ? {
    dsn: t
  } : {}, [r])
}
class ms extends Error {
  constructor(t, n = "warn") {
    super(t), this.message = t, this.logLevel = n
  }
}
const K_ = "Not capturing exception because it's already been captured.";
class xM {
  constructor(t) {
    if (this._options = t, this._integrations = {}, this._numProcessing = 0, this._outcomes = {}, this._hooks = {}, this._eventProcessors = [], t.dsn ? this._dsn = C$(t.dsn) : at && Me.warn("No DSN provided, client will not send events."), this._dsn) {
      const s = _M(this._dsn, t.tunnel, t._metadata ? t._metadata.sdk : void 0);
      this._transport = t.transport({
        tunnel: this._options.tunnel,
        recordDroppedEvent: this.recordDroppedEvent.bind(this),
        ...t.transportOptions,
        url: s
      })
    }
    const r = ["enableTracing", "tracesSampleRate", "tracesSampler"].find(s => s in t && t[s] == null);
    r && Qi(() => {
      console.warn(`[Sentry] Deprecation warning: \`${r}\` is set to undefined, which leads to tracing being enabled. In v9, a value of \`undefined\` will result in tracing being disabled.`)
    })
  }
  captureException(t, n, r) {
    const s = qr();
    if (A_(t)) return at && Me.log(K_), s;
    const a = {
      event_id: s,
      ...n
    };
    return this._process(this.eventFromException(t, a).then(o => this._captureEvent(o, a, r))), a.event_id
  }
  captureMessage(t, n, r, s) {
    const a = {
        event_id: qr(),
        ...r
      },
      o = tg(t) ? t : String(t),
      i = ng(t) ? this.eventFromMessage(o, n, a) : this.eventFromException(t, a);
    return this._process(i.then(l => this._captureEvent(l, a, s))), a.event_id
  }
  captureEvent(t, n, r) {
    const s = qr();
    if (n && n.originalException && A_(n.originalException)) return at && Me.log(K_), s;
    const a = {
        event_id: s,
        ...n
      },
      i = (t.sdkProcessingMetadata || {}).capturedSpanScope;
    return this._process(this._captureEvent(t, a, i || r)), a.event_id
  }
  captureSession(t) {
    typeof t.release != "string" ? at && Me.warn("Discarded session because of missing or non-string release") : (this.sendSession(t), Xl(t, {
      init: !1
    }))
  }
  getDsn() {
    return this._dsn
  }
  getOptions() {
    return this._options
  }
  getSdkMetadata() {
    return this._options._metadata
  }
  getTransport() {
    return this._transport
  }
  flush(t) {
    const n = this._transport;
    return n ? (this.emit("flush"), this._isClientDoneProcessing(t).then(r => n.flush(t).then(s => r && s))) : Bi(!0)
  }
  close(t) {
    return this.flush(t).then(n => (this.getOptions().enabled = !1, this.emit("close"), n))
  }
  getEventProcessors() {
    return this._eventProcessors
  }
  addEventProcessor(t) {
    this._eventProcessors.push(t)
  }
  init() {
    (this._isEnabled() || this._options.integrations.some(({
      name: t
    }) => t.startsWith("Spotlight"))) && this._setupIntegrations()
  }
  getIntegrationByName(t) {
    return this._integrations[t]
  }
  addIntegration(t) {
    const n = this._integrations[t.name];
    B8(this, t, this._integrations), n || q_(this, [t])
  }
  sendEvent(t, n = {}) {
    this.emit("beforeSendEvent", t, n);
    let r = N$(t, this._dsn, this._options._metadata, this._options.tunnel);
    for (const a of n.attachments || []) r = A$(r, M$(a));
    const s = this.sendEnvelope(r);
    s && s.then(a => this.emit("afterSendEvent", t, a), null)
  }
  sendSession(t) {
    const n = R$(t, this._dsn, this._options._metadata, this._options.tunnel);
    this.sendEnvelope(n)
  }
  recordDroppedEvent(t, n, r) {
    if (this._options.sendClientReports) {
      const s = typeof r == "number" ? r : 1,
        a = `${t}:${n}`;
      at && Me.log(`Recording outcome: "${a}"${s>1?` (${s} times)`:""}`), this._outcomes[a] = (this._outcomes[a] || 0) + s
    }
  }
  on(t, n) {
    const r = this._hooks[t] = this._hooks[t] || [];
    return r.push(n), () => {
      const s = r.indexOf(n);
      s > -1 && r.splice(s, 1)
    }
  }
  emit(t, ...n) {
    const r = this._hooks[t];
    r && r.forEach(s => s(...n))
  }
  sendEnvelope(t) {
    return this.emit("beforeEnvelope", t), this._isEnabled() && this._transport ? this._transport.send(t).then(null, n => (at && Me.error("Error while sending envelope:", n), n)) : (at && Me.error("Transport disabled"), Bi({}))
  }
  _setupIntegrations() {
    const {
      integrations: t
    } = this._options;
    this._integrations = wM(this, t), q_(this, t)
  }
  _updateSessionFromEvent(t, n) {
    let r = n.level === "fatal",
      s = !1;
    const a = n.exception && n.exception.values;
    if (a) {
      s = !0;
      for (const l of a) {
        const c = l.mechanism;
        if (c && c.handled === !1) {
          r = !0;
          break
        }
      }
    }
    const o = t.status === "ok";
    (o && t.errors === 0 || o && r) && (Xl(t, {
      ...r && {
        status: "crashed"
      },
      errors: t.errors || Number(s || r)
    }), this.captureSession(t))
  }
  _isClientDoneProcessing(t) {
    return new Wr(n => {
      let r = 0;
      const s = 1,
        a = setInterval(() => {
          this._numProcessing == 0 ? (clearInterval(a), n(!0)) : (r += s, t && r >= t && (clearInterval(a), n(!1)))
        }, s)
    })
  }
  _isEnabled() {
    return this.getOptions().enabled !== !1 && this._transport !== void 0
  }
  _prepareEvent(t, n, r = Kt(), s = Qa()) {
    const a = this.getOptions(),
      o = Object.keys(this._integrations);
    return !n.integrations && o.length > 0 && (n.integrations = o), this.emit("preprocessEvent", t, n), t.type || s.setLastEventId(t.event_id || n.event_id), sM(a, t, n, r, this, s).then(i => {
      if (i === null) return i;
      i.contexts = {
        trace: qI(r),
        ...i.contexts
      };
      const l = E8(this, r);
      return i.sdkProcessingMetadata = {
        dynamicSamplingContext: l,
        ...i.sdkProcessingMetadata
      }, i
    })
  }
  _captureEvent(t, n = {}, r) {
    return this._processEvent(t, n, r).then(s => s.event_id, s => {
      at && (s instanceof ms && s.logLevel === "log" ? Me.log(s.message) : Me.warn(s))
    })
  }
  _processEvent(t, n, r) {
    const s = this.getOptions(),
      {
        sampleRate: a
      } = s,
      o = H8(t),
      i = j8(t),
      l = t.type || "error",
      c = `before send for type \`${l}\``,
      d = typeof a > "u" ? void 0 : T8(a);
    if (i && typeof d == "number" && Math.random() > d) return this.recordDroppedEvent("sample_rate", "error", t), Yf(new ms(`Discarding event because it's not included in the random sample (sampling rate = ${a})`, "log"));
    const f = l === "replay_event" ? "replay" : l,
      h = (t.sdkProcessingMetadata || {}).capturedSpanIsolationScope;
    return this._prepareEvent(t, n, r, h).then(_ => {
      if (_ === null) throw this.recordDroppedEvent("event_processor", f, t), new ms("An event processor returned `null`, will not send event.", "log");
      if (n.data && n.data.__sentry__ === !0) return _;
      const C = SM(this, s, _, n);
      return kM(C, c)
    }).then(_ => {
      if (_ === null) {
        if (this.recordDroppedEvent("before_send", f, t), o) {
          const b = 1 + (t.spans || []).length;
          this.recordDroppedEvent("before_send", "span", b)
        }
        throw new ms(`${c} returned \`null\`, will not send event.`, "log")
      }
      const v = r && r.getSession();
      if (!o && v && this._updateSessionFromEvent(v, _), o) {
        const y = _.sdkProcessingMetadata && _.sdkProcessingMetadata.spanCountBeforeProcessing || 0,
          b = _.spans ? _.spans.length : 0,
          w = y - b;
        w > 0 && this.recordDroppedEvent("before_send", "span", w)
      }
      const C = _.transaction_info;
      if (o && C && _.transaction !== t.transaction) {
        const y = "custom";
        _.transaction_info = {
          ...C,
          source: y
        }
      }
      return this.sendEvent(_, n), _
    }).then(null, _ => {
      throw _ instanceof ms ? _ : (this.captureException(_, {
        data: {
          __sentry__: !0
        },
        originalException: _
      }), new ms(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${_}`))
    })
  }
  _process(t) {
    this._numProcessing++, t.then(n => (this._numProcessing--, n), n => (this._numProcessing--, n))
  }
  _clearOutcomes() {
    const t = this._outcomes;
    return this._outcomes = {}, Object.entries(t).map(([n, r]) => {
      const [s, a] = n.split(":");
      return {
        reason: s,
        category: a,
        quantity: r
      }
    })
  }
  _flushOutcomes() {
    at && Me.log("Flushing outcomes...");
    const t = this._clearOutcomes();
    if (t.length === 0) {
      at && Me.log("No outcomes to send");
      return
    }
    if (!this._dsn) {
      at && Me.log("No dsn provided, will not send outcomes");
      return
    }
    at && Me.log("Sending outcomes:", t);
    const n = CM(t, this._options.tunnel && ld(this._dsn));
    this.sendEnvelope(n)
  }
}

function kM(e, t) {
  const n = `${t} must return \`null\` or a valid event.`;
  if (Fp(e)) return e.then(r => {
    if (!Zl(r) && r !== null) throw new ms(n);
    return r
  }, r => {
    throw new ms(`${t} rejected with ${r}`)
  });
  if (!Zl(e) && e !== null) throw new ms(n);
  return e
}

function SM(e, t, n, r) {
  const {
    beforeSend: s,
    beforeSendTransaction: a,
    beforeSendSpan: o
  } = t;
  if (j8(n) && s) return s(n, r);
  if (H8(n)) {
    if (n.spans && o) {
      const i = [];
      for (const l of n.spans) {
        const c = o(l);
        c ? i.push(c) : (w8(), e.recordDroppedEvent("before_send", "span"))
      }
      n.spans = i
    }
    if (a) {
      if (n.spans) {
        const i = n.spans.length;
        n.sdkProcessingMetadata = {
          ...n.sdkProcessingMetadata,
          spanCountBeforeProcessing: i
        }
      }
      return a(n, r)
    }
  }
  return n
}

function j8(e) {
  return e.type === void 0
}

function H8(e) {
  return e.type === "transaction"
}

function EM(e, t) {
  t.debug === !0 && (at ? Me.enable() : Qi(() => {
    console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.")
  })), Kt().update(t.initialScope);
  const r = new e(t);
  return TM(r), r.init(), r
}

function TM(e) {
  Kt().setClient(e)
}

function AM(e) {
  const t = [];

  function n() {
    return e === void 0 || t.length < e
  }

  function r(o) {
    return t.splice(t.indexOf(o), 1)[0] || Promise.resolve(void 0)
  }

  function s(o) {
    if (!n()) return Yf(new ms("Not adding Promise because buffer limit was reached."));
    const i = o();
    return t.indexOf(i) === -1 && t.push(i), i.then(() => r(i)).then(null, () => r(i).then(null, () => {})), i
  }

  function a(o) {
    return new Wr((i, l) => {
      let c = t.length;
      if (!c) return i(!0);
      const d = setTimeout(() => {
        o && o > 0 && i(!1)
      }, o);
      t.forEach(f => {
        Bi(f).then(() => {
          --c || (clearTimeout(d), i(!0))
        }, l)
      })
    })
  }
  return {
    $: t,
    add: s,
    drain: a
  }
}
const PM = 60 * 1e3;

function IM(e, t = Date.now()) {
  const n = parseInt(`${e}`, 10);
  if (!isNaN(n)) return n * 1e3;
  const r = Date.parse(`${e}`);
  return isNaN(r) ? PM : r - t
}

function $M(e, t) {
  return e[t] || e.all || 0
}

function MM(e, t, n = Date.now()) {
  return $M(e, t) > n
}

function OM(e, {
  statusCode: t,
  headers: n
}, r = Date.now()) {
  const s = {
      ...e
    },
    a = n && n["x-sentry-rate-limits"],
    o = n && n["retry-after"];
  if (a)
    for (const i of a.trim().split(",")) {
      const [l, c, , , d] = i.split(":", 5), f = parseInt(l, 10), p = (isNaN(f) ? 60 : f) * 1e3;
      if (!c) s.all = r + p;
      else
        for (const h of c.split(";")) h === "metric_bucket" ? (!d || d.split(";").includes("custom")) && (s[h] = r + p) : s[h] = r + p
    } else o ? s.all = r + IM(o, r) : t === 429 && (s.all = r + 60 * 1e3);
  return s
}
const DM = 64;

function LM(e, t, n = AM(e.bufferSize || DM)) {
  let r = {};
  const s = o => n.drain(o);

  function a(o) {
    const i = [];
    if (N_(o, (f, p) => {
        const h = F_(p);
        if (MM(r, h)) {
          const _ = Z_(f, p);
          e.recordDroppedEvent("ratelimit_backoff", h, _)
        } else i.push(f)
      }), i.length === 0) return Bi({});
    const l = Pu(o[0], i),
      c = f => {
        N_(l, (p, h) => {
          const _ = Z_(p, h);
          e.recordDroppedEvent(f, F_(h), _)
        })
      },
      d = () => t({
        body: P$(l)
      }).then(f => (f.statusCode !== void 0 && (f.statusCode < 200 || f.statusCode >= 300) && at && Me.warn(`Sentry responded with status code ${f.statusCode} to sent event.`), r = OM(r, f), f), f => {
        throw c("network_error"), f
      });
    return n.add(d).then(f => f, f => {
      if (f instanceof ms) return at && Me.error("Skipped sending event because buffer is full."), c("queue_overflow"), Bi({});
      throw f
    })
  }
  return {
    send: a,
    flush: s
  }
}

function Z_(e, t) {
  if (!(t !== "event" && t !== "transaction")) return Array.isArray(e) ? e[1] : void 0
}

function RM(e, t, n = [t], r = "npm") {
  const s = e._metadata || {};
  s.sdk || (s.sdk = {
    name: `sentry.javascript.${t}`,
    packages: n.map(a => ({
      name: `${r}:@sentry/${a}`,
      version: ki
    })),
    version: ki
  }), e._metadata = s
}

function V8(e = {}) {
  const t = Dt();
  if (!pM() || !t) return {};
  const n = qi(),
    r = Eu(n);
  if (r.getTraceData) return r.getTraceData(e);
  const s = Kt(),
    a = e.span || Zn(),
    o = a ? u$(a) : NM(s),
    i = a ? Au(a) : E8(t, s),
    l = n$(i);
  return m8.test(o) ? {
    "sentry-trace": o,
    baggage: l
  } : (Me.warn("Invalid sentry-trace data. Cannot generate trace data"), {})
}

function NM(e) {
  const {
    traceId: t,
    sampled: n,
    spanId: r
  } = e.getPropagationContext();
  return g8(t, r, n)
}
const FM = 100;

function jo(e, t) {
  const n = Dt(),
    r = Qa();
  if (!n) return;
  const {
    beforeBreadcrumb: s = null,
    maxBreadcrumbs: a = FM
  } = n.getOptions();
  if (a <= 0) return;
  const i = {
      timestamp: id(),
      ...e
    },
    l = s ? Qi(() => s(i, t)) : i;
  l !== null && (n.emit && n.emit("beforeAddBreadcrumb", l, t), r.addBreadcrumb(l, a))
}
let J_;
const BM = "FunctionToString",
  X_ = new WeakMap,
  jM = () => ({
    name: BM,
    setupOnce() {
      J_ = Function.prototype.toString;
      try {
        Function.prototype.toString = function(...e) {
          const t = rg(this),
            n = X_.has(Dt()) && t !== void 0 ? t : this;
          return J_.apply(n, e)
        }
      } catch {}
    },
    setup(e) {
      X_.set(e, !0)
    }
  }),
  HM = jM,
  VM = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/, /^ResizeObserver loop completed with undelivered notifications.$/, /^Cannot redefine property: googletag$/, "undefined is not an object (evaluating 'a.L')", `can't redefine non-configurable property "solana"`, "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)", "Can't find variable: _AutofillCallbackHandler", /^Non-Error promise rejection captured with value: Object Not Found Matching Id:\d+, MethodName:simulateEvent, ParamCount:\d+$/],
  UM = "InboundFilters",
  zM = (e = {}) => ({
    name: UM,
    processEvent(t, n, r) {
      const s = r.getOptions(),
        a = WM(e, s);
      return GM(t, a) ? null : t
    }
  }),
  YM = zM;

function WM(e = {}, t = {}) {
  return {
    allowUrls: [...e.allowUrls || [], ...t.allowUrls || []],
    denyUrls: [...e.denyUrls || [], ...t.denyUrls || []],
    ignoreErrors: [...e.ignoreErrors || [], ...t.ignoreErrors || [], ...e.disableErrorDefaults ? [] : VM],
    ignoreTransactions: [...e.ignoreTransactions || [], ...t.ignoreTransactions || []],
    ignoreInternal: e.ignoreInternal !== void 0 ? e.ignoreInternal : !0
  }
}

function GM(e, t) {
  return t.ignoreInternal && XM(e) ? (at && Me.warn(`Event dropped due to being internal Sentry Error.
Event: ${ho(e)}`), !0) : QM(e, t.ignoreErrors) ? (at && Me.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${ho(e)}`), !0) : tO(e) ? (at && Me.warn(`Event dropped due to not having an error message, error type or stacktrace.
Event: ${ho(e)}`), !0) : qM(e, t.ignoreTransactions) ? (at && Me.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${ho(e)}`), !0) : KM(e, t.denyUrls) ? (at && Me.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${ho(e)}.
Url: ${Gf(e)}`), !0) : ZM(e, t.allowUrls) ? !1 : (at && Me.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${ho(e)}.
Url: ${Gf(e)}`), !0)
}

function QM(e, t) {
  return e.type || !t || !t.length ? !1 : JM(e).some(n => Si(n, t))
}

function qM(e, t) {
  if (e.type !== "transaction" || !t || !t.length) return !1;
  const n = e.transaction;
  return n ? Si(n, t) : !1
}

function KM(e, t) {
  if (!t || !t.length) return !1;
  const n = Gf(e);
  return n ? Si(n, t) : !1
}

function ZM(e, t) {
  if (!t || !t.length) return !0;
  const n = Gf(e);
  return n ? Si(n, t) : !0
}

function JM(e) {
  const t = [];
  e.message && t.push(e.message);
  let n;
  try {
    n = e.exception.values[e.exception.values.length - 1]
  } catch {}
  return n && n.value && (t.push(n.value), n.type && t.push(`${n.type}: ${n.value}`)), t
}

function XM(e) {
  try {
    return e.exception.values[0].type === "SentryError"
  } catch {}
  return !1
}

function eO(e = []) {
  for (let t = e.length - 1; t >= 0; t--) {
    const n = e[t];
    if (n && n.filename !== "<anonymous>" && n.filename !== "[native code]") return n.filename || null
  }
  return null
}

function Gf(e) {
  try {
    let t;
    try {
      t = e.exception.values[0].stacktrace.frames
    } catch {}
    return t ? eO(t) : null
  } catch {
    return at && Me.error(`Cannot extract url for event ${ho(e)}`), null
  }
}

function tO(e) {
  return e.type || !e.exception || !e.exception.values || e.exception.values.length === 0 ? !1 : !e.message && !e.exception.values.some(t => t.stacktrace || t.type && t.type !== "Error" || t.value)
}

function nO(e, t, n = 250, r, s, a, o) {
  if (!a.exception || !a.exception.values || !o || !ja(o.originalException, Error)) return;
  const i = a.exception.values.length > 0 ? a.exception.values[a.exception.values.length - 1] : void 0;
  i && (a.exception.values = rO(xm(e, t, s, o.originalException, r, a.exception.values, i, 0), n))
}

function xm(e, t, n, r, s, a, o, i) {
  if (a.length >= n + 1) return a;
  let l = [...a];
  if (ja(r[s], Error)) {
    ey(o, i);
    const c = e(t, r[s]),
      d = l.length;
    ty(c, s, d, i), l = xm(e, t, n, r[s], s, [c, ...l], c, d)
  }
  return Array.isArray(r.errors) && r.errors.forEach((c, d) => {
    if (ja(c, Error)) {
      ey(o, i);
      const f = e(t, c),
        p = l.length;
      ty(f, `errors[${d}]`, p, i), l = xm(e, t, n, c, s, [f, ...l], f, p)
    }
  }), l
}

function ey(e, t) {
  e.mechanism = e.mechanism || {
    type: "generic",
    handled: !0
  }, e.mechanism = {
    ...e.mechanism,
    ...e.type === "AggregateError" && {
      is_exception_group: !0
    },
    exception_id: t
  }
}

function ty(e, t, n, r) {
  e.mechanism = e.mechanism || {
    type: "generic",
    handled: !0
  }, e.mechanism = {
    ...e.mechanism,
    type: "chained",
    source: t,
    exception_id: n,
    parent_id: r
  }
}

function rO(e, t) {
  return e.map(n => (n.value && (n.value = Tl(n.value, t)), n))
}

function Ai(e) {
  if (!e) return {};
  const t = e.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
  if (!t) return {};
  const n = t[6] || "",
    r = t[8] || "";
  return {
    host: t[4],
    path: t[5],
    protocol: t[2],
    search: n,
    hash: r,
    relative: t[5] + n + r
  }
}

function sO(e) {
  const t = "console";
  Jo(t, e), Xo(t, aO)
}

function aO() {
  "console" in Ct && fm.forEach(function(e) {
    e in Ct.console && Nr(Ct.console, e, function(t) {
      return zf[e] = t,
        function(...n) {
          Qr("console", {
            args: n,
            level: e
          });
          const s = zf[e];
          s && s.apply(Ct.console, n)
        }
    })
  })
}

function oO(e) {
  return e === "warn" ? "warning" : ["fatal", "error", "warning", "log", "info", "debug"].includes(e) ? e : "log"
}
const iO = "Dedupe",
  lO = () => {
    let e;
    return {
      name: iO,
      processEvent(t) {
        if (t.type) return t;
        try {
          if (cO(t, e)) return at && Me.warn("Event dropped due to being a duplicate of previously captured event."), null
        } catch {}
        return e = t
      }
    }
  },
  uO = lO;

function cO(e, t) {
  return t ? !!(dO(e, t) || fO(e, t)) : !1
}

function dO(e, t) {
  const n = e.message,
    r = t.message;
  return !(!n && !r || n && !r || !n && r || n !== r || !z8(e, t) || !U8(e, t))
}

function fO(e, t) {
  const n = ny(t),
    r = ny(e);
  return !(!n || !r || n.type !== r.type || n.value !== r.value || !z8(e, t) || !U8(e, t))
}

function U8(e, t) {
  let n = C_(e),
    r = C_(t);
  if (!n && !r) return !0;
  if (n && !r || !n && r || (n = n, r = r, r.length !== n.length)) return !1;
  for (let s = 0; s < r.length; s++) {
    const a = r[s],
      o = n[s];
    if (a.filename !== o.filename || a.lineno !== o.lineno || a.colno !== o.colno || a.function !== o.function) return !1
  }
  return !0
}

function z8(e, t) {
  let n = e.fingerprint,
    r = t.fingerprint;
  if (!n && !r) return !0;
  if (n && !r || !n && r) return !1;
  n = n, r = r;
  try {
    return n.join("") === r.join("")
  } catch {
    return !1
  }
}

function ny(e) {
  return e.exception && e.exception.values && e.exception.values[0]
}

function pO(e, t, n, r, s = "auto.http.browser") {
  if (!e.fetchData) return;
  const a = Bo() && t(e.fetchData.url);
  if (e.endTimestamp && a) {
    const p = e.fetchData.__span;
    if (!p) return;
    const h = r[p];
    h && (gO(h, e), delete r[p]);
    return
  }
  const {
    method: o,
    url: i
  } = e.fetchData, l = mO(i), c = l ? Ai(l).host : void 0, d = !!Zn(), f = a && d ? ud({
    name: `${o} ${i}`,
    attributes: {
      url: i,
      type: "fetch",
      "http.method": o,
      "http.url": l,
      "server.address": c,
      [Mn]: s,
      [Hi]: "http.client"
    }
  }) : new Tu;
  if (e.fetchData.__span = f.spanContext().spanId, r[f.spanContext().spanId] = f, n(e.fetchData.url)) {
    const p = e.args[0],
      h = e.args[1] || {},
      _ = hO(p, h, Bo() && d ? f : void 0);
    _ && (e.args[1] = h, h.headers = _)
  }
  return f
}

function hO(e, t, n) {
  const r = V8({
      span: n
    }),
    s = r["sentry-trace"],
    a = r.baggage;
  if (!s) return;
  const o = t.headers || (vO(e) ? e.headers : void 0);
  if (o)
    if (_O(o)) {
      const i = new Headers(o);
      if (i.set("sentry-trace", s), a) {
        const l = i.get("baggage");
        if (l) {
          const c = Gd(l);
          i.set("baggage", c ? `${c},${a}` : a)
        } else i.set("baggage", a)
      }
      return i
    } else if (Array.isArray(o)) {
    const i = [...o.filter(l => !(Array.isArray(l) && l[0] === "sentry-trace")).map(l => {
      if (Array.isArray(l) && l[0] === "baggage" && typeof l[1] == "string") {
        const [c, d, ...f] = l;
        return [c, Gd(d), ...f]
      } else return l
    }), ["sentry-trace", s]];
    return a && i.push(["baggage", a]), i
  } else {
    const i = "baggage" in o ? o.baggage : void 0;
    let l = [];
    return Array.isArray(i) ? l = i.map(c => typeof c == "string" ? Gd(c) : c).filter(c => c === "") : i && l.push(Gd(i)), a && l.push(a), {
      ...o,
      "sentry-trace": s,
      baggage: l.length > 0 ? l.join(",") : void 0
    }
  } else return {
    ...r
  }
}

function mO(e) {
  try {
    return new URL(e).href
  } catch {
    return
  }
}

function gO(e, t) {
  if (t.response) {
    p8(e, t.response.status);
    const n = t.response && t.response.headers && t.response.headers.get("content-length");
    if (n) {
      const r = parseInt(n);
      r > 0 && e.setAttribute("http.response_content_length", r)
    }
  } else t.error && e.setStatus({
    code: In,
    message: "internal_error"
  });
  e.end()
}

function Gd(e) {
  return e.split(",").filter(t => !t.split("=")[0].startsWith(ig)).join(",")
}

function vO(e) {
  return typeof Request < "u" && ja(e, Request)
}

function _O(e) {
  return typeof Headers < "u" && ja(e, Headers)
}

function Y8(e) {
  if (e !== void 0) return e >= 400 && e < 500 ? "warning" : e >= 500 ? "error" : void 0
}
const km = Ct;

function W8() {
  if (!("fetch" in km)) return !1;
  try {
    return new Headers, new Request("http://www.example.com"), new Response, !0
  } catch {
    return !1
  }
}

function Sm(e) {
  return e && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(e.toString())
}

function yO() {
  if (typeof EdgeRuntime == "string") return !0;
  if (!W8()) return !1;
  if (Sm(km.fetch)) return !0;
  let e = !1;
  const t = km.document;
  if (t && typeof t.createElement == "function") try {
    const n = t.createElement("iframe");
    n.hidden = !0, t.head.appendChild(n), n.contentWindow && n.contentWindow.fetch && (e = Sm(n.contentWindow.fetch)), t.head.removeChild(n)
  } catch (n) {
    Zo && Me.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", n)
  }
  return e
}

function G8(e, t) {
  const n = "fetch";
  Jo(n, e), Xo(n, () => Q8(void 0, t))
}

function bO(e) {
  const t = "fetch-body-resolved";
  Jo(t, e), Xo(t, () => Q8(CO))
}

function Q8(e, t = !1) {
  t && !yO() || Nr(Ct, "fetch", function(n) {
    return function(...r) {
      const s = new Error,
        {
          method: a,
          url: o
        } = xO(r),
        i = {
          args: r,
          fetchData: {
            method: a,
            url: o
          },
          startTimestamp: cr() * 1e3,
          virtualError: s
        };
      return e || Qr("fetch", {
        ...i
      }), n.apply(Ct, r).then(async l => (e ? e(l) : Qr("fetch", {
        ...i,
        endTimestamp: cr() * 1e3,
        response: l
      }), l), l => {
        throw Qr("fetch", {
          ...i,
          endTimestamp: cr() * 1e3,
          error: l
        }), eg(l) && l.stack === void 0 && (l.stack = s.stack, es(l, "framesToPop", 1)), l
      })
    }
  })
}
async function wO(e, t) {
  if (e && e.body) {
    const n = e.body,
      r = n.getReader(),
      s = setTimeout(() => {
        n.cancel().then(null, () => {})
      }, 90 * 1e3);
    let a = !0;
    for (; a;) {
      let o;
      try {
        o = setTimeout(() => {
          n.cancel().then(null, () => {})
        }, 5e3);
        const {
          done: i
        } = await r.read();
        clearTimeout(o), i && (t(), a = !1)
      } catch {
        a = !1
      } finally {
        clearTimeout(o)
      }
    }
    clearTimeout(s), r.releaseLock(), n.cancel().then(null, () => {})
  }
}

function CO(e) {
  let t;
  try {
    t = e.clone()
  } catch {
    return
  }
  wO(t, () => {
    Qr("fetch-body-resolved", {
      endTimestamp: cr() * 1e3,
      response: e
    })
  })
}

function Em(e, t) {
  return !!e && typeof e == "object" && !!e[t]
}

function ry(e) {
  return typeof e == "string" ? e : e ? Em(e, "url") ? e.url : e.toString ? e.toString() : "" : ""
}

function xO(e) {
  if (e.length === 0) return {
    method: "GET",
    url: ""
  };
  if (e.length === 2) {
    const [n, r] = e;
    return {
      url: ry(n),
      method: Em(r, "method") ? String(r.method).toUpperCase() : "GET"
    }
  }
  const t = e[0];
  return {
    url: ry(t),
    method: Em(t, "method") ? String(t.method).toUpperCase() : "GET"
  }
}

function kO() {
  return "npm"
}
const Qd = Ct;

function SO() {
  const e = Qd.chrome,
    t = e && e.app && e.app.runtime,
    n = "history" in Qd && !!Qd.history.pushState && !!Qd.history.replaceState;
  return !t && n
}
const st = Ct;
let Tm = 0;

function q8() {
  return Tm > 0
}

function EO() {
  Tm++, setTimeout(() => {
    Tm--
  })
}

function tu(e, t = {}) {
  function n(s) {
    return typeof s == "function"
  }
  if (!n(e)) return e;
  try {
    const s = e.__sentry_wrapped__;
    if (s) return typeof s == "function" ? s : e;
    if (rg(e)) return e
  } catch {
    return e
  }
  const r = function(...s) {
    try {
      const a = s.map(o => tu(o, t));
      return e.apply(this, a)
    } catch (a) {
      throw EO(), ag(o => {
        o.addEventProcessor(i => (t.mechanism && (hm(i, void 0), Jl(i, t.mechanism)), i.extra = {
          ...i.extra,
          arguments: s
        }, i)), L8(a)
      }), a
    }
  };
  try {
    for (const s in e) Object.prototype.hasOwnProperty.call(e, s) && (r[s] = e[s])
  } catch {}
  i8(r, e), es(e, "__sentry_wrapped__", r);
  try {
    Object.getOwnPropertyDescriptor(r, "name").configurable && Object.defineProperty(r, "name", {
      get() {
        return e.name
      }
    })
  } catch {}
  return r
}
const ea = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__;

function cg(e, t) {
  const n = dg(e, t),
    r = {
      type: $O(t),
      value: MO(t)
    };
  return n.length && (r.stacktrace = {
    frames: n
  }), r.type === void 0 && r.value === "" && (r.value = "Unrecoverable error caught"), r
}

function TO(e, t, n, r) {
  const s = Dt(),
    a = s && s.getOptions().normalizeDepth,
    o = NO(t),
    i = {
      __serialized__: P8(t, a)
    };
  if (o) return {
    exception: {
      values: [cg(e, o)]
    },
    extra: i
  };
  const l = {
    exception: {
      values: [{
        type: Np(t) ? t.constructor.name : r ? "UnhandledRejection" : "Error",
        value: LO(t, {
          isUnhandledRejection: r
        })
      }]
    },
    extra: i
  };
  if (n) {
    const c = dg(e, n);
    c.length && (l.exception.values[0].stacktrace = {
      frames: c
    })
  }
  return l
}

function B1(e, t) {
  return {
    exception: {
      values: [cg(e, t)]
    }
  }
}

function dg(e, t) {
  const n = t.stacktrace || t.stack || "",
    r = PO(t),
    s = IO(t);
  try {
    return e(n, r, s)
  } catch {}
  return []
}
const AO = /Minified React error #\d+;/i;

function PO(e) {
  return e && AO.test(e.message) ? 1 : 0
}

function IO(e) {
  return typeof e.framesToPop == "number" ? e.framesToPop : 0
}

function K8(e) {
  return typeof WebAssembly < "u" && typeof WebAssembly.Exception < "u" ? e instanceof WebAssembly.Exception : !1
}

function $O(e) {
  const t = e && e.name;
  return !t && K8(e) ? e.message && Array.isArray(e.message) && e.message.length == 2 ? e.message[0] : "WebAssembly.Exception" : t
}

function MO(e) {
  const t = e && e.message;
  return t ? t.error && typeof t.error.message == "string" ? t.error.message : K8(e) && Array.isArray(e.message) && e.message.length == 2 ? e.message[1] : t : "No error message"
}

function OO(e, t, n, r) {
  const s = n && n.syntheticException || void 0,
    a = fg(e, t, s, r);
  return Jl(a), a.level = "error", n && n.event_id && (a.event_id = n.event_id), Bi(a)
}

function DO(e, t, n = "info", r, s) {
  const a = r && r.syntheticException || void 0,
    o = Am(e, t, a, s);
  return o.level = n, r && r.event_id && (o.event_id = r.event_id), Bi(o)
}

function fg(e, t, n, r, s) {
  let a;
  if (s8(t) && t.error) return B1(e, t.error);
  if (k_(t) || SI(t)) {
    const o = t;
    if ("stack" in t) a = B1(e, t);
    else {
      const i = o.name || (k_(o) ? "DOMError" : "DOMException"),
        l = o.message ? `${i}: ${o.message}` : i;
      a = Am(e, l, n, r), hm(a, l)
    }
    return "code" in o && (a.tags = {
      ...a.tags,
      "DOMException.code": `${o.code}`
    }), a
  }
  return eg(t) ? B1(e, t) : Zl(t) || Np(t) ? (a = TO(e, t, n, s), Jl(a, {
    synthetic: !0
  }), a) : (a = Am(e, t, n, r), hm(a, `${t}`), Jl(a, {
    synthetic: !0
  }), a)
}

function Am(e, t, n, r) {
  const s = {};
  if (r && n) {
    const a = dg(e, n);
    a.length && (s.exception = {
      values: [{
        value: t,
        stacktrace: {
          frames: a
        }
      }]
    }), Jl(s, {
      synthetic: !0
    })
  }
  if (tg(t)) {
    const {
      __sentry_template_string__: a,
      __sentry_template_values__: o
    } = t;
    return s.logentry = {
      message: a,
      params: o
    }, s
  }
  return s.message = t, s
}

function LO(e, {
  isUnhandledRejection: t
}) {
  const n = DI(e),
    r = t ? "promise rejection" : "exception";
  return s8(e) ? `Event \`ErrorEvent\` captured as ${r} with message \`${e.message}\`` : Np(e) ? `Event \`${RO(e)}\` (type=${e.type}) captured as ${r}` : `Object captured as ${r} with keys: ${n}`
}

function RO(e) {
  try {
    const t = Object.getPrototypeOf(e);
    return t ? t.constructor.name : void 0
  } catch {}
}

function NO(e) {
  for (const t in e)
    if (Object.prototype.hasOwnProperty.call(e, t)) {
      const n = e[t];
      if (n instanceof Error) return n
    }
}

function FO(e, {
  metadata: t,
  tunnel: n,
  dsn: r
}) {
  const s = {
      event_id: e.event_id,
      sent_at: new Date().toISOString(),
      ...t && t.sdk && {
        sdk: {
          name: t.sdk.name,
          version: t.sdk.version
        }
      },
      ...!!n && !!r && {
        dsn: ld(r)
      }
    },
    a = BO(e);
  return Pu(s, [a])
}

function BO(e) {
  return [{
    type: "user_report"
  }, e]
}
class jO extends xM {
  constructor(t) {
    const n = {
        parentSpanIsAlwaysRootSpan: !0,
        ...t
      },
      r = st.SENTRY_SDK_SOURCE || kO();
    RM(n, "browser", ["browser"], r), super(n), n.sendClientReports && st.document && st.document.addEventListener("visibilitychange", () => {
      st.document.visibilityState === "hidden" && this._flushOutcomes()
    })
  }
  eventFromException(t, n) {
    return OO(this._options.stackParser, t, n, this._options.attachStacktrace)
  }
  eventFromMessage(t, n = "info", r) {
    return DO(this._options.stackParser, t, n, r, this._options.attachStacktrace)
  }
  captureUserFeedback(t) {
    if (!this._isEnabled()) {
      ea && Me.warn("SDK not enabled, will not capture user feedback.");
      return
    }
    const n = FO(t, {
      metadata: this.getSdkMetadata(),
      dsn: this.getDsn(),
      tunnel: this.getOptions().tunnel
    });
    this.sendEnvelope(n)
  }
  _prepareEvent(t, n, r) {
    return t.platform = t.platform || "javascript", super._prepareEvent(t, n, r)
  }
}
const pg = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__,
  HO = (e, t) => e > t[1] ? "poor" : e > t[0] ? "needs-improvement" : "good",
  Iu = (e, t, n, r) => {
    let s, a;
    return o => {
      t.value >= 0 && (o || r) && (a = t.value - (s || 0), (a || s === void 0) && (s = t.value, t.delta = a, t.rating = HO(t.value, n), e(t)))
    }
  },
  Ze = Ct,
  VO = () => `v4-${Date.now()}-${Math.floor(Math.random()*(9e12-1))+1e12}`,
  cd = (e = !0) => {
    const t = Ze.performance && Ze.performance.getEntriesByType && Ze.performance.getEntriesByType("navigation")[0];
    if (!e || t && t.responseStart > 0 && t.responseStart < performance.now()) return t
  },
  dd = () => {
    const e = cd();
    return e && e.activationStart || 0
  },
  $u = (e, t) => {
    const n = cd();
    let r = "navigate";
    return n && (Ze.document && Ze.document.prerendering || dd() > 0 ? r = "prerender" : Ze.document && Ze.document.wasDiscarded ? r = "restore" : n.type && (r = n.type.replace(/_/g, "-"))), {
      name: e,
      value: typeof t > "u" ? -1 : t,
      rating: "good",
      delta: 0,
      entries: [],
      id: VO(),
      navigationType: r
    }
  },
  Zi = (e, t, n) => {
    try {
      if (PerformanceObserver.supportedEntryTypes.includes(e)) {
        const r = new PerformanceObserver(s => {
          Promise.resolve().then(() => {
            t(s.getEntries())
          })
        });
        return r.observe(Object.assign({
          type: e,
          buffered: !0
        }, n || {})), r
      }
    } catch {}
  },
  Mu = e => {
    const t = n => {
      (n.type === "pagehide" || Ze.document && Ze.document.visibilityState === "hidden") && e(n)
    };
    Ze.document && (addEventListener("visibilitychange", t, !0), addEventListener("pagehide", t, !0))
  },
  Vp = e => {
    let t = !1;
    return () => {
      t || (e(), t = !0)
    }
  };
let oc = -1;
const UO = () => Ze.document.visibilityState === "hidden" && !Ze.document.prerendering ? 0 : 1 / 0,
  Qf = e => {
    Ze.document.visibilityState === "hidden" && oc > -1 && (oc = e.type === "visibilitychange" ? e.timeStamp : 0, YO())
  },
  zO = () => {
    addEventListener("visibilitychange", Qf, !0), addEventListener("prerenderingchange", Qf, !0)
  },
  YO = () => {
    removeEventListener("visibilitychange", Qf, !0), removeEventListener("prerenderingchange", Qf, !0)
  },
  Up = () => (Ze.document && oc < 0 && (oc = UO(), zO()), {
    get firstHiddenTime() {
      return oc
    }
  }),
  fd = e => {
    Ze.document && Ze.document.prerendering ? addEventListener("prerenderingchange", () => e(), !0) : e()
  },
  WO = [1800, 3e3],
  GO = (e, t = {}) => {
    fd(() => {
      const n = Up(),
        r = $u("FCP");
      let s;
      const o = Zi("paint", i => {
        i.forEach(l => {
          l.name === "first-contentful-paint" && (o.disconnect(), l.startTime < n.firstHiddenTime && (r.value = Math.max(l.startTime - dd(), 0), r.entries.push(l), s(!0)))
        })
      });
      o && (s = Iu(e, r, WO, t.reportAllChanges))
    })
  },
  QO = [.1, .25],
  qO = (e, t = {}) => {
    GO(Vp(() => {
      const n = $u("CLS", 0);
      let r, s = 0,
        a = [];
      const o = l => {
          l.forEach(c => {
            if (!c.hadRecentInput) {
              const d = a[0],
                f = a[a.length - 1];
              s && d && f && c.startTime - f.startTime < 1e3 && c.startTime - d.startTime < 5e3 ? (s += c.value, a.push(c)) : (s = c.value, a = [c])
            }
          }), s > n.value && (n.value = s, n.entries = a, r())
        },
        i = Zi("layout-shift", o);
      i && (r = Iu(e, n, QO, t.reportAllChanges), Mu(() => {
        o(i.takeRecords()), r(!0)
      }), setTimeout(r, 0))
    }))
  },
  KO = [100, 300],
  ZO = (e, t = {}) => {
    fd(() => {
      const n = Up(),
        r = $u("FID");
      let s;
      const a = l => {
          l.startTime < n.firstHiddenTime && (r.value = l.processingStart - l.startTime, r.entries.push(l), s(!0))
        },
        o = l => {
          l.forEach(a)
        },
        i = Zi("first-input", o);
      s = Iu(e, r, KO, t.reportAllChanges), i && Mu(Vp(() => {
        o(i.takeRecords()), i.disconnect()
      }))
    })
  };
let Z8 = 0,
  j1 = 1 / 0,
  qd = 0;
const JO = e => {
  e.forEach(t => {
    t.interactionId && (j1 = Math.min(j1, t.interactionId), qd = Math.max(qd, t.interactionId), Z8 = qd ? (qd - j1) / 7 + 1 : 0)
  })
};
let Pm;
const XO = () => Pm ? Z8 : performance.interactionCount || 0,
  eD = () => {
    "interactionCount" in performance || Pm || (Pm = Zi("event", JO, {
      type: "event",
      buffered: !0,
      durationThreshold: 0
    }))
  },
  va = [],
  H1 = new Map,
  tD = 40;
let nD = 0;
const rD = () => XO() - nD,
  sD = () => {
    const e = Math.min(va.length - 1, Math.floor(rD() / 50));
    return va[e]
  },
  V1 = 10,
  aD = [],
  oD = e => {
    if (aD.forEach(r => r(e)), !(e.interactionId || e.entryType === "first-input")) return;
    const t = va[va.length - 1],
      n = H1.get(e.interactionId);
    if (n || va.length < V1 || t && e.duration > t.latency) {
      if (n) e.duration > n.latency ? (n.entries = [e], n.latency = e.duration) : e.duration === n.latency && e.startTime === (n.entries[0] && n.entries[0].startTime) && n.entries.push(e);
      else {
        const r = {
          id: e.interactionId,
          latency: e.duration,
          entries: [e]
        };
        H1.set(r.id, r), va.push(r)
      }
      va.sort((r, s) => s.latency - r.latency), va.length > V1 && va.splice(V1).forEach(r => H1.delete(r.id))
    }
  },
  J8 = e => {
    const t = Ze.requestIdleCallback || Ze.setTimeout;
    let n = -1;
    return e = Vp(e), Ze.document && Ze.document.visibilityState === "hidden" ? e() : (n = t(e), Mu(e)), n
  },
  iD = [200, 500],
  lD = (e, t = {}) => {
    "PerformanceEventTiming" in Ze && "interactionId" in PerformanceEventTiming.prototype && fd(() => {
      eD();
      const n = $u("INP");
      let r;
      const s = o => {
          J8(() => {
            o.forEach(oD);
            const i = sD();
            i && i.latency !== n.value && (n.value = i.latency, n.entries = i.entries, r())
          })
        },
        a = Zi("event", s, {
          durationThreshold: t.durationThreshold != null ? t.durationThreshold : tD
        });
      r = Iu(e, n, iD, t.reportAllChanges), a && (a.observe({
        type: "first-input",
        buffered: !0
      }), Mu(() => {
        s(a.takeRecords()), r(!0)
      }))
    })
  },
  uD = [2500, 4e3],
  sy = {},
  cD = (e, t = {}) => {
    fd(() => {
      const n = Up(),
        r = $u("LCP");
      let s;
      const a = i => {
          t.reportAllChanges || (i = i.slice(-1)), i.forEach(l => {
            l.startTime < n.firstHiddenTime && (r.value = Math.max(l.startTime - dd(), 0), r.entries = [l], s())
          })
        },
        o = Zi("largest-contentful-paint", a);
      if (o) {
        s = Iu(e, r, uD, t.reportAllChanges);
        const i = Vp(() => {
          sy[r.id] || (a(o.takeRecords()), o.disconnect(), sy[r.id] = !0, s(!0))
        });
        ["keydown", "click"].forEach(l => {
          Ze.document && addEventListener(l, () => J8(i), {
            once: !0,
            capture: !0
          })
        }), Mu(i)
      }
    })
  },
  dD = [800, 1800],
  Im = e => {
    Ze.document && Ze.document.prerendering ? fd(() => Im(e)) : Ze.document && Ze.document.readyState !== "complete" ? addEventListener("load", () => Im(e), !0) : setTimeout(e, 0)
  },
  fD = (e, t = {}) => {
    const n = $u("TTFB"),
      r = Iu(e, n, dD, t.reportAllChanges);
    Im(() => {
      const s = cd();
      s && (n.value = Math.max(s.responseStart - dd(), 0), n.entries = [s], r(!0))
    })
  },
  ic = {},
  qf = {};
let X8, e9, t9, n9, r9;

function s9(e, t = !1) {
  return pd("cls", e, vD, X8, t)
}

function pD(e, t = !1) {
  return pd("lcp", e, yD, t9, t)
}

function hD(e) {
  return pd("fid", e, _D, e9)
}

function mD(e) {
  return pd("ttfb", e, bD, n9)
}

function gD(e) {
  return pd("inp", e, wD, r9)
}

function Lc(e, t) {
  return a9(e, t), qf[e] || (CD(e), qf[e] = !0), o9(e, t)
}

function Ou(e, t) {
  const n = ic[e];
  if (!(!n || !n.length))
    for (const r of n) try {
      r(t)
    } catch (s) {
      pg && Me.error(`Error while triggering instrumentation handler.
Type: ${e}
Name: ${Ba(r)}
Error:`, s)
    }
}

function vD() {
  return qO(e => {
    Ou("cls", {
      metric: e
    }), X8 = e
  }, {
    reportAllChanges: !0
  })
}

function _D() {
  return ZO(e => {
    Ou("fid", {
      metric: e
    }), e9 = e
  })
}

function yD() {
  return cD(e => {
    Ou("lcp", {
      metric: e
    }), t9 = e
  }, {
    reportAllChanges: !0
  })
}

function bD() {
  return fD(e => {
    Ou("ttfb", {
      metric: e
    }), n9 = e
  })
}

function wD() {
  return lD(e => {
    Ou("inp", {
      metric: e
    }), r9 = e
  })
}

function pd(e, t, n, r, s = !1) {
  a9(e, t);
  let a;
  return qf[e] || (a = n(), qf[e] = !0), r && t({
    metric: r
  }), o9(e, t, s ? a : void 0)
}

function CD(e) {
  const t = {};
  e === "event" && (t.durationThreshold = 0), Zi(e, n => {
    Ou(e, {
      entries: n
    })
  }, t)
}

function a9(e, t) {
  ic[e] = ic[e] || [], ic[e].push(t)
}

function o9(e, t, n) {
  return () => {
    n && n();
    const r = ic[e];
    if (!r) return;
    const s = r.indexOf(t);
    s !== -1 && r.splice(s, 1)
  }
}

function xD(e) {
  return "duration" in e
}

function U1(e) {
  return typeof e == "number" && isFinite(e)
}

function Ha(e, t, n, {
  ...r
}) {
  const s = Tt(e).start_timestamp;
  return s && s > t && typeof e.updateStartTime == "function" && e.updateStartTime(t), M8(e, () => {
    const a = ud({
      startTime: t,
      ...r
    });
    return a && a.end(n), a
  })
}

function i9(e) {
  const t = Dt();
  if (!t) return;
  const {
    name: n,
    transaction: r,
    attributes: s,
    startTime: a
  } = e, {
    release: o,
    environment: i
  } = t.getOptions(), l = t.getIntegrationByName("Replay"), c = l && l.getReplayId(), d = Kt(), f = d.getUser(), p = f !== void 0 ? f.email || f.id || f.ip_address : void 0;
  let h;
  try {
    h = d.getScopeData().contexts.profile.profile_id
  } catch {}
  const _ = {
    release: o,
    environment: i,
    user: p || void 0,
    profile_id: h || void 0,
    replay_id: c || void 0,
    transaction: r,
    "user_agent.original": Ze.navigator && Ze.navigator.userAgent,
    ...s
  };
  return ud({
    name: n,
    attributes: _,
    startTime: a,
    experimental: {
      standalone: !0
    }
  })
}

function hg() {
  return Ze && Ze.addEventListener && Ze.performance
}

function pn(e) {
  return e / 1e3
}

function l9(e) {
  let t = "unknown",
    n = "unknown",
    r = "";
  for (const s of e) {
    if (s === "/") {
      [t, n] = e.split("/");
      break
    }
    if (!isNaN(Number(s))) {
      t = r === "h" ? "http" : r, n = e.split(r)[1];
      break
    }
    r += s
  }
  return r === e && (t = r), {
    name: t,
    version: n
  }
}

function kD() {
  let e = 0,
    t, n;
  if (!ED()) return;
  let r = !1;

  function s() {
    r || (r = !0, n && SD(e, t, n), a())
  }
  const a = s9(({
    metric: o
  }) => {
    const i = o.entries[o.entries.length - 1];
    i && (e = o.value, t = i)
  }, !0);
  Mu(() => {
    s()
  }), setTimeout(() => {
    const o = Dt();
    if (!o) return;
    const i = o.on("startNavigationSpan", () => {
        s(), i && i()
      }),
      l = Zn(),
      c = l && qn(l),
      d = c && Tt(c);
    d && d.op === "pageload" && (n = c.spanContext().spanId)
  }, 0)
}

function SD(e, t, n) {
  pg && Me.log(`Sending CLS span (${e})`);
  const r = pn(($r || 0) + (t && t.startTime || 0)),
    s = Kt().getScopeData().transactionName,
    a = t ? Fi(t.sources[0] && t.sources[0].node) : "Layout shift",
    o = jn({
      [Mn]: "auto.http.browser.cls",
      [Hi]: "ui.webvital.cls",
      [og]: t && t.duration || 0,
      "sentry.pageload.span_id": n
    }),
    i = i9({
      name: a,
      transaction: s,
      attributes: o,
      startTime: r
    });
  i && (i.addEvent("cls", {
    [jp]: "",
    [Hp]: e
  }), i.end(r))
}

function ED() {
  try {
    return PerformanceObserver.supportedEntryTypes.includes("layout-shift")
  } catch {
    return !1
  }
}
const TD = 2147483647;
let ay = 0,
  Ln = {},
  _r, lc;

function AD({
  recordClsStandaloneSpans: e
}) {
  const t = hg();
  if (t && $r) {
    t.mark && Ze.performance.mark("sentry-tracing-init");
    const n = DD(),
      r = OD(),
      s = LD(),
      a = e ? kD() : MD();
    return () => {
      n(), r(), s(), a && a()
    }
  }
  return () => {}
}

function PD() {
  Lc("longtask", ({
    entries: e
  }) => {
    const t = Zn();
    if (!t) return;
    const {
      op: n,
      start_timestamp: r
    } = Tt(t);
    for (const s of e) {
      const a = pn($r + s.startTime),
        o = pn(s.duration);
      n === "navigation" && r && a < r || Ha(t, a, a + o, {
        name: "Main UI thread blocked",
        op: "ui.long-task",
        attributes: {
          [Mn]: "auto.ui.browser.metrics"
        }
      })
    }
  })
}

function ID() {
  new PerformanceObserver(t => {
    const n = Zn();
    if (n)
      for (const r of t.getEntries()) {
        if (!r.scripts[0]) continue;
        const s = pn($r + r.startTime),
          {
            start_timestamp: a,
            op: o
          } = Tt(n);
        if (o === "navigation" && a && s < a) continue;
        const i = pn(r.duration),
          l = {
            [Mn]: "auto.ui.browser.metrics"
          },
          c = r.scripts[0],
          {
            invoker: d,
            invokerType: f,
            sourceURL: p,
            sourceFunctionName: h,
            sourceCharPosition: _
          } = c;
        l["browser.script.invoker"] = d, l["browser.script.invoker_type"] = f, p && (l["code.filepath"] = p), h && (l["code.function"] = h), _ !== -1 && (l["browser.script.source_char_position"] = _), Ha(n, s, s + i, {
          name: "Main UI thread blocked",
          op: "ui.long-animation-frame",
          attributes: l
        })
      }
  }).observe({
    type: "long-animation-frame",
    buffered: !0
  })
}

function $D() {
  Lc("event", ({
    entries: e
  }) => {
    const t = Zn();
    if (t) {
      for (const n of e)
        if (n.name === "click") {
          const r = pn($r + n.startTime),
            s = pn(n.duration),
            a = {
              name: Fi(n.target),
              op: `ui.interaction.${n.name}`,
              startTime: r,
              attributes: {
                [Mn]: "auto.ui.browser.metrics"
              }
            },
            o = o8(n.target);
          o && (a.attributes["ui.component_name"] = o), Ha(t, r, r + s, a)
        }
    }
  })
}

function MD() {
  return s9(({
    metric: e
  }) => {
    const t = e.entries[e.entries.length - 1];
    t && (Ln.cls = {
      value: e.value,
      unit: ""
    }, lc = t)
  }, !0)
}

function OD() {
  return pD(({
    metric: e
  }) => {
    const t = e.entries[e.entries.length - 1];
    t && (Ln.lcp = {
      value: e.value,
      unit: "millisecond"
    }, _r = t)
  }, !0)
}

function DD() {
  return hD(({
    metric: e
  }) => {
    const t = e.entries[e.entries.length - 1];
    if (!t) return;
    const n = pn($r),
      r = pn(t.startTime);
    Ln.fid = {
      value: e.value,
      unit: "millisecond"
    }, Ln["mark.fid"] = {
      value: n + r,
      unit: "second"
    }
  })
}

function LD() {
  return mD(({
    metric: e
  }) => {
    e.entries[e.entries.length - 1] && (Ln.ttfb = {
      value: e.value,
      unit: "millisecond"
    })
  })
}

function RD(e, t) {
  const n = hg();
  if (!n || !n.getEntries || !$r) return;
  const r = pn($r),
    s = n.getEntries(),
    {
      op: a,
      start_timestamp: o
    } = Tt(e);
  if (s.slice(ay).forEach(i => {
      const l = pn(i.startTime),
        c = pn(Math.max(0, i.duration));
      if (!(a === "navigation" && o && r + l < o)) switch (i.entryType) {
        case "navigation": {
          FD(e, i, r);
          break
        }
        case "mark":
        case "paint":
        case "measure": {
          ND(e, i, l, c, r);
          const d = Up(),
            f = i.startTime < d.firstHiddenTime;
          i.name === "first-paint" && f && (Ln.fp = {
            value: i.startTime,
            unit: "millisecond"
          }), i.name === "first-contentful-paint" && f && (Ln.fcp = {
            value: i.startTime,
            unit: "millisecond"
          });
          break
        }
        case "resource": {
          HD(e, i, i.name, l, c, r);
          break
        }
      }
    }), ay = Math.max(s.length - 1, 0), VD(e), a === "pageload") {
    zD(Ln);
    const i = Ln["mark.fid"];
    i && Ln.fid && (Ha(e, i.value, i.value + pn(Ln.fid.value), {
      name: "first input delay",
      op: "ui.action",
      attributes: {
        [Mn]: "auto.ui.browser.metrics"
      }
    }), delete Ln["mark.fid"]), (!("fcp" in Ln) || !t.recordClsOnPageloadSpan) && delete Ln.cls, Object.entries(Ln).forEach(([l, c]) => {
      B$(l, c.value, c.unit)
    }), e.setAttribute("performance.timeOrigin", r), e.setAttribute("performance.activationStart", dd()), UD(e)
  }
  _r = void 0, lc = void 0, Ln = {}
}

function ND(e, t, n, r, s) {
  const a = cd(!1),
    o = pn(a ? a.requestStart : 0),
    i = s + Math.max(n, o),
    l = s + n,
    c = l + r,
    d = {
      [Mn]: "auto.resource.browser.metrics"
    };
  return i !== l && (d["sentry.browser.measure_happened_before_request"] = !0, d["sentry.browser.measure_start_time"] = i), Ha(e, i, c, {
    name: t.name,
    op: t.entryType,
    attributes: d
  }), i
}

function FD(e, t, n) {
  ["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach(r => {
    Kd(e, t, r, n)
  }), Kd(e, t, "secureConnection", n, "TLS/SSL"), Kd(e, t, "fetch", n, "cache"), Kd(e, t, "domainLookup", n, "DNS"), jD(e, t, n)
}

function Kd(e, t, n, r, s = n) {
  const a = BD(n),
    o = t[a],
    i = t[`${n}Start`];
  !i || !o || Ha(e, r + pn(i), r + pn(o), {
    op: `browser.${s}`,
    name: t.name,
    attributes: {
      [Mn]: "auto.ui.browser.metrics"
    }
  })
}

function BD(e) {
  return e === "secureConnection" ? "connectEnd" : e === "fetch" ? "domainLookupStart" : `${e}End`
}

function jD(e, t, n) {
  const r = n + pn(t.requestStart),
    s = n + pn(t.responseEnd),
    a = n + pn(t.responseStart);
  t.responseEnd && (Ha(e, r, s, {
    op: "browser.request",
    name: t.name,
    attributes: {
      [Mn]: "auto.ui.browser.metrics"
    }
  }), Ha(e, a, s, {
    op: "browser.response",
    name: t.name,
    attributes: {
      [Mn]: "auto.ui.browser.metrics"
    }
  }))
}

function HD(e, t, n, r, s, a) {
  if (t.initiatorType === "xmlhttprequest" || t.initiatorType === "fetch") return;
  const o = Ai(n),
    i = {
      [Mn]: "auto.resource.browser.metrics"
    };
  z1(i, t, "transferSize", "http.response_transfer_size"), z1(i, t, "encodedBodySize", "http.response_content_length"), z1(i, t, "decodedBodySize", "http.decoded_response_content_length");
  const l = t.deliveryType;
  l != null && (i["http.response_delivery_type"] = l);
  const c = t.renderBlockingStatus;
  c && (i["resource.render_blocking_status"] = c), o.protocol && (i["url.scheme"] = o.protocol.split(":").pop()), o.host && (i["server.address"] = o.host), i["url.same_origin"] = n.includes(Ze.location.origin);
  const {
    name: d,
    version: f
  } = l9(t.nextHopProtocol);
  i["network.protocol.name"] = d, i["network.protocol.version"] = f;
  const p = a + r,
    h = p + s;
  Ha(e, p, h, {
    name: n.replace(Ze.location.origin, ""),
    op: t.initiatorType ? `resource.${t.initiatorType}` : "resource.other",
    attributes: i
  })
}

function VD(e) {
  const t = Ze.navigator;
  if (!t) return;
  const n = t.connection;
  n && (n.effectiveType && e.setAttribute("effectiveConnectionType", n.effectiveType), n.type && e.setAttribute("connectionType", n.type), U1(n.rtt) && (Ln["connection.rtt"] = {
    value: n.rtt,
    unit: "millisecond"
  })), U1(t.deviceMemory) && e.setAttribute("deviceMemory", `${t.deviceMemory} GB`), U1(t.hardwareConcurrency) && e.setAttribute("hardwareConcurrency", String(t.hardwareConcurrency))
}

function UD(e) {
  _r && (_r.element && e.setAttribute("lcp.element", Fi(_r.element)), _r.id && e.setAttribute("lcp.id", _r.id), _r.url && e.setAttribute("lcp.url", _r.url.trim().slice(0, 200)), _r.loadTime != null && e.setAttribute("lcp.loadTime", _r.loadTime), _r.renderTime != null && e.setAttribute("lcp.renderTime", _r.renderTime), e.setAttribute("lcp.size", _r.size)), lc && lc.sources && lc.sources.forEach((t, n) => e.setAttribute(`cls.source.${n+1}`, Fi(t.node)))
}

function z1(e, t, n, r) {
  const s = t[n];
  s != null && s < TD && (e[r] = s)
}

function zD(e) {
  const t = cd(!1);
  if (!t) return;
  const {
    responseStart: n,
    requestStart: r
  } = t;
  r <= n && (e["ttfb.requestTime"] = {
    value: n - r,
    unit: "millisecond"
  })
}
const YD = 1e3;
let oy, $m, Mm;

function WD(e) {
  const t = "dom";
  Jo(t, e), Xo(t, GD)
}

function GD() {
  if (!Ze.document) return;
  const e = Qr.bind(null, "dom"),
    t = iy(e, !0);
  Ze.document.addEventListener("click", t, !1), Ze.document.addEventListener("keypress", t, !1), ["EventTarget", "Node"].forEach(n => {
    const s = Ze[n],
      a = s && s.prototype;
    !a || !a.hasOwnProperty || !a.hasOwnProperty("addEventListener") || (Nr(a, "addEventListener", function(o) {
      return function(i, l, c) {
        if (i === "click" || i == "keypress") try {
          const d = this.__sentry_instrumentation_handlers__ = this.__sentry_instrumentation_handlers__ || {},
            f = d[i] = d[i] || {
              refCount: 0
            };
          if (!f.handler) {
            const p = iy(e);
            f.handler = p, o.call(this, i, p, c)
          }
          f.refCount++
        } catch {}
        return o.call(this, i, l, c)
      }
    }), Nr(a, "removeEventListener", function(o) {
      return function(i, l, c) {
        if (i === "click" || i == "keypress") try {
          const d = this.__sentry_instrumentation_handlers__ || {},
            f = d[i];
          f && (f.refCount--, f.refCount <= 0 && (o.call(this, i, f.handler, c), f.handler = void 0, delete d[i]), Object.keys(d).length === 0 && delete this.__sentry_instrumentation_handlers__)
        } catch {}
        return o.call(this, i, l, c)
      }
    }))
  })
}

function QD(e) {
  if (e.type !== $m) return !1;
  try {
    if (!e.target || e.target._sentryId !== Mm) return !1
  } catch {}
  return !0
}

function qD(e, t) {
  return e !== "keypress" ? !1 : !t || !t.tagName ? !0 : !(t.tagName === "INPUT" || t.tagName === "TEXTAREA" || t.isContentEditable)
}

function iy(e, t = !1) {
  return n => {
    if (!n || n._sentryCaptured) return;
    const r = KD(n);
    if (qD(n.type, r)) return;
    es(n, "_sentryCaptured", !0), r && !r._sentryId && es(r, "_sentryId", qr());
    const s = n.type === "keypress" ? "input" : n.type;
    QD(n) || (e({
      event: n,
      name: s,
      global: t
    }), $m = n.type, Mm = r ? r._sentryId : void 0), clearTimeout(oy), oy = Ze.setTimeout(() => {
      Mm = void 0, $m = void 0
    }, YD)
  }
}

function KD(e) {
  try {
    return e.target
  } catch {
    return null
  }
}
let Zd;

function mg(e) {
  const t = "history";
  Jo(t, e), Xo(t, ZD)
}

function ZD() {
  if (!SO()) return;
  const e = Ze.onpopstate;
  Ze.onpopstate = function(...n) {
    const r = Ze.location.href,
      s = Zd;
    if (Zd = r, Qr("history", {
        from: s,
        to: r
      }), e) try {
      return e.apply(this, n)
    } catch {}
  };

  function t(n) {
    return function(...r) {
      const s = r.length > 2 ? r[2] : void 0;
      if (s) {
        const a = Zd,
          o = String(s);
        Zd = o, Qr("history", {
          from: a,
          to: o
        })
      }
      return n.apply(this, r)
    }
  }
  Nr(Ze.history, "pushState", t), Nr(Ze.history, "replaceState", t)
}
const mf = {};

function JD(e) {
  const t = mf[e];
  if (t) return t;
  let n = Ze[e];
  if (Sm(n)) return mf[e] = n.bind(Ze);
  const r = Ze.document;
  if (r && typeof r.createElement == "function") try {
    const s = r.createElement("iframe");
    s.hidden = !0, r.head.appendChild(s);
    const a = s.contentWindow;
    a && a[e] && (n = a[e]), r.head.removeChild(s)
  } catch (s) {
    pg && Me.warn(`Could not create sandbox iframe for ${e} check, bailing to window.${e}: `, s)
  }
  return n && (mf[e] = n.bind(Ze))
}

function ly(e) {
  mf[e] = void 0
}
const hl = "__sentry_xhr_v3__";

function u9(e) {
  const t = "xhr";
  Jo(t, e), Xo(t, XD)
}

function XD() {
  if (!Ze.XMLHttpRequest) return;
  const e = XMLHttpRequest.prototype;
  e.open = new Proxy(e.open, {
    apply(t, n, r) {
      const s = new Error,
        a = cr() * 1e3,
        o = Ma(r[0]) ? r[0].toUpperCase() : void 0,
        i = eL(r[1]);
      if (!o || !i) return t.apply(n, r);
      n[hl] = {
        method: o,
        url: i,
        request_headers: {}
      }, o === "POST" && i.match(/sentry_key/) && (n.__sentry_own_request__ = !0);
      const l = () => {
        const c = n[hl];
        if (c && n.readyState === 4) {
          try {
            c.status_code = n.status
          } catch {}
          const d = {
            endTimestamp: cr() * 1e3,
            startTimestamp: a,
            xhr: n,
            virtualError: s
          };
          Qr("xhr", d)
        }
      };
      return "onreadystatechange" in n && typeof n.onreadystatechange == "function" ? n.onreadystatechange = new Proxy(n.onreadystatechange, {
        apply(c, d, f) {
          return l(), c.apply(d, f)
        }
      }) : n.addEventListener("readystatechange", l), n.setRequestHeader = new Proxy(n.setRequestHeader, {
        apply(c, d, f) {
          const [p, h] = f, _ = d[hl];
          return _ && Ma(p) && Ma(h) && (_.request_headers[p.toLowerCase()] = h), c.apply(d, f)
        }
      }), t.apply(n, r)
    }
  }), e.send = new Proxy(e.send, {
    apply(t, n, r) {
      const s = n[hl];
      if (!s) return t.apply(n, r);
      r[0] !== void 0 && (s.body = r[0]);
      const a = {
        startTimestamp: cr() * 1e3,
        xhr: n
      };
      return Qr("xhr", a), t.apply(n, r)
    }
  })
}

function eL(e) {
  if (Ma(e)) return e;
  try {
    return e.toString()
  } catch {}
}
const Y1 = [],
  gf = new Map;

function tL() {
  if (hg() && $r) {
    const t = nL();
    return () => {
      t()
    }
  }
  return () => {}
}
const uy = {
  click: "click",
  pointerdown: "click",
  pointerup: "click",
  mousedown: "click",
  mouseup: "click",
  touchstart: "click",
  touchend: "click",
  mouseover: "hover",
  mouseout: "hover",
  mouseenter: "hover",
  mouseleave: "hover",
  pointerover: "hover",
  pointerout: "hover",
  pointerenter: "hover",
  pointerleave: "hover",
  dragstart: "drag",
  dragend: "drag",
  drag: "drag",
  dragenter: "drag",
  dragleave: "drag",
  dragover: "drag",
  drop: "drag",
  keydown: "press",
  keyup: "press",
  keypress: "press",
  input: "press"
};

function nL() {
  return gD(({
    metric: e
  }) => {
    if (e.value == null) return;
    const t = e.entries.find(_ => _.duration === e.value && uy[_.name]);
    if (!t) return;
    const {
      interactionId: n
    } = t, r = uy[t.name], s = pn($r + t.startTime), a = pn(e.value), o = Zn(), i = o ? qn(o) : void 0, c = (n != null ? gf.get(n) : void 0) || i, d = c ? Tt(c).description : Kt().getScopeData().transactionName, f = Fi(t.target), p = jn({
      [Mn]: "auto.http.browser.inp",
      [Hi]: `ui.interaction.${r}`,
      [og]: t.duration
    }), h = i9({
      name: f,
      transaction: d,
      attributes: p,
      startTime: s
    });
    h && (h.addEvent("inp", {
      [jp]: "millisecond",
      [Hp]: e.value
    }), h.end(s + a))
  })
}

function rL(e) {
  const t = ({
    entries: n
  }) => {
    const r = Zn(),
      s = r && qn(r);
    n.forEach(a => {
      if (!xD(a) || !s) return;
      const o = a.interactionId;
      if (o != null && !gf.has(o)) {
        if (Y1.length > 10) {
          const i = Y1.shift();
          gf.delete(i)
        }
        Y1.push(o), gf.set(o, s)
      }
    })
  };
  Lc("event", t), Lc("first-input", t)
}

function sL(e, t = JD("fetch")) {
  let n = 0,
    r = 0;

  function s(a) {
    const o = a.body.length;
    n += o, r++;
    const i = {
      body: a.body,
      method: "POST",
      referrerPolicy: "origin",
      headers: e.headers,
      keepalive: n <= 6e4 && r < 15,
      ...e.fetchOptions
    };
    if (!t) return ly("fetch"), Yf("No fetch implementation available");
    try {
      return t(e.url, i).then(l => (n -= o, r--, {
        statusCode: l.status,
        headers: {
          "x-sentry-rate-limits": l.headers.get("X-Sentry-Rate-Limits"),
          "retry-after": l.headers.get("Retry-After")
        }
      }))
    } catch (l) {
      return ly("fetch"), n -= o, r--, Yf(l)
    }
  }
  return LM(e, s)
}
const aL = 30,
  oL = 50;

function Om(e, t, n, r) {
  const s = {
    filename: e,
    function: t === "<anonymous>" ? Ni : t,
    in_app: !0
  };
  return n !== void 0 && (s.lineno = n), r !== void 0 && (s.colno = r), s
}
const iL = /^\s*at (\S+?)(?::(\d+))(?::(\d+))\s*$/i,
  lL = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,
  uL = /\((\S*)(?::(\d+))(?::(\d+))\)/,
  cL = e => {
    const t = iL.exec(e);
    if (t) {
      const [, r, s, a] = t;
      return Om(r, Ni, +s, +a)
    }
    const n = lL.exec(e);
    if (n) {
      if (n[2] && n[2].indexOf("eval") === 0) {
        const o = uL.exec(n[2]);
        o && (n[2] = o[1], n[3] = o[2], n[4] = o[3])
      }
      const [s, a] = c9(n[1] || Ni, n[2]);
      return Om(a, s, n[3] ? +n[3] : void 0, n[4] ? +n[4] : void 0)
    }
  },
  dL = [aL, cL],
  fL = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i,
  pL = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i,
  hL = e => {
    const t = fL.exec(e);
    if (t) {
      if (t[3] && t[3].indexOf(" > eval") > -1) {
        const a = pL.exec(t[3]);
        a && (t[1] = t[1] || "eval", t[3] = a[1], t[4] = a[2], t[5] = "")
      }
      let r = t[3],
        s = t[1] || Ni;
      return [s, r] = c9(s, r), Om(r, s, t[4] ? +t[4] : void 0, t[5] ? +t[5] : void 0)
    }
  },
  mL = [oL, hL],
  gL = [dL, mL],
  vL = e8(...gL),
  c9 = (e, t) => {
    const n = e.indexOf("safari-extension") !== -1,
      r = e.indexOf("safari-web-extension") !== -1;
    return n || r ? [e.indexOf("@") !== -1 ? e.split("@")[0] : Ni, n ? `safari-extension:${t}` : `safari-web-extension:${t}`] : [e, t]
  },
  Jd = 1024,
  _L = "Breadcrumbs",
  yL = (e = {}) => {
    const t = {
      console: !0,
      dom: !0,
      fetch: !0,
      history: !0,
      sentry: !0,
      xhr: !0,
      ...e
    };
    return {
      name: _L,
      setup(n) {
        t.console && sO(xL(n)), t.dom && WD(CL(n, t.dom)), t.xhr && u9(kL(n)), t.fetch && G8(SL(n)), t.history && mg(EL(n)), t.sentry && n.on("beforeSendEvent", wL(n))
      }
    }
  },
  bL = yL;

function wL(e) {
  return function(n) {
    Dt() === e && jo({
      category: `sentry.${n.type==="transaction"?"transaction":"event"}`,
      event_id: n.event_id,
      level: n.level,
      message: ho(n)
    }, {
      event: n
    })
  }
}

function CL(e, t) {
  return function(r) {
    if (Dt() !== e) return;
    let s, a, o = typeof t == "object" ? t.serializeAttribute : void 0,
      i = typeof t == "object" && typeof t.maxStringLength == "number" ? t.maxStringLength : void 0;
    i && i > Jd && (ea && Me.warn(`\`dom.maxStringLength\` cannot exceed ${Jd}, but a value of ${i} was configured. Sentry will use ${Jd} instead.`), i = Jd), typeof o == "string" && (o = [o]);
    try {
      const c = r.event,
        d = TL(c) ? c.target : c;
      s = Fi(d, {
        keyAttrs: o,
        maxStringLength: i
      }), a = o8(d)
    } catch {
      s = "<unknown>"
    }
    if (s.length === 0) return;
    const l = {
      category: `ui.${r.name}`,
      message: s
    };
    a && (l.data = {
      "ui.component_name": a
    }), jo(l, {
      event: r.event,
      name: r.name,
      global: r.global
    })
  }
}

function xL(e) {
  return function(n) {
    if (Dt() !== e) return;
    const r = {
      category: "console",
      data: {
        arguments: n.args,
        logger: "console"
      },
      level: oO(n.level),
      message: S_(n.args, " ")
    };
    if (n.level === "assert")
      if (n.args[0] === !1) r.message = `Assertion failed: ${S_(n.args.slice(1)," ")||"console.assert"}`, r.data.arguments = n.args.slice(1);
      else return;
    jo(r, {
      input: n.args,
      level: n.level
    })
  }
}

function kL(e) {
  return function(n) {
    if (Dt() !== e) return;
    const {
      startTimestamp: r,
      endTimestamp: s
    } = n, a = n.xhr[hl];
    if (!r || !s || !a) return;
    const {
      method: o,
      url: i,
      status_code: l,
      body: c
    } = a, d = {
      method: o,
      url: i,
      status_code: l
    }, f = {
      xhr: n.xhr,
      input: c,
      startTimestamp: r,
      endTimestamp: s
    }, p = Y8(l);
    jo({
      category: "xhr",
      data: d,
      type: "http",
      level: p
    }, f)
  }
}

function SL(e) {
  return function(n) {
    if (Dt() !== e) return;
    const {
      startTimestamp: r,
      endTimestamp: s
    } = n;
    if (s && !(n.fetchData.url.match(/sentry_key/) && n.fetchData.method === "POST"))
      if (n.error) {
        const a = n.fetchData,
          o = {
            data: n.error,
            input: n.args,
            startTimestamp: r,
            endTimestamp: s
          };
        jo({
          category: "fetch",
          data: a,
          level: "error",
          type: "http"
        }, o)
      } else {
        const a = n.response,
          o = {
            ...n.fetchData,
            status_code: a && a.status
          },
          i = {
            input: n.args,
            response: a,
            startTimestamp: r,
            endTimestamp: s
          },
          l = Y8(o.status_code);
        jo({
          category: "fetch",
          data: o,
          type: "http",
          level: l
        }, i)
      }
  }
}

function EL(e) {
  return function(n) {
    if (Dt() !== e) return;
    let r = n.from,
      s = n.to;
    const a = Ai(st.location.href);
    let o = r ? Ai(r) : void 0;
    const i = Ai(s);
    (!o || !o.path) && (o = a), a.protocol === i.protocol && a.host === i.host && (s = i.relative), a.protocol === o.protocol && a.host === o.host && (r = o.relative), jo({
      category: "navigation",
      data: {
        from: r,
        to: s
      }
    })
  }
}

function TL(e) {
  return !!e && !!e.target
}
const AL = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "BroadcastChannel", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "SharedWorker", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"],
  PL = "BrowserApiErrors",
  IL = (e = {}) => {
    const t = {
      XMLHttpRequest: !0,
      eventTarget: !0,
      requestAnimationFrame: !0,
      setInterval: !0,
      setTimeout: !0,
      ...e
    };
    return {
      name: PL,
      setupOnce() {
        t.setTimeout && Nr(st, "setTimeout", cy), t.setInterval && Nr(st, "setInterval", cy), t.requestAnimationFrame && Nr(st, "requestAnimationFrame", ML), t.XMLHttpRequest && "XMLHttpRequest" in st && Nr(XMLHttpRequest.prototype, "send", OL);
        const n = t.eventTarget;
        n && (Array.isArray(n) ? n : AL).forEach(DL)
      }
    }
  },
  $L = IL;

function cy(e) {
  return function(...t) {
    const n = t[0];
    return t[0] = tu(n, {
      mechanism: {
        data: {
          function: Ba(e)
        },
        handled: !1,
        type: "instrument"
      }
    }), e.apply(this, t)
  }
}

function ML(e) {
  return function(t) {
    return e.apply(this, [tu(t, {
      mechanism: {
        data: {
          function: "requestAnimationFrame",
          handler: Ba(e)
        },
        handled: !1,
        type: "instrument"
      }
    })])
  }
}

function OL(e) {
  return function(...t) {
    const n = this;
    return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach(s => {
      s in n && typeof n[s] == "function" && Nr(n, s, function(a) {
        const o = {
            mechanism: {
              data: {
                function: s,
                handler: Ba(a)
              },
              handled: !1,
              type: "instrument"
            }
          },
          i = rg(a);
        return i && (o.mechanism.data.handler = Ba(i)), tu(a, o)
      })
    }), e.apply(this, t)
  }
}

function DL(e) {
  const n = st[e],
    r = n && n.prototype;
  !r || !r.hasOwnProperty || !r.hasOwnProperty("addEventListener") || (Nr(r, "addEventListener", function(s) {
    return function(a, o, i) {
      try {
        LL(o) && (o.handleEvent = tu(o.handleEvent, {
          mechanism: {
            data: {
              function: "handleEvent",
              handler: Ba(o),
              target: e
            },
            handled: !1,
            type: "instrument"
          }
        }))
      } catch {}
      return s.apply(this, [a, tu(o, {
        mechanism: {
          data: {
            function: "addEventListener",
            handler: Ba(o),
            target: e
          },
          handled: !1,
          type: "instrument"
        }
      }), i])
    }
  }), Nr(r, "removeEventListener", function(s) {
    return function(a, o, i) {
      try {
        const l = o.__sentry_wrapped__;
        l && s.call(this, a, l, i)
      } catch {}
      return s.call(this, a, o, i)
    }
  }))
}

function LL(e) {
  return typeof e.handleEvent == "function"
}
const RL = () => ({
    name: "BrowserSession",
    setupOnce() {
      if (typeof st.document > "u") {
        ea && Me.warn("Using the `browserSessionIntegration` in non-browser environments is not supported.");
        return
      }
      W_({
        ignoreDuration: !0
      }), G_(), mg(({
        from: e,
        to: t
      }) => {
        e !== void 0 && e !== t && (W_({
          ignoreDuration: !0
        }), G_())
      })
    }
  }),
  NL = "GlobalHandlers",
  FL = (e = {}) => {
    const t = {
      onerror: !0,
      onunhandledrejection: !0,
      ...e
    };
    return {
      name: NL,
      setupOnce() {
        Error.stackTraceLimit = 50
      },
      setup(n) {
        t.onerror && (jL(n), dy("onerror")), t.onunhandledrejection && (HL(n), dy("onunhandledrejection"))
      }
    }
  },
  BL = FL;

function jL(e) {
  t8(t => {
    const {
      stackParser: n,
      attachStacktrace: r
    } = d9();
    if (Dt() !== e || q8()) return;
    const {
      msg: s,
      url: a,
      line: o,
      column: i,
      error: l
    } = t, c = zL(fg(n, l || s, void 0, r, !1), a, o, i);
    c.level = "error", R8(c, {
      originalException: l,
      mechanism: {
        handled: !1,
        type: "onerror"
      }
    })
  })
}

function HL(e) {
  n8(t => {
    const {
      stackParser: n,
      attachStacktrace: r
    } = d9();
    if (Dt() !== e || q8()) return;
    const s = VL(t),
      a = ng(s) ? UL(s) : fg(n, s, void 0, r, !0);
    a.level = "error", R8(a, {
      originalException: s,
      mechanism: {
        handled: !1,
        type: "onunhandledrejection"
      }
    })
  })
}

function VL(e) {
  if (ng(e)) return e;
  try {
    if ("reason" in e) return e.reason;
    if ("detail" in e && "reason" in e.detail) return e.detail.reason
  } catch {}
  return e
}

function UL(e) {
  return {
    exception: {
      values: [{
        type: "UnhandledRejection",
        value: `Non-Error promise rejection captured with value: ${String(e)}`
      }]
    }
  }
}

function zL(e, t, n, r) {
  const s = e.exception = e.exception || {},
    a = s.values = s.values || [],
    o = a[0] = a[0] || {},
    i = o.stacktrace = o.stacktrace || {},
    l = i.frames = i.frames || [],
    c = r,
    d = n,
    f = Ma(t) && t.length > 0 ? t : $I();
  return l.length === 0 && l.push({
    colno: c,
    filename: f,
    function: Ni,
    in_app: !0,
    lineno: d
  }), e
}

function dy(e) {
  ea && Me.log(`Global Handler attached: ${e}`)
}

function d9() {
  const e = Dt();
  return e && e.getOptions() || {
    stackParser: () => [],
    attachStacktrace: !1
  }
}
const YL = () => ({
    name: "HttpContext",
    preprocessEvent(e) {
      if (!st.navigator && !st.location && !st.document) return;
      const t = e.request && e.request.url || st.location && st.location.href,
        {
          referrer: n
        } = st.document || {},
        {
          userAgent: r
        } = st.navigator || {},
        s = {
          ...e.request && e.request.headers,
          ...n && {
            Referer: n
          },
          ...r && {
            "User-Agent": r
          }
        },
        a = {
          ...e.request,
          ...t && {
            url: t
          },
          headers: s
        };
      e.request = a
    }
  }),
  WL = "cause",
  GL = 5,
  QL = "LinkedErrors",
  qL = (e = {}) => {
    const t = e.limit || GL,
      n = e.key || WL;
    return {
      name: QL,
      preprocessEvent(r, s, a) {
        const o = a.getOptions();
        nO(cg, o.stackParser, o.maxValueLength, n, t, r, s)
      }
    }
  },
  KL = qL;

function ZL(e) {
  const t = [YM(), HM(), $L(), bL(), BL(), KL(), uO(), YL()];
  return e.autoSessionTracking !== !1 && t.push(RL()), t
}

function JL(e = {}) {
  const t = {
    defaultIntegrations: ZL(e),
    release: typeof __SENTRY_RELEASE__ == "string" ? __SENTRY_RELEASE__ : st.SENTRY_RELEASE && st.SENTRY_RELEASE.id ? st.SENTRY_RELEASE.id : void 0,
    autoSessionTracking: !0,
    sendClientReports: !0
  };
  return e.defaultIntegrations == null && delete e.defaultIntegrations, {
    ...t,
    ...e
  }
}

function XL() {
  const e = typeof st.window < "u" && st;
  if (!e) return !1;
  const t = e.chrome ? "chrome" : "browser",
    n = e[t],
    r = n && n.runtime && n.runtime.id,
    s = st.location && st.location.href || "",
    a = ["chrome-extension:", "moz-extension:", "ms-browser-extension:", "safari-web-extension:"],
    o = !!r && st === st.top && a.some(l => s.startsWith(`${l}//`)),
    i = typeof e.nw < "u";
  return !!r && !o && !i
}

function eR(e = {}) {
  const t = JL(e);
  if (!t.skipBrowserExtensionCheck && XL()) {
    Qi(() => {
      console.error("[Sentry] You cannot run Sentry this way in a browser extension, check: https://docs.sentry.io/platforms/javascript/best-practices/browser-extensions/")
    });
    return
  }
  ea && (W8() || Me.warn("No Fetch API detected. The Sentry SDK requires a Fetch API compatible environment to send events. Please add a Fetch API polyfill."));
  const n = {
    ...t,
    stackParser: wI(t.stackParser || vL),
    integrations: bM(t),
    transport: t.transport || sL
  };
  return EM(jO, n)
}
const fy = new WeakMap,
  W1 = new Map,
  vf = {
    traceFetch: !0,
    traceXHR: !0,
    enableHTTPTimings: !0,
    trackFetchStreamPerformance: !1
  };

function tR(e, t) {
  const {
    traceFetch: n,
    traceXHR: r,
    trackFetchStreamPerformance: s,
    shouldCreateSpanForRequest: a,
    enableHTTPTimings: o,
    tracePropagationTargets: i
  } = {
    traceFetch: vf.traceFetch,
    traceXHR: vf.traceXHR,
    trackFetchStreamPerformance: vf.trackFetchStreamPerformance,
    ...t
  }, l = typeof a == "function" ? a : f => !0, c = f => sR(f, i), d = {};
  n && (e.addEventProcessor(f => (f.type === "transaction" && f.spans && f.spans.forEach(p => {
    if (p.op === "http.client") {
      const h = W1.get(p.span_id);
      h && (p.timestamp = h / 1e3, W1.delete(p.span_id))
    }
  }), f)), s && bO(f => {
    if (f.response) {
      const p = fy.get(f.response);
      p && f.endTimestamp && W1.set(p, f.endTimestamp)
    }
  }), G8(f => {
    const p = pO(f, l, c, d);
    if (f.response && f.fetchData.__span && fy.set(f.response, f.fetchData.__span), p) {
      const h = f9(f.fetchData.url),
        _ = h ? Ai(h).host : void 0;
      p.setAttributes({
        "http.url": h,
        "server.address": _
      })
    }
    o && p && py(p)
  })), r && u9(f => {
    const p = aR(f, l, c, d);
    o && p && py(p)
  })
}

function nR(e) {
  return e.entryType === "resource" && "initiatorType" in e && typeof e.nextHopProtocol == "string" && (e.initiatorType === "fetch" || e.initiatorType === "xmlhttprequest")
}

function py(e) {
  const {
    url: t
  } = Tt(e).data || {};
  if (!t || typeof t != "string") return;
  const n = Lc("resource", ({
    entries: r
  }) => {
    r.forEach(s => {
      nR(s) && s.name.endsWith(t) && (rR(s).forEach(o => e.setAttribute(...o)), setTimeout(n))
    })
  })
}

function Ds(e = 0) {
  return (($r || performance.timeOrigin) + e) / 1e3
}

function rR(e) {
  const {
    name: t,
    version: n
  } = l9(e.nextHopProtocol), r = [];
  return r.push(["network.protocol.version", n], ["network.protocol.name", t]), $r ? [...r, ["http.request.redirect_start", Ds(e.redirectStart)],
    ["http.request.fetch_start", Ds(e.fetchStart)],
    ["http.request.domain_lookup_start", Ds(e.domainLookupStart)],
    ["http.request.domain_lookup_end", Ds(e.domainLookupEnd)],
    ["http.request.connect_start", Ds(e.connectStart)],
    ["http.request.secure_connection_start", Ds(e.secureConnectionStart)],
    ["http.request.connection_end", Ds(e.connectEnd)],
    ["http.request.request_start", Ds(e.requestStart)],
    ["http.request.response_start", Ds(e.responseStart)],
    ["http.request.response_end", Ds(e.responseEnd)]
  ] : r
}

function sR(e, t) {
  const n = st.location && st.location.href;
  if (n) {
    let r, s;
    try {
      r = new URL(e, n), s = new URL(n).origin
    } catch {
      return !1
    }
    const a = r.origin === s;
    return t ? Si(r.toString(), t) || a && Si(r.pathname, t) : a
  } else {
    const r = !!e.match(/^\/(?!\/)/);
    return t ? Si(e, t) : r
  }
}

function aR(e, t, n, r) {
  const s = e.xhr,
    a = s && s[hl];
  if (!s || s.__sentry_own_request__ || !a) return;
  const o = Bo() && t(a.url);
  if (e.endTimestamp && o) {
    const f = s.__sentry_xhr_span_id__;
    if (!f) return;
    const p = r[f];
    p && a.status_code !== void 0 && (p8(p, a.status_code), p.end(), delete r[f]);
    return
  }
  const i = f9(a.url),
    l = i ? Ai(i).host : void 0,
    c = !!Zn(),
    d = o && c ? ud({
      name: `${a.method} ${a.url}`,
      attributes: {
        type: "xhr",
        "http.method": a.method,
        "http.url": i,
        url: a.url,
        "server.address": l,
        [Mn]: "auto.http.browser",
        [Hi]: "http.client"
      }
    }) : new Tu;
  return s.__sentry_xhr_span_id__ = d.spanContext().spanId, r[s.__sentry_xhr_span_id__] = d, n(a.url) && oR(s, Bo() && c ? d : void 0), d
}

function oR(e, t) {
  const {
    "sentry-trace": n,
    baggage: r
  } = V8({
    span: t
  });
  n && iR(e, n, r)
}

function iR(e, t, n) {
  try {
    e.setRequestHeader("sentry-trace", t), n && e.setRequestHeader("baggage", n)
  } catch {}
}

function f9(e) {
  try {
    return new URL(e, st.location.origin).href
  } catch {
    return
  }
}

function lR() {
  st && st.document ? st.document.addEventListener("visibilitychange", () => {
    const e = Zn();
    if (!e) return;
    const t = qn(e);
    if (st.document.hidden && t) {
      const n = "cancelled",
        {
          op: r,
          status: s
        } = Tt(t);
      ea && Me.log(`[Tracing] Transaction: ${n} -> since tab moved to the background, op: ${r}`), s || t.setStatus({
        code: In,
        message: n
      }), t.setAttribute("sentry.cancellation_reason", "document.hidden"), t.end()
    }
  }) : ea && Me.warn("[Tracing] Could not set up background tab detection due to lack of global document")
}
const uR = "BrowserTracing",
  cR = {
    ...hf,
    instrumentNavigation: !0,
    instrumentPageLoad: !0,
    markBackgroundSpan: !0,
    enableLongTask: !0,
    enableLongAnimationFrame: !0,
    enableInp: !0,
    _experiments: {},
    ...vf
  },
  dR = (e = {}) => {
    p$();
    const {
      enableInp: t,
      enableLongTask: n,
      enableLongAnimationFrame: r,
      _experiments: {
        enableInteractions: s,
        enableStandaloneClsSpans: a
      },
      beforeStartSpan: o,
      idleTimeout: i,
      finalTimeout: l,
      childSpanTimeout: c,
      markBackgroundSpan: d,
      traceFetch: f,
      traceXHR: p,
      trackFetchStreamPerformance: h,
      shouldCreateSpanForRequest: _,
      enableHTTPTimings: v,
      instrumentPageLoad: C,
      instrumentNavigation: y
    } = {
      ...cR,
      ...e
    }, b = AD({
      recordClsStandaloneSpans: a || !1
    });
    t && tL(), r && Ct.PerformanceObserver && PerformanceObserver.supportedEntryTypes && PerformanceObserver.supportedEntryTypes.includes("long-animation-frame") ? ID() : n && PD(), s && $D();
    const w = {
      name: void 0,
      source: void 0
    };

    function x(E, S) {
      const T = S.op === "pageload",
        j = o ? o(S) : S,
        P = j.attributes || {};
      S.name !== j.name && (P[Ea] = "custom", j.attributes = P), w.name = j.name, w.source = P[Ea];
      const N = D8(j, {
        idleTimeout: i,
        finalTimeout: l,
        childSpanTimeout: c,
        disableAutoFinish: T,
        beforeSpanEnd: Y => {
          b(), RD(Y, {
            recordClsOnPageloadSpan: !a
          })
        }
      });

      function ne() {
        ["interactive", "complete"].includes(st.document.readyState) && E.emit("idleSpanEnableAutoFinish", N)
      }
      return T && st.document && (st.document.addEventListener("readystatechange", () => {
        ne()
      }), ne()), N
    }
    return {
      name: uR,
      afterAllSetup(E) {
        let S, T = st.location && st.location.href;

        function j() {
          S && !Tt(S).timestamp && (ea && Me.log(`[Tracing] Finishing current active span with op: ${Tt(S).op}`), S.end())
        }
        E.on("startNavigationSpan", P => {
          Dt() === E && (j(), S = x(E, {
            op: "navigation",
            ...P
          }))
        }), E.on("startPageLoadSpan", (P, N = {}) => {
          if (Dt() !== E) return;
          j();
          const ne = N.sentryTrace || hy("sentry-trace"),
            Y = N.baggage || hy("baggage"),
            _e = o$(ne, Y);
          Kt().setPropagationContext(_e), S = x(E, {
            op: "pageload",
            ...P
          })
        }), E.on("spanEnd", P => {
          const N = Tt(P).op;
          if (P !== qn(P) || N !== "navigation" && N !== "pageload") return;
          const ne = Kt(),
            Y = ne.getPropagationContext();
          ne.setPropagationContext({
            ...Y,
            sampled: Y.sampled !== void 0 ? Y.sampled : Ki(P),
            dsc: Y.dsc || Au(P)
          })
        }), st.location && (C && fR(E, {
          name: st.location.pathname,
          startTime: $r ? $r / 1e3 : void 0,
          attributes: {
            [Ea]: "url",
            [Mn]: "auto.pageload.browser"
          }
        }), y && mg(({
          to: P,
          from: N
        }) => {
          if (N === void 0 && T && T.indexOf(P) !== -1) {
            T = void 0;
            return
          }
          N !== P && (T = void 0, pR(E, {
            name: st.location.pathname,
            attributes: {
              [Ea]: "url",
              [Mn]: "auto.navigation.browser"
            }
          }))
        })), d && lR(), s && hR(i, l, c, w), t && rL(), tR(E, {
          traceFetch: f,
          traceXHR: p,
          trackFetchStreamPerformance: h,
          tracePropagationTargets: E.getOptions().tracePropagationTargets,
          shouldCreateSpanForRequest: _,
          enableHTTPTimings: v
        })
      }
    }
  };

function fR(e, t, n) {
  e.emit("startPageLoadSpan", t, n), Kt().setTransactionName(t.name);
  const r = Zn();
  return (r && Tt(r).op) === "pageload" ? r : void 0
}

function pR(e, t) {
  Qa().setPropagationContext({
    traceId: No()
  }), Kt().setPropagationContext({
    traceId: No()
  }), e.emit("startNavigationSpan", t), Kt().setTransactionName(t.name);
  const n = Zn();
  return (n && Tt(n).op) === "navigation" ? n : void 0
}

function hy(e) {
  const t = MI(`meta[name=${e}]`);
  return t ? t.getAttribute("content") : void 0
}

function hR(e, t, n, r) {
  let s;
  const a = () => {
    const o = "ui.action.click",
      i = Zn(),
      l = i && qn(i);
    if (l) {
      const c = Tt(l).op;
      if (["navigation", "pageload"].includes(c)) {
        ea && Me.warn(`[Tracing] Did not create ${o} span because a pageload or navigation span is in progress.`);
        return
      }
    }
    if (s && (s.setAttribute(vm, "interactionInterrupted"), s.end(), s = void 0), !r.name) {
      ea && Me.warn(`[Tracing] Did not create ${o} transaction because _latestRouteName is missing.`);
      return
    }
    s = D8({
      name: r.name,
      op: o,
      attributes: {
        [Ea]: r.source || "url"
      }
    }, {
      idleTimeout: e,
      finalTimeout: t,
      childSpanTimeout: n
    })
  };
  st.document && addEventListener("click", a, {
    once: !1,
    capture: !0
  })
}
const mR = "2.4.19",
  gR = {
    version: mR
  };

function vR() {
  let e = !1;
  eR({
    dsn: "https://13a10ebf88f849198e10617818d9ce0a@sentry.bgaming-system.com/22",
    release: gR.version,
    environment: "production",
    integrations: [dR()],
    tracesSampleRate: .05,
    attachStacktrace: !0,
    initialScope: {
      tags: {
        growth_project: "lobby"
      }
    },
    denyUrls: [/safari-web-extension:/, /safari-extension:/, /moz-extension:/, /chrome-extension:/, /edge-extension:/, /ms-browser-extension:/]
  }), e = !0;

  function n(i) {
    e && fM(i)
  }

  function r(i) {
    e && L8(i)
  }

  function s(i) {
    e && dM(i)
  }

  function a(i) {
    e && jo({
      data: i
    })
  }

  function o(i) {
    e && uc.setTags({
      currency: i.currency,
      locale: i.locale,
      server_id: i.server_id,
      title: i.title
    })
  }
  return {
    captureException: r,
    captureMessage: s,
    setTags: n,
    updateBreadcrumbs: a,
    init: o
  }
}
const uc = vR();

function p9(e, t) {
  let n = null;
  return (...r) => {
    n !== null && clearTimeout(n), n = setTimeout(() => {
      e(...r)
    }, t)
  }
}
const Kf = L(() => Li.subunits ? Math.floor(Math.log10(Li.subunits)) : 0),
  h9 = L(() => Li.code || ""),
  _R = L(() => Li.symbol || ""),
  Us = (e, t) => rd.value ? `${t} ${e}` : `${e} ${t}`,
  Gn = e => {
    const t = (e / 100).toFixed(2);
    return Us(t, "EUR")
  },
  Rt = (e, t = !1) => {
    const n = (e / Math.pow(10, Kf.value)).toFixed(Kf.value);
    return t ? `${n}` : Us(n, h9.value)
  },
  m9 = (e, t = !1) => {
    const n = e / 100,
      r = t ? "€" : "EUR";
    if (n === 0) return Us(0, r);
    const s = [{
      val: 1e9,
      suffix: "B"
    }, {
      val: 1e6,
      suffix: "M"
    }, {
      val: 1e3,
      suffix: "K"
    }];
    for (const {
        val: a,
        suffix: o
      }
      of s)
      if (n >= a) {
        const i = Math.floor(n / a * 10) / 10;
        return Us(`${i}${o}`, r)
      } return n < 1e-6 ? Us("≤0.000001", r) : Us(n.toFixed(2), r)
  },
  zp = (e, t = !1) => {
    const n = e / Math.pow(10, Kf.value),
      r = t ? _R.value : h9.value;
    if (n === 0) return Us(0, r);
    const s = [{
      val: 1e9,
      suffix: "B"
    }, {
      val: 1e6,
      suffix: "M"
    }, {
      val: 1e3,
      suffix: "K"
    }];
    for (const {
        val: a,
        suffix: o
      }
      of s)
      if (n >= a) {
        const i = Math.floor(n / a * 10) / 10;
        return Us(`${i}${o}`, r)
      } return n < 1e-6 ? Us("≤0.000001", r) : Us(n.toFixed(Kf.value), r)
  },
  ta = (e, t = "en") => {
    const n = new Date(e),
      r = new Intl.DateTimeFormat(t, {
        day: "numeric",
        month: "numeric",
        year: "numeric",
        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
      }).format(n),
      s = new Intl.DateTimeFormat(t, {
        timeStyle: "short",
        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
      }).format(n),
      a = new Intl.DateTimeFormat(t, {
        day: "2-digit",
        month: "short",
        year: "numeric"
      }).format(n);
    return {
      short: r,
      time: s,
      full: a
    }
  },
  g9 = e => {
    const {
      value: t,
      options: {
        round: n,
        isRemoveLeadingZeros: r,
        replaceDot: s,
        isNeedDot: a
      } = {}
    } = e;
    let o = t;
    s && a && (o = o.replace(",", "."));
    const i = a ? /[^\d.]/g : /[^\d]/g;
    o = o.replace(i, "");
    let l = o.split(".");
    return a ? (l.length > 2 && (o = l[0] + "." + l[1], l = o.split(".")), n && l.length === 2 && l[1].length > n && (l[1] = l[1].substring(0, n), o = l.join("."))) : o = l[0], r && o.startsWith("0") && !o.startsWith("0.") && o.length > 1 && (o = o.replace(/^0+/, "")), isNaN(Number(o)) ? "0" : o
  },
  gg = (e, t) => g9({
    value: e,
    options: {
      isRemoveLeadingZeros: !0,
      isNeedDot: !0,
      round: t,
      replaceDot: !0
    }
  }),
  v9 = e => g9({
    value: e,
    options: {
      isRemoveLeadingZeros: !0,
      isNeedDot: !1
    }
  }),
  yR = {
    drop: {
      title: {
        t: 0,
        b: {
          t: 2,
          i: [{
            t: 3
          }],
          s: "Drops"
        }
      },
      general: {
        active_player: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "You are taking part in the promo! Just spin to catch a Drop"
          }
        },
        active_player_progressive: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "The rewards for the drop campaign are being distributed. Data is updated daily at 6:00 AM UTC-00"
          }
        },
        passive_player: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "You took part in the promo!"
          }
        },
        left: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Prizes left"
          }
        },
        prize_pool: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Prize pool"
          }
        },
        rules_button: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "How to play"
          }
        },
        prizes_button: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Prizes"
          }
        }
      },
      join: {
        button: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Join for free"
          }
        },
        badge: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Free"
          }
        },
        loading: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Joining"
          }
        },
        join_pro_title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Fee is"
          }
        },
        join_pro_button: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Pay fee and join"
          }
        },
        join_pro_badge: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Pro"
          }
        },
        join_balance_error: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Balance is not enough to join"
          }
        },
        errors: {
          CAMP_SUBSCRIPTION_PAUSED_CAMPAIGN: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "This drop campaign is paused"
            }
          },
          CAMP_SUBSCRIPTION_CLOSED: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "This drop campaign has already finished"
            }
          },
          CAMP_SUBSCRIPTION_PAYMENT_ERROR: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Payment error"
            }
          },
          CAMP_SUBSCRIPTION_TECHNICAL_ERROR: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Something went wrong"
            }
          }
        }
      },
      prize_pool: {
        title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Drop prize pool"
          }
        },
        title_progressive: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Daily prize pool"
          }
        },
        column_prizes: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Prizes"
          }
        },
        column_left: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Left/Start"
          }
        },
        column_left_progressive: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Left/Total"
          }
        }
      },
      user_wins: {
        title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "You won"
          }
        },
        column_date: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Date"
          }
        },
        column_time: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Time"
          }
        },
        column_value: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Value"
          }
        },
        column_game: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Game"
          }
        }
      },
      top_wins: {
        title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Recently won drops"
          }
        },
        column_id: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "ID"
          }
        },
        column_date: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Date"
          }
        },
        column_time: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Time"
          }
        },
        column_prize: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Prize"
          }
        }
      },
      rules: {
        title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Rules"
          }
        },
        spin: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Just one spin to win"
          }
        },
        rtp: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Doesn't affect RTP of the game"
          }
        },
        bet: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "All bets qualify unless a minimum bet is set"
          }
        },
        goal: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "The higher the bet, the higher the chances of winning the prize"
          }
        },
        max_wins_per_player: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3,
              v: "The number of prizes a single player can win in this campaign is limited to "
            }, {
              t: 4,
              k: "value"
            }, {
              t: 3,
              v: "."
            }]
          }
        },
        details: {
          title: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "All rules of Promo"
            }
          },
          description: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3,
                v: 'The "'
              }, {
                t: 4,
                k: "name"
              }, {
                t: 3,
                v: '" promotion is available for this game and runs from '
              }, {
                t: 4,
                k: "from"
              }, {
                t: 3,
                v: " to "
              }, {
                t: 4,
                k: "to"
              }, {
                t: 3,
                v: ' ("Promotion Deadline") or until all prizes have been drawn.'
              }]
            }
          },
          agreement: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "By participating in a promotion (as defined below), you hereby agree to abide by these terms and conditions."
            }
          },
          summary: {
            title: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3,
                  v: 'Promotion "'
                }, {
                  t: 4,
                  k: "value"
                }, {
                  t: 3,
                  v: '"'
                }]
              }
            },
            total: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3,
                  v: "The total amount of prizes is "
                }, {
                  t: 4,
                  k: "value"
                }, {
                  t: 3,
                  v: "."
                }]
              }
            },
            max: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3,
                  v: "The main prize is "
                }, {
                  t: 4,
                  k: "value"
                }, {
                  t: 3,
                  v: "."
                }]
              }
            },
            amount: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3,
                  v: "The number of prizes is "
                }, {
                  t: 4,
                  k: "value"
                }, {
                  t: 3,
                  v: "."
                }]
              }
            },
            delay: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3
                }],
                s: "Prize payouts may be delayed up to 72 hours."
              }
            }
          },
          conditions: {
            title: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3,
                  v: 'How to take part in the "'
                }, {
                  t: 4,
                  k: "value"
                }, {
                  t: 3,
                  v: '" promotion'
                }]
              }
            },
            join: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3
                }],
                s: "The player needs to join the promotion-related game."
              }
            },
            spin: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3
                }],
                s: "The player must make at least one spin."
              }
            },
            bet: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3
                }],
                s: "Any bet placed on any eligible game may result in a maximum of one random prize from the prize pool during the promotion period."
              }
            },
            player: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3
                }],
                s: "The number of prizes to win by one player is limited only by their number."
              }
            },
            limit: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3
                }],
                s: "The number of prizes a single player can win is limited only by the prize pool of the campaign."
              }
            },
            free: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3
                }],
                s: "Participation in the promotion will not carry any additional costs."
              }
            }
          },
          prizes: {
            title: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3,
                  v: 'Promotion prize table "'
                }, {
                  t: 4,
                  k: "value"
                }, {
                  t: 3,
                  v: '"'
                }]
              }
            },
            amount: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3
                }],
                s: "Quantity/Amount"
              }
            }
          },
          progressive: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "The progressive prize pool grows based on overall players activity within the drop campaign. Recalculation is performed daily. You can track it's dynamic in drop campaign details information"
            }
          }
        }
      }
    },
    challenge: {
      title: {
        t: 0,
        b: {
          t: 2,
          i: [{
            t: 3
          }],
          s: "Challenges"
        }
      },
      general: {
        active_player: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "You are taking part in the promo!"
          }
        },
        passive_player: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "You took part in the promo!"
          }
        },
        rules_button: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Read challenge rules"
          }
        },
        sync_message: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Calculating results"
          }
        },
        spin_limit: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: `Spin
limit`
          }
        },
        limit_message: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Spins limit reached. Further spins won't count"
          }
        },
        left: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Spins left"
          }
        }
      },
      join: {
        title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Paste your invitation code to join the challenge"
          }
        },
        button: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "I'm in!"
          }
        },
        button_auto: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Join"
          }
        },
        fee: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Fee is"
          }
        },
        loading: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Joining"
          }
        },
        badge: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Free"
          }
        },
        join_pro_badge: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Pro"
          }
        },
        join_pro_button: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Pay fee and join"
          }
        },
        join_balance_error: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Balance is not enough to join"
          }
        },
        error: {
          101: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Paste a valid code"
            }
          },
          100: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "You are taking part in another challenge"
            }
          },
          206: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Payment Error"
            }
          },
          107: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "This challenge reached participants limit"
            }
          },
          default: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Something went wrong. Please try again later"
            }
          }
        }
      },
      playerCode: {
        title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Note"
          }
        },
        message: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Each participant is assigned a unique player ID. It may be useful if any questions arise during the challenge or for verifying your identity as a player."
          }
        },
        button: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Copy code"
          }
        },
        toast: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Code is copied"
          }
        }
      },
      rules: {
        title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Rules"
          }
        },
        fee: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3,
              v: "Participation fee is "
            }, {
              t: 4,
              k: "value"
            }, {
              t: 3,
              v: ". Fee will be taken from your balance when you join the challenge. The prize pool is formed from entry fees and is divided among the winners based on the results of the challenge in accordance with the settings"
            }]
          }
        },
        games: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3,
              v: "Games participating the challenge: "
            }, {
              t: 4,
              k: "value"
            }]
          }
        },
        goal: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Highest multiplier wins"
          }
        },
        goal_bets: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3,
              v: "The player with the highest total bets wins. Scoring rule: 1 point for every "
            }, {
              t: 4,
              k: "value"
            }, {
              t: 3,
              v: " bet"
            }]
          }
        },
        goal_mult: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3,
              v: "The player with the highest sum of multipliers wins. The top "
            }, {
              t: 4,
              k: "value"
            }, {
              t: 3,
              v: " multipliers during the Challenge period are considered"
            }]
          }
        },
        goal_sum: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "The player with the highest total sum of multipliers wins. All multipliers accumulated during the challenge period are counted"
          }
        },
        winner: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "If players have equal top multipliers, then the one who gets it first - win"
          }
        },
        winner_bets: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "If players have the same total bets, the one who reached it first wins"
          }
        },
        winner_mult: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "If players have the same sum of multipliers, the winner is the one who achieved it first"
          }
        },
        winner_sum: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "If players have the same total multiplier sum, the one who reaches it first wins"
          }
        },
        id: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Changing the currency will switch your player ID, and your challenge progress will be recorded separately for each player ID"
          }
        },
        bet_eur: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3,
              v: "Min bet is "
            }, {
              t: 4,
              k: "value"
            }]
          }
        },
        bet_ext: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3,
              v: "Min bet is "
            }, {
              t: 4,
              k: "value"
            }, {
              t: 3,
              v: " ("
            }, {
              t: 4,
              k: "ext"
            }, {
              t: 3,
              v: ")"
            }]
          }
        },
        bet: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Any bet level is allowed"
          }
        },
        spin_denied: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "The features you have purchased will not be accounted for in the challenge results"
          }
        },
        spin_feature: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Only purchased and won features will be taken into account for the challenge"
          }
        },
        spin: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Any spin (incl. extra buys) counts in the challenge"
          }
        },
        limit_on: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3,
              v: "Spins: "
            }, {
              t: 4,
              k: "value"
            }, {
              t: 3,
              v: " per player to get the highest multiplier. You'll be notified when your spins are done"
            }]
          }
        },
        limit: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "No limit for spin count"
          }
        },
        one_participant: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "If there's only one participant, the challenge is canceled, and fees are refunded"
          }
        },
        fewer_participant: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "If participants are fewer than prize spots, the challenge is canceled, and fees are refunded"
          }
        },
        prizes_distribution: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Prizes are awarded to active players by max multiplier, others by join order"
          }
        },
        closed_after_start: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "For challenges where joining is closed after the start: the participant count is checked at the start of the challenge"
          }
        },
        opened_after_start: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "For challenges where joining is allowed after the start: the participant count is checked when prizes are distributed"
          }
        },
        limit_participants: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Only a limited number of participants can join the challenge"
          }
        }
      },
      modals: {
        cancelled: {
          title: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "This challenge was cancelled due to insufficient number of participants"
            }
          },
          subtitle: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Try your luck in other challenges"
            }
          }
        }
      },
      leaderboard: {
        title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Leaderboard"
          }
        },
        title_full: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Full leaderboard"
          }
        },
        title_player: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "My result"
          }
        },
        column_rank: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "#"
          }
        },
        column_id: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Player id"
          }
        },
        column_result: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Multiplier"
          }
        },
        column_result_bets: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Bets sum"
          }
        },
        column_result_mult: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Multiplier sum"
          }
        },
        loading_text: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Loading data"
          }
        },
        button: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "View full leaderboard"
          }
        },
        no_data: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "No players participating at the moment"
          }
        },
        prize: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Prize"
          }
        }
      },
      games: {
        title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Participating games"
          }
        },
        more: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3,
              v: "And "
            }, {
              t: 4,
              k: "value"
            }, {
              t: 3,
              v: " more"
            }]
          }
        }
      },
      p2p: {
        title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Create challenge"
          }
        },
        challenge_mode: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Challenge mode"
          }
        },
        challenge_type: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Challenge type"
          }
        },
        challenge_image: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Challenge image"
          }
        },
        multiplier_count: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Max multiplier count"
          }
        },
        fee: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Fee"
          }
        },
        entry_fee: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Entry fee"
          }
        },
        fee_is: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3,
              v: "Fee is "
            }, {
              t: 4,
              k: "value"
            }]
          }
        },
        pool_is: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3,
              v: "Prize pool is "
            }, {
              t: 4,
              k: "value"
            }]
          }
        },
        games: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Games"
          }
        },
        privacy: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Privacy"
          }
        },
        private: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Private"
          }
        },
        public: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Public"
          }
        },
        joining_code: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Joining code"
          }
        },
        start: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Start"
          }
        },
        end: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "End"
          }
        },
        about_limit: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "You can enable either the Spin limit or the Min bet limit at the same time"
          }
        },
        spin_limit: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Spin limit"
          }
        },
        min_bet: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Min bet"
          }
        },
        buy_features_condition: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Buy features condition"
          }
        },
        any_spin_allowed: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Any spin allowed"
          }
        },
        only_buy_features: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Only buy features"
          }
        },
        buy_features_excluded: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Buy features excluded"
          }
        },
        prizes_distribution: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Prizes distribution"
          }
        },
        add: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Add"
          }
        },
        total: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Total"
          }
        },
        should_be: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Should be 100%"
          }
        },
        joining_rules: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Joining rules"
          }
        },
        can_join: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Players can join after the challenge started"
          }
        },
        not_join: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Players can not join after the challenge started"
          }
        },
        agreements_debited: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3,
              v: "I confirm that I'm creating a challenge with a participation fee of "
            }, {
              t: 4,
              k: "value"
            }, {
              t: 3,
              v: ", which will be debited from my balance when I hit “CREATE CHALLENGE”"
            }]
          }
        },
        agreements_debited_pool: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3,
              v: "I confirm that I'm creating a challenge with a prize pool of "
            }, {
              t: 4,
              k: "value"
            }, {
              t: 3,
              v: ", which will be debited from my balance when I hit “CREATE CHALLENGE”"
            }]
          }
        },
        agreements_cant_edit: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "The challenge can't be edited or cancelled once it's created"
          }
        },
        create: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Pay fee and create challenge"
          }
        },
        select_start_date: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Select start date"
          }
        },
        select_end_date: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Select end date"
          }
        },
        form_keep_editing: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Keep Editing"
          }
        },
        got_it: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Got it"
          }
        },
        challenge_creating: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Creating challenge"
          }
        },
        select_all: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Select all"
          }
        },
        set: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Set"
          }
        },
        challenge_pay_fee_create: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Pay fee and create challenge"
          }
        },
        challenge_deposit_prize_create: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Deposit prize pool and create challenge"
          }
        },
        change_image: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Change Image"
          }
        },
        form_discard: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Discard form"
          }
        },
        form_leave_warning: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "By leaving this form you'll lose all data you've filled in"
          }
        },
        select_games: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Select games"
          }
        },
        congratulations: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Congratulations!"
          }
        },
        you_created: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "You've created"
          }
        },
        challenge: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3,
              v: "Challenge #"
            }, {
              t: 4,
              k: "value"
            }]
          }
        },
        invite_more: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Invite more people to compete and have fun!"
          }
        },
        invite_code_first_part: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Invite more people and share the join code"
          }
        },
        invite_code_second_part: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "to compete and have fun!"
          }
        },
        cant_join_challenge_title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "You can't join challenge"
          }
        },
        cant_join_challenge_subtitle: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "This challenge allows to join new participants only before it started."
          }
        },
        type_options: {
          max_multiplayer: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Max Multiplier"
            }
          },
          top_multiplayer_sum: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Top Multiplier Sum"
            }
          },
          bets_sum: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Bets Sum"
            }
          },
          multiplayers_sum: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Accumulated Multiplier"
            }
          }
        },
        mode_options: {
          friends: {
            title: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3
                }],
                s: "“Friends party”"
              }
            },
            option_organizer: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3
                }],
                s: "You join the challenge as a participant"
              }
            },
            option_participant: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3
                }],
                s: "Everyone, including you, pays an entry fee"
              }
            },
            option_prize_pool: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3
                }],
                s: "The prize pool is the sum of all entry fees"
              }
            }
          },
          influencer: {
            title: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3
                }],
                s: "“Influencer's party”"
              }
            },
            option_organizer: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3
                }],
                s: "You don’t join the challenge"
              }
            },
            option_participant: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3
                }],
                s: "Participation is free for everyone"
              }
            },
            option_prize_pool: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3
                }],
                s: "The prize pool is paid from your balance"
              }
            }
          }
        },
        tooltip: {
          mode: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Choose the type of challenge you want to create. Based on your selection, the relevant fields to fill out will appear below."
            }
          },
          type: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Choose the type of challenge you want to create. Depending on your selection, the system will apply different rules for generating the challenge leaderboard."
            }
          },
          image: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Select an image from the provided list to be displayed on your challenge card for all participants."
            }
          },
          games: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Select one or more games from the list provided where your challenge will be active."
            }
          },
          fee: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Specify the fee amount in EUR that will be deducted from participants' balances. This amount will be used to form the challenge prize pool and will be converted at the exchange rate at the time of payment."
            }
          },
          privacy: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Choose the type of challenge. Access to a private challenge is only available via an invite code and payment of the entry fee. In public challenges, players can join by paying the entry fee."
            }
          },
          joining_code: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Generate or enter a unique joining code that players can use to join your private challenge."
            }
          },
          start: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Specify the start date and time of the challenge based on your device. Each participant will see the start time in their local time zone."
            }
          },
          end: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Specify the end date and time of the challenge based on your device. Each participant will see the end time in their local time zone."
            }
          },
          spin_limit: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Specify the limit on the number of spins that will be counted for each participant in the challenge."
            }
          },
          min_bet: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Specify the minimum bet amount in EUR for which a player's bet will be counted in the challenge."
            }
          },
          paid_features_condition: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Choose the condition for spin participation in the challenge: Any Spin Allowed: All spins and purchased bonuses of the player are allowed.  Only Bought Features: Only the player's purchased bonuses are allowed.  Bought Features Excluded: Purchased bonuses of the player do not participate in the challenge."
            }
          },
          prizes_distribution: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Specify the number of prize positions and the distribution of the prize pool in percentages between them. The percentages should be listed from highest to lowest, and their total must equal 100%."
            }
          },
          prizes_distribution_money: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Specify the number of prize positions and the distribution of the prize pool in EUR. The amounts should be listed from highest to lowest, and the entire prize pool cannot be awarded to just one winner."
            }
          },
          joining_rules: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Choose the rule for player participation in the challenge."
            }
          },
          select_games: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Select games"
            }
          },
          multiplier: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Specify the number of highest multipliers that will be considered when summing the bets."
            }
          },
          feature_conditions: {
            header: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3
                }],
                s: "Choose the condition for spin participation in the challenge:"
              }
            },
            allowed_title: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3
                }],
                s: "Any Spin Allowed:"
              }
            },
            allowed_description: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3
                }],
                s: "All spins and purchased bonuses of the player are allowed."
              }
            },
            bought_title: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3
                }],
                s: "Only Buy Features:"
              }
            },
            bought_description: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3
                }],
                s: "Only the player's purchased bonuses are allowed."
              }
            },
            bought_excluded_title: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3
                }],
                s: "Buy Features Excluded:"
              }
            },
            bought_excluded_description: {
              t: 0,
              b: {
                t: 2,
                i: [{
                  t: 3
                }],
                s: "Purchased bonuses of the player do not participate in the challenge."
              }
            }
          }
        },
        error: {
          must_greater: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3,
                v: "Value must be greater than "
              }, {
                t: 4,
                k: "value"
              }]
            }
          },
          must_less: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3,
                v: "Value must be less than "
              }, {
                t: 4,
                k: "value"
              }]
            }
          },
          game: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Add at least one game"
            }
          },
          fee: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Set fee"
            }
          },
          characters: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3,
                v: "Must have "
              }, {
                t: 4,
                k: "value"
              }, {
                t: 3,
                v: " characters"
              }]
            }
          },
          date: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Can't be in the past"
            }
          },
          min_bet: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3,
                v: "The minimum bet must be at least "
              }, {
                t: 4,
                k: "value"
              }]
            }
          },
          max_bet: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3,
                v: "The maximum bet cannot exceed "
              }, {
                t: 4,
                k: "value"
              }, {
                t: 3,
                v: " (considering currency conversion)"
              }]
            }
          },
          only_letters_numbers: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Only letters and numbers allowed"
            }
          },
          organizer_participating: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Can't create the challenge: the organizer is already participating in one or more selected games"
            }
          },
          amount_too_high: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3,
                v: "The amount cannot exceed "
              }, {
                t: 4,
                k: "value"
              }]
            }
          },
          insufficient_balance: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Insufficient balance"
            }
          },
          code_length: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3,
                v: "The code must be exactly "
              }, {
                t: 4,
                k: "value"
              }, {
                t: 3,
                v: " characters long"
              }]
            }
          },
          start_date_invalid: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "The start date cannot be later than the end date"
            }
          },
          start_date_too_soon: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3,
                v: "The challenge must start at least "
              }, {
                t: 4,
                k: "value"
              }, {
                t: 3,
                v: " minutes from now"
              }]
            }
          },
          min_bet_too_low: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3,
                v: "The minimum bet must be at least "
              }, {
                t: 4,
                k: "value"
              }, {
                t: 3,
                v: " (considering currency conversion)"
              }]
            }
          },
          max_bet_too_high: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3,
                v: "The maximum bet cannot exceed "
              }, {
                t: 4,
                k: "value"
              }, {
                t: 3,
                v: " (considering currency conversion)"
              }]
            }
          },
          prize_cannot_be: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3,
                v: "The prize place cannot be "
              }, {
                t: 4,
                k: "value"
              }]
            }
          },
          prize_exceeds_previous: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "The prize for this place cannot exceed the previous place's reward"
            }
          },
          code_invalid: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "The code must contain only Latin letters and digits"
            }
          },
          cannot_be_empty: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Can't be empty"
            }
          },
          response_title_default: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Something went wrong"
            }
          },
          response_subtitle_default: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Please try again later or contact support"
            }
          },
          response_title_206: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Payment Error"
            }
          },
          response_subtitle_206: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Your payment couldn't be processed. Please check your balance or try again later"
            }
          },
          response_title_100: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "You're Already in a Challenge"
            }
          },
          response_subtitle_100: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "You've already joined this challenge or another one with intersecting games."
            }
          },
          min_bet_present: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Can't be set when min bet is present"
            }
          },
          spin_limit_present: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Can't be set when spin limit is present"
            }
          }
        }
      }
    },
    games: {
      title: {
        t: 0,
        b: {
          t: 2,
          i: [{
            t: 3
          }],
          s: "Games"
        }
      },
      empty_title: {
        t: 0,
        b: {
          t: 2,
          i: [{
            t: 3
          }],
          s: "There are no games matching your request"
        }
      },
      empty_subtitle: {
        t: 0,
        b: {
          t: 2,
          i: [{
            t: 3
          }],
          s: "Try to adjust filters and search request"
        }
      },
      search_placeholder: {
        t: 0,
        b: {
          t: 2,
          i: [{
            t: 3
          }],
          s: "Search games"
        }
      },
      filter: {
        title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Filter games"
          }
        },
        label: {
          volatility: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Volatility"
            }
          },
          game_type: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Game type"
            }
          },
          features: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Features"
            }
          },
          events: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Events"
            }
          }
        },
        button: {
          clear: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Clear"
            }
          },
          filter: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Filter"
            }
          }
        },
        volatility: {
          all: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "All"
            }
          },
          low: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Low"
            }
          },
          medium: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Medium"
            }
          },
          high: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "High"
            }
          }
        },
        event: {
          select: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Select an event"
            }
          },
          all: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "All events"
            }
          }
        }
      },
      sort: {
        title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Sort by"
          }
        },
        sort_types: {
          popular: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Popular first"
            }
          },
          newest: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Newest first"
            }
          },
          oldest: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Oldest first"
            }
          },
          hot: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Hot games first"
            }
          },
          cold: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Cold games first"
            }
          }
        }
      }
    },
    profile: {
      title: {
        t: 0,
        b: {
          t: 2,
          i: [{
            t: 3
          }],
          s: "Loyalty"
        }
      },
      level: {
        t: 0,
        b: {
          t: 2,
          i: [{
            t: 3
          }],
          s: "Level"
        }
      },
      xp: {
        t: 0,
        b: {
          t: 2,
          i: [{
            t: 3
          }],
          s: "xp"
        }
      },
      id_title: {
        t: 0,
        b: {
          t: 2,
          i: [{
            t: 3
          }],
          s: "Loyalty profile ID"
        }
      },
      telegram_button_title: {
        t: 0,
        b: {
          t: 2,
          i: [{
            t: 3
          }],
          s: "link telegram"
        }
      },
      telegram_linked: {
        t: 0,
        b: {
          t: 2,
          i: [{
            t: 3
          }],
          s: "Telegram linked"
        }
      },
      privileges: {
        current_title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Current rewards"
          }
        },
        next_title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Next rewards"
          }
        },
        next_empty: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "New rewards will be added soon"
          }
        },
        type_title: {
          extra_points: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 4,
                k: "value"
              }, {
                t: 3,
                v: " Extra Points"
              }]
            }
          },
          p2p_challenges: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "P2P Challenges"
            }
          },
          big_wins: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Big Wins"
            }
          },
          mystery_box: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "Mystery Box"
            }
          }
        }
      },
      error: {
        title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "We couldn't load your profile info"
          }
        },
        sub_title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Try to reload page"
          }
        }
      }
    },
    common: {
      event_list: {
        active_title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Active and planned events"
          }
        },
        ended_title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Recently ended events"
          }
        },
        empty: {
          title: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "There are no active and planned events at the moment"
            }
          },
          sub_title: {
            t: 0,
            b: {
              t: 2,
              i: [{
                t: 3
              }],
              s: "We'll let you know when there's any activity here"
            }
          }
        }
      },
      error: {
        list_title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Can't load events"
          }
        },
        details_title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Can't load event details"
          }
        },
        leaderboard_title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Can't load leaderboard"
          }
        },
        games_title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Can't load games"
          }
        },
        sub_title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Try to see later"
          }
        }
      },
      event_details: {
        empty_title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Empty details view"
          }
        }
      },
      event_status: {
        active: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Active"
          }
        },
        planned: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Planned"
          }
        },
        checking_status: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Checking status"
          }
        }
      },
      event_timer: {
        start_title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Starts in"
          }
        },
        end_title: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Ends in"
          }
        }
      },
      min_bet: {
        t: 0,
        b: {
          t: 2,
          i: [{
            t: 3
          }],
          s: `Minimum bet
requirement`
        }
      },
      event_finished: {
        t: 0,
        b: {
          t: 2,
          i: [{
            t: 3
          }],
          s: "Event ended"
        }
      },
      button: {
        roll_up: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Roll up"
          }
        },
        show_more: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Show more"
          }
        }
      }
    }
  },
  Rc = xE({
    locale: "en",
    fallbackLocale: "en",
    messages: {}
  });
async function bR(e, t) {
  try {
    return await (await fetch(`${t}/l10n/${e}/common.json`)).json()
  } catch {
    return yR
  }
}
async function wR(e, t) {
  const n = await bR(e, t);
  Rc.global.setLocaleMessage(e, n), Rc.global.locale.value = e
}
const my = Rc.global.t.bind(Rc.global),
  Va = e => {
    const t = e.split("|");
    if (t.length === 2) {
      const [n, r] = t;
      return my(n, {
        value: r
      })
    } else return my(e)
  },
  CR = e => e.replace(/([a-z])([A-Z])/g, "$1 $2").replace(/([a-zA-Z])([0-9])/g, "$1 $2").trim(),
  xR = te({
    __name: "ScrollBar",
    props: {
      orientation: {
        default: "vertical"
      },
      forceMount: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {},
      class: {},
      darkTheme: {
        type: Boolean,
        default: !1
      }
    },
    setup(e) {
      const t = e,
        n = L(() => {
          const {
            class: r,
            darkTheme: s,
            ...a
          } = t;
          return a
        });
      return (r, s) => (g(), k(Ee, null, [$(u(h_), Le(n.value, {
        class: "flex touch-none select-none bg-transparent p-0.5 transition-colors duration-200 ease-out data-[orientation=horizontal]:h-2.5 data-[orientation=vertical]:w-2.5 data-[orientation=horizontal]:flex-col",
        orientation: "vertical"
      }), {
        default: V(() => [$(u(m_), {
          class: we(u(rn)("relative flex-1 cursor-pointer rounded-[10px] before:absolute before:left-1/2 before:top-1/2 before:h-full before:min-h-[44px] before:w-full before:min-w-[44px] before:-translate-x-1/2 before:-translate-y-1/2 before:content-[``]", !r.darkTheme && "bg-white-15 hover:bg-white-25", r.darkTheme && "bg-black-35 hover:bg-black-45", t.class))
        }, null, 8, ["class"])]),
        _: 1
      }, 16), $(u(h_), Le(n.value, {
        class: "flex touch-none select-none bg-transparent p-0.5 transition-colors duration-200 ease-out data-[orientation=horizontal]:h-2.5 data-[orientation=vertical]:w-2.5 data-[orientation=horizontal]:flex-col",
        orientation: "horizontal"
      }), {
        default: V(() => [$(u(m_), {
          class: we(u(rn)("relative flex-1 cursor-pointer rounded-[10px] before:absolute before:left-1/2 before:top-1/2 before:h-full before:min-h-[44px] before:w-full before:min-w-[44px] before:-translate-x-1/2 before:-translate-y-1/2 before:content-[``]", !r.darkTheme && "bg-white-15 hover:bg-white-25", r.darkTheme && "bg-black-35 hover:bg-black-45", t.class))
        }, null, 8, ["class"])]),
        _: 1
      }, 16)], 64))
    }
  }),
  Jn = te({
    __name: "ScrollArea",
    props: {
      type: {},
      dir: {},
      scrollHideDelay: {},
      asChild: {
        type: Boolean
      },
      as: {
        type: [String, Object, Function]
      },
      class: {},
      darkTheme: {
        type: Boolean
      },
      handleScroll: {
        type: Function
      }
    },
    setup(e) {
      const t = e,
        n = L(() => {
          const {
            class: r,
            darkTheme: s,
            handleScroll: a,
            ...o
          } = t;
          return o
        });
      return (r, s) => (g(), G(u(jA), Le(n.value, {
        type: "auto",
        class: u(rn)("overflow-hidden", t.class)
      }), {
        default: V(() => [$(u(HA), {
          asChild: "",
          onScroll: r.handleScroll,
          class: "h-full w-full"
        }, {
          default: V(() => [ie(r.$slots, "default")]),
          _: 3
        }, 8, ["onScroll"]), $(xR, {
          darkTheme: r.darkTheme
        }, null, 8, ["darkTheme"])]),
        _: 3
      }, 16, ["class"]))
    }
  }),
  We = (e, t) => {
    const n = e.__vccOpts || e;
    for (const [r, s] of t) n[r] = s;
    return n
  },
  kR = {},
  SR = {
    width: "40",
    height: "40",
    viewBox: "0 0 40 40",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function ER(e, t) {
  return g(), k("svg", SR, t[0] || (t[0] = [m("rect", {
    opacity: "0.5",
    width: "40",
    height: "40",
    rx: "20",
    fill: "#212330"
  }, null, -1), m("path", {
    d: "M13.2031 19.2031L22.2031 10.25C22.625 9.78125 23.3281 9.78125 23.7969 10.25C24.2188 10.6719 24.2188 11.375 23.7969 11.7969L15.5469 20L23.75 28.25C24.2188 28.6719 24.2188 29.375 23.75 29.7969C23.3281 30.2656 22.625 30.2656 22.2031 29.7969L13.2031 20.7969C12.7344 20.375 12.7344 19.6719 13.2031 19.2031Z",
    fill: "currentColor"
  }, null, -1)]))
}
const Yp = We(kR, [
    ["render", ER]
  ]),
  TR = {},
  AR = {
    width: "40",
    height: "40",
    viewBox: "0 0 40 40",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function PR(e, t) {
  return g(), k("svg", AR, t[0] || (t[0] = [m("rect", {
    opacity: "0.5",
    width: "40",
    height: "40",
    rx: "20",
    fill: "#212330"
  }, null, -1), m("path", {
    d: "M27.1719 14.4219L21.5469 20.0469L27.125 25.625C27.5938 26.0469 27.5938 26.75 27.125 27.1719C26.7031 27.6406 26 27.6406 25.5781 27.1719L19.9531 21.5938L14.375 27.1719C13.9531 27.6406 13.25 27.6406 12.8281 27.1719C12.3594 26.75 12.3594 26.0469 12.8281 25.5781L18.4062 20L12.8281 14.4219C12.3594 14 12.3594 13.2969 12.8281 12.8281C13.25 12.4062 13.9531 12.4062 14.4219 12.8281L20 18.4531L25.5781 12.875C26 12.4062 26.7031 12.4062 27.1719 12.875C27.5938 13.2969 27.5938 14 27.1719 14.4219Z",
    fill: "currentColor"
  }, null, -1)]))
}
const pr = We(TR, [
    ["render", PR]
  ]),
  IR = {},
  $R = {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function MR(e, t) {
  return g(), k("svg", $R, t[0] || (t[0] = [mu('<path d="M10.1001 7.99961C10.1001 7.50255 10.503 7.09961 11.0001 7.09961L17.0001 7.09961C17.4972 7.09961 17.9001 7.50255 17.9001 7.99961C17.9001 8.49667 17.4972 8.89961 17.0001 8.89961H11.0001C10.503 8.89961 10.1001 8.49667 10.1001 7.99961Z" fill="currentColor"></path><path d="M7.2 9.1998C7.86274 9.1998 8.4 8.66255 8.4 7.9998C8.4 7.33706 7.86274 6.7998 7.2 6.7998C6.53726 6.7998 6 7.33706 6 7.9998C6 8.66255 6.53726 9.1998 7.2 9.1998Z" fill="currentColor"></path><path d="M10.1001 15.9996C10.1001 15.5026 10.503 15.0996 11.0001 15.0996L17.0001 15.0996C17.4972 15.0996 17.9001 15.5026 17.9001 15.9996C17.9001 16.4967 17.4972 16.8996 17.0001 16.8996L11.0001 16.8996C10.503 16.8996 10.1001 16.4967 10.1001 15.9996Z" fill="currentColor"></path><path d="M7.2 17.1998C7.86274 17.1998 8.4 16.6625 8.4 15.9998C8.4 15.3371 7.86274 14.7998 7.2 14.7998C6.53726 14.7998 6 15.3371 6 15.9998C6 16.6625 6.53726 17.1998 7.2 17.1998Z" fill="currentColor"></path><path d="M10.1001 11.9996C10.1001 11.5026 10.503 11.0996 11.0001 11.0996L17.0001 11.0996C17.4972 11.0996 17.9001 11.5026 17.9001 11.9996C17.9001 12.4967 17.4972 12.8996 17.0001 12.8996H11.0001C10.503 12.8996 10.1001 12.4967 10.1001 11.9996Z" fill="currentColor"></path><path d="M7.2 13.1998C7.86274 13.1998 8.4 12.6625 8.4 11.9998C8.4 11.3371 7.86274 10.7998 7.2 10.7998C6.53726 10.7998 6 11.3371 6 11.9998C6 12.6625 6.53726 13.1998 7.2 13.1998Z" fill="currentColor"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M7 2C4.23858 2 2 4.23858 2 7V17C2 19.7614 4.23858 22 7 22H17C19.7614 22 22 19.7614 22 17V7C22 4.23858 19.7614 2 17 2H7ZM17 4H7C5.34315 4 4 5.34315 4 7V17C4 18.6569 5.34315 20 7 20H17C18.6569 20 20 18.6569 20 17V7C20 5.34315 18.6569 4 17 4Z" fill="currentColor"></path>', 7)]))
}
const OR = We(IR, [
    ["render", MR]
  ]),
  DR = {},
  LR = {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function RR(e, t) {
  return g(), k("svg", LR, t[0] || (t[0] = [m("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M12 2.35418C11.2671 1.52376 10.1947 1 9 1C6.79086 1 5 2.79086 5 5C5 5.72857 5.19479 6.41165 5.53513 7H3C1.89543 7 1 7.89543 1 9V12C1 13.1046 1.89543 14 3 14V21C3 22.1046 3.89543 23 5 23H19C20.1046 23 21 22.1046 21 21V14C22.1046 14 23 13.1046 23 12V9C23 7.89543 22.1046 7 21 7H18.4649C18.8052 6.41165 19 5.72857 19 5C19 2.79086 17.2091 1 15 1C13.8053 1 12.7329 1.52376 12 2.35418ZM11 9H9C8.9464 9 8.89304 8.99895 8.83995 8.99686H3L2.99876 8.99687L2.99778 8.99778L2.99687 8.99876L2.99686 9V12L2.99687 12.0012L2.99778 12.0022L2.99876 12.0031L3 12.0031V12H11V9ZM11 7H9C7.89543 7 7 6.10457 7 5C7 3.89543 7.89543 3 9 3C10.1046 3 11 3.89543 11 5V7ZM13 9V12H21V12.0031L21.0012 12.0031L21.0022 12.0022L21.0031 12.0012L21.0031 12V9L21.0031 8.99876L21.0022 8.99778L21.0012 8.99687L21 8.99686H15.16C15.107 8.99895 15.0536 9 15 9H13ZM15 7C16.1046 7 17 6.10457 17 5C17 3.89543 16.1046 3 15 3C13.8954 3 13 3.89543 13 5V7H15ZM19 14H13V21H19V14ZM11 14H5V21H11V14Z",
    fill: "currentColor"
  }, null, -1)]))
}
const NR = We(DR, [
    ["render", RR]
  ]),
  FR = {},
  BR = {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function jR(e, t) {
  return g(), k("svg", BR, t[0] || (t[0] = [m("path", {
    d: "M15.7071 11.7071C16.0976 11.3166 16.0976 10.6834 15.7071 10.2929C15.3166 9.90237 14.6834 9.90237 14.2929 10.2929L11 13.5858L9.70711 12.2929C9.31658 11.9024 8.68342 11.9024 8.29289 12.2929C7.90237 12.6834 7.90237 13.3166 8.29289 13.7071L10.2929 15.7071C10.6834 16.0976 11.3166 16.0976 11.7071 15.7071L15.7071 11.7071Z",
    fill: "currentColor"
  }, null, -1), m("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M13.2375 1.03678C12.6417 0.167427 11.3587 0.167425 10.7629 1.03678L7.32061 6.05945L1.48006 7.78114C0.469138 8.07914 0.0726696 9.29934 0.715364 10.1346L4.42849 14.9605L4.26108 21.0472C4.23211 22.1008 5.27007 22.8549 6.26308 22.5018L12.0002 20.4617L17.7373 22.5018C18.7303 22.8549 19.7682 22.1008 19.7393 21.0472L19.5719 14.9605L23.285 10.1346C23.9277 9.29934 23.5312 8.07914 22.5203 7.78114L16.6797 6.05945L13.2375 1.03678ZM8.86984 7.33675L12.0002 2.76922L15.1305 7.33675C15.3256 7.62135 15.6127 7.83001 15.9437 7.92756L21.255 9.49324L17.8783 13.8818C17.6679 14.1553 17.5582 14.4929 17.5677 14.8378L17.72 20.3729L12.5027 18.5177C12.1777 18.4021 11.8227 18.4021 11.4976 18.5177L6.28038 20.3729L6.43262 14.8378C6.4421 14.4929 6.33241 14.1553 6.12201 13.8818L2.74536 9.49324L8.05666 7.92756C8.3876 7.83001 8.6748 7.62135 8.86984 7.33675Z",
    fill: "currentColor"
  }, null, -1)]))
}
const HR = We(FR, [
    ["render", jR]
  ]),
  VR = {},
  UR = {
    width: "14",
    height: "12",
    viewBox: "0 0 14 12",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function zR(e, t) {
  return g(), k("svg", UR, t[0] || (t[0] = [m("path", {
    d: "M0 1.25C0 0.84375 0.3125 0.5 0.75 0.5H13.25C13.6562 0.5 14 0.84375 14 1.25C14 1.6875 13.6562 2 13.25 2H0.75C0.3125 2 0 1.6875 0 1.25ZM0 6.25C0 5.84375 0.3125 5.5 0.75 5.5H9.25C9.65625 5.5 10 5.84375 10 6.25C10 6.6875 9.65625 7 9.25 7H0.75C0.3125 7 0 6.6875 0 6.25ZM6 11.25C6 11.6875 5.65625 12 5.25 12H0.75C0.3125 12 0 11.6875 0 11.25C0 10.8438 0.3125 10.5 0.75 10.5H5.25C5.65625 10.5 6 10.8438 6 11.25Z",
    fill: "currentColor"
  }, null, -1)]))
}
const YR = We(VR, [
    ["render", zR]
  ]),
  WR = {},
  GR = {
    width: "100",
    height: "100",
    viewBox: "0 0 100 100",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function QR(e, t) {
  return g(), k("svg", GR, t[0] || (t[0] = [m("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M64.7259 4.05165L62.0676 13.8589L52.0693 16.7133C52.0038 16.7606 51.9483 16.8164 51.9098 16.8702C51.8955 16.8903 51.8862 16.906 51.8805 16.917C51.8868 16.9854 51.9089 17.0416 51.9437 17.0938C51.972 17.1362 52.0116 17.1794 52.0617 17.2184L62.0677 19.871L64.7223 29.869C64.7614 29.9191 64.8046 29.9586 64.8471 29.9869C64.8993 30.0217 64.9555 30.0438 65.024 30.0501C65.035 30.0443 65.0507 30.0351 65.0708 30.0208C65.1247 29.9823 65.1805 29.9269 65.2279 29.8614L68.0846 19.871L77.8996 17.2149C78.0185 17.1391 78.1205 17.0493 78.1885 16.9644C78.1899 16.9626 78.1912 16.9609 78.1926 16.9592C78.1481 16.9126 78.0922 16.8618 78.0259 16.811C77.9803 16.7761 77.9339 16.7443 77.8882 16.7161L68.0845 13.8589L65.2251 4.06304C65.1969 4.01742 65.165 3.97097 65.1301 3.92542C65.0793 3.85925 65.0284 3.80334 64.9818 3.75893C64.9801 3.76026 64.9783 3.76162 64.9766 3.76301C64.8916 3.83093 64.8018 3.9329 64.7259 4.05165ZM61.3426 2.52489C61.8599 1.4912 63.1086 0 65.0657 0C66.0499 0 66.8393 0.476503 67.3511 0.914781C67.8838 1.37106 68.3128 1.94907 68.6009 2.52489L68.6755 2.67404L71.0697 10.8761L79.2783 13.2684L79.4276 13.343C80.0039 13.6309 80.5823 14.0595 81.039 14.5918C81.4776 15.1031 81.9545 15.892 81.9545 16.8753C81.9545 18.8309 80.4621 20.0787 79.4276 20.5955L79.2622 20.6781L71.0696 22.8952L68.6778 31.2598L68.6009 31.4136C68.0025 32.6093 66.7015 33.7506 65.0657 33.7506C63.3277 33.7506 61.9862 32.6997 61.3426 31.4136L61.2577 31.244L59.041 22.8953L50.6856 20.6803L50.5159 20.5955C49.2288 19.9525 48.177 18.6119 48.177 16.8753C48.177 15.2408 49.3192 13.9409 50.5159 13.343L50.6698 13.2661L59.0411 10.8762L61.2599 2.69016L61.3426 2.52489ZM35.5206 32.3465L26.4477 50.872L5.94046 53.8274C5.93894 53.8277 5.93741 53.8279 5.93589 53.8281C3.79205 54.1529 2.90065 56.7515 4.5232 58.3839L19.3118 72.7667L15.7642 93.0505C15.4294 95.3745 17.6964 96.9637 19.6694 95.9951L37.8048 86.3437L56.1343 95.9935C58.108 96.9654 60.3777 95.3758 60.0427 93.0506L56.4952 72.7667L71.2836 58.384C72.8397 56.8176 71.9193 54.1599 69.8629 53.8269L49.3593 50.872L40.2864 32.3465C39.2752 30.337 36.5318 30.337 35.5206 32.3465ZM32.2066 30.6986C34.5804 25.9547 41.2265 25.9547 43.6003 30.6986L43.6039 30.7057L51.8242 47.4903L70.4175 50.1699L70.4297 50.1718C75.5056 50.9726 77.5873 57.3161 73.8934 61.007L73.8846 61.0159L60.4781 74.0545L63.6972 92.4601L63.7005 92.4822C64.4768 97.6531 59.2475 101.684 54.4634 99.2941L54.4458 99.2852L37.8142 90.5293L21.3649 99.2834L21.3436 99.2941C16.5594 101.684 11.3302 97.6531 12.1064 92.4822L12.1097 92.4601L15.3288 74.0545L1.92236 61.0159L1.91352 61.007C-1.71544 57.381 0.0229633 50.9743 5.39136 50.1697L5.4017 50.1681L23.9828 47.4903L32.2031 30.7057L32.2066 30.6986ZM86.0248 34.3518L88.1961 41.8465L95.6967 44.016L88.1961 46.1855L86.0248 53.6802L83.8536 46.1855L76.353 44.016L83.8536 41.8465L86.0248 34.3518ZM82.6416 32.7282C83.0558 31.1528 84.5533 30.0519 86.1188 30.0519C86.9623 30.0519 87.6963 30.4397 88.1966 30.8562C88.7146 31.2876 89.1968 31.9243 89.4081 32.7282L91.1846 38.8603L97.3216 40.6354C98.1261 40.8466 98.7634 41.3284 99.1951 41.846C99.6119 42.3458 100 43.0792 100 43.9221C100 45.4863 98.8982 46.9827 97.3216 47.3966L91.1846 49.1716L89.4082 55.3035C88.9456 57.066 87.278 57.7922 86.1188 57.7922C84.8985 57.7922 83.1283 57.1607 82.6415 55.3033L80.8651 49.1716L74.7286 47.3967C72.8697 46.9102 72.2377 45.1414 72.2377 43.9221C72.2377 42.7639 72.9645 41.0976 74.7284 40.6353L80.8651 38.8603L82.6416 32.7282Z",
    fill: "currentColor"
  }, null, -1)]))
}
const qR = We(WR, [
    ["render", QR]
  ]),
  KR = {},
  ZR = {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function JR(e, t) {
  return g(), k("svg", ZR, t[0] || (t[0] = [m("path", {
    d: "M12.0288 0C7.70708 0 3.78872 2.30769 1.59904 6C-0.533013 9.75 -0.533013 14.3077 1.59904 18C3.78872 21.75 7.70708 24 12.0288 24C16.2929 24 20.2113 21.75 22.401 18C24.533 14.3077 24.533 9.75 22.401 6C20.2113 2.30769 16.2929 0 12.0288 0ZM18.5402 9.28846L11.1645 16.6731C10.5882 17.25 9.72389 17.25 9.20528 16.6731L5.51741 12.9808C4.94118 12.4615 4.94118 11.5962 5.51741 11.0769C6.03601 10.5 6.90036 10.5 7.47659 11.0769L10.1849 13.7885L16.581 7.38462C17.0996 6.80769 17.964 6.80769 18.5402 7.38462C19.0588 7.90385 19.0588 8.76923 18.5402 9.28846Z",
    fill: "currentColor"
  }, null, -1)]))
}
const Wp = We(KR, [
    ["render", JR]
  ]),
  XR = {},
  eN = {
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function tN(e, t) {
  return g(), k("svg", eN, t[0] || (t[0] = [m("path", {
    d: "M14.7812 3.21875C15.0625 3.53125 15.0625 4 14.7812 4.28125L6.53125 12.5312C6.21875 12.8438 5.75 12.8438 5.46875 12.5312L1.21875 8.28125C0.90625 8 0.90625 7.53125 1.21875 7.25C1.5 6.9375 1.96875 6.9375 2.25 7.25L5.96875 10.9688L13.7188 3.21875C14 2.9375 14.4688 2.9375 14.75 3.21875H14.7812Z",
    fill: "currentColor"
  }, null, -1)]))
}
const _9 = We(XR, [
    ["render", tN]
  ]),
  nN = {},
  rN = {
    width: "16",
    height: "15",
    viewBox: "0 0 16 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function sN(e, t) {
  return g(), k("svg", rN, t[0] || (t[0] = [m("path", {
    d: "M0 1.8125C0 1.09375 0.5625 0.5 1.28125 0.5H14.6875C15.4062 0.5 16 1.09375 16 1.8125C16 2.125 15.875 2.40625 15.6875 2.625L10.5 9.03125V13.5C10.5 14.0625 10.0312 14.5 9.46875 14.5C9.25 14.5 9.03125 14.4375 8.84375 14.2812L5.96875 12C5.65625 11.75 5.5 11.4062 5.5 11.0312V9.03125L0.28125 2.625C0.09375 2.40625 0 2.125 0 1.8125ZM1.71875 2L6.8125 8.28125C6.9375 8.4375 7 8.59375 7 8.75V10.9062L9 12.5V8.75C9 8.59375 9.03125 8.4375 9.15625 8.28125L14.2812 2H1.71875Z",
    fill: "currentColor"
  }, null, -1)]))
}
const aN = We(nN, [
    ["render", sN]
  ]),
  oN = {},
  iN = {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function lN(e, t) {
  return g(), k("svg", iN, t[0] || (t[0] = [m("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M19.5 7.5H4.5C3.67157 7.5 3 8.17157 3 9V15C3 15.8284 3.67157 16.5 4.5 16.5H19.5C20.3284 16.5 21 15.8284 21 15V9C21 8.17157 20.3284 7.5 19.5 7.5ZM4.5 6C2.84315 6 1.5 7.34315 1.5 9V15C1.5 16.6569 2.84315 18 4.5 18H19.5C21.1569 18 22.5 16.6569 22.5 15V9C22.5 7.34315 21.1569 6 19.5 6H4.5Z",
    fill: "currentColor",
    stroke: "currentColor",
    "stroke-width": "0.5"
  }, null, -1), m("path", {
    d: "M8.0625 9.1958C8.22656 9.1958 8.43164 9.3083 8.55469 9.4583C8.67773 9.6083 8.71875 9.7958 8.67773 9.9458L7.36571 14.5498C7.28368 14.8498 7.03759 14.9998 6.75048 14.9998C6.66845 14.9998 6.62743 14.9998 6.58642 14.9998C6.21728 14.9248 6.0122 14.5873 6.09423 14.2873L7.20117 10.3958H5.4375C5.06836 10.3958 4.78125 10.1333 4.78125 9.7958C4.78125 9.4958 5.06836 9.1958 5.4375 9.1958H8.0625ZM13.3125 9.1958C13.4766 9.1958 13.6816 9.3083 13.8047 9.4583C13.9277 9.6083 13.9688 9.7958 13.9277 9.9458L12.6157 14.5498C12.5337 14.8498 12.2876 14.9998 12.0005 14.9998C11.9184 14.9998 11.8774 14.9998 11.8364 14.9998C11.4673 14.9248 11.2622 14.5873 11.3442 14.2873L12.4512 10.3958H10.6875C10.3184 10.3958 10.0312 10.1333 10.0312 9.7958C10.0312 9.4958 10.3184 9.1958 10.6875 9.1958H13.3125ZM18.5625 9.1958C18.7266 9.1958 18.9316 9.3083 19.0547 9.4583C19.1777 9.6083 19.2188 9.7958 19.1777 9.9458L17.8657 14.5498C17.7837 14.8498 17.5376 14.9998 17.2505 14.9998C17.1684 14.9998 17.1274 14.9998 17.0864 14.9998C16.7173 14.9248 16.5122 14.5873 16.5942 14.2873L17.7012 10.3958H15.9375C15.5684 10.3958 15.2812 10.1333 15.2812 9.7958C15.2812 9.4958 15.5684 9.1958 15.9375 9.1958H18.5625Z",
    fill: "currentColor",
    stroke: "currentColor",
    "stroke-width": "0.5"
  }, null, -1), m("path", {
    d: "M6.5 3H17.5C18.3284 3 19 3.67157 19 4.5V7H20.5V4.5C20.5 2.84315 19.1569 1.5 17.5 1.5H6.5C4.84315 1.5 3.5 2.84315 3.5 4.5V7H5V4.5C5 3.67157 5.67157 3 6.5 3Z",
    fill: "currentColor",
    stroke: "currentColor",
    "stroke-width": "0.5"
  }, null, -1), m("path", {
    d: "M6.5 21H17.5C18.3284 21 19 20.3284 19 19.5V17H20.5V19.5C20.5 21.1569 19.1569 22.5 17.5 22.5H6.5C4.84315 22.5 3.5 21.1569 3.5 19.5V17H5V19.5C5 20.3284 5.67157 21 6.5 21Z",
    fill: "currentColor",
    stroke: "currentColor",
    "stroke-width": "0.5"
  }, null, -1)]))
}
const _f = We(oN, [
    ["render", lN]
  ]),
  uN = {},
  cN = {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function dN(e, t) {
  return g(), k("svg", cN, t[0] || (t[0] = [m("path", {
    d: "M16.5117 10.6101L16.7266 10.3953L18.7031 10.739C18.7891 11.2117 18.875 11.6843 18.875 12.2C18.875 16.0242 15.7812 19.075 12 19.075C8.17578 19.075 5.125 16.0242 5.125 12.2C5.125 8.4187 8.17578 5.32495 12 5.32495C12.5156 5.32495 12.9883 5.41089 13.4609 5.49683L13.8047 7.47339L13.5898 7.68823C13.0742 7.51636 12.5586 7.38745 12 7.38745C9.33594 7.38745 7.1875 9.57886 7.1875 12.2C7.1875 14.864 9.33594 17.0125 12 17.0125C14.6211 17.0125 16.8125 14.864 16.8125 12.2C16.8125 11.6414 16.6836 11.1257 16.5117 10.6101ZM20.6797 10.2664H20.7227L22.3555 8.59058C22.7852 9.70776 23 10.9539 23 12.2C23 18.3015 18.0586 23.2 12 23.2C5.89844 23.2 1 18.3015 1 12.2C1 6.14136 5.89844 1.19995 12 1.19995C13.2461 1.19995 14.4922 1.41479 15.6094 1.84448L13.9336 3.47729C13.332 3.34839 12.6445 3.26245 12 3.26245C7.05859 3.26245 3.0625 7.30151 3.0625 12.2C3.0625 17.1414 7.05859 21.1375 11.957 21.1375C16.8984 21.1375 20.8945 17.1414 20.8945 12.2C20.8945 11.5554 20.8516 10.8679 20.6797 10.2664ZM16.6836 8.97729L12.6875 12.9304C12.3008 13.3601 11.6562 13.3601 11.2695 12.9304C10.8398 12.5437 10.8398 11.8992 11.2695 11.4695L15.2227 7.51636L14.8359 5.36792C14.793 4.93823 14.9219 4.46558 15.2227 4.16479L17.4141 1.97339C17.8008 1.58667 18.3594 1.71558 18.5742 2.18823L19.5625 4.63745L22.0117 5.62573C22.4844 5.84058 22.5703 6.44214 22.2266 6.78589L20.0352 8.97729C19.7344 9.27808 19.2617 9.40698 18.832 9.36401L16.6836 8.97729Z",
    fill: "currentColor"
  }, null, -1)]))
}
const fN = We(uN, [
    ["render", dN]
  ]),
  pN = {},
  hN = {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function mN(e, t) {
  return g(), k("svg", hN, t[0] || (t[0] = [m("path", {
    d: "M13.418 3.56421L15.6953 3.86499C16.082 3.90796 16.2539 4.42358 15.9531 4.72437L14.3203 6.27124L14.707 8.54858C14.75 8.9353 14.3633 9.23608 13.9766 9.06421L12 7.98999L9.98047 9.06421C9.59375 9.23608 9.16406 8.9353 9.25 8.54858L9.63672 6.31421L8.00391 4.72437C7.70312 4.42358 7.875 3.95093 8.26172 3.86499L10.5391 3.56421L11.5273 1.50171C11.7422 1.11499 12.2578 1.11499 12.4297 1.50171L13.418 3.56421ZM10.8542 14.2634V21.1384H13.1458V14.2634H10.8542ZM8.79167 14.2634C8.79167 13.1462 9.69401 12.2009 10.8542 12.2009H13.1458C14.263 12.2009 15.2083 13.1462 15.2083 14.2634V21.1384C15.2083 22.2986 14.263 23.2009 13.1458 23.2009H10.8542C9.69401 23.2009 8.79167 22.2986 8.79167 21.1384V14.2634ZM3.0625 17.0134V21.1384H5.35417V17.0134H3.0625ZM1 17.0134C1 15.8962 1.90234 14.9509 3.0625 14.9509H5.35417C6.47135 14.9509 7.41667 15.8962 7.41667 17.0134V21.1384C7.41667 22.2986 6.47135 23.2009 5.35417 23.2009H3.0625C1.90234 23.2009 1 22.2986 1 21.1384V17.0134ZM20.9375 18.3884H18.6458V21.1384H20.9375V18.3884ZM18.6458 16.3259H20.9375C22.0547 16.3259 23 17.2712 23 18.3884V21.1384C23 22.2986 22.0547 23.2009 20.9375 23.2009H18.6458C17.4857 23.2009 16.5833 22.2986 16.5833 21.1384V18.3884C16.5833 17.2712 17.4857 16.3259 18.6458 16.3259Z",
    fill: "currentColor"
  }, null, -1)]))
}
const gN = We(pN, [
    ["render", mN]
  ]),
  vN = {},
  _N = {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function yN(e, t) {
  return g(), k("svg", _N, t[0] || (t[0] = [m("path", {
    d: "M20.5556 5.03328H3.44444C3.10069 5.03328 2.83333 5.33884 2.83333 5.6444V17.8666C2.83333 18.2104 3.10069 18.4777 3.44444 18.4777H20.5556C20.8611 18.4777 21.1667 18.2104 21.1667 17.8666V5.6444C21.1667 5.33884 20.8611 5.03328 20.5556 5.03328ZM3.44444 3.19995H20.5556C21.8924 3.19995 23 4.30759 23 5.6444V17.8666C23 19.2416 21.8924 20.3111 20.5556 20.3111H3.44444C2.06944 20.3111 1 19.2416 1 17.8666V5.6444C1 4.30759 2.06944 3.19995 3.44444 3.19995ZM8.94444 11.7555C8.06597 11.7555 7.26389 11.2972 6.80556 10.5333C6.38542 9.80759 6.38542 8.85273 6.80556 8.08884C7.26389 7.36314 8.06597 6.86662 8.94444 6.86662C9.78472 6.86662 10.5868 7.36314 11.0451 8.08884C11.4653 8.85273 11.4653 9.80759 11.0451 10.5333C10.5868 11.2972 9.78472 11.7555 8.94444 11.7555ZM7.72222 12.9777H10.1667C11.8472 12.9777 13.2222 14.3527 13.2222 16.0333C13.2222 16.377 12.9167 16.6444 12.6111 16.6444H5.27778C4.93403 16.6444 4.66667 16.377 4.66667 16.0333C4.66667 14.3527 6.00347 12.9777 7.72222 12.9777ZM15.3611 7.47773H18.4167C18.9132 7.47773 19.3333 7.89787 19.3333 8.39439C19.3333 8.92912 18.9132 9.31106 18.4167 9.31106H15.3611C14.8264 9.31106 14.4444 8.92912 14.4444 8.39439C14.4444 7.89787 14.8264 7.47773 15.3611 7.47773ZM15.3611 11.1444H18.4167C18.9132 11.1444 19.3333 11.5645 19.3333 12.0611C19.3333 12.5958 18.9132 12.9777 18.4167 12.9777H15.3611C14.8264 12.9777 14.4444 12.5958 14.4444 12.0611C14.4444 11.5645 14.8264 11.1444 15.3611 11.1444Z",
    fill: "currentColor"
  }, null, -1)]))
}
const bN = We(vN, [
    ["render", yN]
  ]),
  wN = {},
  CN = {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function xN(e, t) {
  return g(), k("svg", CN, t[0] || (t[0] = [m("path", {
    d: "M8.5625 4.9812C8.5625 5.02417 8.5625 5.02417 8.5625 5.06714C8.60547 5.11011 8.64844 5.19604 8.77734 5.28198C8.77734 5.32495 8.82031 5.32495 8.82031 5.32495C8.00391 5.36792 7.23047 5.41089 6.5 5.53979V4.9812C6.5 4.20776 6.88672 3.6062 7.40234 3.17651C7.875 2.70386 8.51953 2.36011 9.25 2.10229C10.7109 1.5437 12.6445 1.19995 14.75 1.19995C16.8125 1.19995 18.7461 1.5437 20.207 2.10229C20.9375 2.36011 21.582 2.70386 22.0547 3.17651C22.5703 3.6062 23 4.20776 23 4.9812V13.9187C23 14.6921 22.5703 15.3367 22.0547 15.7664C21.582 16.196 20.9375 16.5828 20.207 16.8406C19.7773 17.0125 19.3477 17.1414 18.875 17.2703V15.1218C19.0898 15.0789 19.2617 14.9929 19.4766 14.907C20.0352 14.6921 20.4648 14.4343 20.6797 14.2625C20.8086 14.1335 20.8516 14.0476 20.8945 14.0046C20.9375 13.9617 20.9375 13.9617 20.9375 13.9617V12.071C20.6797 12.157 20.4648 12.2859 20.207 12.3718C19.7773 12.5437 19.3477 12.6726 18.875 12.8015V10.6531C19.0898 10.6101 19.2617 10.5242 19.4766 10.4382C20.0352 10.2234 20.4648 9.96558 20.6797 9.7937C20.8086 9.66479 20.8516 9.57886 20.8945 9.53589C20.9375 9.49292 20.9375 9.49292 20.9375 9.49292V7.60229C20.6797 7.68823 20.4648 7.81714 20.207 7.90308C19.6055 8.11792 18.9609 8.33276 18.2305 8.46167C18.0156 8.11792 17.7578 7.86011 17.5 7.64526C17.0703 7.25854 16.5547 6.91479 16.0391 6.65698C17.4141 6.57104 18.5742 6.31323 19.4766 5.96948C20.0352 5.75464 20.4648 5.49683 20.6797 5.28198C20.8086 5.19604 20.8516 5.11011 20.8945 5.06714C20.9375 5.02417 20.9375 5.02417 20.9375 4.9812C20.9375 4.9812 20.9375 4.9812 20.8945 4.93823C20.8516 4.89526 20.8086 4.80933 20.6797 4.68042C20.4648 4.46558 20.0352 4.25073 19.4766 4.03589C18.3164 3.56323 16.6406 3.26245 14.75 3.26245C12.8164 3.26245 11.1406 3.56323 9.98047 4.03589C9.42188 4.25073 8.99219 4.46558 8.77734 4.68042C8.64844 4.80933 8.60547 4.89526 8.5625 4.93823C8.5625 4.9812 8.5625 4.9812 8.5625 4.9812ZM3.0625 10.4812C3.0625 10.5242 3.0625 10.5242 3.0625 10.5671C3.10547 10.6101 3.14844 10.696 3.27734 10.782C3.49219 10.9968 3.92188 11.2546 4.48047 11.4695C5.64062 11.8992 7.31641 12.2 9.25 12.2C11.1406 12.2 12.8164 11.8992 13.9766 11.4695C14.5352 11.2546 14.9648 10.9968 15.1797 10.782C15.3086 10.696 15.3516 10.6101 15.3945 10.5671C15.3945 10.5242 15.4375 10.5242 15.4375 10.4812C15.4375 10.4812 15.4375 10.4812 15.3945 10.4382C15.3516 10.3953 15.3086 10.3093 15.1797 10.1804C14.9648 9.96558 14.5352 9.75073 13.9766 9.53589C12.8164 9.06323 11.1406 8.80542 9.25 8.80542C7.31641 8.80542 5.64062 9.06323 4.48047 9.53589C3.92188 9.75073 3.49219 10.0085 3.27734 10.1804C3.14844 10.3093 3.10547 10.3953 3.0625 10.4382C3.0625 10.4812 3.0625 10.4812 3.0625 10.4812ZM1 10.4812C1 9.70776 1.38672 9.1062 1.90234 8.67651C2.375 8.20386 3.01953 7.86011 3.75 7.60229C5.21094 7.0437 7.14453 6.69995 9.25 6.69995C11.3125 6.69995 13.2461 7.0437 14.707 7.60229C15.4375 7.86011 16.082 8.20386 16.5547 8.67651C17.0703 9.1062 17.5 9.70776 17.5 10.4812V19.4187C17.5 20.1921 17.0703 20.8367 16.5547 21.2664C16.082 21.696 15.4375 22.0828 14.707 22.3406C13.2461 22.8992 11.3125 23.2 9.25 23.2C7.14453 23.2 5.21094 22.8992 3.75 22.3406C3.01953 22.0828 2.375 21.739 1.90234 21.2664C1.38672 20.8367 1 20.1921 1 19.4187V10.4812ZM15.4375 14.95V13.1023C15.1797 13.1882 14.9648 13.3171 14.707 13.4031C13.2461 13.9617 11.3125 14.2625 9.25 14.2625C7.14453 14.2625 5.21094 13.9617 3.75 13.4031C3.49219 13.3171 3.27734 13.2312 3.0625 13.1023V14.95C3.0625 14.9929 3.0625 14.9929 3.0625 15.0359C3.10547 15.0789 3.14844 15.1648 3.27734 15.2507C3.49219 15.4656 3.92188 15.7234 4.48047 15.9382C5.64062 16.3679 7.31641 16.6687 9.25 16.6687C11.1406 16.6687 12.8164 16.3679 13.9766 15.9382C14.5352 15.7234 14.9648 15.4656 15.1797 15.2507C15.3086 15.1648 15.3516 15.0789 15.3945 15.0359C15.3945 14.9929 15.4375 14.9929 15.4375 14.95ZM3.75 17.8718C3.49219 17.7859 3.27734 17.7 3.0625 17.571V19.4187C3.0625 19.4187 3.0625 19.4617 3.0625 19.5046C3.10547 19.5476 3.14844 19.6335 3.27734 19.7195C3.49219 19.9343 3.92188 20.1921 4.48047 20.407C5.64062 20.8367 7.31641 21.1375 9.25 21.1375C11.1406 21.1375 12.8164 20.8367 13.9766 20.407C14.5352 20.1921 14.9648 19.9343 15.1797 19.7195C15.3086 19.6335 15.3516 19.5476 15.3945 19.5046C15.4375 19.4617 15.4375 19.4187 15.4375 19.4187V17.571C15.1797 17.657 14.9648 17.7859 14.707 17.8718C13.2461 18.4304 11.3125 18.7312 9.25 18.7312C7.14453 18.7312 5.21094 18.4304 3.75 17.8718Z",
    fill: "currentColor"
  }, null, -1)]))
}
const kN = We(wN, [
    ["render", xN]
  ]),
  SN = {},
  EN = {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function TN(e, t) {
  return g(), k("svg", EN, t[0] || (t[0] = [m("path", {
    d: "M22.25 9.59492C22.25 10.1928 21.7802 10.6199 21.225 10.6199H15.075C14.4771 10.6199 14.05 10.1928 14.05 9.59492C14.05 9.03971 14.4771 8.56992 15.075 8.56992H18.7479L16.5271 6.34909C15.2885 5.15326 13.6656 4.46992 12 4.46992C8.88229 4.46992 6.19167 6.3918 5.08125 9.08242C4.825 9.59492 4.22708 9.80846 3.71458 9.59492C3.20208 9.38138 2.94583 8.78346 3.15937 8.27096C4.61146 4.8543 8.02812 2.41992 12 2.41992C14.2208 2.41992 16.3562 3.3168 17.9365 4.89701L20.2 7.16055V3.44492C20.2 2.88971 20.6271 2.41992 21.225 2.41992C21.7802 2.41992 22.25 2.88971 22.25 3.44492V9.59492ZM2.775 13.3533H7.55833C8.11354 13.3533 8.58333 13.823 8.58333 14.3783C8.58333 14.9762 8.11354 15.4033 7.55833 15.4033H5.20937L7.47292 17.6668C8.66875 18.8626 10.2917 19.5033 12 19.5033C15.075 19.5033 17.7656 17.6668 18.876 14.9762C19.1323 14.421 19.7302 14.2074 20.2427 14.421C20.7552 14.6345 21.0115 15.2324 20.7979 15.7876C19.3031 19.1616 15.9292 21.5533 12 21.5533C9.73646 21.5533 7.60104 20.6991 6.02083 19.1189L3.8 16.8553V19.1616C3.8 19.7595 3.33021 20.1866 2.775 20.1866C2.17708 20.1866 1.75 19.7595 1.75 19.1616V14.3783C1.75 13.823 2.17708 13.3533 2.775 13.3533Z",
    fill: "currentColor"
  }, null, -1)]))
}
const AN = We(SN, [
    ["render", TN]
  ]),
  PN = {},
  IN = {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function $N(e, t) {
  return g(), k("svg", IN, t[0] || (t[0] = [m("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M16.4688 4.24414C19.2188 5.87695 20.9375 8.79883 20.9375 11.9785C20.9375 15.2012 19.2188 18.123 16.4688 19.7559C13.6758 21.3457 10.2812 21.3457 7.53125 19.7559C4.73828 18.123 3.0625 15.2012 3.0625 11.9785C3.0625 8.79883 4.73828 5.87695 7.53125 4.24414C10.2812 2.6543 13.6758 2.6543 16.4688 4.24414ZM6.5 2.48242C3.0625 4.45898 1 8.06836 1 11.9785C1 15.9316 3.0625 19.541 6.5 21.5176C9.89453 23.4941 14.0625 23.4941 17.5 21.5176C20.8945 19.541 23 15.9316 23 11.9785C23 8.06836 20.8945 4.45898 17.5 2.48242C14.0625 0.505859 9.89453 0.505859 6.5 2.48242ZM15.5872 7.87233C15.5872 7.40584 15.9915 7.0015 16.458 7.0015C16.9497 7.0015 17.3289 7.40958 17.3289 7.87233V10.6223C17.3289 11.1103 16.946 11.4932 16.458 11.4932H13.7295C13.2415 11.4932 12.8587 11.1103 12.8587 10.6223C12.8587 10.1596 13.2378 9.7515 13.7295 9.7515H14.3611L14.3099 9.70026C13.0285 8.43974 10.9747 8.43862 9.69252 9.69792C9.34259 10.069 9.08118 10.4747 8.94132 10.9142L8.93959 10.9197C8.77834 11.3766 8.26705 11.626 7.82308 11.4606C7.36695 11.2987 7.11956 10.8101 7.28319 10.3465C7.52845 9.65528 7.92981 9.00846 8.46511 8.47316L8.46585 8.47242C10.4279 6.53267 13.5721 6.53267 15.5342 8.47242L15.5387 8.47684L15.5872 8.52839V7.87233ZM7.43271 12.5208C7.45033 12.5149 7.49031 12.5015 7.54201 12.5015H10.292C10.7585 12.5015 11.1628 12.9058 11.1628 13.3723C11.1628 13.864 10.7548 14.2432 10.292 14.2432H9.62163L9.69249 14.3182C10.974 15.5769 13.026 15.5769 14.3075 14.3182C14.6574 13.9471 14.9189 13.5415 15.0587 13.1019L15.0605 13.0964C15.2217 12.6396 15.733 12.3901 16.177 12.5555C16.6331 12.7175 16.8805 13.206 16.7168 13.6697C16.4708 14.363 16.069 14.9867 15.5375 15.5403L15.5342 15.5438C13.5722 17.4835 10.4279 17.4835 8.46585 15.5437L8.46138 15.5393L8.41284 15.4878V16.1223C8.41284 16.614 8.00476 16.9932 7.54201 16.9932C7.05404 16.9932 6.67118 16.6103 6.67118 16.1223V13.2865L6.67108 13.2792C6.67059 13.2514 6.66944 13.1874 6.7058 13.1237C6.74228 12.9888 6.82261 12.8657 6.91823 12.77C7.01461 12.6737 7.13895 12.5928 7.27513 12.5568C7.30992 12.5382 7.34275 12.5313 7.36148 12.5282C7.38777 12.5238 7.41238 12.5231 7.42621 12.523L7.43032 12.5216L7.43271 12.5208Z",
    fill: "currentColor"
  }, null, -1)]))
}
const MN = We(PN, [
    ["render", $N]
  ]),
  ON = {},
  DN = {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function LN(e, t) {
  return g(), k("svg", DN, t[0] || (t[0] = [m("path", {
    d: "M12.0234 2.25C8.50781 2.25 5.32031 4.125 3.53906 7.125C1.80469 10.1719 1.80469 13.875 3.53906 16.875C5.32031 19.9219 8.50781 21.75 12.0234 21.75C15.4922 21.75 18.6797 19.9219 20.4609 16.875C22.1953 13.875 22.1953 10.1719 20.4609 7.125C18.6797 4.125 15.4922 2.25 12.0234 2.25ZM12.0234 24C7.71094 24 3.77344 21.75 1.61719 18C-0.539063 14.2969 -0.539063 9.75 1.61719 6C3.77344 2.29688 7.71094 0 12.0234 0C16.2891 0 20.2266 2.29688 22.3828 6C24.5391 9.75 24.5391 14.2969 22.3828 18C20.2266 21.75 16.2891 24 12.0234 24ZM12.0234 6C12.6328 6 13.1484 6.51563 13.1484 7.125V12.375C13.1484 13.0313 12.6328 13.5 12.0234 13.5C11.3672 13.5 10.8984 13.0313 10.8984 12.375V7.125C10.8984 6.51563 11.3672 6 12.0234 6ZM13.5234 16.5C13.5234 17.3438 12.8203 18 12.0234 18C11.1797 18 10.5234 17.3438 10.5234 16.5C10.5234 15.7031 11.1797 15 12.0234 15C12.8203 15 13.5234 15.7031 13.5234 16.5Z",
    fill: "currentColor"
  }, null, -1)]))
}
const RN = We(ON, [
    ["render", LN]
  ]),
  NN = {},
  FN = {
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function BN(e, t) {
  return g(), k("svg", FN, t[0] || (t[0] = [m("path", {
    d: "M8.00277 0.665039C12.0243 0.665039 15.3361 3.97687 15.3361 7.99837C15.3361 12.0494 12.0243 15.3317 8.00277 15.3317C3.95169 15.3317 0.669434 12.0494 0.669434 7.99837C0.669434 3.97687 3.95169 0.665039 8.00277 0.665039ZM8.00277 13.9123C11.2555 13.9123 13.9167 11.2806 13.9167 7.99837C13.9167 4.74568 11.2555 2.08439 8.00277 2.08439C4.72051 2.08439 2.08879 4.74568 2.08879 7.99837C2.08879 11.2806 4.72051 13.9123 8.00277 13.9123ZM11.1667 6.37203C11.1667 8.35321 9.00814 8.38278 9.00814 9.12203V9.29945C9.00814 9.50644 8.86029 9.65428 8.6533 9.65428H7.32266C7.11567 9.65428 6.96782 9.50644 6.96782 9.29945V9.06289C6.96782 7.99837 7.76621 7.58439 8.3576 7.22955C8.88986 6.93386 9.21513 6.75644 9.21513 6.37203C9.21513 5.83977 8.56459 5.5145 8.03234 5.5145C7.35223 5.5145 7.02696 5.83977 6.58341 6.4016C6.46513 6.54945 6.22857 6.57902 6.08072 6.46074L5.25277 5.83977C5.10492 5.72149 5.07535 5.5145 5.19363 5.36665C5.87373 4.33171 6.76083 3.74031 8.15062 3.74031C9.59954 3.74031 11.1667 4.89353 11.1667 6.37203ZM9.2447 11.3102C9.2447 12.0199 8.68287 12.5521 8.00277 12.5521C7.29309 12.5521 6.76083 12.0199 6.76083 11.3102C6.76083 10.6301 7.29309 10.0683 8.00277 10.0683C8.68287 10.0683 9.2447 10.6301 9.2447 11.3102Z",
    fill: "currentColor"
  }, null, -1)]))
}
const hd = We(NN, [
    ["render", BN]
  ]),
  jN = {},
  HN = {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function VN(e, t) {
  return g(), k("svg", HN, t[0] || (t[0] = [m("path", {
    d: "M15.5859 15.0195C14.6875 13.4961 13.0859 12.4805 11.25 12.4805H8.75C6.875 12.4805 5.27344 13.4961 4.41406 15.0195C5.78125 16.543 7.77344 17.4805 10 17.4805C12.1875 17.4805 14.1797 16.543 15.5859 15.0195ZM0 9.98047C0 6.42578 1.875 3.14453 5 1.34766C8.08594 -0.449219 11.875 -0.449219 15 1.34766C18.0859 3.14453 20 6.42578 20 9.98047C20 13.5742 18.0859 16.8555 15 18.6523C11.875 20.4492 8.08594 20.4492 5 18.6523C1.875 16.8555 0 13.5742 0 9.98047ZM10 10.6055C10.9766 10.6055 11.9141 10.0977 12.4219 9.19922C12.9297 8.33984 12.9297 7.28516 12.4219 6.38672C11.9141 5.52734 10.9766 4.98047 10 4.98047C8.98438 4.98047 8.04688 5.52734 7.53906 6.38672C7.03125 7.28516 7.03125 8.33984 7.53906 9.19922C8.04688 10.0977 8.98438 10.6055 10 10.6055Z",
    fill: "currentColor"
  }, null, -1)]))
}
const Dm = We(jN, [
    ["render", VN]
  ]),
  UN = {},
  zN = {
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function YN(e, t) {
  return g(), k("svg", zN, t[0] || (t[0] = [m("path", {
    d: "M8.0127 3.53125C6.33691 3.53125 4.99121 4.29297 3.9502 5.25781C2.95996 6.17188 2.2998 7.23828 1.94434 8C2.2998 8.76172 2.95996 9.85352 3.9502 10.7676C4.99121 11.7324 6.33691 12.4688 8.0127 12.4688C9.66309 12.4688 11.0088 11.7324 12.0498 10.7676C13.04 9.85352 13.7256 8.76172 14.0557 8C13.7256 7.23828 13.04 6.17188 12.0752 5.25781C11.0088 4.29297 9.66309 3.53125 8.0127 3.53125ZM3.1123 4.36914C4.30566 3.25195 5.95605 2.3125 8.0127 2.3125C10.0439 2.3125 11.6943 3.25195 12.8877 4.36914C14.0811 5.48633 14.8682 6.78125 15.249 7.69531C15.3252 7.89844 15.3252 8.12695 15.249 8.33008C14.8682 9.21875 14.0811 10.5391 12.8877 11.6562C11.6943 12.7734 10.0439 13.6875 8.0127 13.6875C5.95605 13.6875 4.30566 12.7734 3.1123 11.6562C1.91895 10.5391 1.13184 9.21875 0.750977 8.33008C0.674805 8.12695 0.674805 7.89844 0.750977 7.69531C1.13184 6.78125 1.91895 5.46094 3.1123 4.36914ZM8.0127 10.0312C9.12988 10.0312 10.0439 9.14258 10.0439 8C10.0439 6.88281 9.12988 5.96875 8.0127 5.96875C7.9873 5.96875 7.96191 5.96875 7.96191 5.96875C7.9873 6.12109 8.0127 6.24805 8.0127 6.375C8.0127 7.28906 7.27637 8 6.3877 8C6.23535 8 6.1084 8 5.98145 7.94922C5.98145 7.97461 5.98145 8 5.98145 8C5.98145 9.14258 6.87012 10.0312 8.0127 10.0312ZM8.0127 4.75C9.15527 4.75 10.2217 5.38477 10.8057 6.375C11.3896 7.39062 11.3896 8.63477 10.8057 9.625C10.2217 10.6406 9.15527 11.25 8.0127 11.25C6.84473 11.25 5.77832 10.6406 5.19434 9.625C4.61035 8.63477 4.61035 7.39062 5.19434 6.375C5.77832 5.38477 6.84473 4.75 8.0127 4.75Z",
    fill: "currentColor"
  }, null, -1)]))
}
const WN = We(UN, [
    ["render", YN]
  ]),
  GN = {},
  QN = {
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function qN(e, t) {
  return g(), k("svg", QN, t[0] || (t[0] = [m("path", {
    d: "M0.966191 1.64382L3.76472 3.85135C4.88913 2.98864 6.2884 2.30354 8.01249 2.30354C10.0114 2.30354 11.6356 3.24238 12.81 4.35883C13.9844 5.44991 14.759 6.76936 15.1338 7.68283C15.2087 7.88582 15.2087 8.11418 15.1338 8.31717C14.8089 9.12914 14.1343 10.2963 13.1348 11.3113L15.7584 13.4173C16.0333 13.6203 16.0833 14.0009 15.8584 14.2547C15.6585 14.5338 15.2837 14.5845 15.0338 14.3562L0.241571 2.58265C-0.0332846 2.37966 -0.0832584 1.99905 0.141624 1.74531C0.341519 1.4662 0.716322 1.41545 0.966191 1.64382ZM4.73921 4.63795L5.88861 5.55141C6.46331 5.04393 7.18793 4.73944 8.01249 4.73944C9.76158 4.73944 11.2108 6.21113 11.2108 7.98731C11.2108 8.54554 11.0859 9.05302 10.836 9.48438L12.1853 10.5501C13.0598 9.68737 13.6595 8.69778 13.9594 7.98731C13.6345 7.22609 12.9599 6.16039 11.9854 5.24692C10.9609 4.28271 9.63664 3.52149 8.01249 3.52149C6.73816 3.52149 5.66373 3.97822 4.73921 4.63795ZM9.86152 8.72316C9.96147 8.49479 10.0114 8.24105 10.0114 7.98731C10.0114 6.87086 9.11192 5.95739 8.01249 5.95739C7.98751 5.95739 7.96252 5.95739 7.96252 5.95739C7.98751 6.10964 8.01249 6.23651 8.01249 6.36338C8.01249 6.64249 7.93753 6.87086 7.83758 7.09922L9.86152 8.72316ZM10.1114 12.0218L11.1608 12.8591C10.2363 13.3666 9.18688 13.6711 8.01249 13.6711C5.98856 13.6711 4.36441 12.7576 3.19002 11.6412C2.01564 10.5247 1.24105 9.20526 0.866243 8.31717C0.791283 8.11418 0.791283 7.88582 0.866243 7.68283C1.11611 7.09922 1.5159 6.36338 2.0906 5.60216L3.01512 6.36338C2.56535 6.94698 2.24052 7.53058 2.04063 7.98731C2.39044 8.74853 3.0401 9.83961 4.01459 10.7531C5.03905 11.7173 6.36336 12.4531 8.01249 12.4531C8.7621 12.4531 9.46173 12.3009 10.1114 12.0218ZM4.81417 7.98731H4.78918C4.78918 7.93656 4.81417 7.86044 4.81417 7.78432L6.21344 8.90078C6.46331 9.43363 6.96304 9.83961 7.56273 9.96648L8.962 11.1083C8.66215 11.1844 8.33732 11.2352 8.01249 11.2352C6.23842 11.2352 4.81417 9.78887 4.81417 7.98731Z",
    fill: "currentColor"
  }, null, -1)]))
}
const KN = We(GN, [
    ["render", qN]
  ]),
  ZN = {},
  JN = {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function XN(e, t) {
  return g(), k("svg", JN, t[0] || (t[0] = [m("path", {
    d: "M1.51562 10.9734C1.28125 10.9734 1.09375 10.7859 1.14062 10.5515C1.60938 8.11401 2.92188 5.86401 5.03125 4.22338C9.57812 0.660882 16.1875 1.45776 19.75 6.05151L21.25 7.97338V3.84838C21.25 3.66088 21.3906 3.47338 21.625 3.47338C21.8125 3.47338 22 3.66088 22 3.84838V9.09838C22 9.33276 21.8125 9.47338 21.625 9.47338H16.375C16.1406 9.47338 16 9.33276 16 9.09838C16 8.91088 16.1406 8.72338 16.375 8.72338H20.875L19.1406 6.47338C15.8594 2.25463 9.71875 1.50463 5.45312 4.83276C3.53125 6.33276 2.3125 8.44213 1.89062 10.6921C1.84375 10.8796 1.70312 10.9734 1.51562 10.9734ZM1.375 15.4734H6.625C6.8125 15.4734 7 15.6609 7 15.8484C7 16.0828 6.8125 16.2234 6.625 16.2234H2.03125L3.76562 18.5203C7.04688 22.739 13.1875 23.489 17.4062 20.1609C19.375 18.6609 20.5938 16.5515 21.0156 14.3015C21.0156 14.114 21.2031 13.9734 21.3906 13.9734C21.625 13.9734 21.8125 14.2078 21.7656 14.4421C21.2969 16.8328 19.9844 19.1296 17.875 20.7703C13.3281 24.3328 6.71875 23.5359 3.15625 18.9421L1.75 17.0671V21.0984C1.75 21.3328 1.5625 21.4734 1.375 21.4734C1.14062 21.4734 1 21.3328 1 21.0984V15.8484C1 15.6609 1.14062 15.4734 1.375 15.4734Z",
    fill: "currentColor",
    stroke: "currentColor",
    "stroke-width": "0.3"
  }, null, -1)]))
}
const eF = We(ZN, [
    ["render", XN]
  ]),
  tF = {},
  nF = {
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function rF(e, t) {
  return g(), k("svg", nF, t[0] || (t[0] = [m("path", {
    d: "M15.1719 2.42188L9.54688 8.04688L15.125 13.625C15.5938 14.0469 15.5938 14.75 15.125 15.1719C14.7031 15.6406 14 15.6406 13.5781 15.1719L7.95312 9.59375L2.375 15.1719C1.95312 15.6406 1.25 15.6406 0.828125 15.1719C0.359375 14.75 0.359375 14.0469 0.828125 13.5781L6.40625 8L0.828125 2.42188C0.359375 2 0.359375 1.29688 0.828125 0.828125C1.25 0.40625 1.95312 0.40625 2.42188 0.828125L8 6.45312L13.5781 0.875C14 0.40625 14.7031 0.40625 15.1719 0.875C15.5938 1.29688 15.5938 2 15.1719 2.42188Z",
    fill: "currentColor"
  }, null, -1)]))
}
const qa = We(tF, [
    ["render", rF]
  ]),
  sF = {},
  aF = {
    width: "46",
    height: "46",
    viewBox: "0 0 46 46",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function oF(e, t) {
  return g(), k("svg", aF, t[0] || (t[0] = [mu('<g filter="url(#filter0_ddi_7486_3170)"><path d="M14.8691 14.8693C16.9355 12.8029 19.8105 11.5001 23 11.5001C29.334 11.5001 34.5 16.6661 34.5 23.0001C34.5 29.379 29.334 34.5001 23 34.5001C20.5293 34.5001 18.2832 33.7364 16.3965 32.4786C15.7676 31.9845 15.5879 31.0861 16.0371 30.4572C16.4863 29.7833 17.3848 29.6486 18.0586 30.0978C19.4512 31.0861 21.1582 31.6251 23 31.6251C27.7617 31.6251 31.625 27.7618 31.625 23.0001C31.625 18.2384 27.7617 14.3751 23 14.3751C20.6191 14.3751 18.4629 15.3634 16.8906 16.9357L18.2832 18.2833C18.957 19.0021 18.4629 20.1251 17.5195 20.1251H12.5781C11.9492 20.1251 11.5 19.6759 11.5 19.047V14.1056C11.5 13.1622 12.623 12.6681 13.3418 13.3419L14.8691 14.8693ZM23 17.2501H22.9551C23.584 17.2501 24.0332 17.7443 24.0332 18.3282V22.5958L26.9531 25.5157C27.4023 25.92 27.4023 26.5939 26.9531 26.9982C26.5488 27.4474 25.875 27.4474 25.4707 26.9982L22.2363 23.7638C22.0117 23.5841 21.9219 23.3146 21.9219 23.0001V18.3282C21.9219 17.7443 22.3711 17.2501 23 17.2501Z" fill="url(#paint0_linear_7486_3170)"></path></g><defs><filter id="filter0_ddi_7486_3170" x="0" y="0.00012207" width="46" height="46" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB"><feFlood flood-opacity="0" result="BackgroundImageFix"></feFlood><feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"></feColorMatrix><feOffset></feOffset><feGaussianBlur stdDeviation="5.75"></feGaussianBlur><feComposite in2="hardAlpha" operator="out"></feComposite><feColorMatrix type="matrix" values="0 0 0 0 1 0 0 0 0 0.48 0 0 0 0 0 0 0 0 1 0"></feColorMatrix><feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_7486_3170"></feBlend><feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"></feColorMatrix><feOffset dy="0.958333"></feOffset><feComposite in2="hardAlpha" operator="out"></feComposite><feColorMatrix type="matrix" values="0 0 0 0 0.815686 0 0 0 0 0.494118 0 0 0 0 0.0156863 0 0 0 1 0"></feColorMatrix><feBlend mode="normal" in2="effect1_dropShadow_7486_3170" result="effect2_dropShadow_7486_3170"></feBlend><feBlend mode="normal" in="SourceGraphic" in2="effect2_dropShadow_7486_3170" result="shape"></feBlend><feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"></feColorMatrix><feOffset dy="0.958333"></feOffset><feGaussianBlur stdDeviation="0.479167"></feGaussianBlur><feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"></feComposite><feColorMatrix type="matrix" values="0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0"></feColorMatrix><feBlend mode="normal" in2="shape" result="effect3_innerShadow_7486_3170"></feBlend></filter><linearGradient id="paint0_linear_7486_3170" x1="25.4078" y1="34.5001" x2="25.4078" y2="11.5001" gradientUnits="userSpaceOnUse"><stop stop-color="#FFE142"></stop><stop offset="0.572917" stop-color="#FFCD00"></stop><stop offset="1" stop-color="#FFC700"></stop></linearGradient></defs>', 2)]))
}
const iF = We(sF, [
    ["render", oF]
  ]),
  lF = {},
  uF = {
    width: "48",
    height: "47",
    viewBox: "0 0 48 47",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function cF(e, t) {
  return g(), k("svg", uF, t[0] || (t[0] = [mu('<g filter="url(#filter0_ddi_7486_3163)"><path d="M13.9419 14.8465C13.9419 13.8565 14.482 12.9114 15.382 12.3714C16.2371 11.8764 17.3621 11.8764 18.2622 12.3714C19.1172 12.9114 19.7023 13.8565 19.7023 14.8465C19.7023 15.8816 19.1172 16.8266 18.2622 17.3667C17.3621 17.8617 16.2371 17.8617 15.382 17.3667C14.482 16.8266 13.9419 15.8816 13.9419 14.8465ZM12.1868 22.497C12.3668 20.6069 13.9419 19.1668 15.787 19.1668H17.8121C19.0272 19.1668 20.1073 19.7968 20.7373 20.7419C20.6473 20.7869 20.5123 20.9219 20.4223 21.0119L17.5421 23.892C16.5521 24.8821 16.5521 26.4572 17.5421 27.4473L19.7023 29.6074V32.8476C19.7023 34.0626 18.7122 35.0077 17.5421 35.0077H16.102C14.887 35.0077 13.9419 34.0626 13.9419 32.8476V27.6723C12.7269 27.2222 11.9168 26.0522 12.0068 24.7021L12.1868 22.497ZM28.3427 14.8465C28.3427 13.8565 28.8828 12.9114 29.7828 12.3714C30.6379 11.8764 31.7629 11.8764 32.663 12.3714C33.518 12.9114 34.1031 13.8565 34.1031 14.8465C34.1031 15.8816 33.518 16.8266 32.663 17.3667C31.7629 17.8617 30.6379 17.8617 29.7828 17.3667C28.8828 16.8266 28.3427 15.8816 28.3427 14.8465ZM27.5777 21.0119C27.4877 20.9219 27.3527 20.7869 27.2627 20.7419C27.8927 19.7968 28.9728 19.1668 30.1878 19.1668H32.213C34.1031 19.1668 35.6332 20.6069 35.8132 22.497L35.9932 24.7021C36.0832 26.0522 35.2731 27.2222 34.1031 27.6723V32.8476C34.1031 34.0626 33.113 35.0077 31.9429 35.0077H30.5029C29.2878 35.0077 28.3427 34.0626 28.3427 32.8476V29.6074L30.4579 27.4473C31.4479 26.4572 31.4479 24.8821 30.4579 23.892L27.5777 21.0119ZM23.3025 22.767V24.2071H24.7425V22.767C24.7425 22.362 24.9676 21.9569 25.3726 21.7769C25.7776 21.6419 26.2726 21.7319 26.5876 22.0019L29.4678 24.8821C29.8728 25.3321 29.8728 26.0072 29.4678 26.4122L26.5876 29.2924C26.2726 29.6074 25.7776 29.6974 25.3726 29.5624C24.9676 29.3824 24.7425 28.9773 24.7425 28.5273V27.0872H23.3025V28.5273C23.3025 28.9773 23.0324 29.3824 22.6274 29.5624C22.2224 29.6974 21.7274 29.6074 21.4574 29.2924L18.5772 26.4122C18.1272 26.0072 18.1272 25.3321 18.5772 24.9271L21.4574 22.0469C21.7274 21.7319 22.2224 21.6419 22.6274 21.7769C23.0324 21.9569 23.3025 22.362 23.3025 22.812V22.767Z" fill="url(#paint0_linear_7486_3163)"></path></g><defs><filter id="filter0_ddi_7486_3163" x="0" y="0.00012207" width="48" height="47.0076" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB"><feFlood flood-opacity="0" result="BackgroundImageFix"></feFlood><feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"></feColorMatrix><feOffset></feOffset><feGaussianBlur stdDeviation="6"></feGaussianBlur><feComposite in2="hardAlpha" operator="out"></feComposite><feColorMatrix type="matrix" values="0 0 0 0 1 0 0 0 0 0.48 0 0 0 0 0 0 0 0 1 0"></feColorMatrix><feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_7486_3163"></feBlend><feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"></feColorMatrix><feOffset dy="1"></feOffset><feComposite in2="hardAlpha" operator="out"></feComposite><feColorMatrix type="matrix" values="0 0 0 0 0.815686 0 0 0 0 0.494118 0 0 0 0 0.0156863 0 0 0 1 0"></feColorMatrix><feBlend mode="normal" in2="effect1_dropShadow_7486_3163" result="effect2_dropShadow_7486_3163"></feBlend><feBlend mode="normal" in="SourceGraphic" in2="effect2_dropShadow_7486_3163" result="shape"></feBlend><feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"></feColorMatrix><feOffset dy="1"></feOffset><feGaussianBlur stdDeviation="0.5"></feGaussianBlur><feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"></feComposite><feColorMatrix type="matrix" values="0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0"></feColorMatrix><feBlend mode="normal" in2="shape" result="effect3_innerShadow_7486_3163"></feBlend></filter><linearGradient id="paint0_linear_7486_3163" x1="27.8747" y1="35.0077" x2="27.8747" y2="11.9664" gradientUnits="userSpaceOnUse"><stop stop-color="#FFE142"></stop><stop offset="0.572917" stop-color="#FFCD00"></stop><stop offset="1" stop-color="#FFC700"></stop></linearGradient></defs>', 2)]))
}
const dF = We(lF, [
    ["render", cF]
  ]),
  fF = {},
  pF = {
    width: "46",
    height: "46",
    viewBox: "0 0 46 46",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function hF(e, t) {
  return g(), k("svg", pF, t[0] || (t[0] = [mu('<g filter="url(#filter0_ddi_7486_3157)"><path d="M15.5 12.5001H30.5C32.1406 12.5001 33.5 13.8595 33.5 15.5001V30.5001C33.5 32.1876 32.1406 33.5001 30.5 33.5001H15.5C13.8125 33.5001 12.5 32.1876 12.5 30.5001V15.5001C12.5 13.8595 13.8125 12.5001 15.5 12.5001ZM18.9219 19.5314V19.5782C18.7344 20.1407 19.0156 20.797 19.625 21.0314C20.1875 21.2189 20.8438 20.9376 21.0312 20.3282L21.0781 20.2814C21.125 20.1407 21.2656 20.047 21.4062 20.047H24.125C24.5469 20.047 24.875 20.3282 24.875 20.7501C24.875 20.9845 24.7344 21.2189 24.5 21.3595L22.4375 22.5314C22.0625 22.7189 21.875 23.0939 21.875 23.5157V24.1251C21.875 24.7814 22.3438 25.2501 23 25.2501C23.6094 25.2501 24.0781 24.7814 24.125 24.172L25.625 23.2814C26.5156 22.7657 27.125 21.7814 27.125 20.7501C27.125 19.1095 25.7656 17.7501 24.125 17.7501H21.4062C20.2812 17.7501 19.2969 18.4532 18.9219 19.5314ZM21.5 28.2501C21.5 29.0939 22.1562 29.7501 23 29.7501C23.7969 29.7501 24.5 29.0939 24.5 28.2501C24.5 27.4532 23.7969 26.7501 23 26.7501C22.1562 26.7501 21.5 27.4532 21.5 28.2501ZM14.75 15.8751C14.75 16.5314 15.2188 17.0001 15.875 17.0001C16.4844 17.0001 17 16.5314 17 15.8751C17 15.2657 16.4844 14.7501 15.875 14.7501C15.2188 14.7501 14.75 15.2657 14.75 15.8751ZM30.125 14.7501C29.4688 14.7501 29 15.2657 29 15.8751C29 16.5314 29.4688 17.0001 30.125 17.0001C30.7344 17.0001 31.25 16.5314 31.25 15.8751C31.25 15.2657 30.7344 14.7501 30.125 14.7501ZM14.75 30.1251C14.75 30.7814 15.2188 31.2501 15.875 31.2501C16.4844 31.2501 17 30.7814 17 30.1251C17 29.5157 16.4844 29.0001 15.875 29.0001C15.2188 29.0001 14.75 29.5157 14.75 30.1251ZM30.125 29.0001C29.4688 29.0001 29 29.5157 29 30.1251C29 30.7814 29.4688 31.2501 30.125 31.2501C30.7344 31.2501 31.25 30.7814 31.25 30.1251C31.25 29.5157 30.7344 29.0001 30.125 29.0001Z" fill="url(#paint0_linear_7486_3157)"></path></g><defs><filter id="filter0_ddi_7486_3157" x="0.5" y="0.500122" width="45" height="45" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB"><feFlood flood-opacity="0" result="BackgroundImageFix"></feFlood><feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"></feColorMatrix><feOffset></feOffset><feGaussianBlur stdDeviation="6"></feGaussianBlur><feComposite in2="hardAlpha" operator="out"></feComposite><feColorMatrix type="matrix" values="0 0 0 0 1 0 0 0 0 0.48 0 0 0 0 0 0 0 0 1 0"></feColorMatrix><feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_7486_3157"></feBlend><feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"></feColorMatrix><feOffset dy="1"></feOffset><feComposite in2="hardAlpha" operator="out"></feComposite><feColorMatrix type="matrix" values="0 0 0 0 0.815686 0 0 0 0 0.494118 0 0 0 0 0.0156863 0 0 0 1 0"></feColorMatrix><feBlend mode="normal" in2="effect1_dropShadow_7486_3157" result="effect2_dropShadow_7486_3157"></feBlend><feBlend mode="normal" in="SourceGraphic" in2="effect2_dropShadow_7486_3157" result="shape"></feBlend><feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"></feColorMatrix><feOffset dy="1"></feOffset><feGaussianBlur stdDeviation="0.5"></feGaussianBlur><feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"></feComposite><feColorMatrix type="matrix" values="0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0"></feColorMatrix><feBlend mode="normal" in2="shape" result="effect3_innerShadow_7486_3157"></feBlend></filter><linearGradient id="paint0_linear_7486_3157" x1="25.5125" y1="35.0001" x2="25.5125" y2="11.0001" gradientUnits="userSpaceOnUse"><stop stop-color="#FFE142"></stop><stop offset="0.572917" stop-color="#FFCD00"></stop><stop offset="1" stop-color="#FFC700"></stop></linearGradient></defs>', 2)]))
}
const mF = We(fF, [
    ["render", hF]
  ]),
  gF = {},
  vF = {
    width: "48",
    height: "45",
    viewBox: "0 0 48 45",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function _F(e, t) {
  return g(), k("svg", vF, t[0] || (t[0] = [mu('<g filter="url(#filter0_ddi_7486_3183)"><path d="M28.3015 20.0253L28.2663 19.955C28.0063 19.435 28.1996 18.7965 28.736 18.5283C29.256 18.2683 29.8945 18.4616 30.1627 18.998L30.1978 19.0683C30.2492 19.1711 30.369 19.249 30.5065 19.249H31.8952C32.3091 19.249 32.6608 18.9058 32.6608 18.4833C32.6608 18.0739 32.3046 17.7177 31.8952 17.7177H30.067C29.6102 17.7177 29.2402 17.4474 29.0782 17.0585C28.9093 16.6533 29.0113 16.1825 29.343 15.8818L30.7048 14.624H29.2233C28.6307 14.624 28.1608 14.154 28.1608 13.5615C28.1608 12.9967 28.6207 12.499 29.2233 12.499H33.442C33.8852 12.499 34.2782 12.7919 34.4201 13.1925C34.5795 13.5942 34.4755 14.0567 34.1475 14.3533L32.6773 15.7001C33.8927 16.0418 34.7858 17.1598 34.7858 18.4833C34.7858 20.0978 33.4873 21.374 31.8952 21.374H30.5065C29.5803 21.374 28.7233 20.8468 28.3039 20.0301L28.3015 20.0253Z" fill="url(#paint0_linear_7486_3183)"></path><path d="M22.2372 20.338C22.411 20.1642 22.6545 20.0625 22.8856 20.0625C23.4005 20.0625 23.827 20.4891 23.827 21.0039C23.827 21.2351 23.7254 21.4785 23.5516 21.6523L20.1942 25.0098C19.8961 25.3078 19.7955 25.7685 19.9631 26.1709C20.1388 26.5924 20.5493 26.8125 20.952 26.8125H25.452C26.0168 26.8125 26.5145 26.3527 26.5145 25.75C26.5145 25.1751 26.027 24.6875 25.452 24.6875H23.5126L25.0497 23.1505C25.6136 22.5866 25.952 21.8107 25.952 21.0039C25.952 19.304 24.5856 17.9375 22.8856 17.9375C22.0788 17.9375 21.303 18.276 20.7391 18.8398L20.2001 19.3788C19.7704 19.7843 19.7684 20.4748 20.194 20.883C20.6022 21.3086 21.2927 21.3066 21.6982 20.877L22.2372 20.338Z" fill="url(#paint1_linear_7486_3183)"></path><path d="M16.4942 18.0791L16.4698 18.0644L16.4438 18.0526C16.1257 17.9081 15.7236 17.889 15.3755 18.1296L13.692 19.252C13.2034 19.5777 13.063 20.2206 13.3951 20.7188C13.7154 21.1992 14.3765 21.3551 14.8664 21.0127L14.9108 20.9835V24.6875H14.2858C13.6831 24.6875 13.2233 25.1852 13.2233 25.75C13.2233 26.3426 13.6932 26.8125 14.2858 26.8125H17.6608C18.2255 26.8125 18.7233 26.3527 18.7233 25.75C18.7233 25.175 18.2357 24.6875 17.6608 24.6875H17.0358V19C17.0358 18.604 16.7958 18.2601 16.4942 18.0791Z" fill="url(#paint2_linear_7486_3183)"></path><path d="M30.2194 28.07L31.7654 24.8046L31.7684 24.7978C32.0011 24.2661 31.7656 23.6507 31.2527 23.3943L31.2412 23.3886L31.2295 23.3834C30.7084 23.1555 30.0768 23.3755 29.8359 23.9151L27.5906 28.6866C27.4208 29.0314 27.4704 29.3909 27.6112 29.6726L27.6251 29.7004L27.6424 29.7263C27.856 30.0467 28.2198 30.195 28.5506 30.195H31.9881V31.1013C31.9881 31.6938 32.458 32.1638 33.0506 32.1638C33.6154 32.1638 34.1131 31.7039 34.1131 31.1013V30.195H34.1756C34.7404 30.195 35.2381 29.7352 35.2381 29.1325C35.2381 28.5576 34.7506 28.07 34.1756 28.07H34.1131V26.0388C34.1131 25.4638 33.6256 24.9763 33.0506 24.9763C32.448 24.9763 31.9881 25.474 31.9881 26.0388V28.07H30.2194Z" fill="url(#paint3_linear_7486_3183)"></path><path d="M12.5674 30.4272C12.5674 29.7368 13.127 29.1772 13.8174 29.1772H25.2422C25.9325 29.1772 26.4922 29.7368 26.4922 30.4272C26.4922 31.1175 25.9325 31.6772 25.2422 31.6772H13.8174C13.127 31.6772 12.5674 31.1175 12.5674 30.4272Z" fill="url(#paint4_linear_7486_3183)"></path><path d="M12.5674 14.784C12.5674 14.0936 13.127 13.534 13.8174 13.534H25.2422C25.9325 13.534 26.4922 14.0936 26.4922 14.784C26.4922 15.4743 25.9325 16.034 25.2422 16.034H13.8174C13.127 16.034 12.5674 15.4743 12.5674 14.784Z" fill="url(#paint5_linear_7486_3183)"></path></g><defs><filter id="filter0_ddi_7486_3183" x="0.567383" y="0.498962" width="46.6709" height="43.6648" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB"><feFlood flood-opacity="0" result="BackgroundImageFix"></feFlood><feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"></feColorMatrix><feOffset></feOffset><feGaussianBlur stdDeviation="6"></feGaussianBlur><feComposite in2="hardAlpha" operator="out"></feComposite><feColorMatrix type="matrix" values="0 0 0 0 1 0 0 0 0 0.48 0 0 0 0 0 0 0 0 1 0"></feColorMatrix><feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_7486_3183"></feBlend><feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"></feColorMatrix><feOffset dy="1"></feOffset><feComposite in2="hardAlpha" operator="out"></feComposite><feColorMatrix type="matrix" values="0 0 0 0 0.815686 0 0 0 0 0.494118 0 0 0 0 0.0156863 0 0 0 1 0"></feColorMatrix><feBlend mode="normal" in2="effect1_dropShadow_7486_3183" result="effect2_dropShadow_7486_3183"></feBlend><feBlend mode="normal" in="SourceGraphic" in2="effect2_dropShadow_7486_3183" result="shape"></feBlend><feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"></feColorMatrix><feOffset dy="1"></feOffset><feGaussianBlur stdDeviation="0.5"></feGaussianBlur><feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"></feComposite><feColorMatrix type="matrix" values="0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0"></feColorMatrix><feBlend mode="normal" in2="shape" result="effect3_innerShadow_7486_3183"></feBlend></filter><linearGradient id="paint0_linear_7486_3183" x1="17.4909" y1="16.6288" x2="17.4909" y2="14.9334" gradientUnits="userSpaceOnUse"><stop stop-color="#FFE142"></stop><stop offset="0.572917" stop-color="#FFCD00"></stop><stop offset="1" stop-color="#FFC700"></stop></linearGradient><linearGradient id="paint1_linear_7486_3183" x1="17.4909" y1="16.6288" x2="17.4909" y2="14.9334" gradientUnits="userSpaceOnUse"><stop stop-color="#FFE142"></stop><stop offset="0.572917" stop-color="#FFCD00"></stop><stop offset="1" stop-color="#FFC700"></stop></linearGradient><linearGradient id="paint2_linear_7486_3183" x1="17.4909" y1="16.6288" x2="17.4909" y2="14.9334" gradientUnits="userSpaceOnUse"><stop stop-color="#FFE142"></stop><stop offset="0.572917" stop-color="#FFCD00"></stop><stop offset="1" stop-color="#FFC700"></stop></linearGradient><linearGradient id="paint3_linear_7486_3183" x1="17.4909" y1="16.6288" x2="17.4909" y2="14.9334" gradientUnits="userSpaceOnUse"><stop stop-color="#FFE142"></stop><stop offset="0.572917" stop-color="#FFCD00"></stop><stop offset="1" stop-color="#FFC700"></stop></linearGradient><linearGradient id="paint4_linear_7486_3183" x1="17.4909" y1="16.6288" x2="17.4909" y2="14.9334" gradientUnits="userSpaceOnUse"><stop stop-color="#FFE142"></stop><stop offset="0.572917" stop-color="#FFCD00"></stop><stop offset="1" stop-color="#FFC700"></stop></linearGradient><linearGradient id="paint5_linear_7486_3183" x1="17.4909" y1="16.6288" x2="17.4909" y2="14.9334" gradientUnits="userSpaceOnUse"><stop stop-color="#FFE142"></stop><stop offset="0.572917" stop-color="#FFCD00"></stop><stop offset="1" stop-color="#FFC700"></stop></linearGradient></defs>', 2)]))
}
const yF = We(gF, [
    ["render", _F]
  ]),
  bF = {},
  wF = {
    width: "42",
    height: "47",
    viewBox: "0 0 42 47",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function CF(e, t) {
  return g(), k("svg", wF, t[0] || (t[0] = [mu('<g filter="url(#filter0_ddi_7486_3147)"><path d="M13.8125 12.0001H28.1875C28.9512 12.0001 29.625 12.674 29.625 13.4376C29.625 14.2462 28.9512 14.8751 28.1875 14.8751V15.3693C28.1875 17.3009 27.4238 19.1427 26.0762 20.4904L23.0215 23.5001L26.0762 26.5548C27.4238 27.9025 28.1875 29.7443 28.1875 31.631V32.1251C28.9512 32.1251 29.625 32.799 29.625 33.5626C29.625 34.3712 28.9512 35.0001 28.1875 35.0001H13.8125C13.0039 35.0001 12.375 34.3712 12.375 33.5626C12.375 32.799 13.0039 32.1251 13.8125 32.1251V31.631C13.8125 29.7443 14.5312 27.9025 15.8789 26.5548L18.9336 23.5001L15.8789 20.4904C14.5312 19.1427 13.8125 17.3009 13.8125 15.3693V14.8751C13.0039 14.8751 12.375 14.2462 12.375 13.4376C12.375 12.674 13.0039 12.0001 13.8125 12.0001ZM25.3125 31.631V31.6759C25.3125 30.5079 24.8184 29.4298 24.0098 28.6212L21 25.5665L17.9453 28.6212C17.1367 29.4298 16.6875 30.5079 16.6875 31.631V32.1251H25.3125V31.631Z" fill="url(#paint0_linear_7486_3147)"></path></g><defs><filter id="filter0_ddi_7486_3147" x="0.875" y="0.500122" width="40.25" height="46" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB"><feFlood flood-opacity="0" result="BackgroundImageFix"></feFlood><feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"></feColorMatrix><feOffset></feOffset><feGaussianBlur stdDeviation="5.75"></feGaussianBlur><feComposite in2="hardAlpha" operator="out"></feComposite><feColorMatrix type="matrix" values="0 0 0 0 1 0 0 0 0 0.48 0 0 0 0 0 0 0 0 1 0"></feColorMatrix><feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_7486_3147"></feBlend><feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"></feColorMatrix><feOffset dy="0.958333"></feOffset><feComposite in2="hardAlpha" operator="out"></feComposite><feColorMatrix type="matrix" values="0 0 0 0 0.815686 0 0 0 0 0.494118 0 0 0 0 0.0156863 0 0 0 1 0"></feColorMatrix><feBlend mode="normal" in2="effect1_dropShadow_7486_3147" result="effect2_dropShadow_7486_3147"></feBlend><feBlend mode="normal" in="SourceGraphic" in2="effect2_dropShadow_7486_3147" result="shape"></feBlend><feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"></feColorMatrix><feOffset dy="0.958333"></feOffset><feGaussianBlur stdDeviation="0.479167"></feGaussianBlur><feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"></feComposite><feColorMatrix type="matrix" values="0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0"></feColorMatrix><feBlend mode="normal" in2="shape" result="effect3_innerShadow_7486_3147"></feBlend></filter><linearGradient id="paint0_linear_7486_3147" x1="23.4078" y1="35.0001" x2="23.4078" y2="12.0001" gradientUnits="userSpaceOnUse"><stop stop-color="#FFE142"></stop><stop offset="0.572917" stop-color="#FFCD00"></stop><stop offset="1" stop-color="#FFC700"></stop></linearGradient></defs>', 2)]))
}
const xF = We(bF, [
    ["render", CF]
  ]),
  kF = {},
  SF = {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function EF(e, t) {
  return g(), k("svg", SF, t[0] || (t[0] = [m("path", {
    d: "M4.8 2.40002H14.4C15.7125 2.40002 16.8 3.48752 16.8 4.80002H2.4C2.4 3.48752 3.45 2.40002 4.8 2.40002ZM2.4 6.00003H16.8C18.1125 6.00003 19.2 7.08753 19.2 8.40003V15.6C19.2 16.95 18.1125 18 16.8 18V19.2H19.8C20.4375 19.2 21 18.675 21 18V10.35C20.625 10.0125 20.4 9.56253 20.4 9.00003C20.4 8.02503 21.1875 7.20003 22.2 7.20003C23.175 7.20003 24 8.02503 24 9.00003C24 9.56253 23.7375 10.0125 23.4 10.35V18C23.4 19.9875 21.7875 21.6 19.8 21.6H16.8H15.6H4.8C3.45 21.6 2.4 20.55 2.4 19.2V18C1.05 18 0 16.95 0 15.6V8.40003C0 7.08753 1.05 6.00003 2.4 6.00003ZM2.1 9.90003C2.1 10.425 2.475 10.8 3 10.8H4.3125L3.075 13.7625C2.85 14.2125 3.075 14.7375 3.525 14.9625C3.975 15.15 4.5 14.925 4.725 14.475L6.3375 10.6875C6.675 9.90003 6.075 9.00003 5.2125 9.00003H3C2.475 9.00003 2.1 9.41253 2.1 9.90003ZM8.4 9.00003C7.875 9.00003 7.5 9.41253 7.5 9.90003C7.5 10.425 7.875 10.8 8.4 10.8H9.7125L8.475 13.7625C8.25 14.2125 8.475 14.7375 8.925 14.9625C9.375 15.15 9.9 14.925 10.125 14.475L11.7375 10.6875C12.075 9.90003 11.475 9.00003 10.6125 9.00003H8.4ZM12.9 9.90003C12.9 10.425 13.275 10.8 13.8 10.8H15.1125L13.875 13.7625C13.65 14.2125 13.875 14.7375 14.325 14.9625C14.775 15.15 15.3 14.925 15.525 14.475L17.1375 10.6875C17.475 9.90003 16.875 9.00003 16.0125 9.00003H13.8C13.275 9.00003 12.9 9.41253 12.9 9.90003Z",
    fill: "currentColor"
  }, null, -1)]))
}
const vg = We(kF, [
    ["render", EF]
  ]),
  TF = {},
  AF = {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function PF(e, t) {
  return g(), k("svg", AF, t[0] || (t[0] = [m("path", {
    d: "M12.0001 12C10.2751 12 8.7001 11.1 7.8376 9.60003C6.9751 8.13753 6.9751 6.30003 7.8376 4.80002C8.7001 3.33752 10.2751 2.40002 12.0001 2.40002C13.6876 2.40002 15.2626 3.33752 16.1251 4.80002C16.9876 6.30003 16.9876 8.13753 16.1251 9.60003C15.2626 11.1 13.6876 12 12.0001 12ZM10.2751 13.8H13.6876C17.4001 13.8 20.4001 16.8 20.4001 20.5125C20.4001 21.1125 19.8751 21.6 19.2751 21.6H4.6876C4.0876 21.6 3.6001 21.1125 3.6001 20.5125C3.6001 16.8 6.5626 13.8 10.2751 13.8Z",
    fill: "currentColor"
  }, null, -1)]))
}
const _g = We(TF, [
    ["render", PF]
  ]),
  IF = {},
  $F = {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function MF(e, t) {
  return g(), k("svg", $F, t[0] || (t[0] = [m("path", {
    d: "M16.2 17.9999H3V19.1999C3 20.2124 3.7875 20.9999 4.8 20.9999H14.4C15.375 20.9999 16.2 20.2124 16.2 19.1999V17.9999ZM15.975 20.9999H19.8C20.925 20.9999 21.9 20.0624 21.9 18.8999V10.7999C21.0375 10.6499 20.4 9.8999 20.4 8.9999C20.4 8.0249 21.1875 7.1999 22.2 7.1999C23.175 7.1999 24 8.0249 24 8.9999C24 9.8999 23.325 10.6499 22.5 10.7999V18.8999C22.5 20.3999 21.2625 21.5999 19.8 21.5999H14.4H4.8C3.45 21.5999 2.4 20.5499 2.4 19.1999V17.9999C1.05 17.9999 0 16.9499 0 15.5999V8.3999C0 7.0874 1.05 5.9999 2.4 5.9999V4.7999C2.4 3.4874 3.45 2.3999 4.8 2.3999H14.4C15.7125 2.3999 16.8 3.4874 16.8 4.7999V5.9999C18.1125 5.9999 19.2 7.0874 19.2 8.3999V15.5999C19.2 16.9499 18.1125 17.9999 16.8 17.9999V19.1999C16.8 19.9499 16.4625 20.5874 15.975 20.9999ZM21 8.9999C21 9.6749 21.525 10.1999 22.2 10.1999C22.8375 10.1999 23.4 9.6749 23.4 8.9999C23.4 8.3624 22.8375 7.7999 22.2 7.7999C21.525 7.7999 21 8.3624 21 8.9999ZM16.2 4.7999C16.2 3.8249 15.375 2.9999 14.4 2.9999H4.8C3.7875 2.9999 3 3.8249 3 4.7999V5.9999H16.2V4.7999ZM16.8 6.5999H2.4C1.3875 6.5999 0.6 7.4249 0.6 8.3999V15.5999C0.6 16.6124 1.3875 17.3999 2.4 17.3999H16.8C17.775 17.3999 18.6 16.6124 18.6 15.5999V8.3999C18.6 7.4249 17.775 6.5999 16.8 6.5999ZM3.6 8.9999H6.3C6.375 8.9999 6.4875 9.0749 6.525 9.1499C6.6 9.2249 6.6 9.3374 6.5625 9.4124L4.4625 14.8124C4.3875 14.9999 4.2375 15.0749 4.0875 14.9999C3.9 14.9249 3.825 14.7749 3.9 14.6249L5.85 9.5999H3.6C3.4125 9.5999 3.3 9.4874 3.3 9.2999C3.3 9.1499 3.4125 8.9999 3.6 8.9999ZM8.4 8.9999H11.1C11.175 8.9999 11.2875 9.0749 11.325 9.1499C11.4 9.2249 11.4 9.3374 11.3625 9.4124L9.2625 14.8124C9.1875 14.9999 9.0375 15.0749 8.8875 14.9999C8.7 14.9249 8.625 14.7749 8.7 14.6249L10.65 9.5999H8.4C8.2125 9.5999 8.1 9.4874 8.1 9.2999C8.1 9.1499 8.2125 8.9999 8.4 8.9999ZM13.2 8.9999H15.9C15.975 8.9999 16.0875 9.0749 16.125 9.1499C16.2 9.2249 16.2 9.3374 16.1625 9.4124L14.0625 14.8124C13.9875 14.9999 13.8375 15.0749 13.6875 14.9999C13.5 14.9249 13.425 14.7749 13.5 14.6249L15.45 9.5999H13.2C13.0125 9.5999 12.9 9.4874 12.9 9.2999C12.9 9.1499 13.0125 8.9999 13.2 8.9999Z",
    fill: "currentColor"
  }, null, -1)]))
}
const OF = We(IF, [
    ["render", MF]
  ]),
  DF = {},
  LF = {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function RF(e, t) {
  return g(), k("svg", LF, t[0] || (t[0] = [m("path", {
    d: "M16.2 7.18594C16.2 5.68594 15.375 4.33594 14.1 3.58594C12.7875 2.79844 11.175 2.79844 9.89998 3.58594C8.58748 4.33594 7.79998 5.68594 7.79998 7.18594C7.79998 8.72344 8.58748 10.0734 9.89998 10.8234C11.175 11.6109 12.7875 11.6109 14.1 10.8234C15.375 10.0734 16.2 8.72344 16.2 7.18594ZM7.19998 7.18594C7.19998 5.49844 8.09998 3.92344 9.59998 3.06094C11.0625 2.19844 12.9 2.19844 14.4 3.06094C15.8625 3.92344 16.8 5.49844 16.8 7.18594C16.8 8.91094 15.8625 10.4859 14.4 11.3484C12.9 12.2109 11.0625 12.2109 9.59998 11.3484C8.09998 10.4859 7.19998 8.91094 7.19998 7.18594ZM4.19998 20.4984C4.19998 20.7609 4.42498 20.9859 4.68748 20.9859H19.275C19.5375 20.9859 19.8 20.7609 19.8 20.4984C19.8 17.1234 17.0625 14.3859 13.6875 14.3859H10.275C6.89998 14.3859 4.19998 17.1234 4.19998 20.4984ZM3.59998 20.4984C3.59998 16.7859 6.56248 13.7859 10.275 13.7859H13.6875C17.4 13.7859 20.4 16.7859 20.4 20.4984C20.4 21.0984 19.875 21.5859 19.275 21.5859H4.68748C4.08748 21.5859 3.59998 21.0984 3.59998 20.4984Z",
    fill: "currentColor"
  }, null, -1)]))
}
const NF = We(DF, [
    ["render", RF]
  ]),
  FF = ["stroke"],
  Ka = te({
    __name: "IconLoading",
    props: {
      isSecondary: {
        type: Boolean
      }
    },
    setup(e) {
      return (t, n) => (g(), k("svg", {
        width: "48",
        height: "48",
        viewBox: "0 0 48 48",
        xmlns: "http://www.w3.org/2000/svg",
        stroke: t.isSecondary ? "#000" : "#fff"
      }, n[0] || (n[0] = [m("g", {
        fill: "none",
        "fill-rule": "evenodd",
        "stroke-width": "4"
      }, [m("circle", {
        cx: "24",
        cy: "24",
        r: "22",
        "stroke-opacity": "0.1"
      }), m("path", {
        d: "M24 2 A 22 22 0 0 1 46 24",
        "stroke-linecap": "round"
      }, [m("animateTransform", {
        attributeName: "transform",
        type: "rotate",
        from: "0 24 24",
        to: "360 24 24",
        dur: "1s",
        repeatCount: "indefinite"
      })])], -1)]), 8, FF))
    }
  }),
  BF = {},
  jF = {
    width: "48",
    height: "48",
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function HF(e, t) {
  return g(), k("svg", jF, t[0] || (t[0] = [m("rect", {
    opacity: "0.5",
    x: "4",
    y: "4",
    width: "40",
    height: "40",
    rx: "20",
    fill: "#212330"
  }, null, -1), m("path", {
    d: "M32.4766 18.5234C32.8281 18.9141 32.8281 19.5 32.4766 19.8516L22.1641 30.1641C21.7734 30.5547 21.1875 30.5547 20.8359 30.1641L15.5234 24.8516C15.1328 24.5 15.1328 23.9141 15.5234 23.5625C15.875 23.1719 16.4609 23.1719 16.8125 23.5625L21.4609 28.2109L31.1484 18.5234C31.5 18.1719 32.0859 18.1719 32.4375 18.5234H32.4766Z",
    fill: "currentColor"
  }, null, -1)]))
}
const VF = We(BF, [
    ["render", HF]
  ]),
  UF = {},
  zF = {
    width: "48",
    height: "48",
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function YF(e, t) {
  return g(), k("svg", zF, t[0] || (t[0] = [m("rect", {
    opacity: "0.5",
    x: "4",
    y: "4",
    width: "40",
    height: "40",
    rx: "20",
    fill: "#212330"
  }, null, -1), m("path", {
    d: "M15.4062 28.6016C15.5625 28.0547 15.875 27.5469 16.2656 27.1562L28.1406 15.2812C29.1172 14.3047 30.7188 14.3047 31.6953 15.2812L33.2188 16.8047C33.3359 16.9219 33.4531 17.0781 33.5312 17.1953C34.1953 18.1719 34.0781 19.5 33.2188 20.3594L21.3438 32.2344C21.3047 32.2734 21.2266 32.3125 21.1875 32.3906C20.7969 32.7031 20.3672 32.9375 19.8984 33.0938L16.8516 33.9922L15.1719 34.5C14.8594 34.5781 14.5078 34.5 14.2734 34.2266C14 33.9922 13.9219 33.6406 14.0391 33.3281L14.5078 31.6484L15.4062 28.6016ZM17.2031 29.1484L16.9297 30.0469L16.3047 32.1953L18.4531 31.5703L19.3516 31.2969C19.625 31.2188 19.8203 31.1016 20.0156 30.9062L28.9609 21.9609L26.5391 19.5391L17.5938 28.4844C17.5547 28.4844 17.5547 28.5234 17.5156 28.5625C17.3594 28.7188 17.2812 28.9141 17.2031 29.1484Z",
    fill: "currentColor"
  }, null, -1)]))
}
const WF = We(UF, [
    ["render", YF]
  ]),
  GF = {},
  QF = {
    width: "15",
    height: "17",
    viewBox: "0 0 15 17",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function qF(e, t) {
  return g(), k("svg", QF, t[0] || (t[0] = [m("path", {
    d: "M14.0625 8.375C14.0625 6.03125 12.8027 3.89258 10.7812 2.7207C8.73047 1.51953 6.24023 1.51953 4.21875 2.7207C2.16797 3.89258 0.9375 6.03125 0.9375 8.375C0.9375 10.748 2.16797 12.8867 4.21875 14.0586C6.24023 15.2598 8.73047 15.2598 10.7812 14.0586C12.8027 12.8867 14.0625 10.748 14.0625 8.375ZM0 8.375C0 5.70898 1.40625 3.24805 3.75 1.90039C6.06445 0.552734 8.90625 0.552734 11.25 1.90039C13.5645 3.24805 15 5.70898 15 8.375C15 11.0703 13.5645 13.5313 11.25 14.8789C8.90625 16.2266 6.06445 16.2266 3.75 14.8789C1.40625 13.5313 0 11.0703 0 8.375ZM7.03125 4.15625C7.03125 3.92188 7.23633 3.6875 7.5 3.6875C7.73437 3.6875 7.96875 3.92188 7.96875 4.15625L7.96875 8.14063L10.5469 9.86914C10.7812 10.0156 10.8398 10.3086 10.6934 10.5137C10.5469 10.748 10.2539 10.8066 10.0488 10.6602L7.23633 8.78516C7.08984 8.69727 7.03125 8.55078 7.03125 8.375L7.03125 4.15625Z",
    fill: "currentColor",
    "fill-opacity": "0.3"
  }, null, -1)]))
}
const gy = We(GF, [
    ["render", qF]
  ]),
  KF = {},
  ZF = {
    width: "25",
    height: "24",
    viewBox: "0 0 25 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  };

function JF(e, t) {
  return g(), k("svg", ZF, t[0] || (t[0] = [m("path", {
    d: "M4.75 12.0004H12.75M20.75 12.0004H12.75M12.75 12.0004V4.00037M12.75 12.0004V20.0004",
    stroke: "currentColor",
    "stroke-width": "2.5",
    "stroke-linecap": "round"
  }, null, -1)]))
}
const y9 = We(KF, [
    ["render", JF]
  ]),
  XF = {},
  eB = {
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function tB(e, t) {
  return g(), k("svg", eB, t[0] || (t[0] = [m("path", {
    d: "M9.34375 5.90625C9.34375 4.45898 8.55664 3.13867 7.3125 2.40234C6.04297 1.66602 4.49414 1.66602 3.25 2.40234C1.98047 3.13867 1.21875 4.45898 1.21875 5.90625C1.21875 7.37891 1.98047 8.69922 3.25 9.43555C4.49414 10.1719 6.04297 10.1719 7.3125 9.43555C8.55664 8.69922 9.34375 7.37891 9.34375 5.90625ZM8.55664 10.0703C7.64258 10.7812 6.5 11.1875 5.28125 11.1875C2.36133 11.1875 0 8.82617 0 5.90625C0 3.01172 2.36133 0.625 5.28125 0.625C8.17578 0.625 10.5625 3.01172 10.5625 5.90625C10.5625 7.15039 10.1309 8.29297 9.41992 9.20703L12.8223 12.584C13.0508 12.8379 13.0508 13.2188 12.8223 13.4473C12.5684 13.7012 12.1875 13.7012 11.959 13.4473L8.55664 10.0703Z",
    fill: "currentColor"
  }, null, -1)]))
}
const Al = We(XF, [
    ["render", tB]
  ]),
  nB = {},
  rB = {
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function sB(e, t) {
  return g(), k("svg", rB, t[0] || (t[0] = [m("g", {
    id: "check"
  }, [m("path", {
    id: "check_2",
    d: "M14.7812 3.21875C15.0625 3.53125 15.0625 4 14.7812 4.28125L6.53125 12.5312C6.21875 12.8438 5.75 12.8438 5.46875 12.5312L1.21875 8.28125C0.90625 8 0.90625 7.53125 1.21875 7.25C1.5 6.9375 1.96875 6.9375 2.25 7.25L5.96875 10.9688L13.7188 3.21875C14 2.9375 14.4688 2.9375 14.75 3.21875H14.7812Z",
    fill: "#FFCC29"
  })], -1)]))
}
const b9 = We(nB, [
    ["render", sB]
  ]),
  aB = {},
  oB = {
    width: "17",
    height: "16",
    viewBox: "0 0 17 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function iB(e, t) {
  return g(), k("svg", oB, t[0] || (t[0] = [m("g", {
    id: "Close"
  }, [m("path", {
    id: "Close_2",
    d: "M13.5469 4.27383L9.79688 8.02383L13.5156 11.7426C13.8281 12.0238 13.8281 12.4926 13.5156 12.7738C13.2344 13.0863 12.7656 13.0863 12.4844 12.7738L8.73438 9.05508L5.01562 12.7738C4.73438 13.0863 4.26562 13.0863 3.98438 12.7738C3.67188 12.4926 3.67188 12.0238 3.98438 11.7113L7.70312 7.99258L3.98438 4.27383C3.67188 3.99258 3.67188 3.52383 3.98438 3.21133C4.26562 2.93008 4.73438 2.93008 5.04688 3.21133L8.76562 6.96133L12.4844 3.24258C12.7656 2.93008 13.2344 2.93008 13.5469 3.24258C13.8281 3.52383 13.8281 3.99258 13.5469 4.27383Z",
    fill: "currentColor"
  })], -1)]))
}
const lB = We(aB, [
    ["render", iB]
  ]),
  uB = {},
  cB = {
    width: "20",
    height: "18",
    viewBox: "0 0 20 18",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function dB(e, t) {
  return g(), k("svg", cB, t[0] || (t[0] = [m("path", {
    d: "M19.5 6.56287C19.5 7.10974 19.0703 7.50037 18.5625 7.50037H12.9375C12.3906 7.50037 12 7.10974 12 6.56287C12 6.05505 12.3906 5.62537 12.9375 5.62537H16.2969L14.2656 3.59412C13.1328 2.50037 11.6484 1.87537 10.125 1.87537C7.27344 1.87537 4.8125 3.63318 3.79688 6.09412C3.5625 6.56287 3.01562 6.75818 2.54688 6.56287C2.07812 6.36755 1.84375 5.82068 2.03906 5.35193C3.36719 2.22693 6.49219 0.000366211 10.125 0.000366211C12.1562 0.000366211 14.1094 0.820679 15.5547 2.26599L17.625 4.3363V0.937866C17.625 0.430054 18.0156 0.000366211 18.5625 0.000366211C19.0703 0.000366211 19.5 0.430054 19.5 0.937866V6.56287ZM1.6875 10.0004H6.0625C6.57031 10.0004 7 10.4301 7 10.9379C7 11.4847 6.57031 11.8754 6.0625 11.8754H3.91406L5.98438 13.9457C7.07812 15.0394 8.5625 15.6254 10.125 15.6254C12.9375 15.6254 15.3984 13.9457 16.4141 11.4847C16.6484 10.9769 17.1953 10.7816 17.6641 10.9769C18.1328 11.1722 18.3672 11.7191 18.1719 12.2269C16.8047 15.3129 13.7188 17.5004 10.125 17.5004C8.05469 17.5004 6.10156 16.7191 4.65625 15.2738L2.625 13.2035V15.3129C2.625 15.8597 2.19531 16.2504 1.6875 16.2504C1.14062 16.2504 0.75 15.8597 0.75 15.3129V10.9379C0.75 10.4301 1.14062 10.0004 1.6875 10.0004Z",
    fill: "currentColor"
  }, null, -1)]))
}
const fB = We(uB, [
    ["render", dB]
  ]),
  pB = {},
  hB = {
    width: "25",
    height: "24",
    viewBox: "0 0 25 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  };

function mB(e, t) {
  return g(), k("svg", hB, t[0] || (t[0] = [m("path", {
    d: "M4.75 12.0004H20.75",
    stroke: "currentColor",
    "stroke-width": "2.5",
    "stroke-linecap": "round"
  }, null, -1)]))
}
const gB = We(pB, [
    ["render", mB]
  ]),
  vB = {},
  _B = {
    width: "11",
    height: "9",
    viewBox: "0 0 11 9",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function yB(e, t) {
  return g(), k("svg", _B, t[0] || (t[0] = [m("path", {
    opacity: "0.5",
    d: "M1.75 4.80036L4.15 7.20036L9.75 1.60036",
    stroke: "currentColor",
    "stroke-width": "2",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null, -1)]))
}
const w9 = We(vB, [
    ["render", yB]
  ]),
  bB = {},
  wB = {
    width: "18",
    height: "21",
    viewBox: "0 0 18 21",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function CB(e, t) {
  return g(), k("svg", wB, t[0] || (t[0] = [m("path", {
    d: "M6.64062 2.53165L5.89844 3.6254L11.5625 3.6254L10.8203 2.53165C10.7812 2.45352 10.6641 2.3754 10.5469 2.3754L6.91406 2.3754C6.79687 2.3754 6.67969 2.45352 6.64062 2.53165ZM12.3828 1.47696L13.8281 3.6254L14.375 3.6254L16.25 3.6254L16.5625 3.6254C17.0703 3.6254 17.5 4.05509 17.5 4.5629C17.5 5.10978 17.0703 5.5004 16.5625 5.5004L16.25 5.5004L16.25 17.3754C16.25 19.1332 14.8437 20.5004 13.125 20.5004L4.375 20.5004C2.61718 20.5004 1.25 19.1332 1.25 17.3754L1.25 5.5004L0.937499 5.5004C0.390624 5.5004 -1.24304e-06 5.10977 -1.14742e-06 4.5629C-1.05864e-06 4.05509 0.390624 3.6254 0.937499 3.6254L1.25 3.6254L3.125 3.6254L3.63281 3.6254L5.07812 1.47696C5.46875 0.891024 6.17187 0.500399 6.91406 0.500399L10.5469 0.500399C11.2891 0.5004 11.9922 0.891025 12.3828 1.47696ZM3.125 5.5004L3.125 17.3754C3.125 18.0785 3.67187 18.6254 4.375 18.6254L13.125 18.6254C13.7891 18.6254 14.375 18.0785 14.375 17.3754L14.375 5.5004L3.125 5.5004ZM6.25 8.0004L6.25 16.1254C6.25 16.477 5.9375 16.7504 5.625 16.7504C5.27343 16.7504 5 16.477 5 16.1254L5 8.0004C5 7.6879 5.27344 7.3754 5.625 7.3754C5.9375 7.3754 6.25 7.6879 6.25 8.0004ZM9.375 8.0004L9.375 16.1254C9.375 16.477 9.0625 16.7504 8.75 16.7504C8.39843 16.7504 8.125 16.477 8.125 16.1254L8.125 8.0004C8.125 7.6879 8.39844 7.3754 8.75 7.3754C9.0625 7.3754 9.375 7.6879 9.375 8.0004ZM12.5 8.0004L12.5 16.1254C12.5 16.477 12.1875 16.7504 11.875 16.7504C11.5234 16.7504 11.25 16.477 11.25 16.1254L11.25 8.0004C11.25 7.6879 11.5234 7.3754 11.875 7.3754C12.1875 7.3754 12.5 7.6879 12.5 8.0004Z",
    fill: "currentColor"
  }, null, -1)]))
}
const vy = We(bB, [
    ["render", CB]
  ]),
  xB = {},
  kB = {
    width: "25",
    height: "24",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function SB(e, t) {
  return g(), k("svg", kB, t[0] || (t[0] = [m("path", {
    d: "M19.1953 18.188C20.7422 16.5981 21.6875 14.4067 21.6875 12.0005C21.6875 7.10205 17.6484 3.06299 12.75 3.06299C7.80859 3.06299 3.8125 7.10205 3.8125 12.0005C3.8125 14.4067 4.71484 16.5981 6.26172 18.188C7.07812 16.1685 9.05469 14.7505 11.375 14.7505H14.125C16.4023 14.7505 18.3789 16.1685 19.1953 18.188ZM17.4766 19.606C17.1758 18.0161 15.7578 16.813 14.125 16.813H11.375C9.69922 16.813 8.28125 18.0161 7.98047 19.606C9.35547 20.4653 10.9883 20.938 12.75 20.938C14.4688 20.938 16.1016 20.4653 17.4766 19.606ZM12.75 23.0005C8.79688 23.0005 5.1875 20.938 3.21094 17.5005C1.23438 14.106 1.23438 9.93799 3.21094 6.50049C5.1875 3.10596 8.79688 1.00049 12.75 1.00049C16.6602 1.00049 20.2695 3.10596 22.2461 6.50049C24.2227 9.93799 24.2227 14.106 22.2461 17.5005C20.2695 20.938 16.6602 23.0005 12.75 23.0005ZM12.75 11.313C13.3516 11.313 13.9102 11.0122 14.2109 10.4536C14.5117 9.93799 14.5117 9.29346 14.2109 8.73486C13.9102 8.21924 13.3516 7.87549 12.75 7.87549C12.1055 7.87549 11.5469 8.21924 11.2461 8.73486C10.9453 9.29346 10.9453 9.93799 11.2461 10.4536C11.5469 11.0122 12.1055 11.313 12.75 11.313ZM8.96875 9.59424C8.96875 8.26221 9.65625 7.01611 10.8594 6.32861C12.0195 5.68408 13.4375 5.68408 14.6406 6.32861C15.8008 7.01611 16.5312 8.26221 16.5312 9.59424C16.5312 10.9692 15.8008 12.2153 14.6406 12.9028C13.4375 13.5474 12.0195 13.5474 10.8594 12.9028C9.65625 12.2153 8.96875 10.9692 8.96875 9.59424Z",
    fill: "currentColor"
  }, null, -1)]))
}
const EB = We(xB, [
    ["render", SB]
  ]),
  TB = {},
  AB = {
    width: "25",
    height: "24",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function PB(e, t) {
  return g(), k("svg", AB, t[0] || (t[0] = [m("path", {
    d: "M8.9375 1.78174C8.9375 1.22314 9.36719 0.750488 9.96875 0.750488H14.7812C15.3398 0.750488 15.8125 1.22314 15.8125 1.78174C15.8125 2.3833 15.3398 2.81299 14.7812 2.81299H13.4062V4.96143C15.2539 5.17627 16.9297 5.94971 18.2617 7.15283L19.5508 5.86377C19.9375 5.47705 20.582 5.47705 20.9688 5.86377C21.3984 6.29346 21.3984 6.93799 20.9688 7.32471L19.6367 8.65674C20.668 10.1177 21.3125 11.9224 21.3125 13.813C21.3125 18.7544 17.2734 22.7505 12.375 22.7505C7.43359 22.7505 3.4375 18.7544 3.4375 13.813C3.4375 9.2583 6.875 5.47705 11.3438 4.96143V2.81299H9.96875C9.36719 2.81299 8.9375 2.3833 8.9375 1.78174ZM12.375 20.688C14.8242 20.688 17.0586 19.3989 18.3047 17.2505C19.5508 15.145 19.5508 12.5239 18.3047 10.3755C17.0586 8.27002 14.8242 6.93799 12.375 6.93799C9.88281 6.93799 7.64844 8.27002 6.40234 10.3755C5.15625 12.5239 5.15625 15.145 6.40234 17.2505C7.64844 19.3989 9.88281 20.688 12.375 20.688ZM13.4062 10.0317V14.5005C13.4062 15.1021 12.9336 15.5317 12.375 15.5317C11.7734 15.5317 11.3438 15.1021 11.3438 14.5005V10.0317C11.3438 9.47314 11.7734 9.00049 12.375 9.00049C12.9336 9.00049 13.4062 9.47314 13.4062 10.0317Z",
    fill: "currentColor"
  }, null, -1)]))
}
const IB = We(TB, [
    ["render", PB]
  ]),
  $B = {},
  MB = {
    width: "11",
    height: "11",
    viewBox: "0 0 11 11",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function OB(e, t) {
  return g(), k("svg", MB, t[0] || (t[0] = [m("path", {
    d: "M10.0195 2.29883L6.94336 5.375L10.0195 8.48047C10.4004 8.83203 10.4004 9.44727 10.0195 9.79883C9.66797 10.1797 9.05273 10.1797 8.70117 9.79883L5.625 6.72266L2.51953 9.79883C2.16797 10.1797 1.55273 10.1797 1.20117 9.79883C0.820312 9.44727 0.820312 8.83203 1.20117 8.48047L4.27734 5.375L1.20117 2.29883C0.820312 1.94727 0.820312 1.33203 1.20117 0.980469C1.55273 0.599609 2.16797 0.599609 2.51953 0.980469L5.625 4.05664L8.70117 0.980469C9.05273 0.599609 9.66797 0.599609 10.0195 0.980469C10.4004 1.33203 10.4004 1.94727 10.0195 2.29883Z",
    fill: "currentColor"
  }, null, -1)]))
}
const _y = We($B, [
    ["render", OB]
  ]),
  DB = {},
  LB = {
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function RB(e, t) {
  return g(), k("svg", LB, t[0] || (t[0] = [m("path", {
    d: "M5.9999 4.40005V5.60005H9.9999V4.40005C9.9999 3.30005 9.0999 2.40005 7.9999 2.40005C6.8749 2.40005 5.9999 3.30005 5.9999 4.40005ZM4.3999 5.60005V4.40005C4.3999 2.42505 5.9999 0.800049 7.9999 0.800049C9.9749 0.800049 11.5999 2.42505 11.5999 4.40005V5.60005H11.9999C12.8749 5.60005 13.5999 6.32505 13.5999 7.20005V12C13.5999 12.9 12.8749 13.6 11.9999 13.6H3.9999C3.0999 13.6 2.3999 12.9 2.3999 12V7.20005C2.3999 6.32505 3.0999 5.60005 3.9999 5.60005H4.3999Z",
    fill: "currentColor"
  }, null, -1)]))
}
const C9 = We(DB, [
    ["render", RB]
  ]),
  NB = {},
  FB = {
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    "stroke-width": "2",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  };

function BB(e, t) {
  return g(), k("svg", FB, t[0] || (t[0] = [m("path", {
    d: "M6 9l6 6l6 -6"
  }, null, -1)]))
}
const yg = We(NB, [
    ["render", BB]
  ]),
  jB = {},
  HB = {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function VB(e, t) {
  return g(), k("svg", HB, t[0] || (t[0] = [m("path", {
    d: "M13.5 2C14.3125 2 15 2.6875 14.9688 3.53125C14.9375 3.6875 14.9375 3.84375 14.9375 4H18.25C18.6562 4 19 4.34375 19 4.75C19 7.65625 17.9375 9.65625 16.5312 11.0312C15.1562 12.375 13.4688 13.0625 12.2188 13.4062C11.4688 13.5938 11 14.2188 11 14.8438C11 15.4688 11.5312 16 12.1562 16H13C13.5312 16 14 16.4688 14 17C14 17.5625 13.5312 18 13 18H7C6.4375 18 6 17.5625 6 17C6 16.4688 6.4375 16 7 16H7.8125C8.46875 16 9 15.4688 9 14.8438C9 14.2188 8.5 13.5938 7.75 13.4062C6.5 13.0625 4.8125 12.375 3.4375 11.0312C2.03125 9.65625 1 7.65625 1 4.75C1 4.34375 1.3125 4 1.75 4H5.03125C5.03125 3.84375 5.03125 3.6875 5 3.53125C4.96875 2.6875 5.65625 2 6.5 2H13.5ZM2.5 5.5H2.53125C2.6875 7.59375 3.5 9 4.5 9.96875C5.1875 10.6562 6 11.125 6.78125 11.4688C6.0625 10.2188 5.4375 8.34375 5.15625 5.5H2.5ZM15.5 9.96875C16.5 9 17.3125 7.59375 17.4688 5.5H14.8125C14.5312 8.34375 13.9062 10.2188 13.1875 11.4688C13.9688 11.125 14.7812 10.6562 15.5 9.96875Z",
    fill: "currentColor"
  }, null, -1)]))
}
const md = We(jB, [
    ["render", VB]
  ]),
  UB = {},
  zB = {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function YB(e, t) {
  return g(), k("svg", zB, t[0] || (t[0] = [m("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M6.29917 4.20462C6.33756 4.41248 6.33754 4.61558 6.33753 4.78888L6.33752 5.1001H2.10002C1.74885 5.1001 1.50002 5.37003 1.50002 5.7001C1.50002 9.10758 2.7055 11.43 4.33476 13.0231C5.93408 14.586 7.90425 15.3922 9.37633 15.7974C10.3874 16.0518 11.1 16.9059 11.1 17.8126C11.1 18.7334 10.323 19.5001 9.37502 19.5001H8.40002C7.89676 19.5001 7.50002 19.9222 7.50002 20.4001C7.50002 20.9094 7.89071 21.3001 8.40002 21.3001H15.6C16.078 21.3001 16.5 20.9034 16.5 20.4001C16.5 19.9283 16.0718 19.5001 15.6 19.5001H14.5875C13.6718 19.5001 12.9 18.7283 12.9 17.8126C12.9 16.9146 13.5661 16.0541 14.5862 15.7974C16.0583 15.3922 18.0285 14.586 19.6278 13.023C21.2591 11.428 22.5 9.10477 22.5 5.7001C22.5 5.37828 22.2218 5.1001 21.9 5.1001H17.625V4.78888C17.625 4.61557 17.625 4.41247 17.6634 4.20461C17.6819 3.37446 17.0004 2.7001 16.2 2.7001H7.80002C6.95836 2.7001 6.28079 3.37845 6.29917 4.20462ZM5.70023 4.2487C5.65619 3.05974 6.6241 2.1001 7.80002 2.1001H16.2C17.3426 2.1001 18.3062 3.06385 18.2623 4.2487L18.2614 4.27279L18.2567 4.29643C18.2434 4.36273 18.2357 4.42981 18.2312 4.5001H21.9C22.5532 4.5001 23.1 5.04691 23.1 5.7001C23.1 9.27038 21.791 11.7471 20.0473 13.4521C18.3478 15.113 16.2696 15.9568 14.7421 16.3769L14.7353 16.3787C13.9575 16.5732 13.5 17.2117 13.5 17.8126C13.5 18.3969 14.0032 18.9001 14.5875 18.9001H15.6C16.4032 18.9001 17.1 19.5969 17.1 20.4001C17.1 21.2468 16.3971 21.9001 15.6 21.9001H8.40002C7.55934 21.9001 6.90002 21.2408 6.90002 20.4001C6.90002 19.603 7.55329 18.9001 8.40002 18.9001H9.37502C10.0021 18.9001 10.5 18.3917 10.5 17.8126C10.5 17.2204 10.0143 16.5754 9.22726 16.3786L9.22046 16.3769C7.6929 15.9569 5.61484 15.113 3.91534 13.4522C2.16961 11.7452 0.900024 9.26761 0.900024 5.7001C0.900024 5.05517 1.4012 4.5001 2.10002 4.5001H5.73131C5.72682 4.42981 5.71911 4.36273 5.70585 4.29643L5.70112 4.27279L5.70023 4.2487ZM3.00002 6.6029L2.73836 6.62242C2.93137 9.20883 3.93889 10.9641 5.18956 12.1764C6.04921 13.0355 7.05924 13.6159 8.0167 14.0372L8.85308 14.4052L8.3976 13.6131C7.56211 12.16 6.82072 9.95426 6.48607 6.57057L6.45932 6.3001H3.00002V6.6029ZM3.36563 6.9001H5.91684C6.21064 9.64216 6.77457 11.6366 7.45532 13.0969C6.80669 12.7466 6.17194 12.3102 5.61216 11.7505L5.60876 11.7471C4.51162 10.6843 3.60328 9.15909 3.36563 6.9001ZM17.5032 6.3001H21.2857L21.2617 6.62242C21.0686 9.21002 20.0602 10.9657 18.8088 12.1781L18.8074 12.1794C17.9124 13.0355 16.9047 13.6153 15.9458 14.0372L15.1095 14.4052L15.565 13.6131C16.4004 12.16 17.1418 9.95426 17.4765 6.57057L17.5032 6.3001ZM18.0457 6.9001C17.7519 9.64258 17.1878 11.6373 16.5069 13.0975C17.1588 12.7468 17.8035 12.3092 18.3919 11.7465C19.4888 10.6837 20.3968 9.15866 20.6344 6.9001H18.0457Z",
    fill: "currentColor"
  }, null, -1)]))
}
const WB = We(UB, [
    ["render", YB]
  ]),
  GB = {},
  QB = {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function qB(e, t) {
  return g(), k("svg", QB, t[0] || (t[0] = [m("path", {
    d: "M12.0187 2.3999C18.3562 2.3999 21.2812 6.7124 21.5812 10.1999C21.6187 10.5374 21.3187 10.7999 21.0187 10.7999H19.6312L15.2812 15.1874C15.4687 15.4499 15.6187 15.8249 15.6187 16.1999V19.7999C15.6187 20.8124 14.7937 21.5999 13.8187 21.5999H10.2187C9.20621 21.5999 8.41871 20.8124 8.41871 19.7999V16.1999C8.41871 15.8249 8.53121 15.4499 8.71871 15.1874L4.36871 10.7999H3.01871C2.68121 10.7999 2.38121 10.5374 2.41871 10.1999C2.71871 6.7124 5.64371 2.3999 12.0187 2.3999ZM18.7687 10.7999H17.3812H16.7812H12.3187V14.3999H13.8187C14.1937 14.3999 14.5687 14.5499 14.8312 14.7374L18.7687 10.7999ZM11.7187 10.7999H7.21871H6.61871H5.23121L9.16871 14.7374C9.46871 14.5499 9.80621 14.3999 10.2187 14.3999H11.7187V10.7999ZM9.54371 3.2624C5.26871 4.1999 3.28121 7.4624 3.01871 10.1999H6.61871C6.61871 7.1999 7.81871 4.5374 9.54371 3.2624ZM8.68121 5.0249C7.78121 6.3374 7.21871 8.1749 7.21871 10.1999H16.8187C16.8187 8.1749 16.2187 6.3374 15.3187 5.0249C14.4187 3.7499 13.2562 2.9999 12.0187 2.9999C10.7437 2.9999 9.58121 3.7499 8.68121 5.0249ZM20.9812 10.1999C20.7187 7.4624 18.7312 4.1999 14.4562 3.2624C16.2187 4.5374 17.4187 7.1999 17.4187 10.1999H20.9812ZM13.8187 14.9999H10.2187C9.54371 14.9999 9.01871 15.5624 9.01871 16.1999V19.7999C9.01871 20.4749 9.54371 20.9999 10.2187 20.9999H13.8187C14.4562 20.9999 15.0187 20.4749 15.0187 19.7999V16.1999C15.0187 15.5624 14.4562 14.9999 13.8187 14.9999Z",
    fill: "currentColor"
  }, null, -1)]))
}
const KB = We(GB, [
    ["render", qB]
  ]),
  ZB = {},
  JB = {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function XB(e, t) {
  return g(), k("svg", JB, t[0] || (t[0] = [m("path", {
    d: "M13.9834 8H10.5147V12H11.5147C11.7334 12 11.9209 12.0625 12.1084 12.1562L15.8584 8H14.9834C14.9834 7.84375 15.0147 7.6875 15.0147 7.5C15.0147 5.53125 14.2959 3.71875 13.2022 2.53125C16.0772 3.5625 17.4209 5.84375 17.8584 7.4375C17.9522 7.75 17.7334 8 17.4209 8H17.2334L12.8272 12.8438C12.9522 13.0312 13.0147 13.2812 13.0147 13.5V16.5C13.0147 17.3438 12.3272 18 11.5147 18H8.51468C7.67093 18 7.01468 17.3438 7.01468 16.5V13.5C7.01468 13.2812 7.04593 13.0312 7.17093 12.8438L2.76468 8H2.57718C2.29593 8 2.04593 7.75 2.13968 7.4375C2.57718 5.84375 3.95218 3.5625 6.79593 2.53125C5.70218 3.71875 5.01468 5.5 5.01468 7.5C5.01468 7.6875 5.01468 7.84375 5.01468 8H4.13968L7.88968 12.1562C8.07718 12.0625 8.29593 12 8.51468 12H9.51468V8H6.01468C6.01468 7.84375 6.01468 7.6875 6.01468 7.5C6.01468 5.90625 6.48343 4.5 7.26468 3.53125C8.01468 2.53125 8.98343 2 10.0147 2C11.0147 2 11.9834 2.53125 12.7334 3.53125C13.5147 4.5 14.0147 5.90625 14.0147 7.5C14.0147 7.6875 13.9834 7.84375 13.9834 8Z",
    fill: "currentColor"
  }, null, -1)]))
}
const Gp = We(ZB, [
    ["render", XB]
  ]),
  ej = {},
  tj = {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function nj(e, t) {
  return g(), k("svg", tj, t[0] || (t[0] = [m("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M10.6095 0.953909C11.3848 0.203841 12.6153 0.20384 13.3907 0.953909L15.0634 2.5721L17.3678 2.24616C18.4359 2.09507 19.4314 2.81834 19.6178 3.88089L20.0199 6.17324L22.0758 7.26404C23.0288 7.76965 23.409 8.93992 22.9353 9.9091L21.9132 12L22.9353 14.0909C23.409 15.0601 23.0288 16.2304 22.0758 16.736L20.0199 17.8268L19.6178 20.1191C19.4314 21.1817 18.4359 21.9049 17.3678 21.7539L15.0634 21.4279L13.3907 23.0461C12.6153 23.7962 11.3848 23.7962 10.6095 23.0461L8.93677 21.4279L6.63236 21.7539C5.56421 21.9049 4.56872 21.1817 4.38233 20.1191L3.98022 17.8268L1.92433 16.736C0.971382 16.2304 0.591138 15.0601 1.0649 14.0909L2.08699 12L1.0649 9.9091C0.591138 8.93992 0.971381 7.76965 1.92433 7.26404L3.98022 6.17324L4.38233 3.88089C4.56872 2.81834 5.56421 2.09507 6.63236 2.24616L8.93677 2.5721L10.6095 0.953909ZM13.6728 4.00955L12.0001 2.39136L10.3274 4.00955C9.88398 4.43847 9.26748 4.63879 8.65667 4.55239L6.35226 4.22645L5.95015 6.51879C5.84356 7.12641 5.46254 7.65083 4.9176 7.93997L2.86171 9.03077L3.88381 11.1217C4.15472 11.6759 4.15472 12.3241 3.88381 12.8783L2.86171 14.9692L4.9176 16.06C5.46254 16.3492 5.84356 16.8736 5.95015 17.4812L6.35226 19.7736L8.65667 19.4476C9.26748 19.3612 9.88398 19.5615 10.3274 19.9905L12.0001 21.6087L13.6728 19.9905C14.1162 19.5615 14.7327 19.3612 15.3435 19.4476L17.6479 19.7736L18.05 17.4812C18.1566 16.8736 18.5376 16.3492 19.0826 16.06L21.1384 14.9692L20.1164 12.8783C19.8454 12.3241 19.8454 11.6759 20.1163 11.1217L21.1384 9.03077L19.0826 7.93997C18.5376 7.65083 18.1566 7.12641 18.05 6.51879L17.6479 4.22645L15.3435 4.55239C14.7327 4.63879 14.1162 4.43847 13.6728 4.00955Z",
    fill: "currentColor"
  }, null, -1), m("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M12.167 16.0002C12.9075 16.0002 13.4827 15.835 13.9104 15.5135C13.9395 15.4917 13.9679 15.4691 13.9956 15.4458C14.0104 15.4333 14.0251 15.4206 14.0395 15.4078C14.4782 15.0046 14.7033 14.4238 14.7033 13.6654C14.7033 13.6615 14.7033 13.6575 14.7033 13.6536C14.7027 13.5131 14.6917 13.3795 14.6706 13.2522C14.6249 12.976 14.5319 12.7291 14.3952 12.504C14.3001 12.3475 14.1813 12.2173 14.0375 12.1135C14.0084 12.0925 13.9784 12.0727 13.9473 12.0538C13.9414 12.0503 13.9354 12.0467 13.9294 12.0432C13.7924 11.9631 13.6358 11.9034 13.4587 11.8641C13.7031 11.7544 13.8995 11.615 14.0565 11.4371C14.1204 11.3647 14.1778 11.2859 14.2292 11.2C14.3742 10.9414 14.4558 10.6463 14.4742 10.3231C14.4745 10.3178 14.4748 10.3125 14.475 10.3071C14.4771 10.2656 14.4782 10.2235 14.4782 10.181C14.4782 9.45809 14.2412 8.91277 13.7787 8.54527C13.726 8.5034 13.671 8.46399 13.6137 8.42703C13.6134 8.42687 13.6139 8.42719 13.6137 8.42703C13.1683 8.14011 12.5817 8.0002 11.847 8.0002H9.5002V16.0002H12.167ZM10.9463 14.7438H12.0483C12.0891 14.7438 12.1287 14.7424 12.167 14.7395C12.4111 14.7214 12.6041 14.646 12.7463 14.5191C12.7633 14.5039 12.7796 14.488 12.7951 14.4713C12.8553 14.3972 12.9047 14.3122 12.9425 14.2142C12.9458 14.2057 12.949 14.197 12.9521 14.1882C13.0038 14.0435 13.0313 13.8713 13.0323 13.6654C13.0323 13.6615 13.0323 13.6575 13.0323 13.6536C13.0323 13.6399 13.0322 13.6262 13.032 13.6128C13.032 13.6096 13.0319 13.6065 13.0319 13.6033C13.0303 13.5112 13.0244 13.4242 13.0144 13.3425C13.0143 13.3425 13.0144 13.3426 13.0144 13.3425C12.9967 13.199 12.9661 13.0718 12.9237 12.9619C12.8972 12.8933 12.8661 12.8314 12.8306 12.7765C12.8051 12.7383 12.777 12.7039 12.7463 12.6732C12.6051 12.5322 12.408 12.4683 12.1552 12.4683H10.9463V14.7438ZM11.8113 11.3781C11.9372 11.3734 12.052 11.3558 12.1552 11.3255C12.3143 11.2787 12.4456 11.2014 12.5463 11.0936C12.6385 10.9948 12.705 10.874 12.746 10.7272C12.7461 10.7268 12.7462 10.7265 12.7463 10.7262C12.7736 10.6279 12.7895 10.518 12.7939 10.3953C12.794 10.3915 12.7941 10.3878 12.7942 10.3839C12.7947 10.3698 12.7949 10.3555 12.7951 10.3411C12.7951 10.3351 12.7951 10.3291 12.7951 10.3231C12.7951 10.2741 12.7936 10.2267 12.7907 10.181C12.7838 10.0767 12.7692 9.98126 12.7463 9.8946C12.743 9.88211 12.7395 9.86981 12.7359 9.85769C12.7359 9.85762 12.7359 9.85776 12.7359 9.85769C12.693 9.71492 12.6263 9.59731 12.5343 9.50519C12.3749 9.34585 12.1487 9.26284 11.847 9.24744C11.8124 9.24567 11.7768 9.24479 11.7402 9.24479H10.9463V11.3781H11.8113ZM15.9949 11.6741C16.3382 12.2808 16.5033 12.9514 16.5033 13.6654C16.5033 14.7941 16.1551 15.9081 15.2576 16.733L15.2374 16.7513C14.3709 17.5239 13.2743 17.8002 12.167 17.8002H9.5002C8.50608 17.8002 7.7002 16.9943 7.7002 16.0002V8.0002C7.7002 7.00608 8.50608 6.2002 9.5002 6.2002H11.847C12.9127 6.2002 14.0061 6.42684 14.8985 7.13598M15.9949 11.6741C16.1917 11.1908 16.2782 10.683 16.2782 10.181C16.2782 9.03221 15.8785 7.91475 14.8985 7.13598",
    fill: "currentColor"
  }, null, -1)]))
}
const rj = We(ej, [
    ["render", nj]
  ]),
  sj = {},
  aj = {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function oj(e, t) {
  return g(), k("svg", aj, t[0] || (t[0] = [m("path", {
    d: "M13.4533 11.8911C13.5616 11.8911 13.6543 11.8911 13.7465 11.8911C15.4482 11.8911 17.1499 11.8944 18.852 11.8892C19.3838 11.8878 19.8582 12.0233 20.2487 12.3984C21.117 13.2327 20.8906 14.677 19.8083 15.2121C19.7245 15.2535 19.6374 15.2883 19.5353 15.3335C19.7847 15.8262 19.8431 16.3316 19.6327 16.8512C19.4261 17.3618 19.0483 17.6921 18.5122 17.8869C18.7513 18.3759 18.8163 18.8757 18.62 19.3858C18.4266 19.8884 18.0595 20.2235 17.5513 20.4296C17.8049 20.9054 17.8652 21.3887 17.6962 21.8913C17.4543 22.6108 16.7927 23.1176 16.0515 23.1148C14.4129 23.1082 12.7733 23.1172 11.1361 23.0588C10.2702 23.0278 9.40854 22.8682 8.54499 22.7666C7.55533 22.6503 6.56472 22.5463 5.56705 22.6437C5.47575 22.6527 5.36422 22.7162 5.30822 22.7896C4.91057 23.3115 4.39197 23.5863 3.73501 23.5878C2.68417 23.5901 1.63333 23.5892 0.582482 23.5878C0.164121 23.5878 0.000352948 23.4226 0.000352948 23.0014C-0.000117649 19.1585 -0.000117649 15.3161 0.000352948 11.4732C0.000352948 11.052 0.165533 10.883 0.579188 10.8826C1.63003 10.8812 2.68088 10.8797 3.73172 10.8826C4.39762 10.8845 4.9308 11.1569 5.31152 11.7042C5.39105 11.8186 5.46446 11.8496 5.59905 11.8318C6.45695 11.7174 7.27155 11.4859 7.98074 10.9682C8.85135 10.3324 9.22406 9.44254 9.25842 8.39123C9.27112 8.00722 9.25842 7.62274 9.26595 7.23873C9.28524 6.2293 9.96949 5.44105 10.9742 5.26316C11.898 5.0994 12.8185 5.64811 13.1841 6.55778C13.8496 8.21428 13.9667 9.89996 13.4914 11.6238C13.4769 11.6765 13.4646 11.7301 13.4538 11.7838C13.4496 11.8064 13.4529 11.8304 13.4529 11.8906L13.4533 11.8911ZM5.65882 21.6037C6.71154 21.6856 7.73509 21.7534 8.75582 21.8489C9.58219 21.9261 10.4039 22.0927 11.2312 22.1214C12.8293 22.1764 14.4298 22.1623 16.0294 22.175C16.099 22.1755 16.1706 22.1651 16.2374 22.1463C16.6346 22.0353 16.8929 21.6418 16.8454 21.2268C16.8002 20.8334 16.491 20.5548 16.0604 20.5213C15.7282 20.4955 15.5291 20.3143 15.532 20.0409C15.5348 19.7538 15.7423 19.5825 16.0938 19.5802C16.3682 19.5783 16.6449 19.6004 16.9164 19.5726C17.1042 19.5533 17.3066 19.502 17.4642 19.4041C17.7551 19.2234 17.8576 18.855 17.7569 18.5317C17.6492 18.1862 17.3626 17.9665 16.9828 17.9552C16.6459 17.9453 16.308 17.9589 15.9715 17.9453C15.7202 17.9354 15.5451 17.7467 15.5329 17.5081C15.5211 17.2738 15.6844 17.0686 15.9263 17.0248C16.0026 17.0107 16.0826 17.013 16.1607 17.013C16.788 17.0112 17.4158 17.0201 18.0426 17.006C18.4882 16.9961 18.8261 16.629 18.8205 16.1956C18.8148 15.7617 18.469 15.4154 18.0238 15.3989C17.9296 15.3956 17.8355 15.397 17.7414 15.397C17.1767 15.397 16.612 15.4003 16.0473 15.3956C15.7432 15.3932 15.5357 15.1989 15.5324 14.9306C15.5291 14.6596 15.7334 14.4666 16.0364 14.4572C16.1226 14.4544 16.2091 14.4563 16.2953 14.4563C17.2049 14.4563 18.1146 14.4605 19.0247 14.4539C19.4793 14.4506 19.82 14.1179 19.844 13.6784C19.8666 13.268 19.5429 12.9005 19.1066 12.8468C18.9979 12.8337 18.8878 12.8337 18.7781 12.8332C16.8722 12.8323 14.9668 12.8327 13.0608 12.8327C12.9747 12.8327 12.8881 12.8355 12.802 12.8285C12.4674 12.8012 12.2844 12.5518 12.3615 12.2252C12.4029 12.0501 12.45 11.876 12.5008 11.7033C12.9705 10.1113 12.9757 8.53476 12.3314 6.98461C12.2552 6.80108 12.1545 6.60813 12.0133 6.47401C11.6843 6.16201 11.2829 6.08436 10.8603 6.26977C10.442 6.45331 10.2217 6.78461 10.2062 7.24532C10.186 7.84016 10.2208 8.44346 10.1351 9.02889C9.88808 10.7193 8.87488 11.8049 7.30356 12.3819C6.77884 12.5744 6.22165 12.6774 5.65929 12.8266V21.6047L5.65882 21.6037ZM0.952842 22.647C1.87804 22.647 2.78629 22.6484 3.69454 22.647C4.31573 22.6456 4.70586 22.2555 4.70586 21.6315C4.70727 18.6983 4.70727 15.7655 4.70586 12.8323C4.70586 12.2214 4.31526 11.8271 3.71007 11.8247C2.84747 11.8214 1.98486 11.8238 1.12226 11.8238C1.06955 11.8238 1.01684 11.8238 0.953313 11.8238V22.6475L0.952842 22.647Z",
    fill: "currentColor"
  }, null, -1), m("path", {
    d: "M19.2921 9.41149C16.6901 9.40914 14.5837 7.29474 14.5899 4.69093C14.5955 2.09135 16.7118 -0.00610442 19.3227 1.33491e-05C21.9039 0.00566052 24.007 2.12853 24.0013 4.72105C23.9952 7.31027 21.8832 9.41385 19.2921 9.41149ZM21.1773 4.72199C21.1843 3.68197 20.3424 2.8283 19.3062 2.82407C18.2756 2.81983 17.4257 3.65232 17.4144 4.67728C17.4026 5.71918 18.2384 6.57802 19.2737 6.58744C20.3133 6.59732 21.1707 5.75683 21.1778 4.72199H21.1773ZM16.461 5.18741H15.5673C15.6539 5.86507 15.9019 6.45755 16.2953 6.97003C16.5259 6.74462 16.7457 6.52908 16.941 6.33849C16.7847 5.96437 16.6294 5.59165 16.4605 5.18741H16.461ZM18.8168 0.976033C18.1297 1.06968 17.5377 1.31345 17.0064 1.72758C17.2393 1.95817 17.4544 2.17135 17.644 2.35865C18.0398 2.19441 18.4243 2.03535 18.8168 1.87252V0.975562V0.976033ZM20.918 2.34971C21.1293 2.153 21.3509 1.94688 21.5876 1.72616C21.0483 1.31204 20.4563 1.06403 19.7801 0.978386V1.87299C20.1801 2.04052 20.5523 2.19676 20.918 2.34971ZM16.3146 2.41183C15.9042 2.96713 15.644 3.55114 15.5734 4.22221H16.4614C16.6322 3.81656 16.7913 3.43867 16.9419 3.08054C16.7457 2.8716 16.5391 2.65089 16.3146 2.41183ZM23.0244 4.22786C22.9345 3.54361 22.6884 2.9516 22.3053 2.45512C22.0705 2.67771 21.8479 2.88901 21.6526 3.0749C21.8112 3.4589 21.9669 3.83727 22.1288 4.22833H23.0248L23.0244 4.22786ZM21.6498 6.33237C21.8521 6.53755 22.0644 6.75262 22.2884 6.97944C22.6893 6.45802 22.9368 5.86554 23.0234 5.19023H22.1288C21.9608 5.59118 21.8046 5.96342 21.6502 6.33237H21.6498ZM16.9988 7.68016C17.5466 8.09853 18.1377 8.34794 18.8149 8.43265V7.5371C18.4139 7.37004 18.0295 7.20957 17.636 7.04533C17.4431 7.23733 17.2332 7.44628 16.9988 7.67969V7.68016ZM20.9472 7.05286C20.5542 7.21521 20.1749 7.37239 19.7763 7.53757V8.43547C20.4568 8.34418 21.0521 8.09994 21.5674 7.69946C21.3396 7.46181 21.1302 7.24345 20.9476 7.05286H20.9472Z",
    fill: "currentColor"
  }, null, -1)]))
}
const x9 = We(sj, [
    ["render", oj]
  ]),
  ij = {},
  lj = {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };

function uj(e, t) {
  return g(), k("svg", lj, t[0] || (t[0] = [m("path", {
    d: "M12.0288 0C7.70708 0 3.78872 2.30769 1.59904 6C-0.533013 9.75 -0.533013 14.3077 1.59904 18C3.78872 21.75 7.70708 24 12.0288 24C16.2929 24 20.2113 21.75 22.401 18C24.533 14.3077 24.533 9.75 22.401 6C20.2113 2.30769 16.2929 0 12.0288 0ZM18.5402 9.28846L11.1645 16.6731C10.5882 17.25 9.72389 17.25 9.20528 16.6731L5.51741 12.9808C4.94118 12.4615 4.94118 11.5962 5.51741 11.0769C6.03601 10.5 6.90036 10.5 7.47659 11.0769L10.1849 13.7885L16.581 7.38462C17.0996 6.80769 17.964 6.80769 18.5402 7.38462C19.0588 7.90385 19.0588 8.76923 18.5402 9.28846Z",
    fill: "currentColor"
  }, null, -1)]))
}
const Qp = We(ij, [
    ["render", uj]
  ]),
  cj = {
    class: "display-theme-block-none"
  },
  dj = te({
    __name: "NavLink",
    props: {
      path: String,
      isActivePath: Boolean,
      isLG: Boolean,
      title: String
    },
    setup(e) {
      return (t, n) => {
        const r = w5("router-link");
        return g(), G(r, {
          to: e.path,
          class: we(["relative flex max-h-20 w-full flex-1 flex-col items-center justify-center gap-0.5 whitespace-nowrap px-3 py-1.5 text-11 text-white md:gap-1.5 md:text-13", {
            "md:bg-theme-navigation  text-yellow  md:rounded-lg": e.isActivePath
          }])
        }, {
          default: V(() => [ie(t.$slots, "default"), m("span", cj, R(e.title), 1)]),
          _: 3
        }, 8, ["to", "class"])
      }
    }
  }),
  fj = {
    class: "relative"
  },
  bg = te({
    __name: "Navigation",
    props: {
      isActivePath: {},
      variant: {},
      class: {}
    },
    setup(e) {
      const {
        t
      } = Fe(), {
        isDropsTabVisible: n,
        isChallengesTabVisible: r,
        isGameListTabVisible: s,
        isProfileTabVisible: a
      } = $b(), o = e, i = L(() => n.value ? {
        path: "/lobby/drop",
        icon: Gp,
        iconOutline: KB,
        title: t("drop.title")
      } : null), l = L(() => r.value ? {
        path: "/lobby/challenge",
        icon: md,
        iconOutline: WB,
        title: t("challenge.title")
      } : null), c = L(() => s.value ? {
        path: "/lobby/games",
        icon: vg,
        iconOutline: OF,
        title: t("games.title")
      } : null), d = L(() => a.value ? {
        path: "/lobby/profile",
        icon: _g,
        iconOutline: NF,
        title: t("profile.title")
      } : null), f = L(() => [i.value, l.value, c.value, d.value].filter(p => p !== null));
      return (p, h) => (g(), k("div", {
        class: we(u(rn)(u(pj)({
          variant: p.variant
        }), o.class))
      }, [ie(p.$slots, "default"), (g(!0), k(Ee, null, Je(f.value, _ => (g(), G(dj, {
        key: _.path,
        path: _.path,
        isActivePath: _.path === p.isActivePath,
        title: _.title
      }, {
        default: V(() => [m("div", fj, [(g(), G(Kr(p.variant === "left" ? _.iconOutline : _.icon), {
          class: "size-8"
        }))])]),
        _: 2
      }, 1032, ["path", "isActivePath", "title"]))), 128))], 2))
    }
  }),
  pj = _u("flex items-center z-[56] bg-theme-gray-gray_dark", {
    variants: {
      variant: {
        bottom: 'absolute bottom-0  left-0 h-16 w-full justify-center border-t border-white-10 before:flex-1 before:grow-[0.5] before:content-[""] after:flex-1 after:grow-[0.5] after:content-[""]',
        left: "flex-col w-24 h-full border-r border-white-10 p-1",
        right: "flex-col w-20 h-full border-l border-white-10"
      }
    },
    defaultVariants: {
      variant: "bottom"
    }
  });

function wg(e, t) {
  const n = r => {
    r.composedPath().some(o => (o == null ? void 0 : o.id) === e) && t()
  };
  Ge(() => {
    document.addEventListener("click", n)
  }), en(() => {
    document.removeEventListener("click", n)
  })
}
var wt;
(function(e) {
  e.assertEqual = s => {};

  function t(s) {}
  e.assertIs = t;

  function n(s) {
    throw new Error
  }
  e.assertNever = n, e.arrayToEnum = s => {
    const a = {};
    for (const o of s) a[o] = o;
    return a
  }, e.getValidEnumValues = s => {
    const a = e.objectKeys(s).filter(i => typeof s[s[i]] != "number"),
      o = {};
    for (const i of a) o[i] = s[i];
    return e.objectValues(o)
  }, e.objectValues = s => e.objectKeys(s).map(function(a) {
    return s[a]
  }), e.objectKeys = typeof Object.keys == "function" ? s => Object.keys(s) : s => {
    const a = [];
    for (const o in s) Object.prototype.hasOwnProperty.call(s, o) && a.push(o);
    return a
  }, e.find = (s, a) => {
    for (const o of s)
      if (a(o)) return o
  }, e.isInteger = typeof Number.isInteger == "function" ? s => Number.isInteger(s) : s => typeof s == "number" && Number.isFinite(s) && Math.floor(s) === s;

  function r(s, a = " | ") {
    return s.map(o => typeof o == "string" ? `'${o}'` : o).join(a)
  }
  e.joinValues = r, e.jsonStringifyReplacer = (s, a) => typeof a == "bigint" ? a.toString() : a
})(wt || (wt = {}));
var yy;
(function(e) {
  e.mergeShapes = (t, n) => ({
    ...t,
    ...n
  })
})(yy || (yy = {}));
const Be = wt.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]),
  mo = e => {
    switch (typeof e) {
      case "undefined":
        return Be.undefined;
      case "string":
        return Be.string;
      case "number":
        return Number.isNaN(e) ? Be.nan : Be.number;
      case "boolean":
        return Be.boolean;
      case "function":
        return Be.function;
      case "bigint":
        return Be.bigint;
      case "symbol":
        return Be.symbol;
      case "object":
        return Array.isArray(e) ? Be.array : e === null ? Be.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? Be.promise : typeof Map < "u" && e instanceof Map ? Be.map : typeof Set < "u" && e instanceof Set ? Be.set : typeof Date < "u" && e instanceof Date ? Be.date : Be.object;
      default:
        return Be.unknown
    }
  },
  Pe = wt.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]);
class Ua extends Error {
  get errors() {
    return this.issues
  }
  constructor(t) {
    super(), this.issues = [], this.addIssue = r => {
      this.issues = [...this.issues, r]
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r]
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = t
  }
  format(t) {
    const n = t || function(a) {
        return a.message
      },
      r = {
        _errors: []
      },
      s = a => {
        for (const o of a.issues)
          if (o.code === "invalid_union") o.unionErrors.map(s);
          else if (o.code === "invalid_return_type") s(o.returnTypeError);
        else if (o.code === "invalid_arguments") s(o.argumentsError);
        else if (o.path.length === 0) r._errors.push(n(o));
        else {
          let i = r,
            l = 0;
          for (; l < o.path.length;) {
            const c = o.path[l];
            l === o.path.length - 1 ? (i[c] = i[c] || {
              _errors: []
            }, i[c]._errors.push(n(o))) : i[c] = i[c] || {
              _errors: []
            }, i = i[c], l++
          }
        }
      };
    return s(this), r
  }
  static assert(t) {
    if (!(t instanceof Ua)) throw new Error(`Not a ZodError: ${t}`)
  }
  toString() {
    return this.message
  }
  get message() {
    return JSON.stringify(this.issues, wt.jsonStringifyReplacer, 2)
  }
  get isEmpty() {
    return this.issues.length === 0
  }
  flatten(t = n => n.message) {
    const n = {},
      r = [];
    for (const s of this.issues) s.path.length > 0 ? (n[s.path[0]] = n[s.path[0]] || [], n[s.path[0]].push(t(s))) : r.push(t(s));
    return {
      formErrors: r,
      fieldErrors: n
    }
  }
  get formErrors() {
    return this.flatten()
  }
}
Ua.create = e => new Ua(e);
const Lm = (e, t) => {
  let n;
  switch (e.code) {
    case Pe.invalid_type:
      e.received === Be.undefined ? n = "Required" : n = `Expected ${e.expected}, received ${e.received}`;
      break;
    case Pe.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(e.expected,wt.jsonStringifyReplacer)}`;
      break;
    case Pe.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${wt.joinValues(e.keys,", ")}`;
      break;
    case Pe.invalid_union:
      n = "Invalid input";
      break;
    case Pe.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${wt.joinValues(e.options)}`;
      break;
    case Pe.invalid_enum_value:
      n = `Invalid enum value. Expected ${wt.joinValues(e.options)}, received '${e.received}'`;
      break;
    case Pe.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case Pe.invalid_return_type:
      n = "Invalid function return type";
      break;
    case Pe.invalid_date:
      n = "Invalid date";
      break;
    case Pe.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (n = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? n = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? n = `Invalid input: must end with "${e.validation.endsWith}"` : wt.assertNever(e.validation) : e.validation !== "regex" ? n = `Invalid ${e.validation}` : n = "Invalid";
      break;
    case Pe.too_small:
      e.type === "array" ? n = `Array must contain ${e.exact?"exactly":e.inclusive?"at least":"more than"} ${e.minimum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact?"exactly":e.inclusive?"at least":"over"} ${e.minimum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact?"exactly equal to ":e.inclusive?"greater than or equal to ":"greater than "}${e.minimum}` : e.type === "date" ? n = `Date must be ${e.exact?"exactly equal to ":e.inclusive?"greater than or equal to ":"greater than "}${new Date(Number(e.minimum))}` : n = "Invalid input";
      break;
    case Pe.too_big:
      e.type === "array" ? n = `Array must contain ${e.exact?"exactly":e.inclusive?"at most":"less than"} ${e.maximum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact?"exactly":e.inclusive?"at most":"under"} ${e.maximum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact?"exactly":e.inclusive?"less than or equal to":"less than"} ${e.maximum}` : e.type === "bigint" ? n = `BigInt must be ${e.exact?"exactly":e.inclusive?"less than or equal to":"less than"} ${e.maximum}` : e.type === "date" ? n = `Date must be ${e.exact?"exactly":e.inclusive?"smaller than or equal to":"smaller than"} ${new Date(Number(e.maximum))}` : n = "Invalid input";
      break;
    case Pe.custom:
      n = "Invalid input";
      break;
    case Pe.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case Pe.not_multiple_of:
      n = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case Pe.not_finite:
      n = "Number must be finite";
      break;
    default:
      n = t.defaultError, wt.assertNever(e)
  }
  return {
    message: n
  }
};
let hj = Lm;

function mj() {
  return hj
}
const gj = e => {
  const {
    data: t,
    path: n,
    errorMaps: r,
    issueData: s
  } = e, a = [...n, ...s.path || []], o = {
    ...s,
    path: a
  };
  if (s.message !== void 0) return {
    ...s,
    path: a,
    message: s.message
  };
  let i = "";
  const l = r.filter(c => !!c).slice().reverse();
  for (const c of l) i = c(o, {
    data: t,
    defaultError: i
  }).message;
  return {
    ...s,
    path: a,
    message: i
  }
};

function Oe(e, t) {
  const n = mj(),
    r = gj({
      issueData: t,
      data: e.data,
      path: e.path,
      errorMaps: [e.common.contextualErrorMap, e.schemaErrorMap, n, n === Lm ? void 0 : Lm].filter(s => !!s)
    });
  e.common.issues.push(r)
}
class jr {
  constructor() {
    this.value = "valid"
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty")
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted")
  }
  static mergeArray(t, n) {
    const r = [];
    for (const s of n) {
      if (s.status === "aborted") return ot;
      s.status === "dirty" && t.dirty(), r.push(s.value)
    }
    return {
      status: t.value,
      value: r
    }
  }
  static async mergeObjectAsync(t, n) {
    const r = [];
    for (const s of n) {
      const a = await s.key,
        o = await s.value;
      r.push({
        key: a,
        value: o
      })
    }
    return jr.mergeObjectSync(t, r)
  }
  static mergeObjectSync(t, n) {
    const r = {};
    for (const s of n) {
      const {
        key: a,
        value: o
      } = s;
      if (a.status === "aborted" || o.status === "aborted") return ot;
      a.status === "dirty" && t.dirty(), o.status === "dirty" && t.dirty(), a.value !== "__proto__" && (typeof o.value < "u" || s.alwaysSet) && (r[a.value] = o.value)
    }
    return {
      status: t.value,
      value: r
    }
  }
}
const ot = Object.freeze({
    status: "aborted"
  }),
  Ku = e => ({
    status: "dirty",
    value: e
  }),
  rs = e => ({
    status: "valid",
    value: e
  }),
  by = e => e.status === "aborted",
  wy = e => e.status === "dirty",
  nu = e => e.status === "valid",
  Zf = e => typeof Promise < "u" && e instanceof Promise;
var je;
(function(e) {
  e.errToObj = t => typeof t == "string" ? {
    message: t
  } : t || {}, e.toString = t => typeof t == "string" ? t : t == null ? void 0 : t.message
})(je || (je = {}));
var Jf = function(e, t, n, r) {
    if (n === "a" && !r) throw new TypeError("Private accessor was defined without a getter");
    if (typeof t == "function" ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return n === "m" ? r : n === "a" ? r.call(e) : r ? r.value : t.get(e)
  },
  k9 = function(e, t, n, r, s) {
    if (r === "m") throw new TypeError("Private method is not writable");
    if (r === "a" && !s) throw new TypeError("Private accessor was defined without a setter");
    if (typeof t == "function" ? e !== t || !s : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return r === "a" ? s.call(e, n) : s ? s.value = n : t.set(e, n), n
  },
  Zu, Ju;
class Ho {
  constructor(t, n, r, s) {
    this._cachedPath = [], this.parent = t, this.data = n, this._path = r, this._key = s
  }
  get path() {
    return this._cachedPath.length || (Array.isArray(this._key) ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath
  }
}
const Cy = (e, t) => {
  if (nu(t)) return {
    success: !0,
    data: t.value
  };
  if (!e.common.issues.length) throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error) return this._error;
      const n = new Ua(e.common.issues);
      return this._error = n, this._error
    }
  }
};

function pt(e) {
  if (!e) return {};
  const {
    errorMap: t,
    invalid_type_error: n,
    required_error: r,
    description: s
  } = e;
  if (t && (n || r)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? {
    errorMap: t,
    description: s
  } : {
    errorMap: (o, i) => {
      const {
        message: l
      } = e;
      return o.code === "invalid_enum_value" ? {
        message: l ?? i.defaultError
      } : typeof i.data > "u" ? {
        message: l ?? r ?? i.defaultError
      } : o.code !== "invalid_type" ? {
        message: i.defaultError
      } : {
        message: l ?? n ?? i.defaultError
      }
    },
    description: s
  }
}
class _t {
  get description() {
    return this._def.description
  }
  _getType(t) {
    return mo(t.data)
  }
  _getOrReturnCtx(t, n) {
    return n || {
      common: t.parent.common,
      data: t.data,
      parsedType: mo(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    }
  }
  _processInputParams(t) {
    return {
      status: new jr,
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: mo(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    }
  }
  _parseSync(t) {
    const n = this._parse(t);
    if (Zf(n)) throw new Error("Synchronous parse encountered promise.");
    return n
  }
  _parseAsync(t) {
    const n = this._parse(t);
    return Promise.resolve(n)
  }
  parse(t, n) {
    const r = this.safeParse(t, n);
    if (r.success) return r.data;
    throw r.error
  }
  safeParse(t, n) {
    const r = {
        common: {
          issues: [],
          async: (n == null ? void 0 : n.async) ?? !1,
          contextualErrorMap: n == null ? void 0 : n.errorMap
        },
        path: (n == null ? void 0 : n.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: t,
        parsedType: mo(t)
      },
      s = this._parseSync({
        data: t,
        path: r.path,
        parent: r
      });
    return Cy(r, s)
  }
  "~validate"(t) {
    var r, s;
    const n = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: mo(t)
    };
    if (!this["~standard"].async) try {
      const a = this._parseSync({
        data: t,
        path: [],
        parent: n
      });
      return nu(a) ? {
        value: a.value
      } : {
        issues: n.common.issues
      }
    } catch (a) {
      (s = (r = a == null ? void 0 : a.message) == null ? void 0 : r.toLowerCase()) != null && s.includes("encountered") && (this["~standard"].async = !0), n.common = {
        issues: [],
        async: !0
      }
    }
    return this._parseAsync({
      data: t,
      path: [],
      parent: n
    }).then(a => nu(a) ? {
      value: a.value
    } : {
      issues: n.common.issues
    })
  }
  async parseAsync(t, n) {
    const r = await this.safeParseAsync(t, n);
    if (r.success) return r.data;
    throw r.error
  }
  async safeParseAsync(t, n) {
    const r = {
        common: {
          issues: [],
          contextualErrorMap: n == null ? void 0 : n.errorMap,
          async: !0
        },
        path: (n == null ? void 0 : n.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: t,
        parsedType: mo(t)
      },
      s = this._parse({
        data: t,
        path: r.path,
        parent: r
      }),
      a = await (Zf(s) ? s : Promise.resolve(s));
    return Cy(r, a)
  }
  refine(t, n) {
    const r = s => typeof n == "string" || typeof n > "u" ? {
      message: n
    } : typeof n == "function" ? n(s) : n;
    return this._refinement((s, a) => {
      const o = t(s),
        i = () => a.addIssue({
          code: Pe.custom,
          ...r(s)
        });
      return typeof Promise < "u" && o instanceof Promise ? o.then(l => l ? !0 : (i(), !1)) : o ? !0 : (i(), !1)
    })
  }
  refinement(t, n) {
    return this._refinement((r, s) => t(r) ? !0 : (s.addIssue(typeof n == "function" ? n(r, s) : n), !1))
  }
  _refinement(t) {
    return new au({
      schema: this,
      typeName: rt.ZodEffects,
      effect: {
        type: "refinement",
        refinement: t
      }
    })
  }
  superRefine(t) {
    return this._refinement(t)
  }
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: n => this["~validate"](n)
    }
  }
  optional() {
    return Io.create(this, this._def)
  }
  nullable() {
    return ou.create(this, this._def)
  }
  nullish() {
    return this.nullable().optional()
  }
  array() {
    return Zs.create(this)
  }
  promise() {
    return tp.create(this, this._def)
  }
  or(t) {
    return Xf.create([this, t], this._def)
  }
  and(t) {
    return ep.create(this, t, this._def)
  }
  transform(t) {
    return new au({
      ...pt(this._def),
      schema: this,
      typeName: rt.ZodEffects,
      effect: {
        type: "transform",
        transform: t
      }
    })
  }
  default (t) {
    const n = typeof t == "function" ? t : () => t;
    return new Bm({
      ...pt(this._def),
      innerType: this,
      defaultValue: n,
      typeName: rt.ZodDefault
    })
  }
  brand() {
    return new Bj({
      typeName: rt.ZodBranded,
      type: this,
      ...pt(this._def)
    })
  } catch (t) {
    const n = typeof t == "function" ? t : () => t;
    return new jm({
      ...pt(this._def),
      innerType: this,
      catchValue: n,
      typeName: rt.ZodCatch
    })
  }
  describe(t) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: t
    })
  }
  pipe(t) {
    return Cg.create(this, t)
  }
  readonly() {
    return Hm.create(this)
  }
  isOptional() {
    return this.safeParse(void 0).success
  }
  isNullable() {
    return this.safeParse(null).success
  }
}
const vj = /^c[^\s-]{8,}$/i,
  _j = /^[0-9a-z]+$/,
  yj = /^[0-9A-HJKMNP-TV-Z]{26}$/i,
  bj = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
  wj = /^[a-z0-9_-]{21}$/i,
  Cj = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
  xj = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
  kj = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
  Sj = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let G1;
const Ej = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  Tj = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  Aj = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,
  Pj = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  Ij = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  $j = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  S9 = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",
  Mj = new RegExp(`^${S9}$`);

function E9(e) {
  let t = "[0-5]\\d";
  e.precision ? t = `${t}\\.\\d{${e.precision}}` : e.precision == null && (t = `${t}(\\.\\d+)?`);
  const n = e.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${t})${n}`
}

function Oj(e) {
  return new RegExp(`^${E9(e)}$`)
}

function Dj(e) {
  let t = `${S9}T${E9(e)}`;
  const n = [];
  return n.push(e.local ? "Z?" : "Z"), e.offset && n.push("([+-]\\d{2}:?\\d{2})"), t = `${t}(${n.join("|")})`, new RegExp(`^${t}$`)
}

function Lj(e, t) {
  return !!((t === "v4" || !t) && Ej.test(e) || (t === "v6" || !t) && Aj.test(e))
}

function Rj(e, t) {
  if (!Cj.test(e)) return !1;
  try {
    const [n] = e.split("."), r = n.replace(/-/g, "+").replace(/_/g, "/").padEnd(n.length + (4 - n.length % 4) % 4, "="), s = JSON.parse(atob(r));
    return !(typeof s != "object" || s === null || "typ" in s && (s == null ? void 0 : s.typ) !== "JWT" || !s.alg || t && s.alg !== t)
  } catch {
    return !1
  }
}

function Nj(e, t) {
  return !!((t === "v4" || !t) && Tj.test(e) || (t === "v6" || !t) && Pj.test(e))
}
class Ao extends _t {
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== Be.string) {
      const a = this._getOrReturnCtx(t);
      return Oe(a, {
        code: Pe.invalid_type,
        expected: Be.string,
        received: a.parsedType
      }), ot
    }
    const r = new jr;
    let s;
    for (const a of this._def.checks)
      if (a.kind === "min") t.data.length < a.value && (s = this._getOrReturnCtx(t, s), Oe(s, {
        code: Pe.too_small,
        minimum: a.value,
        type: "string",
        inclusive: !0,
        exact: !1,
        message: a.message
      }), r.dirty());
      else if (a.kind === "max") t.data.length > a.value && (s = this._getOrReturnCtx(t, s), Oe(s, {
      code: Pe.too_big,
      maximum: a.value,
      type: "string",
      inclusive: !0,
      exact: !1,
      message: a.message
    }), r.dirty());
    else if (a.kind === "length") {
      const o = t.data.length > a.value,
        i = t.data.length < a.value;
      (o || i) && (s = this._getOrReturnCtx(t, s), o ? Oe(s, {
        code: Pe.too_big,
        maximum: a.value,
        type: "string",
        inclusive: !0,
        exact: !0,
        message: a.message
      }) : i && Oe(s, {
        code: Pe.too_small,
        minimum: a.value,
        type: "string",
        inclusive: !0,
        exact: !0,
        message: a.message
      }), r.dirty())
    } else if (a.kind === "email") kj.test(t.data) || (s = this._getOrReturnCtx(t, s), Oe(s, {
      validation: "email",
      code: Pe.invalid_string,
      message: a.message
    }), r.dirty());
    else if (a.kind === "emoji") G1 || (G1 = new RegExp(Sj, "u")), G1.test(t.data) || (s = this._getOrReturnCtx(t, s), Oe(s, {
      validation: "emoji",
      code: Pe.invalid_string,
      message: a.message
    }), r.dirty());
    else if (a.kind === "uuid") bj.test(t.data) || (s = this._getOrReturnCtx(t, s), Oe(s, {
      validation: "uuid",
      code: Pe.invalid_string,
      message: a.message
    }), r.dirty());
    else if (a.kind === "nanoid") wj.test(t.data) || (s = this._getOrReturnCtx(t, s), Oe(s, {
      validation: "nanoid",
      code: Pe.invalid_string,
      message: a.message
    }), r.dirty());
    else if (a.kind === "cuid") vj.test(t.data) || (s = this._getOrReturnCtx(t, s), Oe(s, {
      validation: "cuid",
      code: Pe.invalid_string,
      message: a.message
    }), r.dirty());
    else if (a.kind === "cuid2") _j.test(t.data) || (s = this._getOrReturnCtx(t, s), Oe(s, {
      validation: "cuid2",
      code: Pe.invalid_string,
      message: a.message
    }), r.dirty());
    else if (a.kind === "ulid") yj.test(t.data) || (s = this._getOrReturnCtx(t, s), Oe(s, {
      validation: "ulid",
      code: Pe.invalid_string,
      message: a.message
    }), r.dirty());
    else if (a.kind === "url") try {
      new URL(t.data)
    } catch {
      s = this._getOrReturnCtx(t, s), Oe(s, {
        validation: "url",
        code: Pe.invalid_string,
        message: a.message
      }), r.dirty()
    } else a.kind === "regex" ? (a.regex.lastIndex = 0, a.regex.test(t.data) || (s = this._getOrReturnCtx(t, s), Oe(s, {
      validation: "regex",
      code: Pe.invalid_string,
      message: a.message
    }), r.dirty())) : a.kind === "trim" ? t.data = t.data.trim() : a.kind === "includes" ? t.data.includes(a.value, a.position) || (s = this._getOrReturnCtx(t, s), Oe(s, {
      code: Pe.invalid_string,
      validation: {
        includes: a.value,
        position: a.position
      },
      message: a.message
    }), r.dirty()) : a.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : a.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : a.kind === "startsWith" ? t.data.startsWith(a.value) || (s = this._getOrReturnCtx(t, s), Oe(s, {
      code: Pe.invalid_string,
      validation: {
        startsWith: a.value
      },
      message: a.message
    }), r.dirty()) : a.kind === "endsWith" ? t.data.endsWith(a.value) || (s = this._getOrReturnCtx(t, s), Oe(s, {
      code: Pe.invalid_string,
      validation: {
        endsWith: a.value
      },
      message: a.message
    }), r.dirty()) : a.kind === "datetime" ? Dj(a).test(t.data) || (s = this._getOrReturnCtx(t, s), Oe(s, {
      code: Pe.invalid_string,
      validation: "datetime",
      message: a.message
    }), r.dirty()) : a.kind === "date" ? Mj.test(t.data) || (s = this._getOrReturnCtx(t, s), Oe(s, {
      code: Pe.invalid_string,
      validation: "date",
      message: a.message
    }), r.dirty()) : a.kind === "time" ? Oj(a).test(t.data) || (s = this._getOrReturnCtx(t, s), Oe(s, {
      code: Pe.invalid_string,
      validation: "time",
      message: a.message
    }), r.dirty()) : a.kind === "duration" ? xj.test(t.data) || (s = this._getOrReturnCtx(t, s), Oe(s, {
      validation: "duration",
      code: Pe.invalid_string,
      message: a.message
    }), r.dirty()) : a.kind === "ip" ? Lj(t.data, a.version) || (s = this._getOrReturnCtx(t, s), Oe(s, {
      validation: "ip",
      code: Pe.invalid_string,
      message: a.message
    }), r.dirty()) : a.kind === "jwt" ? Rj(t.data, a.alg) || (s = this._getOrReturnCtx(t, s), Oe(s, {
      validation: "jwt",
      code: Pe.invalid_string,
      message: a.message
    }), r.dirty()) : a.kind === "cidr" ? Nj(t.data, a.version) || (s = this._getOrReturnCtx(t, s), Oe(s, {
      validation: "cidr",
      code: Pe.invalid_string,
      message: a.message
    }), r.dirty()) : a.kind === "base64" ? Ij.test(t.data) || (s = this._getOrReturnCtx(t, s), Oe(s, {
      validation: "base64",
      code: Pe.invalid_string,
      message: a.message
    }), r.dirty()) : a.kind === "base64url" ? $j.test(t.data) || (s = this._getOrReturnCtx(t, s), Oe(s, {
      validation: "base64url",
      code: Pe.invalid_string,
      message: a.message
    }), r.dirty()) : wt.assertNever(a);
    return {
      status: r.value,
      value: t.data
    }
  }
  _regex(t, n, r) {
    return this.refinement(s => t.test(s), {
      validation: n,
      code: Pe.invalid_string,
      ...je.errToObj(r)
    })
  }
  _addCheck(t) {
    return new Ao({
      ...this._def,
      checks: [...this._def.checks, t]
    })
  }
  email(t) {
    return this._addCheck({
      kind: "email",
      ...je.errToObj(t)
    })
  }
  url(t) {
    return this._addCheck({
      kind: "url",
      ...je.errToObj(t)
    })
  }
  emoji(t) {
    return this._addCheck({
      kind: "emoji",
      ...je.errToObj(t)
    })
  }
  uuid(t) {
    return this._addCheck({
      kind: "uuid",
      ...je.errToObj(t)
    })
  }
  nanoid(t) {
    return this._addCheck({
      kind: "nanoid",
      ...je.errToObj(t)
    })
  }
  cuid(t) {
    return this._addCheck({
      kind: "cuid",
      ...je.errToObj(t)
    })
  }
  cuid2(t) {
    return this._addCheck({
      kind: "cuid2",
      ...je.errToObj(t)
    })
  }
  ulid(t) {
    return this._addCheck({
      kind: "ulid",
      ...je.errToObj(t)
    })
  }
  base64(t) {
    return this._addCheck({
      kind: "base64",
      ...je.errToObj(t)
    })
  }
  base64url(t) {
    return this._addCheck({
      kind: "base64url",
      ...je.errToObj(t)
    })
  }
  jwt(t) {
    return this._addCheck({
      kind: "jwt",
      ...je.errToObj(t)
    })
  }
  ip(t) {
    return this._addCheck({
      kind: "ip",
      ...je.errToObj(t)
    })
  }
  cidr(t) {
    return this._addCheck({
      kind: "cidr",
      ...je.errToObj(t)
    })
  }
  datetime(t) {
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof(t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (t == null ? void 0 : t.offset) ?? !1,
      local: (t == null ? void 0 : t.local) ?? !1,
      ...je.errToObj(t == null ? void 0 : t.message)
    })
  }
  date(t) {
    return this._addCheck({
      kind: "date",
      message: t
    })
  }
  time(t) {
    return typeof t == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: t
    }) : this._addCheck({
      kind: "time",
      precision: typeof(t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      ...je.errToObj(t == null ? void 0 : t.message)
    })
  }
  duration(t) {
    return this._addCheck({
      kind: "duration",
      ...je.errToObj(t)
    })
  }
  regex(t, n) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...je.errToObj(n)
    })
  }
  includes(t, n) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: n == null ? void 0 : n.position,
      ...je.errToObj(n == null ? void 0 : n.message)
    })
  }
  startsWith(t, n) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...je.errToObj(n)
    })
  }
  endsWith(t, n) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...je.errToObj(n)
    })
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...je.errToObj(n)
    })
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...je.errToObj(n)
    })
  }
  length(t, n) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...je.errToObj(n)
    })
  }
  nonempty(t) {
    return this.min(1, je.errToObj(t))
  }
  trim() {
    return new Ao({
      ...this._def,
      checks: [...this._def.checks, {
        kind: "trim"
      }]
    })
  }
  toLowerCase() {
    return new Ao({
      ...this._def,
      checks: [...this._def.checks, {
        kind: "toLowerCase"
      }]
    })
  }
  toUpperCase() {
    return new Ao({
      ...this._def,
      checks: [...this._def.checks, {
        kind: "toUpperCase"
      }]
    })
  }
  get isDatetime() {
    return !!this._def.checks.find(t => t.kind === "datetime")
  }
  get isDate() {
    return !!this._def.checks.find(t => t.kind === "date")
  }
  get isTime() {
    return !!this._def.checks.find(t => t.kind === "time")
  }
  get isDuration() {
    return !!this._def.checks.find(t => t.kind === "duration")
  }
  get isEmail() {
    return !!this._def.checks.find(t => t.kind === "email")
  }
  get isURL() {
    return !!this._def.checks.find(t => t.kind === "url")
  }
  get isEmoji() {
    return !!this._def.checks.find(t => t.kind === "emoji")
  }
  get isUUID() {
    return !!this._def.checks.find(t => t.kind === "uuid")
  }
  get isNANOID() {
    return !!this._def.checks.find(t => t.kind === "nanoid")
  }
  get isCUID() {
    return !!this._def.checks.find(t => t.kind === "cuid")
  }
  get isCUID2() {
    return !!this._def.checks.find(t => t.kind === "cuid2")
  }
  get isULID() {
    return !!this._def.checks.find(t => t.kind === "ulid")
  }
  get isIP() {
    return !!this._def.checks.find(t => t.kind === "ip")
  }
  get isCIDR() {
    return !!this._def.checks.find(t => t.kind === "cidr")
  }
  get isBase64() {
    return !!this._def.checks.find(t => t.kind === "base64")
  }
  get isBase64url() {
    return !!this._def.checks.find(t => t.kind === "base64url")
  }
  get minLength() {
    let t = null;
    for (const n of this._def.checks) n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t
  }
  get maxLength() {
    let t = null;
    for (const n of this._def.checks) n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t
  }
}
Ao.create = e => new Ao({
  checks: [],
  typeName: rt.ZodString,
  coerce: (e == null ? void 0 : e.coerce) ?? !1,
  ...pt(e)
});

function Fj(e, t) {
  const n = (e.toString().split(".")[1] || "").length,
    r = (t.toString().split(".")[1] || "").length,
    s = n > r ? n : r,
    a = Number.parseInt(e.toFixed(s).replace(".", "")),
    o = Number.parseInt(t.toFixed(s).replace(".", ""));
  return a % o / 10 ** s
}
class ru extends _t {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== Be.number) {
      const a = this._getOrReturnCtx(t);
      return Oe(a, {
        code: Pe.invalid_type,
        expected: Be.number,
        received: a.parsedType
      }), ot
    }
    let r;
    const s = new jr;
    for (const a of this._def.checks) a.kind === "int" ? wt.isInteger(t.data) || (r = this._getOrReturnCtx(t, r), Oe(r, {
      code: Pe.invalid_type,
      expected: "integer",
      received: "float",
      message: a.message
    }), s.dirty()) : a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (r = this._getOrReturnCtx(t, r), Oe(r, {
      code: Pe.too_small,
      minimum: a.value,
      type: "number",
      inclusive: a.inclusive,
      exact: !1,
      message: a.message
    }), s.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (r = this._getOrReturnCtx(t, r), Oe(r, {
      code: Pe.too_big,
      maximum: a.value,
      type: "number",
      inclusive: a.inclusive,
      exact: !1,
      message: a.message
    }), s.dirty()) : a.kind === "multipleOf" ? Fj(t.data, a.value) !== 0 && (r = this._getOrReturnCtx(t, r), Oe(r, {
      code: Pe.not_multiple_of,
      multipleOf: a.value,
      message: a.message
    }), s.dirty()) : a.kind === "finite" ? Number.isFinite(t.data) || (r = this._getOrReturnCtx(t, r), Oe(r, {
      code: Pe.not_finite,
      message: a.message
    }), s.dirty()) : wt.assertNever(a);
    return {
      status: s.value,
      value: t.data
    }
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, je.toString(n))
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, je.toString(n))
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, je.toString(n))
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, je.toString(n))
  }
  setLimit(t, n, r, s) {
    return new ru({
      ...this._def,
      checks: [...this._def.checks, {
        kind: t,
        value: n,
        inclusive: r,
        message: je.toString(s)
      }]
    })
  }
  _addCheck(t) {
    return new ru({
      ...this._def,
      checks: [...this._def.checks, t]
    })
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: je.toString(t)
    })
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: je.toString(t)
    })
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: je.toString(t)
    })
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: je.toString(t)
    })
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: je.toString(t)
    })
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: je.toString(n)
    })
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: je.toString(t)
    })
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: je.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: je.toString(t)
    })
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks) n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks) n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t
  }
  get isInt() {
    return !!this._def.checks.find(t => t.kind === "int" || t.kind === "multipleOf" && wt.isInteger(t.value))
  }
  get isFinite() {
    let t = null,
      n = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf") return !0;
      r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (t === null || r.value < t) && (t = r.value)
    }
    return Number.isFinite(n) && Number.isFinite(t)
  }
}
ru.create = e => new ru({
  checks: [],
  typeName: rt.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...pt(e)
});
class Nc extends _t {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte
  }
  _parse(t) {
    if (this._def.coerce) try {
      t.data = BigInt(t.data)
    } catch {
      return this._getInvalidInput(t)
    }
    if (this._getType(t) !== Be.bigint) return this._getInvalidInput(t);
    let r;
    const s = new jr;
    for (const a of this._def.checks) a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (r = this._getOrReturnCtx(t, r), Oe(r, {
      code: Pe.too_small,
      type: "bigint",
      minimum: a.value,
      inclusive: a.inclusive,
      message: a.message
    }), s.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (r = this._getOrReturnCtx(t, r), Oe(r, {
      code: Pe.too_big,
      type: "bigint",
      maximum: a.value,
      inclusive: a.inclusive,
      message: a.message
    }), s.dirty()) : a.kind === "multipleOf" ? t.data % a.value !== BigInt(0) && (r = this._getOrReturnCtx(t, r), Oe(r, {
      code: Pe.not_multiple_of,
      multipleOf: a.value,
      message: a.message
    }), s.dirty()) : wt.assertNever(a);
    return {
      status: s.value,
      value: t.data
    }
  }
  _getInvalidInput(t) {
    const n = this._getOrReturnCtx(t);
    return Oe(n, {
      code: Pe.invalid_type,
      expected: Be.bigint,
      received: n.parsedType
    }), ot
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, je.toString(n))
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, je.toString(n))
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, je.toString(n))
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, je.toString(n))
  }
  setLimit(t, n, r, s) {
    return new Nc({
      ...this._def,
      checks: [...this._def.checks, {
        kind: t,
        value: n,
        inclusive: r,
        message: je.toString(s)
      }]
    })
  }
  _addCheck(t) {
    return new Nc({
      ...this._def,
      checks: [...this._def.checks, t]
    })
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: je.toString(t)
    })
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: je.toString(t)
    })
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: je.toString(t)
    })
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: je.toString(t)
    })
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: je.toString(n)
    })
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks) n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks) n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t
  }
}
Nc.create = e => new Nc({
  checks: [],
  typeName: rt.ZodBigInt,
  coerce: (e == null ? void 0 : e.coerce) ?? !1,
  ...pt(e)
});
class Rm extends _t {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== Be.boolean) {
      const r = this._getOrReturnCtx(t);
      return Oe(r, {
        code: Pe.invalid_type,
        expected: Be.boolean,
        received: r.parsedType
      }), ot
    }
    return rs(t.data)
  }
}
Rm.create = e => new Rm({
  typeName: rt.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...pt(e)
});
class Fc extends _t {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== Be.date) {
      const a = this._getOrReturnCtx(t);
      return Oe(a, {
        code: Pe.invalid_type,
        expected: Be.date,
        received: a.parsedType
      }), ot
    }
    if (Number.isNaN(t.data.getTime())) {
      const a = this._getOrReturnCtx(t);
      return Oe(a, {
        code: Pe.invalid_date
      }), ot
    }
    const r = new jr;
    let s;
    for (const a of this._def.checks) a.kind === "min" ? t.data.getTime() < a.value && (s = this._getOrReturnCtx(t, s), Oe(s, {
      code: Pe.too_small,
      message: a.message,
      inclusive: !0,
      exact: !1,
      minimum: a.value,
      type: "date"
    }), r.dirty()) : a.kind === "max" ? t.data.getTime() > a.value && (s = this._getOrReturnCtx(t, s), Oe(s, {
      code: Pe.too_big,
      message: a.message,
      inclusive: !0,
      exact: !1,
      maximum: a.value,
      type: "date"
    }), r.dirty()) : wt.assertNever(a);
    return {
      status: r.value,
      value: new Date(t.data.getTime())
    }
  }
  _addCheck(t) {
    return new Fc({
      ...this._def,
      checks: [...this._def.checks, t]
    })
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: je.toString(n)
    })
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: je.toString(n)
    })
  }
  get minDate() {
    let t = null;
    for (const n of this._def.checks) n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t != null ? new Date(t) : null
  }
  get maxDate() {
    let t = null;
    for (const n of this._def.checks) n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t != null ? new Date(t) : null
  }
}
Fc.create = e => new Fc({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || !1,
  typeName: rt.ZodDate,
  ...pt(e)
});
class xy extends _t {
  _parse(t) {
    if (this._getType(t) !== Be.symbol) {
      const r = this._getOrReturnCtx(t);
      return Oe(r, {
        code: Pe.invalid_type,
        expected: Be.symbol,
        received: r.parsedType
      }), ot
    }
    return rs(t.data)
  }
}
xy.create = e => new xy({
  typeName: rt.ZodSymbol,
  ...pt(e)
});
class ky extends _t {
  _parse(t) {
    if (this._getType(t) !== Be.undefined) {
      const r = this._getOrReturnCtx(t);
      return Oe(r, {
        code: Pe.invalid_type,
        expected: Be.undefined,
        received: r.parsedType
      }), ot
    }
    return rs(t.data)
  }
}
ky.create = e => new ky({
  typeName: rt.ZodUndefined,
  ...pt(e)
});
class Nm extends _t {
  _parse(t) {
    if (this._getType(t) !== Be.null) {
      const r = this._getOrReturnCtx(t);
      return Oe(r, {
        code: Pe.invalid_type,
        expected: Be.null,
        received: r.parsedType
      }), ot
    }
    return rs(t.data)
  }
}
Nm.create = e => new Nm({
  typeName: rt.ZodNull,
  ...pt(e)
});
class Sy extends _t {
  constructor() {
    super(...arguments), this._any = !0
  }
  _parse(t) {
    return rs(t.data)
  }
}
Sy.create = e => new Sy({
  typeName: rt.ZodAny,
  ...pt(e)
});
class Ey extends _t {
  constructor() {
    super(...arguments), this._unknown = !0
  }
  _parse(t) {
    return rs(t.data)
  }
}
Ey.create = e => new Ey({
  typeName: rt.ZodUnknown,
  ...pt(e)
});
class Vo extends _t {
  _parse(t) {
    const n = this._getOrReturnCtx(t);
    return Oe(n, {
      code: Pe.invalid_type,
      expected: Be.never,
      received: n.parsedType
    }), ot
  }
}
Vo.create = e => new Vo({
  typeName: rt.ZodNever,
  ...pt(e)
});
class Ty extends _t {
  _parse(t) {
    if (this._getType(t) !== Be.undefined) {
      const r = this._getOrReturnCtx(t);
      return Oe(r, {
        code: Pe.invalid_type,
        expected: Be.void,
        received: r.parsedType
      }), ot
    }
    return rs(t.data)
  }
}
Ty.create = e => new Ty({
  typeName: rt.ZodVoid,
  ...pt(e)
});
class Zs extends _t {
  _parse(t) {
    const {
      ctx: n,
      status: r
    } = this._processInputParams(t), s = this._def;
    if (n.parsedType !== Be.array) return Oe(n, {
      code: Pe.invalid_type,
      expected: Be.array,
      received: n.parsedType
    }), ot;
    if (s.exactLength !== null) {
      const o = n.data.length > s.exactLength.value,
        i = n.data.length < s.exactLength.value;
      (o || i) && (Oe(n, {
        code: o ? Pe.too_big : Pe.too_small,
        minimum: i ? s.exactLength.value : void 0,
        maximum: o ? s.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: s.exactLength.message
      }), r.dirty())
    }
    if (s.minLength !== null && n.data.length < s.minLength.value && (Oe(n, {
        code: Pe.too_small,
        minimum: s.minLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: s.minLength.message
      }), r.dirty()), s.maxLength !== null && n.data.length > s.maxLength.value && (Oe(n, {
        code: Pe.too_big,
        maximum: s.maxLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: s.maxLength.message
      }), r.dirty()), n.common.async) return Promise.all([...n.data].map((o, i) => s.type._parseAsync(new Ho(n, o, n.path, i)))).then(o => jr.mergeArray(r, o));
    const a = [...n.data].map((o, i) => s.type._parseSync(new Ho(n, o, n.path, i)));
    return jr.mergeArray(r, a)
  }
  get element() {
    return this._def.type
  }
  min(t, n) {
    return new Zs({
      ...this._def,
      minLength: {
        value: t,
        message: je.toString(n)
      }
    })
  }
  max(t, n) {
    return new Zs({
      ...this._def,
      maxLength: {
        value: t,
        message: je.toString(n)
      }
    })
  }
  length(t, n) {
    return new Zs({
      ...this._def,
      exactLength: {
        value: t,
        message: je.toString(n)
      }
    })
  }
  nonempty(t) {
    return this.min(1, t)
  }
}
Zs.create = (e, t) => new Zs({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: rt.ZodArray,
  ...pt(t)
});

function dl(e) {
  if (e instanceof _n) {
    const t = {};
    for (const n in e.shape) {
      const r = e.shape[n];
      t[n] = Io.create(dl(r))
    }
    return new _n({
      ...e._def,
      shape: () => t
    })
  } else return e instanceof Zs ? new Zs({
    ...e._def,
    type: dl(e.element)
  }) : e instanceof Io ? Io.create(dl(e.unwrap())) : e instanceof ou ? ou.create(dl(e.unwrap())) : e instanceof Vi ? Vi.create(e.items.map(t => dl(t))) : e
}
class _n extends _t {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend
  }
  _getCached() {
    if (this._cached !== null) return this._cached;
    const t = this._def.shape(),
      n = wt.objectKeys(t);
    return this._cached = {
      shape: t,
      keys: n
    }, this._cached
  }
  _parse(t) {
    if (this._getType(t) !== Be.object) {
      const c = this._getOrReturnCtx(t);
      return Oe(c, {
        code: Pe.invalid_type,
        expected: Be.object,
        received: c.parsedType
      }), ot
    }
    const {
      status: r,
      ctx: s
    } = this._processInputParams(t), {
      shape: a,
      keys: o
    } = this._getCached(), i = [];
    if (!(this._def.catchall instanceof Vo && this._def.unknownKeys === "strip"))
      for (const c in s.data) o.includes(c) || i.push(c);
    const l = [];
    for (const c of o) {
      const d = a[c],
        f = s.data[c];
      l.push({
        key: {
          status: "valid",
          value: c
        },
        value: d._parse(new Ho(s, f, s.path, c)),
        alwaysSet: c in s.data
      })
    }
    if (this._def.catchall instanceof Vo) {
      const c = this._def.unknownKeys;
      if (c === "passthrough")
        for (const d of i) l.push({
          key: {
            status: "valid",
            value: d
          },
          value: {
            status: "valid",
            value: s.data[d]
          }
        });
      else if (c === "strict") i.length > 0 && (Oe(s, {
        code: Pe.unrecognized_keys,
        keys: i
      }), r.dirty());
      else if (c !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.")
    } else {
      const c = this._def.catchall;
      for (const d of i) {
        const f = s.data[d];
        l.push({
          key: {
            status: "valid",
            value: d
          },
          value: c._parse(new Ho(s, f, s.path, d)),
          alwaysSet: d in s.data
        })
      }
    }
    return s.common.async ? Promise.resolve().then(async () => {
      const c = [];
      for (const d of l) {
        const f = await d.key,
          p = await d.value;
        c.push({
          key: f,
          value: p,
          alwaysSet: d.alwaysSet
        })
      }
      return c
    }).then(c => jr.mergeObjectSync(r, c)) : jr.mergeObjectSync(r, l)
  }
  get shape() {
    return this._def.shape()
  }
  strict(t) {
    return je.errToObj, new _n({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (n, r) => {
          var a, o;
          const s = ((o = (a = this._def).errorMap) == null ? void 0 : o.call(a, n, r).message) ?? r.defaultError;
          return n.code === "unrecognized_keys" ? {
            message: je.errToObj(t).message ?? s
          } : {
            message: s
          }
        }
      } : {}
    })
  }
  strip() {
    return new _n({
      ...this._def,
      unknownKeys: "strip"
    })
  }
  passthrough() {
    return new _n({
      ...this._def,
      unknownKeys: "passthrough"
    })
  }
  extend(t) {
    return new _n({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    })
  }
  merge(t) {
    return new _n({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: rt.ZodObject
    })
  }
  setKey(t, n) {
    return this.augment({
      [t]: n
    })
  }
  catchall(t) {
    return new _n({
      ...this._def,
      catchall: t
    })
  }
  pick(t) {
    const n = {};
    for (const r of wt.objectKeys(t)) t[r] && this.shape[r] && (n[r] = this.shape[r]);
    return new _n({
      ...this._def,
      shape: () => n
    })
  }
  omit(t) {
    const n = {};
    for (const r of wt.objectKeys(this.shape)) t[r] || (n[r] = this.shape[r]);
    return new _n({
      ...this._def,
      shape: () => n
    })
  }
  deepPartial() {
    return dl(this)
  }
  partial(t) {
    const n = {};
    for (const r of wt.objectKeys(this.shape)) {
      const s = this.shape[r];
      t && !t[r] ? n[r] = s : n[r] = s.optional()
    }
    return new _n({
      ...this._def,
      shape: () => n
    })
  }
  required(t) {
    const n = {};
    for (const r of wt.objectKeys(this.shape))
      if (t && !t[r]) n[r] = this.shape[r];
      else {
        let a = this.shape[r];
        for (; a instanceof Io;) a = a._def.innerType;
        n[r] = a
      } return new _n({
      ...this._def,
      shape: () => n
    })
  }
  keyof() {
    return T9(wt.objectKeys(this.shape))
  }
}
_n.create = (e, t) => new _n({
  shape: () => e,
  unknownKeys: "strip",
  catchall: Vo.create(),
  typeName: rt.ZodObject,
  ...pt(t)
});
_n.strictCreate = (e, t) => new _n({
  shape: () => e,
  unknownKeys: "strict",
  catchall: Vo.create(),
  typeName: rt.ZodObject,
  ...pt(t)
});
_n.lazycreate = (e, t) => new _n({
  shape: e,
  unknownKeys: "strip",
  catchall: Vo.create(),
  typeName: rt.ZodObject,
  ...pt(t)
});
class Xf extends _t {
  _parse(t) {
    const {
      ctx: n
    } = this._processInputParams(t), r = this._def.options;

    function s(a) {
      for (const i of a)
        if (i.result.status === "valid") return i.result;
      for (const i of a)
        if (i.result.status === "dirty") return n.common.issues.push(...i.ctx.common.issues), i.result;
      const o = a.map(i => new Ua(i.ctx.common.issues));
      return Oe(n, {
        code: Pe.invalid_union,
        unionErrors: o
      }), ot
    }
    if (n.common.async) return Promise.all(r.map(async a => {
      const o = {
        ...n,
        common: {
          ...n.common,
          issues: []
        },
        parent: null
      };
      return {
        result: await a._parseAsync({
          data: n.data,
          path: n.path,
          parent: o
        }),
        ctx: o
      }
    })).then(s);
    {
      let a;
      const o = [];
      for (const l of r) {
        const c = {
            ...n,
            common: {
              ...n.common,
              issues: []
            },
            parent: null
          },
          d = l._parseSync({
            data: n.data,
            path: n.path,
            parent: c
          });
        if (d.status === "valid") return d;
        d.status === "dirty" && !a && (a = {
          result: d,
          ctx: c
        }), c.common.issues.length && o.push(c.common.issues)
      }
      if (a) return n.common.issues.push(...a.ctx.common.issues), a.result;
      const i = o.map(l => new Ua(l));
      return Oe(n, {
        code: Pe.invalid_union,
        unionErrors: i
      }), ot
    }
  }
  get options() {
    return this._def.options
  }
}
Xf.create = (e, t) => new Xf({
  options: e,
  typeName: rt.ZodUnion,
  ...pt(t)
});

function Fm(e, t) {
  const n = mo(e),
    r = mo(t);
  if (e === t) return {
    valid: !0,
    data: e
  };
  if (n === Be.object && r === Be.object) {
    const s = wt.objectKeys(t),
      a = wt.objectKeys(e).filter(i => s.indexOf(i) !== -1),
      o = {
        ...e,
        ...t
      };
    for (const i of a) {
      const l = Fm(e[i], t[i]);
      if (!l.valid) return {
        valid: !1
      };
      o[i] = l.data
    }
    return {
      valid: !0,
      data: o
    }
  } else if (n === Be.array && r === Be.array) {
    if (e.length !== t.length) return {
      valid: !1
    };
    const s = [];
    for (let a = 0; a < e.length; a++) {
      const o = e[a],
        i = t[a],
        l = Fm(o, i);
      if (!l.valid) return {
        valid: !1
      };
      s.push(l.data)
    }
    return {
      valid: !0,
      data: s
    }
  } else return n === Be.date && r === Be.date && +e == +t ? {
    valid: !0,
    data: e
  } : {
    valid: !1
  }
}
class ep extends _t {
  _parse(t) {
    const {
      status: n,
      ctx: r
    } = this._processInputParams(t), s = (a, o) => {
      if (by(a) || by(o)) return ot;
      const i = Fm(a.value, o.value);
      return i.valid ? ((wy(a) || wy(o)) && n.dirty(), {
        status: n.value,
        value: i.data
      }) : (Oe(r, {
        code: Pe.invalid_intersection_types
      }), ot)
    };
    return r.common.async ? Promise.all([this._def.left._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    })]).then(([a, o]) => s(a, o)) : s(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }))
  }
}
ep.create = (e, t, n) => new ep({
  left: e,
  right: t,
  typeName: rt.ZodIntersection,
  ...pt(n)
});
class Vi extends _t {
  _parse(t) {
    const {
      status: n,
      ctx: r
    } = this._processInputParams(t);
    if (r.parsedType !== Be.array) return Oe(r, {
      code: Pe.invalid_type,
      expected: Be.array,
      received: r.parsedType
    }), ot;
    if (r.data.length < this._def.items.length) return Oe(r, {
      code: Pe.too_small,
      minimum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), ot;
    !this._def.rest && r.data.length > this._def.items.length && (Oe(r, {
      code: Pe.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), n.dirty());
    const a = [...r.data].map((o, i) => {
      const l = this._def.items[i] || this._def.rest;
      return l ? l._parse(new Ho(r, o, r.path, i)) : null
    }).filter(o => !!o);
    return r.common.async ? Promise.all(a).then(o => jr.mergeArray(n, o)) : jr.mergeArray(n, a)
  }
  get items() {
    return this._def.items
  }
  rest(t) {
    return new Vi({
      ...this._def,
      rest: t
    })
  }
}
Vi.create = (e, t) => {
  if (!Array.isArray(e)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Vi({
    items: e,
    typeName: rt.ZodTuple,
    rest: null,
    ...pt(t)
  })
};
class Ay extends _t {
  get keySchema() {
    return this._def.keyType
  }
  get valueSchema() {
    return this._def.valueType
  }
  _parse(t) {
    const {
      status: n,
      ctx: r
    } = this._processInputParams(t);
    if (r.parsedType !== Be.map) return Oe(r, {
      code: Pe.invalid_type,
      expected: Be.map,
      received: r.parsedType
    }), ot;
    const s = this._def.keyType,
      a = this._def.valueType,
      o = [...r.data.entries()].map(([i, l], c) => ({
        key: s._parse(new Ho(r, i, r.path, [c, "key"])),
        value: a._parse(new Ho(r, l, r.path, [c, "value"]))
      }));
    if (r.common.async) {
      const i = new Map;
      return Promise.resolve().then(async () => {
        for (const l of o) {
          const c = await l.key,
            d = await l.value;
          if (c.status === "aborted" || d.status === "aborted") return ot;
          (c.status === "dirty" || d.status === "dirty") && n.dirty(), i.set(c.value, d.value)
        }
        return {
          status: n.value,
          value: i
        }
      })
    } else {
      const i = new Map;
      for (const l of o) {
        const c = l.key,
          d = l.value;
        if (c.status === "aborted" || d.status === "aborted") return ot;
        (c.status === "dirty" || d.status === "dirty") && n.dirty(), i.set(c.value, d.value)
      }
      return {
        status: n.value,
        value: i
      }
    }
  }
}
Ay.create = (e, t, n) => new Ay({
  valueType: t,
  keyType: e,
  typeName: rt.ZodMap,
  ...pt(n)
});
class Bc extends _t {
  _parse(t) {
    const {
      status: n,
      ctx: r
    } = this._processInputParams(t);
    if (r.parsedType !== Be.set) return Oe(r, {
      code: Pe.invalid_type,
      expected: Be.set,
      received: r.parsedType
    }), ot;
    const s = this._def;
    s.minSize !== null && r.data.size < s.minSize.value && (Oe(r, {
      code: Pe.too_small,
      minimum: s.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: s.minSize.message
    }), n.dirty()), s.maxSize !== null && r.data.size > s.maxSize.value && (Oe(r, {
      code: Pe.too_big,
      maximum: s.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: s.maxSize.message
    }), n.dirty());
    const a = this._def.valueType;

    function o(l) {
      const c = new Set;
      for (const d of l) {
        if (d.status === "aborted") return ot;
        d.status === "dirty" && n.dirty(), c.add(d.value)
      }
      return {
        status: n.value,
        value: c
      }
    }
    const i = [...r.data.values()].map((l, c) => a._parse(new Ho(r, l, r.path, c)));
    return r.common.async ? Promise.all(i).then(l => o(l)) : o(i)
  }
  min(t, n) {
    return new Bc({
      ...this._def,
      minSize: {
        value: t,
        message: je.toString(n)
      }
    })
  }
  max(t, n) {
    return new Bc({
      ...this._def,
      maxSize: {
        value: t,
        message: je.toString(n)
      }
    })
  }
  size(t, n) {
    return this.min(t, n).max(t, n)
  }
  nonempty(t) {
    return this.min(1, t)
  }
}
Bc.create = (e, t) => new Bc({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: rt.ZodSet,
  ...pt(t)
});
class Py extends _t {
  get schema() {
    return this._def.getter()
  }
  _parse(t) {
    const {
      ctx: n
    } = this._processInputParams(t);
    return this._def.getter()._parse({
      data: n.data,
      path: n.path,
      parent: n
    })
  }
}
Py.create = (e, t) => new Py({
  getter: e,
  typeName: rt.ZodLazy,
  ...pt(t)
});
class Iy extends _t {
  _parse(t) {
    if (t.data !== this._def.value) {
      const n = this._getOrReturnCtx(t);
      return Oe(n, {
        received: n.data,
        code: Pe.invalid_literal,
        expected: this._def.value
      }), ot
    }
    return {
      status: "valid",
      value: t.data
    }
  }
  get value() {
    return this._def.value
  }
}
Iy.create = (e, t) => new Iy({
  value: e,
  typeName: rt.ZodLiteral,
  ...pt(t)
});

function T9(e, t) {
  return new su({
    values: e,
    typeName: rt.ZodEnum,
    ...pt(t)
  })
}
class su extends _t {
  constructor() {
    super(...arguments), Zu.set(this, void 0)
  }
  _parse(t) {
    if (typeof t.data != "string") {
      const n = this._getOrReturnCtx(t),
        r = this._def.values;
      return Oe(n, {
        expected: wt.joinValues(r),
        received: n.parsedType,
        code: Pe.invalid_type
      }), ot
    }
    if (Jf(this, Zu, "f") || k9(this, Zu, new Set(this._def.values), "f"), !Jf(this, Zu, "f").has(t.data)) {
      const n = this._getOrReturnCtx(t),
        r = this._def.values;
      return Oe(n, {
        received: n.data,
        code: Pe.invalid_enum_value,
        options: r
      }), ot
    }
    return rs(t.data)
  }
  get options() {
    return this._def.values
  }
  get enum() {
    const t = {};
    for (const n of this._def.values) t[n] = n;
    return t
  }
  get Values() {
    const t = {};
    for (const n of this._def.values) t[n] = n;
    return t
  }
  get Enum() {
    const t = {};
    for (const n of this._def.values) t[n] = n;
    return t
  }
  extract(t, n = this._def) {
    return su.create(t, {
      ...this._def,
      ...n
    })
  }
  exclude(t, n = this._def) {
    return su.create(this.options.filter(r => !t.includes(r)), {
      ...this._def,
      ...n
    })
  }
}
Zu = new WeakMap;
su.create = T9;
class $y extends _t {
  constructor() {
    super(...arguments), Ju.set(this, void 0)
  }
  _parse(t) {
    const n = wt.getValidEnumValues(this._def.values),
      r = this._getOrReturnCtx(t);
    if (r.parsedType !== Be.string && r.parsedType !== Be.number) {
      const s = wt.objectValues(n);
      return Oe(r, {
        expected: wt.joinValues(s),
        received: r.parsedType,
        code: Pe.invalid_type
      }), ot
    }
    if (Jf(this, Ju, "f") || k9(this, Ju, new Set(wt.getValidEnumValues(this._def.values)), "f"), !Jf(this, Ju, "f").has(t.data)) {
      const s = wt.objectValues(n);
      return Oe(r, {
        received: r.data,
        code: Pe.invalid_enum_value,
        options: s
      }), ot
    }
    return rs(t.data)
  }
  get enum() {
    return this._def.values
  }
}
Ju = new WeakMap;
$y.create = (e, t) => new $y({
  values: e,
  typeName: rt.ZodNativeEnum,
  ...pt(t)
});
class tp extends _t {
  unwrap() {
    return this._def.type
  }
  _parse(t) {
    const {
      ctx: n
    } = this._processInputParams(t);
    if (n.parsedType !== Be.promise && n.common.async === !1) return Oe(n, {
      code: Pe.invalid_type,
      expected: Be.promise,
      received: n.parsedType
    }), ot;
    const r = n.parsedType === Be.promise ? n.data : Promise.resolve(n.data);
    return rs(r.then(s => this._def.type.parseAsync(s, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })))
  }
}
tp.create = (e, t) => new tp({
  type: e,
  typeName: rt.ZodPromise,
  ...pt(t)
});
class au extends _t {
  innerType() {
    return this._def.schema
  }
  sourceType() {
    return this._def.schema._def.typeName === rt.ZodEffects ? this._def.schema.sourceType() : this._def.schema
  }
  _parse(t) {
    const {
      status: n,
      ctx: r
    } = this._processInputParams(t), s = this._def.effect || null, a = {
      addIssue: o => {
        Oe(r, o), o.fatal ? n.abort() : n.dirty()
      },
      get path() {
        return r.path
      }
    };
    if (a.addIssue = a.addIssue.bind(a), s.type === "preprocess") {
      const o = s.transform(r.data, a);
      if (r.common.async) return Promise.resolve(o).then(async i => {
        if (n.value === "aborted") return ot;
        const l = await this._def.schema._parseAsync({
          data: i,
          path: r.path,
          parent: r
        });
        return l.status === "aborted" ? ot : l.status === "dirty" || n.value === "dirty" ? Ku(l.value) : l
      });
      {
        if (n.value === "aborted") return ot;
        const i = this._def.schema._parseSync({
          data: o,
          path: r.path,
          parent: r
        });
        return i.status === "aborted" ? ot : i.status === "dirty" || n.value === "dirty" ? Ku(i.value) : i
      }
    }
    if (s.type === "refinement") {
      const o = i => {
        const l = s.refinement(i, a);
        if (r.common.async) return Promise.resolve(l);
        if (l instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return i
      };
      if (r.common.async === !1) {
        const i = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return i.status === "aborted" ? ot : (i.status === "dirty" && n.dirty(), o(i.value), {
          status: n.value,
          value: i.value
        })
      } else return this._def.schema._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }).then(i => i.status === "aborted" ? ot : (i.status === "dirty" && n.dirty(), o(i.value).then(() => ({
        status: n.value,
        value: i.value
      }))))
    }
    if (s.type === "transform")
      if (r.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!nu(o)) return o;
        const i = s.transform(o.value, a);
        if (i instanceof Promise) throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return {
          status: n.value,
          value: i
        }
      } else return this._def.schema._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }).then(o => nu(o) ? Promise.resolve(s.transform(o.value, a)).then(i => ({
        status: n.value,
        value: i
      })) : o);
    wt.assertNever(s)
  }
}
au.create = (e, t, n) => new au({
  schema: e,
  typeName: rt.ZodEffects,
  effect: t,
  ...pt(n)
});
au.createWithPreprocess = (e, t, n) => new au({
  schema: t,
  effect: {
    type: "preprocess",
    transform: e
  },
  typeName: rt.ZodEffects,
  ...pt(n)
});
class Io extends _t {
  _parse(t) {
    return this._getType(t) === Be.undefined ? rs(void 0) : this._def.innerType._parse(t)
  }
  unwrap() {
    return this._def.innerType
  }
}
Io.create = (e, t) => new Io({
  innerType: e,
  typeName: rt.ZodOptional,
  ...pt(t)
});
class ou extends _t {
  _parse(t) {
    return this._getType(t) === Be.null ? rs(null) : this._def.innerType._parse(t)
  }
  unwrap() {
    return this._def.innerType
  }
}
ou.create = (e, t) => new ou({
  innerType: e,
  typeName: rt.ZodNullable,
  ...pt(t)
});
class Bm extends _t {
  _parse(t) {
    const {
      ctx: n
    } = this._processInputParams(t);
    let r = n.data;
    return n.parsedType === Be.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: n.path,
      parent: n
    })
  }
  removeDefault() {
    return this._def.innerType
  }
}
Bm.create = (e, t) => new Bm({
  innerType: e,
  typeName: rt.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...pt(t)
});
class jm extends _t {
  _parse(t) {
    const {
      ctx: n
    } = this._processInputParams(t), r = {
      ...n,
      common: {
        ...n.common,
        issues: []
      }
    }, s = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r
      }
    });
    return Zf(s) ? s.then(a => ({
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new Ua(r.common.issues)
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new Ua(r.common.issues)
        },
        input: r.data
      })
    }
  }
  removeCatch() {
    return this._def.innerType
  }
}
jm.create = (e, t) => new jm({
  innerType: e,
  typeName: rt.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...pt(t)
});
class My extends _t {
  _parse(t) {
    if (this._getType(t) !== Be.nan) {
      const r = this._getOrReturnCtx(t);
      return Oe(r, {
        code: Pe.invalid_type,
        expected: Be.nan,
        received: r.parsedType
      }), ot
    }
    return {
      status: "valid",
      value: t.data
    }
  }
}
My.create = e => new My({
  typeName: rt.ZodNaN,
  ...pt(e)
});
class Bj extends _t {
  _parse(t) {
    const {
      ctx: n
    } = this._processInputParams(t), r = n.data;
    return this._def.type._parse({
      data: r,
      path: n.path,
      parent: n
    })
  }
  unwrap() {
    return this._def.type
  }
}
class Cg extends _t {
  _parse(t) {
    const {
      status: n,
      ctx: r
    } = this._processInputParams(t);
    if (r.common.async) return (async () => {
      const a = await this._def.in._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return a.status === "aborted" ? ot : a.status === "dirty" ? (n.dirty(), Ku(a.value)) : this._def.out._parseAsync({
        data: a.value,
        path: r.path,
        parent: r
      })
    })();
    {
      const s = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return s.status === "aborted" ? ot : s.status === "dirty" ? (n.dirty(), {
        status: "dirty",
        value: s.value
      }) : this._def.out._parseSync({
        data: s.value,
        path: r.path,
        parent: r
      })
    }
  }
  static create(t, n) {
    return new Cg({
      in: t,
      out: n,
      typeName: rt.ZodPipeline
    })
  }
}
class Hm extends _t {
  _parse(t) {
    const n = this._def.innerType._parse(t),
      r = s => (nu(s) && (s.value = Object.freeze(s.value)), s);
    return Zf(n) ? n.then(s => r(s)) : r(n)
  }
  unwrap() {
    return this._def.innerType
  }
}
Hm.create = (e, t) => new Hm({
  innerType: e,
  typeName: rt.ZodReadonly,
  ...pt(t)
});
var rt;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly"
})(rt || (rt = {}));
const or = Ao.create,
  ci = ru.create,
  Oy = Rm.create,
  Dy = Fc.create,
  jj = Nm.create;
Vo.create;
const Vm = Zs.create,
  yf = _n.create;
Xf.create;
ep.create;
Vi.create;
const Uu = su.create;
tp.create;
Io.create;
ou.create;
const A9 = -1,
  qp = 0,
  cc = 1,
  np = 2,
  xg = 3,
  kg = 4,
  Sg = 5,
  Eg = 6,
  P9 = 7,
  I9 = 8,
  Ly = typeof self == "object" ? self : globalThis,
  Hj = (e, t) => {
    const n = (s, a) => (e.set(a, s), s),
      r = s => {
        if (e.has(s)) return e.get(s);
        const [a, o] = t[s];
        switch (a) {
          case qp:
          case A9:
            return n(o, s);
          case cc: {
            const i = n([], s);
            for (const l of o) i.push(r(l));
            return i
          }
          case np: {
            const i = n({}, s);
            for (const [l, c] of o) i[r(l)] = r(c);
            return i
          }
          case xg:
            return n(new Date(o), s);
          case kg: {
            const {
              source: i,
              flags: l
            } = o;
            return n(new RegExp(i, l), s)
          }
          case Sg: {
            const i = n(new Map, s);
            for (const [l, c] of o) i.set(r(l), r(c));
            return i
          }
          case Eg: {
            const i = n(new Set, s);
            for (const l of o) i.add(r(l));
            return i
          }
          case P9: {
            const {
              name: i,
              message: l
            } = o;
            return n(new Ly[i](l), s)
          }
          case I9:
            return n(BigInt(o), s);
          case "BigInt":
            return n(Object(BigInt(o)), s);
          case "ArrayBuffer":
            return n(new Uint8Array(o).buffer, o);
          case "DataView": {
            const {
              buffer: i
            } = new Uint8Array(o);
            return n(new DataView(i), o)
          }
        }
        return n(new Ly[a](o), s)
      };
    return r
  },
  Ry = e => Hj(new Map, e)(0),
  sl = "",
  {
    toString: Vj
  } = {},
  {
    keys: Uj
  } = Object,
  zu = e => {
    const t = typeof e;
    if (t !== "object" || !e) return [qp, t];
    const n = Vj.call(e).slice(8, -1);
    switch (n) {
      case "Array":
        return [cc, sl];
      case "Object":
        return [np, sl];
      case "Date":
        return [xg, sl];
      case "RegExp":
        return [kg, sl];
      case "Map":
        return [Sg, sl];
      case "Set":
        return [Eg, sl];
      case "DataView":
        return [cc, n]
    }
    return n.includes("Array") ? [cc, n] : n.includes("Error") ? [P9, n] : [np, n]
  },
  Xd = ([e, t]) => e === qp && (t === "function" || t === "symbol"),
  zj = (e, t, n, r) => {
    const s = (o, i) => {
        const l = r.push(o) - 1;
        return n.set(i, l), l
      },
      a = o => {
        if (n.has(o)) return n.get(o);
        let [i, l] = zu(o);
        switch (i) {
          case qp: {
            let d = o;
            switch (l) {
              case "bigint":
                i = I9, d = o.toString();
                break;
              case "function":
              case "symbol":
                if (e) throw new TypeError("unable to serialize " + l);
                d = null;
                break;
              case "undefined":
                return s([A9], o)
            }
            return s([i, d], o)
          }
          case cc: {
            if (l) {
              let p = o;
              return l === "DataView" ? p = new Uint8Array(o.buffer) : l === "ArrayBuffer" && (p = new Uint8Array(o)), s([l, [...p]], o)
            }
            const d = [],
              f = s([i, d], o);
            for (const p of o) d.push(a(p));
            return f
          }
          case np: {
            if (l) switch (l) {
              case "BigInt":
                return s([l, o.toString()], o);
              case "Boolean":
              case "Number":
              case "String":
                return s([l, o.valueOf()], o)
            }
            if (t && "toJSON" in o) return a(o.toJSON());
            const d = [],
              f = s([i, d], o);
            for (const p of Uj(o))(e || !Xd(zu(o[p]))) && d.push([a(p), a(o[p])]);
            return f
          }
          case xg:
            return s([i, o.toISOString()], o);
          case kg: {
            const {
              source: d,
              flags: f
            } = o;
            return s([i, {
              source: d,
              flags: f
            }], o)
          }
          case Sg: {
            const d = [],
              f = s([i, d], o);
            for (const [p, h] of o)(e || !(Xd(zu(p)) || Xd(zu(h)))) && d.push([a(p), a(h)]);
            return f
          }
          case Eg: {
            const d = [],
              f = s([i, d], o);
            for (const p of o)(e || !Xd(zu(p))) && d.push(a(p));
            return f
          }
        }
        const {
          message: c
        } = o;
        return s([i, {
          name: l,
          message: c
        }], o)
      };
    return a
  },
  Ny = (e, {
    json: t,
    lossy: n
  } = {}) => {
    const r = [];
    return zj(!(t || n), !!t, new Map, r)(e), r
  },
  $9 = typeof structuredClone == "function" ? (e, t) => t && ("json" in t || "lossy" in t) ? Ry(Ny(e, t)) : structuredClone(e) : (e, t) => Ry(Ny(e, t));
var ht = (e => (e.MaxMultiplier = "max_multiplier", e.BetsSum = "bets_sum", e.TopMultiplierSum = "top_multiplier_sum", e.MultipliersSum = "multipliers_sum", e))(ht || {}),
  Pr = (e => (e.Allowed = "allowed", e.DeniedBuy = "denied_buy", e.OnlyFeature = "only_feature", e))(Pr || {}),
  bn = (e => (e.Private = "private", e.Public = "public", e))(bn || {}),
  ln = (e => (e.Regular = "regular", e.P2P = "p2p", e.Influencer = "influencer", e))(ln || {}),
  As = (e => (e.AllowAfterStart = "allow_after_start", e.DenyAfterStart = "deny_after_start", e))(As || {});
const M9 = {
    category: ln.P2P,
    challenge_type: ht.MaxMultiplier,
    image_url: "",
    game_identifiers: [],
    fee: null,
    join_code: null,
    start_at: null,
    finish_at: null,
    top_multiplier_count: null,
    spin_limit: null,
    min_bet: null,
    feature_condition: Pr.Allowed,
    prize_places: [{
      place: 1,
      prize: "0"
    }, {
      place: 2,
      prize: "0"
    }],
    privacy: bn.Private,
    joining_rule: As.AllowAfterStart,
    confirm_fee: !1,
    confirm_creation: !1
  },
  ue = xn($9(M9)),
  O9 = () => {
    tH(), Object.assign(ue, $9(M9))
  },
  na = xn({
    game_identifiers: null,
    fee: null,
    join_code: null,
    start_at: null,
    finish_at: null,
    top_multiplier_count: null,
    spin_limit: null,
    min_bet: null,
    prize_places: null
  }),
  Yj = e => {
    var t;
    (t = na[e]) == null || t.scrollIntoView({
      behavior: "smooth",
      block: "center"
    })
  },
  Wj = () => {
    var e;
    return ((e = dn.game_identifiers) == null ? void 0 : e.value.length) !== ue.game_identifiers.length ? !1 : dn.game_identifiers.value.every((t, n) => t === ue.game_identifiers[n].identifier)
  },
  Gj = () => {
    var e, t;
    return ((t = (e = dn.prize_places) == null ? void 0 : e.value) == null ? void 0 : t.length) !== ue.prize_places.length ? !1 : dn.prize_places.value.every((n, r) => {
      const {
        place: s,
        prize: a
      } = ue.prize_places[r];
      return n.place === s && n.prize === a
    })
  },
  Dr = (e, t, n) => {
    n.addIssue({
      path: [e],
      code: Pe.custom,
      message: t
    })
  };

function Qj(e, t) {
  if (e.category === ln.P2P) {
    if (e.fee === null) return;
    const n = Number(e.fee);
    if (n < .01) {
      Dr("fee", "challenge.p2p.error.must_greater|0.01 EUR", t);
      return
    }
    n > 20 && Dr("fee", "challenge.p2p.error.amount_too_high|20 EUR", t)
  }
}

function qj(e, t) {
  if (e.min_bet === null) return;
  const n = Number(e.min_bet);
  if (n < .01) {
    Dr("min_bet", "challenge.p2p.error.must_greater|0.01 EUR", t);
    return
  }
  n > 20 && Dr("min_bet", "challenge.p2p.error.amount_too_high|20 EUR", t)
}

function Kj(e, t) {
  var r;
  const n = e.prize_places;
  for (let s = 0; s < n.length; s++) {
    const a = n[s].prize,
      o = (r = n[s - 1]) == null ? void 0 : r.prize;
    if (o && o < a) {
      Dr("prize_places", "challenge.p2p.error.prize_exceeds_previous", t);
      return
    }
  }
}

function Zj(e) {
  return e.start_at && e.finish_at ? e.start_at <= e.finish_at : !0
}
const D9 = yf({
    privacy: Uu([bn.Private, bn.Public]),
    confirm_fee: Oy(),
    confirm_creation: Oy(),
    category: Uu([ln.P2P, ln.Influencer]),
    challenge_type: Uu([ht.MaxMultiplier, ht.TopMultiplierSum, ht.BetsSum, ht.MultipliersSum]),
    image_url: or(),
    game_identifiers: Vm(yf({
      identifier: or(),
      title: or(),
      img: or(),
      url: or(),
      bet_sum_eur: ci(),
      max_multiplier: ci()
    })),
    fee: or().nullable(),
    join_code: or().length(5, "challenge.p2p.error.characters|5").regex(/^[a-zA-Z0-9]+$/, "challenge.p2p.error.code_invalid").nullable(),
    start_at: Dy().nullable(),
    finish_at: Dy().nullable(),
    top_multiplier_count: ci().max(99, "challenge.p2p.error.must_less|100").min(2, "challenge.p2p.error.must_greater|1").nullable(),
    spin_limit: ci().min(1, "challenge.p2p.error.must_greater|0").max(999, "challenge.p2p.error.must_less|1000").nullable(),
    min_bet: or().nullable(),
    feature_condition: Uu([Pr.Allowed, Pr.OnlyFeature, Pr.DeniedBuy]),
    prize_places: Vm(yf({
      place: ci(),
      prize: or()
    })),
    joining_rule: Uu([As.AllowAfterStart, As.DenyAfterStart]),
    confirm: jj().optional()
  }).refine(Zj, {
    path: ["start_at"],
    message: "challenge.p2p.error.start_date_invalid"
  }).superRefine((e, t) => {
    Qj(e, t), qj(e, t), Kj(e, t)
  }),
  Jj = D9.superRefine((e, t) => {
    e.game_identifiers.length < 1 && Dr("game_identifiers", "challenge.p2p.error.cannot_be_empty", t);
    const n = e.prize_places.reduce((a, o) => a += Number(o.prize), 0);
    e.category === ln.P2P && n !== 100 && Dr("prize_places", " ", t), e.prize_places.some(a => Number(a.prize) === 0) && Dr("prize_places", "challenge.p2p.error.prize_cannot_be|0", t);
    const s = ["spin_limit", "min_bet", "prize_places"];
    for (const a in vt) {
      const o = a;
      if (!ue[o]) {
        if (s.includes(o) || o === "top_multiplier_count" && e.challenge_type !== ht.TopMultiplierSum || o === "join_code" && e.privacy === bn.Public) continue;
        Dr(o, "challenge.p2p.error.cannot_be_empty", t)
      }
    }
  }).superRefine((e, t) => {
    var n, r, s;
    for (const a in dn) {
      const o = a,
        i = (n = dn[o]) == null ? void 0 : n.message;
      if (i) {
        if (o === "game_identifiers") {
          Wj() ? Dr(o, i, t) : (dn.game_identifiers.value = [], dn.game_identifiers.message = null);
          continue
        }
        if (o === "prize_places") {
          Gj() ? Dr(o, i, t) : (dn.prize_places.value = [], dn.prize_places.message = null);
          continue
        }
        if (o === "start_at" || o === "finish_at") {
          const l = dn[o];
          l != null && l.value && l.value.toString() === ((r = e[o]) == null ? void 0 : r.toString()) ? Dr(o, i, t) : (dn[o].value = null, dn[o].message = null);
          continue
        }
        e[o] === ((s = dn[o]) == null ? void 0 : s.value) ? Dr(o, i, t) : (dn[o].value = null, dn[o].message = null)
      }
    }
  }),
  Fy = {
    default: D9.safeParse,
    afterSubmit: Jj.safeParse
  },
  fl = {
    START_MIN_MINUTES: 20,
    START_DEFAULT_MINUTES: 30,
    START_OFFSET_MONTHS: 1,
    END_MIN_LIMIT_HOURS: 5,
    END_MAX_LIMIT_MONTHS: 3
  },
  Ta = e => `challenge.p2p.error.${e}`,
  Xj = {
    title: Ta("response_title_default"),
    subtitle: Ta("response_subtitle_default"),
    icon: "default"
  },
  By = {
    206: {
      title: Ta("response_title_206"),
      subtitle: Ta("response_subtitle_206"),
      icon: "wallet"
    },
    100: {
      title: Ta("response_title_100"),
      subtitle: Ta("response_subtitle_100"),
      icon: "default"
    }
  },
  eH = {
    "must be at least 20 minutes from now": Ta(`start_date_too_soon|${fl.START_MIN_MINUTES}`),
    "cannot be set when min_bet is present": Ta("min_bet_present"),
    "cannot be set when spin_limit is present": Ta("spin_limit_present")
  },
  jy = L(() => Object.values(vt).some(e => e)),
  rp = U(!1),
  gd = U(!1),
  gs = xn({
    id: null,
    name: null,
    join_code: null,
    privacy: null
  }),
  Um = U(null),
  tH = () => {
    rp.value = !1, gd.value = !1, Object.keys(gs).forEach(e => gs[e] = null)
  },
  vt = xn({
    game_identifiers: null,
    fee: null,
    join_code: null,
    start_at: null,
    finish_at: null,
    top_multiplier_count: null,
    spin_limit: null,
    min_bet: null,
    prize_places: null
  }),
  dn = xn({
    game_identifiers: {
      value: [],
      message: null
    },
    fee: {
      value: null,
      message: null
    },
    join_code: {
      value: null,
      message: null
    },
    start_at: {
      value: null,
      message: null
    },
    finish_at: {
      value: null,
      message: null
    },
    top_multiplier_count: {
      value: null,
      message: null
    },
    spin_limit: {
      value: null,
      message: null
    },
    min_bet: {
      value: null,
      message: null
    },
    prize_places: {
      value: null,
      message: null
    }
  }),
  Tg = () => {
    var t;
    const e = rp.value ? Fy.afterSubmit(ue) : Fy.default(ue);
    sH((t = e.error) == null ? void 0 : t.issues)
  },
  nH = e => {
    e.errors && (Object.keys(e.errors).forEach(t => {
      var n;
      if (t in vt) {
        const r = t,
          s = (n = e.errors) == null ? void 0 : n[r];
        if (!s || !Array.isArray(s) || s.length === 0) return;
        if (dn[r]) {
          switch (r) {
            case "game_identifiers":
              dn.game_identifiers.value = ue[r].map(o => o.identifier);
              break;
            case "prize_places":
              dn[r].value = ue[r].map(o => ({
                place: o.place,
                prize: o.prize
              }));
              break;
            default:
              dn[r].value = ue[r]
          }
          const a = s[0];
          dn[r].message = eH[a] || a
        }
      }
    }), Tg())
  },
  rH = e => {
    e.code === 1 && e.errors ? nH(e) : (Um.value = e.code || -1, bt.error = !0)
  },
  sH = e => {
    if (!e) {
      for (const t in vt) vt[t] = null;
      return
    }
    for (const t in vt) {
      const n = e.findIndex(r => r.path[0] === t);
      n === -1 ? vt[t] = null : vt[t] = e[n].message
    }
  };
Ne(() => ue, () => {
  Tg()
}, {
  deep: !0
});
let sp = null,
  L9 = 0;
Ne(() => vt, e => {
  const t = Object.keys(e).filter(s => e[s]),
    n = t[0] ?? null,
    r = aH(n, t.length);
  L9 = t.length, r ? (sp = n, n && Yj(n)) : sp = null
}, {
  deep: !0
});

function aH(e, t) {
  const n = sp === null,
    r = sp !== e,
    s = L9 > t;
  return (n || r || s) && e !== null
}
const bt = xn({
    loading: !1,
    leave: !1,
    error: !1,
    success: !1,
    closeLobby: !1,
    leavePath: ""
  }),
  R9 = () => {
    bt.leave = !1, bt.leavePath = "", bt.closeLobby = !1, gd.value = !1
  },
  Ag = e => {
    e.fullPath === "/lobby/create/challenge" ? (bt.closeLobby = !0, bt.leave = !0) : ps()
  },
  oH = {
    class: "bg-theme-gray-dark flex h-full flex-col"
  },
  iH = {
    class: "flex h-full w-full min-w-80 gap-0 text-white"
  },
  lH = te({
    __name: "SMScreenLayout",
    props: {
      id: {},
      isActivePath: {}
    },
    setup(e) {
      const t = Mr();
      return wg("lobby-app-wrapper", () => {
        Ag(t)
      }), (r, s) => (g(), k(Ee, null, [m("div", oH, [m("div", iH, [ie(r.$slots, "default")])]), r.id ? z("", !0) : (g(), G(u(bg), {
        key: 0,
        isActivePath: r.isActivePath,
        variant: "bottom"
      }, null, 8, ["isActivePath"]))], 64))
    }
  }),
  uH = e => {
    const t = e.indexOf("/api/");
    return t !== -1 ? e.slice(0, t) : e
  },
  cH = () => uH(Zr.profile_api_url),
  dH = () => "/api/v2/",
  fH = () => {
    const e = Zr.profile_token;
    return e ? {
      headers: {
        Authorization: `Bearer ${e}`
      }
    } : {}
  },
  pH = e => `${cH()}${dH()}${e}`,
  hH = async () => {
    const t = pH("profile");
    return await fetch(t, fH()).then(n => n.json())
  }, Kp = () => ns({
    queryKey: ["profile"],
    queryFn: () => hH(),
    select: e => (e != null && e.id && (wn.value = e.id), e),
    enabled: Zr.profile_enabled && !rd.value,
    refetchInterval: 30 * 1e3,
    placeholderData: ts,
    staleTime: 30 * 1e3
  }), mH = {
    key: 1
  }, gH = {
    class: "block w-full border-white-10 sm:hidden"
  }, vH = {
    class: "relative"
  }, _H = {
    key: 0
  }, yH = {
    key: 2
  }, bH = {
    key: 0,
    class: "flex items-center"
  }, wH = {
    class: "ml-2 w-full sm:ml-3"
  }, CH = {
    class: "flex items-center justify-between"
  }, xH = {
    class: "text-10 font-bold uppercase text-yellow md:text-13 lg:text-16"
  }, kH = {
    class: "text-10 text-white-40 lg:text-14"
  }, SH = {
    class: "mt-1 sm:mt-2"
  }, EH = {
    class: "h-1 w-full rounded-xl bg-black-30"
  }, TH = {
    key: 1,
    class: "flex items-center"
  }, AH = {
    class: "mx-1 w-full border-white-10"
  }, PH = {
    class: "relative"
  }, Zp = te({
    __name: "EventsProfile",
    props: {
      isSearch: {
        type: Boolean
      },
      isOpenedSearch: {
        type: Boolean
      },
      toggleSearch: {
        type: Function
      }
    },
    setup(e) {
      const {
        t
      } = Fe(), n = Mr(), r = L(() => n.path.includes("/lobby/profile`")), {
        data: s,
        isLoading: a
      } = Kp(), {
        data: o
      } = A0(), i = () => {
        Cn.push({
          name: "profile"
        })
      };
      return (l, c) => u(a) ? (g(), k("div", {
        key: 0,
        style: Mt({
          visibility: r.value ? "hidden" : "visible"
        }),
        class: "mx-4 my-2 flex h-full rounded-xl border border-white-10 bg-gray-lighter py-1 pl-1.5 pr-3 sm:m-0 sm:w-48 sm:rounded-none sm:border-0 sm:border-l sm:bg-transparent sm:py-3 sm:pl-3 md:w-56 lg:w-72"
      }, c[4] || (c[4] = [m("div", {
        class: "min-h-5"
      }, null, -1)]), 4)) : u(s) ? (g(), k("div", yH, [l.isOpenedSearch ? (g(), k("div", TH, [m("div", AH, [m("div", PH, [Tn(m("input", {
        "onUpdate:modelValue": c[2] || (c[2] = d => Ht(Cr) ? Cr.value = d : null),
        type: "text",
        class: "shadow-inner inline-flex h-[34px] w-full items-center justify-start gap-2 rounded-3xl bg-[#171922] px-8 py-2 text-13 shadow-[0px_2px_0px_rgba(0,0,0,0.25)] focus:outline-none"
      }, null, 512), [
        [Mi, u(Cr)]
      ]), $(u(Al), {
        class: "absolute left-2.5 top-2 text-15 leading-4 text-white-30"
      }), $(u(_y), {
        class: "absolute right-2.5 top-3 text-15 leading-4 text-white-30",
        onClick: u(Tc)
      }, null, 8, ["onClick"])])]), m("div", {
        onClick: c[3] || (c[3] = (...d) => l.toggleSearch && l.toggleSearch(...d)),
        class: "flex items-center break-words pl-2 text-center text-10 font-medium uppercase leading-3 text-white-30"
      }, " Cancel ")])) : (g(), k("div", bH, [m("div", {
        style: Mt({
          visibility: r.value ? "hidden" : "visible"
        }),
        class: "ml-1 mr-2 flex w-full cursor-pointer rounded-3xl border border-white-10 bg-gray-lighter py-1.5 pl-2 pr-3 sm:m-0 sm:w-48 sm:rounded-none sm:border-0 sm:border-l sm:bg-transparent sm:py-3 sm:pl-3 md:w-56 lg:w-72",
        onClick: i
      }, [$(u(Dm), {
        class: "shrink-0 text-yellow sm:h-6 sm:w-6 md:h-7 md:w-7 lg:h-9 lg:w-9"
      }), m("div", wH, [m("div", CH, [m("div", xH, R(u(t)("profile.level")) + " " + R(u(s).current_level), 1), m("div", kH, R(Math.floor(u(s).current_points - u(s).initial_level_points)) + "/" + R(u(s).points_for_next_level) + R(u(t)("profile.xp")), 1)]), m("div", SH, [m("div", EH, [m("div", {
        class: "h-1 rounded-xl bg-yellow duration-300 ease-linear",
        style: Mt({
          width: u(s).progress + "%"
        })
      }, null, 4)])])])], 4), u(o) && l.isSearch ? (g(), k("div", {
        key: 0,
        onClick: c[1] || (c[1] = (...d) => l.toggleSearch && l.toggleSearch(...d)),
        class: "mr-1 flex h-full w-9 cursor-pointer items-center justify-center rounded-3xl border border-white-10 bg-gray-lighter p-2 sm:hidden"
      }, [$(u(Al), {
        class: "text-16 leading-4 text-white"
      })])) : z("", !0)]))])) : (g(), k("div", mH, [m("div", gH, [m("div", vH, [Tn(m("input", {
        "onUpdate:modelValue": c[0] || (c[0] = d => Ht(Cr) ? Cr.value = d : null),
        type: "text",
        class: "shadow-inner inline-flex h-[34px] w-full items-center justify-start gap-2 rounded-3xl bg-[#171922] px-8 py-2 text-13 shadow-[0px_2px_0px_rgba(0,0,0,0.25)] focus:outline-none"
      }, null, 512), [
        [Mi, u(Cr)]
      ]), l.isSearch ? (g(), k("div", _H, [$(u(Al), {
        class: "absolute left-2.5 top-2 text-15 leading-4 text-white-30"
      }), $(u(_y), {
        class: "absolute right-2.5 top-3 text-15 leading-4 text-white-30",
        onClick: u(Tc)
      }, null, 8, ["onClick"])])) : z("", !0)])])]))
    }
  }), IH = {
    class: "flex h-full bg-gray"
  }, $H = {
    class: "flex w-[calc(100%-5rem)] flex-col"
  }, MH = {
    class: "bg-theme-gray-gray_dark relative z-[55] flex w-full flex-col-reverse border-b border-white-10 sm:flex-row sm:justify-between"
  }, OH = {
    key: 0,
    class: "flex h-14 items-center gap-2 pl-5 text-yellow"
  }, DH = {
    class: "text-transform-theme-none-uppercase text-center font-accent text-18 font-bold"
  }, LH = {
    key: 1,
    class: "flex h-14 items-center gap-2 pl-5 text-yellow"
  }, RH = {
    class: "text-transform-theme-none-uppercase text-center font-accent text-18 font-bold"
  }, NH = {
    key: 2,
    class: "flex h-14 items-center gap-2 pl-5 text-yellow"
  }, FH = {
    class: "text-transform-theme-none-uppercase text-center font-accent text-18 font-bold"
  }, BH = {
    key: 3,
    class: "flex h-14 items-center gap-2 pl-5 text-yellow"
  }, jH = {
    class: "text-transform-theme-none-uppercase text-center font-accent text-18 font-bold"
  }, HH = {
    class: "bg-theme-gray-dark flex h-full w-full min-w-80 gap-0 overflow-hidden text-white"
  }, VH = {
    class: "flex max-h-20 w-full flex-1 items-center justify-center border-b border-white-10"
  }, UH = te({
    __name: "MDScreenLayout",
    props: {
      isActivePath: {}
    },
    setup(e) {
      const {
        t
      } = Fe(), n = Mr(), r = L(() => n.path.includes("/lobby/drop")), s = L(() => n.path.includes("/lobby/challenge")), a = L(() => n.path.includes("/lobby/create/challenge")), o = L(() => n.path.includes("/lobby/profile")), i = L(() => n.path.includes("/lobby/games")), l = () => {
        Ag(n)
      };
      return wg("lobby-app-wrapper", l), (c, d) => (g(), k("div", IH, [m("div", $H, [m("div", MH, [r.value ? (g(), k("div", OH, [$(u(Gp), {
        class: "h-6 w-6"
      }), m("h1", DH, R(u(t)("drop.title")), 1)])) : s.value || a.value ? (g(), k("div", LH, [$(u(md), {
        class: "h-6 w-6"
      }), m("h1", RH, R(u(t)("challenge.title")), 1)])) : o.value ? (g(), k("div", NH, [$(u(_g), {
        class: "h-6 w-6"
      }), m("h1", FH, R(u(t)("profile.title")), 1)])) : i.value ? (g(), k("div", BH, [$(u(vg), {
        class: "h-6 w-6"
      }), m("h1", jH, R(u(t)("games.title")), 1)])) : z("", !0), $(Zp)]), m("div", HH, [ie(c.$slots, "default")])]), $(u(bg), {
        isActivePath: c.isActivePath,
        variant: "right"
      }, {
        default: V(() => [m("div", VH, [$(u(qa), {
          onClick: l,
          class: "size-5 cursor-pointer text-white"
        })])]),
        _: 1
      }, 8, ["isActivePath"])]))
    }
  }), zH = {
    class: "flex h-full rounded-xl border border-white-10"
  }, YH = {
    class: "flex w-[calc(100%-6rem)] flex-col"
  }, WH = {
    class: "bg-theme-gray-gray_dark relative z-[55] flex w-full flex-col-reverse border-b border-white-10 sm:flex-row sm:justify-between"
  }, GH = {
    key: 0,
    class: "flex h-14 items-center gap-2 pl-5 text-yellow"
  }, QH = {
    class: "text-transform-theme-none-uppercase text-center font-accent text-20 font-bold lg:text-22"
  }, qH = {
    key: 1,
    class: "flex h-14 items-center gap-2 pl-5 text-yellow"
  }, KH = {
    class: "text-transform-theme-none-uppercase text-center font-accent text-20 font-bold lg:text-22"
  }, ZH = {
    key: 2,
    class: "flex h-14 items-center gap-2 pl-5 text-yellow"
  }, JH = {
    class: "text-transform-theme-none-uppercase text-center font-accent text-20 font-bold lg:text-22"
  }, XH = {
    key: 3,
    class: "flex h-14 items-center gap-2 pl-5 text-yellow"
  }, eV = {
    class: "text-transform-theme-none-uppercase text-center font-accent text-20 font-bold lg:text-22"
  }, tV = {
    class: "flex items-center"
  }, nV = {
    class: "flex size-14 items-center justify-center border-l border-white-10"
  }, rV = {
    class: "bg-theme-gray-dark flex h-full w-full min-w-80 gap-0 overflow-hidden text-white"
  }, sV = te({
    __name: "LGScreenLayout",
    props: {
      isActivePath: {}
    },
    setup(e) {
      const {
        t
      } = Fe(), n = Mr(), r = L(() => n.path.includes("/lobby/drop")), s = L(() => n.path.includes("/lobby/challenge")), a = L(() => n.path.includes("/lobby/create/challenge")), o = L(() => n.path.includes("/lobby/profile")), i = L(() => n.path.includes("/lobby/games")), l = () => {
        Tc(), Ag(n)
      };
      return wg("lobby-app-wrapper", l), (c, d) => (g(), k("div", zH, [$(u(bg), {
        isActivePath: c.isActivePath,
        variant: "left"
      }, null, 8, ["isActivePath"]), m("div", YH, [m("div", WH, [r.value ? (g(), k("div", GH, [$(u(Gp), {
        class: "h-6 w-6"
      }), m("h1", QH, R(u(t)("drop.title")), 1)])) : s.value || a.value ? (g(), k("div", qH, [$(u(md), {
        class: "h-6 w-6"
      }), m("h1", KH, R(u(t)("challenge.title")), 1)])) : o.value ? (g(), k("div", ZH, [$(u(_g), {
        class: "h-6 w-6"
      }), m("h1", JH, R(u(t)("profile.title")), 1)])) : i.value ? (g(), k("div", XH, [$(u(vg), {
        class: "h-6 w-6"
      }), m("h1", eV, R(u(t)("games.title")), 1)])) : z("", !0), m("div", tV, [$(Zp), m("div", nV, [$(u(qa), {
        onClick: l,
        class: "size-4 cursor-pointer text-white"
      })])])]), m("div", rV, [ie(c.$slots, "default")])])]))
    }
  }), vd = te({
    __name: "PageLayout",
    props: {
      id: {},
      isActivePath: {}
    },
    setup(e) {
      const t = Tr("(max-width: 567px)"),
        n = Tr("(min-width: 568px) and (max-width: 963px)"),
        r = Tr("(min-width: 964px)");
      return (s, a) => (g(), k(Ee, null, [u(t) ? (g(), G(lH, {
        key: 0,
        id: s.id,
        isActivePath: s.isActivePath
      }, {
        default: V(() => [ie(s.$slots, "default")]),
        _: 3
      }, 8, ["id", "isActivePath"])) : z("", !0), u(n) ? (g(), G(UH, {
        key: 1,
        isActivePath: s.isActivePath
      }, {
        default: V(() => [ie(s.$slots, "default")]),
        _: 3
      }, 8, ["isActivePath"])) : z("", !0), u(r) ? (g(), G(sV, {
        key: 2,
        isActivePath: s.isActivePath
      }, {
        default: V(() => [ie(s.$slots, "default")]),
        _: 3
      }, 8, ["isActivePath"])) : z("", !0)], 64))
    }
  }), Jp = te({
    __name: "Card",
    props: {
      class: {}
    },
    setup(e) {
      const t = e;
      return (n, r) => (g(), k("div", {
        class: we(u(rn)("rounded-xl", t.class))
      }, [ie(n.$slots, "default")], 2))
    }
  }), N9 = te({
    __name: "CardHeader",
    props: {
      class: {}
    },
    setup(e) {
      const t = e;
      return (n, r) => (g(), k("div", {
        class: we(u(rn)("flex flex-col", t.class))
      }, [ie(n.$slots, "default")], 2))
    }
  }), F9 = te({
    __name: "CardContent",
    props: {
      class: {}
    },
    setup(e) {
      const t = e;
      return (n, r) => (g(), k("div", {
        class: we(u(rn)("p-6 pt-0", t.class))
      }, [ie(n.$slots, "default")], 2))
    }
  });
var Xp = (e => (e.Manual = "manual", e.Paid = "paid", e))(Xp || {}),
  ut = (e => (e.Draft = "draft", e.BeforePromotion = "before_promotion", e.Promoting = "promoting", e.Ongoing = "ongoing", e.Finalizing = "finalizing", e.ShowingResults = "showing_results", e.Archived = "archived", e.Paused = "paused", e))(ut || {}),
  e1 = (e => (e.Fixed = "fixed", e.Progressive = "progressive", e))(e1 || {});
const aV = {
    class: "m-6 flex w-full flex-col items-center justify-center gap-3 text-center"
  },
  oV = {
    class: "font-accent text-18 font-bold"
  },
  iV = {
    class: "font-accent text-13 font-normal text-white-50"
  },
  Pi = te({
    __name: "EmptyEventList",
    props: {
      title: {},
      subTitle: {},
      isRounded: {
        type: Boolean
      }
    },
    setup(e) {
      return (t, n) => (g(), k("div", {
        class: we(["flex h-full items-center justify-center overflow-hidden bg-gray-lighter", {
          "w-[94%] rounded-3xl": t.isRounded,
          "w-full": !t.isRounded
        }])
      }, [m("div", aV, [m("div", null, [$(u(md), {
        class: "h-24 w-24 text-gray-light"
      })]), m("div", oV, [m("h1", null, R(t.title), 1)]), m("div", iV, [m("p", null, R(t.subTitle), 1)])])], 2))
    }
  }),
  lV = _u("inline-flex items-center rounded-full border px-2.5 py-0.5 text-12 font-semibold transition-colors", {
    variants: {
      variant: {
        default: "border-transparent",
        large: "border-transparent bg-yellow text-gray"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }),
  jc = te({
    __name: "Badge",
    props: {
      variant: {},
      class: {}
    },
    setup(e) {
      const t = e;
      return (n, r) => (g(), k("div", {
        class: we(u(rn)(u(lV)({
          variant: n.variant
        }), t.class))
      }, [ie(n.$slots, "default")], 2))
    }
  }),
  uV = {
    key: 0,
    class: "absolute left-0 top-0 z-[56] w-full"
  },
  cV = {
    class: "flex h-12 w-full items-center justify-center rounded-t-xl border-b border-white-10 bg-gray-lighter"
  },
  dV = {
    class: "flex items-center justify-between gap-2"
  },
  fV = {
    class: "text-theme-white-yellow text-center font-accent text-24 font-bold"
  },
  B9 = te({
    __name: "DetailsStickyHeader",
    props: {
      title: {},
      handleBack: {
        type: Function
      },
      handleClose: {
        type: Function
      }
    },
    setup(e) {
      const t = Tr("(min-width: 568px)");
      return (n, r) => (g(), G(zi, {
        "enter-active-class": "transition-opacity duration-200 ease-out",
        "leave-active-class": "transition-opacity duration-200 ease-in",
        "enter-from-class": "opacity-0",
        "enter-to-class": "opacity-100",
        "leave-from-class": "opacity-100",
        "leave-to-class": "opacity-0"
      }, {
        default: V(() => [u(t) ? z("", !0) : (g(), k("div", uV, [m("div", cV, [n.handleBack ? (g(), G(u(Yp), {
          key: 0,
          class: "absolute left-1 top-1 cursor-pointer hover:scale-95 sm:hidden",
          onClick: n.handleBack
        }, null, 8, ["onClick"])) : z("", !0), m("div", dV, [ie(n.$slots, "default"), m("h1", fV, R(n.title), 1)]), n.handleClose ? (g(), G(u(pr), {
          key: 1,
          class: "absolute right-1 top-1 cursor-pointer hover:scale-95 sm:hidden",
          onClick: n.handleClose
        }, null, 8, ["onClick"])) : z("", !0)])]))]),
        _: 3
      }))
    }
  }),
  j9 = te({
    __name: "EventRuleIcon",
    props: {
      iconType: {}
    },
    setup(e) {
      const t = e,
        n = {
          IconGames: _f,
          IconGoal: fN,
          IconWinner: gN,
          IconId: bN,
          IconBet: kN,
          IconSpin: AN,
          IconSpinCount: MN,
          IconUser: EB,
          IconTimer: IB,
          IconPrize: NR,
          IconGear: rj,
          IconStar: HR,
          IconList: OR
        },
        r = U(t.iconType),
        s = L(() => n[r.value]);
      return (a, o) => (g(), G(Kr(s.value), {
        class: "text-theme-blue-yellow"
      }))
    }
  }),
  Pg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAWYAAACwCAYAAAA8NsSQAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJwSURBVHgB7dRBFQAQAEAx5PEU0D8XNf5hC7G5z30DgIw1AEgRM0CMmAFixAwQI2aAGDEDxIgZIEbMADFiBogRM0CMmAFixAwQI2aAGDEDxIgZIEbMADFiBogRM0CMmAFixAwQI2aAGDEDxIgZIEbMADFiBogRM0CMmAFixAwQI2aAGDEDxIgZIEbMADFiBogRM0CMmAFixAwQI2aAGDEDxIgZIEbMADFiBogRM0CMmAFixAwQI2aAGDEDxIgZIEbMADFiBogRM0CMmAFixAwQI2aAGDEDxIgZIEbMADFiBogRM0CMmAFixAwQI2aAGDEDxIgZIEbMADFiBogRM0CMmAFixAwQI2aAGDEDxIgZIEbMADFiBogRM0CMmAFixAwQI2aAGDEDxIgZIEbMADFiBogRM0CMmAFixAwQI2aAGDEDxIgZIEbMADFiBogRM0CMmAFixAwQI2aAGDEDxIgZIEbMADFiBogRM0CMmAFixAwQI2aAGDEDxIgZIEbMADFiBogRM0CMmAFixAwQI2aAGDEDxIgZIEbMADFiBogRM0CMmAFixAwQI2aAGDEDxIgZIEbMADFiBogRM0CMmAFixAwQI2aAGDEDxIgZIEbMADFiBogRM0CMmAFixAwQI2aAGDEDxIgZIEbMADFiBogRM0CMmAFixAwQI2aAGDEDxIgZIEbMADFiBogRM0CMmAFixAwQI2aAGDEDxIgZIEbMADFiBogRM0CMmAFixAwQI2aAGDEDxIgZIEbMADFiBogRM0CMmAFixAwQI2aAGDEDxIgZIEbMADFiBogRM0CMmAFixAwQI2aAGDEDxIgZIOYDZ78C9HFKiZ0AAAAASUVORK5CYII=",
  Bt = te({
    __name: "DetailsCard",
    props: {
      colored: {
        default: !1
      },
      class: {}
    },
    setup(e) {
      const t = e;
      return (n, r) => (g(), k("div", {
        class: we(u(rn)(u(hV)({
          colored: n.colored
        }), t.class))
      }, [ie(n.$slots, "default")], 2))
    }
  }),
  pV = "relative text-center mx-4 mt-4 box-border flex flex-col gap-5 rounded-xl border pb-5 pl-4 pr-4 pt-5",
  hV = _u(`${pV}`, {
    variants: {
      colored: {
        true: "border-theme-transparent-yellow bg-theme-yellow-dark_gradient",
        false: "box-theme-border-shadow bg-theme-gray-dark_gradient"
      }
    },
    defaultVariants: {
      colored: !1
    }
  }),
  mV = {
    class: "mb-4 flex h-fit flex-col"
  },
  gV = {
    class: "relative w-full"
  },
  vV = {
    class: "relative min-h-36"
  },
  _V = {
    class: "absolute left-0 top-0 flex h-full w-full items-center justify-center bg-transparent"
  },
  yV = {
    key: 0,
    class: "mx-auto my-4 flex w-full justify-center"
  },
  bV = {
    class: "flex gap-3"
  },
  Pl = te({
    __name: "EventDetailsSkeleton",
    props: {
      isLoading: {
        type: Boolean
      },
      isError: {
        type: Boolean
      },
      handleBack: {
        type: Function
      },
      handleClose: {
        type: Function
      }
    },
    setup(e) {
      const {
        t
      } = Fe();
      return (n, r) => (g(), k("div", mV, [m("div", gV, [m("div", vV, [r[0] || (r[0] = m("img", {
        class: "h-auto w-full",
        src: Pg,
        alt: "Skeleton Img"
      }, null, -1)), m("div", _V, [n.isLoading ? (g(), G(u(Ka), {
        key: 0
      })) : z("", !0)])]), n.handleBack ? (g(), G(u(Yp), {
        key: 0,
        class: "absolute left-1 top-1 cursor-pointer hover:scale-95 sm:hidden",
        onClick: n.handleBack
      }, null, 8, ["onClick"])) : z("", !0), n.handleClose ? (g(), G(u(pr), {
        key: 1,
        class: "absolute right-1 top-1 cursor-pointer hover:scale-95 sm:hidden",
        onClick: n.handleClose
      }, null, 8, ["onClick"])) : z("", !0)]), n.isError ? (g(), k("div", yV, [$(u(Pi), {
        isRounded: !0,
        title: u(t)("common.error.details_title"),
        subTitle: u(t)("common.error.sub_title")
      }, null, 8, ["title", "subTitle"])])) : (g(), k(Ee, {
        key: 1
      }, [$(u(Bt), {
        class: "h-12"
      }), $(u(Bt), {
        class: "h-12"
      }), $(u(Bt), {
        class: "h-32"
      }), m("div", bV, [$(u(Bt), {
        class: "mr-0 h-12 w-full"
      }), $(u(Bt), {
        class: "ml-0 h-12 w-full"
      })]), $(u(Bt), {
        class: "h-80"
      })], 64))]))
    }
  });
U(!1);
const wV = _u("general-button-style responsive-button-style focus-button-style disabled-button-style", {
    variants: {
      variant: {
        primary: "bg-button-primary",
        secondary: "bg-button-secondary",
        link: "bg-button-link",
        linkSecondary: "bg-button-link-secondary",
        ghost: "bg-button-ghost",
        processing: "button-processing"
      },
      full: {
        true: "w-full",
        false: "w-auto"
      }
    },
    defaultVariants: {
      variant: "secondary",
      full: !0
    }
  }),
  qt = te({
    __name: "Button",
    props: {
      variant: {},
      full: {},
      class: {},
      asChild: {
        type: Boolean
      },
      as: {
        type: [String, Object, Function],
        default: "button"
      }
    },
    setup(e) {
      const t = e;
      return (n, r) => (g(), G(u(xt), {
        as: n.as,
        "as-child": n.asChild,
        class: we(u(rn)(u(wV)({
          variant: n.variant,
          full: n.full
        }), t.class))
      }, {
        default: V(() => [ie(n.$slots, "default")]),
        _: 3
      }, 8, ["as", "as-child", "class"]))
    }
  }),
  CV = _u("general-title-style", {
    variants: {
      variant: {
        white: "title-white-yellow-capitalize-uppercase",
        black: "title-black-yellow-capitalize-uppercase",
        blackNoneTransform: "title-black-yellow-default-uppercase",
        whiteNoneTransform: "title-white-yellow-default-uppercase"
      }
    },
    defaultVariants: {
      variant: "white"
    }
  }),
  Za = te({
    __name: "Title",
    props: {
      class: {},
      variant: {},
      asChild: {
        type: Boolean
      },
      as: {
        type: [String, Object, Function],
        default: "h2"
      }
    },
    setup(e) {
      const t = e;
      return (n, r) => (g(), G(u(xt), {
        as: n.as,
        "as-child": n.asChild,
        class: we(u(rn)(u(CV)({
          variant: n.variant
        }), t.class))
      }, {
        default: V(() => [ie(n.$slots, "default")]),
        _: 3
      }, 8, ["as", "as-child", "class"]))
    }
  });
let zm = null;
const Hy = new Map,
  xV = 500;

function kV(e) {
  zm = e
}

function SV(e) {
  var s, a;
  const t = (s = e == null ? void 0 : e.payload) == null ? void 0 : s.eventName,
    n = (a = e == null ? void 0 : e.payload) == null ? void 0 : a.eventData,
    r = JSON.stringify(n ?? {});
  return `${t}::${r}`
}

function Jt(e) {
  var s;
  if (!zm) {
    console.error("CommandDispatcher | sendCommand не инициализирован");
    return
  }
  const t = Date.now(),
    n = SV(e),
    r = Hy.get(n);
  if (r && t - r.timestamp < xV) {
    console.warn(`CommandDispatcher | Пропущено повторное событие: ${n}`);
    return
  }(s = e == null ? void 0 : e.payload) != null && s.eventData && typeof e.payload.eventData == "object" && (e.payload.eventData.game_identifier = Kn.identifier), Hy.set(n, {
    timestamp: t
  }), zm("dispatch_event", e)
}
const EV = {
    class: "flex w-full items-center justify-center"
  },
  TV = {
    class: "flex flex-col gap-4"
  },
  AV = {
    class: "flex-1 leading-multiline"
  },
  Vy = 6,
  H9 = te({
    __name: "EventRules",
    props: {
      rulesList: {},
      id: {},
      challenge: {}
    },
    setup(e) {
      const {
        t
      } = Fe(), n = e, r = U(!1), s = L(() => r.value ? n.rulesList : n.rulesList.slice(0, Vy)), a = () => {
        var o, i, l;
        (o = n.challenge) != null && o.id && Jt({
          payload: {
            eventName: r.value ? "lobby_challenges_how_to_closed" : "lobby_challenges_how_to_open",
            eventData: {
              player_id: wn.value,
              challenge_id: (i = n.challenge) == null ? void 0 : i.id,
              challenge_status: (l = n.challenge) == null ? void 0 : l.status
            }
          }
        }), r.value = !r.value
      };
      return (o, i) => (g(), G(u(Bt), {
        id: o.id,
        class: "text-theme-white-opacity"
      }, {
        default: V(() => [m("div", EV, [$(Za, null, {
          default: V(() => [Ye(R(u(t)("challenge.rules.title")), 1)]),
          _: 1
        })]), m("div", TV, [(g(!0), k(Ee, null, Je(s.value, ({
          iconType: l,
          text: c
        }) => (g(), k("div", {
          key: c,
          class: "flex items-start justify-start gap-4 text-left text-13"
        }, [$(u(j9), {
          iconType: l
        }, null, 8, ["iconType"]), m("p", AV, R(c), 1)]))), 128))]), o.rulesList.length > Vy ? (g(), G(qt, {
          key: 0,
          onClick: a
        }, {
          default: V(() => [Ye(R(r.value ? u(t)("common.button.roll_up") : u(t)("common.button.show_more")), 1)]),
          _: 1
        })) : z("", !0)]),
        _: 1
      }, 8, ["id"]))
    }
  }),
  V9 = te({
    __name: "TimerCheckingStatus",
    props: {
      isSelected: {
        type: Boolean
      },
      isCompact: {
        type: Boolean
      }
    },
    setup(e) {
      const {
        t
      } = Fe();
      return (n, r) => (g(), k("div", {
        class: we(["flex w-full", {
          "items-start": n.isCompact,
          "items-center justify-center": !n.isCompact
        }])
      }, [m("div", {
        class: we(["flex items-center justify-center gap-2", {
          "min-h-[18px] flex-row": n.isCompact,
          "h-[44px] flex-col": !n.isCompact
        }])
      }, [$(u(Ka), {
        "is-secondary": !!n.isSelected,
        width: "12",
        height: "12"
      }, null, 8, ["is-secondary"]), m("div", {
        class: we(["text-14 uppercase", {
          "text-gray": n.isSelected,
          "text-gray-400": !n.isSelected
        }])
      }, R(u(t)("common.event_status.checking_status")), 3)], 2)], 2))
    }
  }),
  PV = () => "/api/games/",
  IV = () => {
    const e = Zr.gamelist_token;
    return e ? {
      headers: {
        Authorization: `Bearer ${e}`
      }
    } : {}
  },
  $V = e => `${Zr.gamelist_api_url}${PV()}${e}`,
  MV = async () => {
    const t = $V("all");
    return await fetch(t, IV()).then(n => n.json())
  };

function OV(e, t, n) {
  const r = new URL(e);
  return r.searchParams.set(t, n), r.toString()
}

function DV(e) {
  if (!e || !e.length) return [];
  let t = [];
  return t = e.map(n => n.includes("low") ? "low" : n.includes("medium") ? "medium" : n.includes("high") ? "high" : n), Array.from(new Set(t))
}
const LV = yf({
    title: or(),
    identifier: or(),
    max_multiplier: or().nullable(),
    volatility: Vm(or()).nullable(),
    released_at: or(),
    category: or().nullable(),
    effective_rtp: ci(),
    bet_sum_eur: ci()
  }).transform(e => {
    const t = OV(Kn.lobby_launch_url, "game", e.identifier);
    return {
      ...e,
      volatility: DV(e.volatility),
      img: `https://cdn.softswiss.net/i/s3/softswiss/${e.identifier}.png`,
      url: t,
      released_at: new Date(e.released_at),
      max_multiplier: parseFloat(e.max_multiplier || "0")
    }
  }),
  Ig = () => ns({
    queryKey: ["games"],
    queryFn: () => MV(),
    select: e => e.map(t => LV.parse(t)).sort((t, n) => n.bet_sum_eur - t.bet_sum_eur),
    refetchInterval: !1,
    staleTime: 30 * 60 * 1e3,
    placeholderData: ts
  });

function U9(e) {
  let t = null,
    n = e.startAfterRootAdding;
  const {
    rootMargin: r = "0px",
    threshold: s = .1
  } = e;
  let a = null;
  const o = typeof window < "u" && "IntersectionObserver" in window && "isIntersecting" in IntersectionObserverEntry.prototype,
    i = h => {
      h.src = h.dataset.src || ""
    },
    l = new Set,
    c = h => {
      if (h instanceof Element) {
        if (!o) {
          i(h);
          return
        }
        l.has(h) || (l.add(h), !n && a && a.observe(h))
      }
    },
    d = h => {
      h instanceof Element && (a == null || a.unobserve(h))
    },
    f = () => {
      a && a.disconnect();
      const h = t instanceof Element || t instanceof Document ? t : null;
      a = new IntersectionObserver(_ => {
        _.forEach(v => {
          v.isIntersecting && (i(v.target), d(v.target), l.delete(v.target))
        })
      }, {
        root: h,
        rootMargin: r,
        threshold: s
      })
    };
  return n || f(), {
    addIntersectionObserver: c,
    setRoot: h => {
      if (t = h instanceof Element || h instanceof Document ? h : null, n) {
        f(), l.forEach(_ => a == null ? void 0 : a.observe(_)), l.clear(), n = !1;
        return
      }
    }
  }
}
const RV = {
    class: "flex w-full items-center justify-center"
  },
  NV = {
    class: "relative flex h-28 cursor-default justify-center"
  },
  FV = ["src", "data-src", "onError"],
  Ym = te({
    __name: "ParticipatingGames",
    props: {
      gameIdentifiers: {},
      eventId: {},
      querySource: {},
      sendEventOpening: {
        type: Function
      }
    },
    setup(e) {
      const {
        t
      } = Fe(), n = e, {
        addIntersectionObserver: r
      } = U9({}), {
        data: s
      } = Ig(), a = L(() => {
        const _ = s.value && n.gameIdentifiers ? s.value.filter(y => n.gameIdentifiers.includes(y.identifier)) : [],
          v = Kn.identifier;
        if (!_.some(y => y.identifier === v) && n.gameIdentifiers.includes(v)) return [{
          identifier: v,
          title: CR(v),
          img: `https://cdn.softswiss.net/i/s3/softswiss/${v}.png`,
          url: ""
        }, ..._];
        {
          const y = _.findIndex(b => b.identifier === v);
          if (y > 0) {
            const b = _[y],
              w = _.filter((x, E) => E !== y);
            return [b, ...w]
          }
          return _
        }
      }), o = L(() => a.value), i = U([]), l = U(null), c = U(1), d = () => new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAXwAAAF8CAYAAADM5wDKAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAxnSURBVHgB7d2/j1VlGsDxV3GFVWYZVLKBkAUSMsYKDH+AYw8CJTaODZZgtJ+hlwRKaYBipQSFnqGXiO2ELLBrUBcVyKCLMS47z03YWIhw7zn3vOfyfD4J8UdlMXx5fc57nvPMg89fe1AAeOo9WwBIQfABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCSeK9Ci/R9+Va4s3S+TauvGPw3+Oj21avD3Wzf9qeyYWTP4550zqwtMMsGnVXeW/1uu3/ylTKo/+m+fnnp2JfprBr/e2PVimd31wuDfwaR45sHnrz0o0JI33/tnWbz8Y8kior9vdqrsXfn18P8OoK8cT6CBxcs/lcNHvy3b9lxd+cPuRjl94W6BvhJ8aEnEf27hZtn21tXy7pGb5frXkzva4ukk+NCyeA5w6vzdwan//aPfCD+9IfgwRsfO3DbqoTcEH8YsTvwPRz1O+9Qk+NCRCH+MeY6cuFWgBsGHji2c+G4w5nHap2uCDxXEjR7Rp2uCD5XEiOf1t6+VK0s/F+iC4ENFd5Z/HZz0RZ8uCD5U9jD6xjuMm+BDDzyMfiyfg3ERfOiJmOnHSgYYF8GHHjm3uFyOn/mhwDgIPvRM3NM32mEcBB96Jub5R078u0DbBB96KJauubVD2wQfesrOHdom+NBT5xbvmeXTKh8xZyJdO7+98TdkY2QSVyGvLN0vly7/NPgWb58CG7P842e+L/MHNxRogxM+acUfGPER8sMHXipnP9pcbl98tZxc2FS2burPx8jjmia0RfDhN+Z2ryvXPtvem/DHjp3YrAltEHz4HRH+ix9v6UX0L62MmqANgg+PECOfL/6+reycWVNqcsKnLYIPf2B6atXKSf9vVaMfYx23dWiD4MNjRPTPHt288tc6v13itk7cJIKmBB+eQIx3Dh94udTypeDTAsGHJ3TowPpqp/x4XwCaEnx4QjHaqXXKt1eHNgg+DOGd3etKDWb4tEHwYQhxL7/G3Xy3dGiD4MOQZne9WLoWN3WgKcGHIe2cWV1qMMenKcGHITXd0gm1CD4Macum5wtMIsGHIU2v9duGyeQnFyAJwYcJMb12VYEmBB8mRK21Djw9/ATBkO7c6/4lqD59dpHJJfgwpBovQbkKShsEH4ZU4wWoWNwGTQk+DOlGhVXFs7teKNCU4MOQanxjdkfl7+rydBB8GNKVpf+Urjnh0wbBhyHE6b7rVcViT1sEH4Zw+sKd0rV39kwXaIPgwxOK2zmnzt8tXXPCpy2CD0/odKXYu4NPWwQfnkCc7hdO3CpdM86hTYIPjxGxf/O9G6VrsU5hrtJH03k6CT78gbiRs/+Dr8r1Ci9bzR/cUKBNgg+P8PBkf2Xpfuma0z3jIPjwO+K+fa3Yh4sfbynQtucK8H8R+iMrD2drrE94aP7gK27mMBaCT3pXln4uly7/WM4tLlcNfZjd9WJZMLtnTASfifTuws3SVMzoY7d916sSHiXm9icXNhYYF8FnItU+ibctYh9ze6McxslDW6hM7OmK4ENFO2fWiD2dEXyo5NCBl8oXn2wTezpjhg8dGzycnd9kCyadE3zoyPTUsyun+pfL4ZWTffw9dE3wYcyEnr7w0wdjNj21qny5dL98eml5cPcfanHChzGLTZvxK97kDTG7n9szXd6xHI2OOeFDx+KlsbmFm2XbW1fL6Qvdf0WLvAQfKolTf4T/9bf/YdRDJwQfKovlbdv2XC3Hz/xQYJwEH3ri8NFvy/tHvykwLoIPPXLszO2y/8OverPBk6eL4EPPxG2e/R/+q0DbBB96KG7yGO/QNsGHnorxjge5tEnwoccWTnznyiat8aYtE+na+e1jWSscD0uvLN0f/Lq0MlZZvPxj1Qeo8QnG+Jxj7MyHppzw4TdiuVmsPohFZ2c/2lxuX3y1nFzYNFhpXEvM872RSxsEHx5jbve6cu2z7WX+4IZSy8KJW65q0pjgwxNaOPjK4NRfY8VxrGE4fub7Ak0IPgxh3+zU4GtVNcStHad8mhB8GFJEP2b8XYsHuLFTH0Yl+DCC+ZXxTo3RzqnzdwqMSvBhBPEVq8MHXi5dixs77uUzKsGHER06sL7KKf+0Uz4jEnwYUZzy53ZPl67FKR9GIfjQwN6VB7hdi+C7rcMoBB8a2DmzuspYJ1Y+wLAEHxqIsc7OmT+Xrl0y1mEEgg8NxSm/a27qMArBh4ZqLFaLbZ4wLMGHhsaxpvlxYrcODEvwoaEtm54vNbipw7AEHxqaXlvnt9Gde78WGIbgw4RywmdYgg8N1biHH2J7JgxD8KGhuIsPk0DwoSEnbSaF4ENDZulMCsGHhu7cqxN8oySGJfjQUK2RTq2HxUwuPzHQ0JeV1hzUeMOXySb40FCNNQfGOYxC8KGhK0s/l65t3fhcgWEJPjQQ8/saHyNxwmcUgg8N1PoQyc6ZNQWGJfjQwKkLd0sNNXbwM/kEH0YUX506t7hcatjhhM8IBB9GdOTErVLL7K4XCgxL8GEEiyuz+1Pn64xzxJ5RCT4MKUY57x65WWqZ3fVigVEIPgwhYv/mezeqflN27+xUgVEIPjyhGOPUjn3cztk5s7rAKLyuB48R64/jAe2xMz+U2oxzaELw4XdE5M9dWi6nz98ZnOz7Yv7gKwVGJfhMpE8Xl8u6FtcL3F3+dTCqid32sSqh5tjmUeJ2jg2ZNCH4TKTDR78t2Rw68FKBJjy0hQkQD2v3uZ1DQ4IPE+Dk/KYCTQk+9Nzcnmlv19IKwYcei1GOmzm0RfChx+YPbnAzh9YIPvRU3MqZ272uQFsEH3oovmh17IO/FmiT4EPPxNz+7NHNBdom+NAjEfuLH28xt2csvGkLPRFjnIj99JRzGOPhJwt6IB7QfvHJNrFnrJzwoaIIfFy9PGxPDh0QfKgkdtufXNhoXk9nBB865lRPLYIPHYq9OLEqwameGgQfOhDjmwi9JWjUJPgwJjG6mdu9vhx6e70TPb0g+NCyOM3vnV27Evtp1yzpFcGHhiLq+2b/Ut5YGdfse2NK5OktwYchxOqDeCN268bny45XV/uwOBPlmQefv/agQEsWL/9Urn/9S3laRMzjxD49tUrYmXiCD5CEYSNAEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyTxP61ZuRoVO2pjAAAAAElFTkSuQmCC", import.meta.url).href, f = (_, v) => {
        const C = _.target;
        C.src = d(), i.value.includes(v) || i.value.push(v)
      }, p = () => {
        l.value && (c.value = l.value.offsetWidth / 170)
      }, h = L(() => {
        let _ = 0;
        return _ = Math.round(16 * c.value), _ < 10 ? _ = 10 : _ > 24 && (_ = 24), `text-${_}`
      });
      return Ne(() => [l.value], () => p(), {
        immediate: !0
      }), Ge(() => {
        window.addEventListener("resize", p)
      }), en(() => {
        i.value = [], window.removeEventListener("resize", p)
      }), (_, v) => a.value.length ? (g(), G(u(Bt), {
        key: 0,
        id: "participating-games"
      }, {
        default: V(() => [m("div", RV, [$(u(Za), null, {
          default: V(() => [Ye(R(u(t)("challenge.games.title")), 1)]),
          _: 1
        })]), m("div", NV, [$(u(Jn), {
          class: "absolute left-0 flex h-full w-full"
        }, {
          default: V(() => [m("div", {
            class: we(["flex gap-2", {
              "justify-start": o.value.length > 2,
              "justify-center": o.value.length < 3,
              "md:justify-start": o.value.length > 4,
              "md:justify-center": o.value.length < 5
            }])
          }, [(g(!0), k(Ee, null, Je(o.value, (C, y) => (g(), k("div", {
            key: C.identifier,
            class: "relative h-24 w-24 flex-none",
            ref_for: !0,
            ref: b => y === 0 ? l.value = b : null
          }, [m("img", {
            ref_for: !0,
            ref: b => u(r)(b),
            src: d(),
            "data-src": C.img,
            onError: b => f(b, C.identifier),
            class: "h-full w-full rounded-lg object-cover",
            draggable: "false"
          }, null, 40, FV), i.value.includes(C.identifier) ? (g(), k("div", {
            key: 0,
            class: we(["text-theme-black-white absolute top-[65%] flex w-full flex-wrap justify-center px-3 font-accent font-bold uppercase", h.value])
          }, R(C.title), 3)) : z("", !0)]))), 128))], 2)]),
          _: 1
        })])]),
        _: 1
      })) : z("", !0)
    }
  }),
  BV = {
    key: 0
  },
  jV = {
    key: 0
  },
  HV = {
    key: 1,
    class: "flex grow flex-col items-center justify-center gap-1 text-10 font-medium text-gray-lightest lg:text-14"
  },
  VV = {
    key: 0,
    class: "flex h-7 items-baseline gap-1"
  },
  UV = {
    class: "font-accent text-20 font-bold text-white lg:text-28"
  },
  zV = {
    class: "font-accent text-20 font-bold text-white lg:text-28"
  },
  YV = {
    class: "font-accent text-20 font-bold text-white lg:text-28"
  },
  WV = {
    key: 1,
    class: "flex h-7 items-baseline gap-1"
  },
  GV = {
    class: "font-accent text-20 font-bold text-white lg:text-28"
  },
  QV = {
    class: "font-accent text-20 font-bold text-white lg:text-28"
  },
  qV = {
    class: "font-accent text-20 font-bold text-white lg:text-28"
  },
  KV = {
    class: "flex items-center gap-2 uppercase"
  },
  $g = te({
    __name: "DropTimer",
    props: {
      id: {},
      status: {},
      isCompactMode: {
        type: Boolean
      },
      start_at: {},
      finish_at: {},
      isSelected: {
        type: Boolean
      }
    },
    setup(e) {
      const {
        t
      } = Fe(), n = e;
      let r = U(!1);
      const s = L(() => {
          switch (n.status) {
            case ut.Ongoing:
              return t("common.event_timer.end_title");
            case ut.Promoting:
              return t("common.event_timer.start_title");
            default:
              return ""
          }
        }),
        a = L(() => {
          switch (n.status) {
            case ut.Ongoing:
              return t("common.event_status.active");
            case ut.Promoting:
              return t("common.event_status.planned");
            default:
              return ""
          }
        }),
        o = U({
          days: 0,
          hours: 0,
          minutes: 0,
          seconds: 0
        }),
        i = () => {
          const f = new Date(n.status === ut.Ongoing ? n.finish_at : n.start_at),
            p = new Date,
            h = f.getTime() - p.getTime(),
            _ = Math.floor(h / (1e3 * 60 * 60 * 24)),
            v = Math.floor(h % (1e3 * 60 * 60 * 24) / (1e3 * 60 * 60)),
            C = Math.floor(h % (1e3 * 60 * 60) / (1e3 * 60)),
            y = Math.floor(h % (1e3 * 60) / 1e3);
          return {
            days: _,
            hours: v,
            minutes: C,
            seconds: y
          }
        },
        l = () => {
          if (n.status === ut.Archived) return !1;
          const f = new Date().getTime(),
            p = n.status === ut.Ongoing ? n.finish_at : n.start_at;
          return f > new Date(p).getTime()
        },
        c = () => {
          const f = i();
          if ((n.status === ut.Ongoing || n.status === ut.Promoting) && l()) {
            vk(), r.value = !0;
            return
          }
          r.value = !1, !(f.seconds < 0) && (o.value = f)
        };
      let d = null;
      return Ge(() => {
        c(), d = setInterval(c, 1e3)
      }), en(() => {
        d && clearInterval(d)
      }), Ne(() => [n.start_at, n.finish_at], () => {
        c(), d && clearInterval(d), d = setInterval(c, 1e3)
      }), (f, p) => u(r) ? (g(), G(u(V9), {
        key: 0,
        isSelected: !!f.isSelected,
        isCompact: !!f.isCompactMode
      }, null, 8, ["isSelected", "isCompact"])) : (g(), k(Ee, {
        key: 1
      }, [f.isCompactMode ? (g(), k("div", BV, [m("div", {
        class: we(["flex min-h-[18px] flex-wrap items-center text-12 uppercase md:text-13 lg:text-14", {
          "text-green": f.status === u(ut).Ongoing && !f.isSelected,
          "text-violet": f.status === u(ut).Promoting && !f.isSelected,
          "text-gray": f.isSelected,
          "opacity-25": f.status === u(ut).Archived
        }])
      }, [f.status !== u(ut).Archived ? (g(), k("div", jV, R(a.value) + " • ", 1)) : z("", !0), m("div", null, R(u(ta)(f.start_at, u(Kn).locale).full) + " - " + R(u(ta)(f.finish_at, u(Kn).locale).full), 1)], 2)])) : (g(), k("div", HV, [o.value.days > 0 ? (g(), k("p", VV, [m("span", UV, R(o.value.days), 1), p[0] || (p[0] = m("span", null, "d", -1)), p[1] || (p[1] = m("span", {
        class: "pb-1 text-11"
      }, ":", -1)), m("span", zV, R(o.value.hours.toString().padStart(2, "0")), 1), p[2] || (p[2] = m("span", null, "h", -1)), p[3] || (p[3] = m("span", {
        class: "pb-1 text-11"
      }, ":", -1)), m("span", YV, R(o.value.minutes.toString().padStart(2, "0")), 1), p[4] || (p[4] = m("span", null, "m", -1))])) : (g(), k("p", WV, [m("span", GV, R(o.value.hours.toString().padStart(2, "0")), 1), p[5] || (p[5] = m("span", null, "h", -1)), p[6] || (p[6] = m("span", {
        class: "pb-1 text-11"
      }, ":", -1)), m("span", QV, R(o.value.minutes.toString().padStart(2, "0")), 1), p[7] || (p[7] = m("span", null, "m", -1)), p[8] || (p[8] = m("span", {
        class: "pb-1 text-11"
      }, ":", -1)), m("span", qV, R(o.value.seconds.toString().padStart(2, "0")), 1), p[9] || (p[9] = m("span", null, "s", -1))])), m("div", KV, [m("span", {
        class: we({
          "text-green": f.status === u(ut).Ongoing,
          "text-violet": f.status === u(ut).Promoting
        })
      }, R(f.status === u(ut).Ongoing ? u(t)("common.event_status.active") : f.status === u(ut).Promoting ? u(t)("common.event_status.planned") : ""), 3), p[10] || (p[10] = m("span", null, "•", -1)), m("span", null, R(s.value), 1)])]))], 64))
    }
  }),
  ZV = {
    class: "flex items-center gap-3"
  },
  JV = {
    class: "flex flex-col gap-1"
  },
  XV = {
    class: "item-end ml-auto w-auto self-start pr-2 pt-1"
  },
  eU = te({
    __name: "DropListCardCompact",
    props: {
      campaign: {},
      isSubsribed: {
        type: Boolean
      },
      status: {},
      finished: {
        type: Boolean
      },
      isSelected: {
        type: Boolean
      }
    },
    setup(e) {
      const {
        t
      } = Fe();
      return (n, r) => (g(), G(u(Jp), {
        class: we(["mx-4 mb-4 cursor-pointer gap-0 overflow-hidden border-t border-white-10 p-3 sm:mx-0 sm:mb-0 sm:rounded-none md:p-4 lg:p-5", {
          "bg-gray-lighter": !n.isSelected,
          "bg-yellow text-black": n.isSelected,
          "bg-opacity-50": n.finished
        }])
      }, {
        default: V(() => [m("div", ZV, [m("div", JV, [m("h2", {
          class: we(["text-14 font-bold md:text-16 lg:text-18", {
            "opacity-50": n.finished
          }])
        }, R(n.campaign.public_name), 3), n.finished ? z("", !0) : (g(), k("div", {
          key: 0,
          class: we(["text-12 uppercase opacity-50 md:text-13 lg:text-14", {
            "text-white-50": !n.isSelected,
            "text-gray": n.isSelected
          }])
        }, R(n.campaign.join_rule === u(Xp).Paid ? u(t)("drop.join.join_pro_badge") : u(t)("drop.join.badge")), 3)), $($g, {
          id: n.campaign.id,
          status: n.status,
          isCompactMode: !0,
          start_at: n.campaign.start_at,
          finish_at: n.campaign.end_at,
          isSelected: n.isSelected
        }, null, 8, ["id", "status", "start_at", "finish_at", "isSelected"])]), m("div", XV, [!n.isSelected && n.isSubsribed ? (g(), G(u(Qp), {
          key: 0,
          class: we(["text-theme-blue-green h-5 w-5", {
            "text-gray": n.isSelected
          }])
        }, null, 8, ["class"])) : z("", !0), n.isSelected && n.isSubsribed ? (g(), G(u(Wp), {
          key: 1,
          class: we(["h-5 w-5 text-gray", {
            "text-opacity-50": n.finished
          }])
        }, null, 8, ["class"])) : z("", !0)])])]),
        _: 1
      }, 8, ["class"]))
    }
  }),
  _d = te({
    __name: "Popover",
    props: {
      defaultOpen: {
        type: Boolean
      },
      open: {
        type: Boolean
      },
      modal: {
        type: Boolean
      }
    },
    emits: ["update:open"],
    setup(e, {
      emit: t
    }) {
      const s = Ga(e, t);
      return (a, o) => (g(), G(u(MA), Nt(Qt(u(s))), {
        default: V(() => [ie(a.$slots, "default")]),
        _: 3
      }, 16))
    }
  }),
  yd = te({
    __name: "PopoverTrigger",
    props: {
      asChild: {
        type: Boolean
      },
      as: {
        type: [String, Object, Function]
      }
    },
    setup(e) {
      const t = e,
        n = r => {
          r.stopPropagation()
        };
      return (r, s) => (g(), G(u(OA), Le(t, {
        onClick: n
      }), {
        default: V(() => [ie(r.$slots, "default")]),
        _: 3
      }, 16))
    }
  }),
  bd = te({
    inheritAttrs: !1,
    __name: "PopoverContent",
    props: {
      forceMount: {
        type: Boolean
      },
      trapFocus: {
        type: Boolean
      },
      side: {
        default: "bottom"
      },
      sideOffset: {
        default: 4
      },
      align: {
        default: "center"
      },
      alignOffset: {},
      avoidCollisions: {
        type: Boolean
      },
      collisionBoundary: {},
      collisionPadding: {},
      arrowPadding: {},
      sticky: {},
      hideWhenDetached: {
        type: Boolean,
        default: !0
      },
      updatePositionStrategy: {},
      prioritizePosition: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {},
      disableOutsidePointerEvents: {
        type: Boolean
      },
      class: {}
    },
    emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
    setup(e, {
      emit: t
    }) {
      const n = e,
        r = t,
        s = L(() => {
          const {
            class: o,
            ...i
          } = n;
          return i
        }),
        a = Ga(s, r);
      return (o, i) => (g(), G(u(RA), Le({
        ...u(a),
        ...o.$attrs
      }, {
        class: u(rn)("z-50 w-auto max-w-72 rounded-md border bg-gray-tooltip fill-gray-tooltip px-3 py-1.5 text-24 font-bold text-black shadow-[0_0_10px_0_rgba(0,0,0)] outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2", n.class)
      }), {
        default: V(() => [ie(o.$slots, "default"), $(u(NA), {
          width: 12,
          height: 8
        })]),
        _: 3
      }, 16, ["class"]))
    }
  }),
  Il = (e = "default", t = null) => t || tU(e),
  tU = (e = "default") => `https://drops-skins.bgaming-network.com/skins/${Do.value==="_dark"?"sp_2025":e}/header.png`,
  nU = () => "https://drops-skins.bgaming-network.com/skins/icons/icon_1.png",
  rU = () => "https://drops-skins.bgaming-network.com/skins/icons/icon_2.png",
  sU = () => "https://drops-skins.bgaming-network.com/skins/icons/icon_3.png",
  aU = () => "https://drops-skins.bgaming-network.com/skins/icons/icon_4.png",
  oU = () => "https://drops-skins.bgaming-network.com/skins/icons/icon_5.png",
  iU = {
    class: "relative w-full"
  },
  lU = ["src"],
  uU = {
    key: 1,
    src: Pg,
    alt: "Event",
    class: "relative w-full"
  },
  cU = {
    class: "text-12 font-normal uppercase md:text-20"
  },
  dU = {
    class: "flex items-center gap-3 px-3 py-3"
  },
  fU = {
    class: "font-accent text-20 font-bold"
  },
  pU = {
    class: "flex justify-between gap-2.5 px-3 pb-3"
  },
  hU = {
    class: "flex w-full flex-col items-center gap-1 rounded-lg border-b border-white-10 bg-black-30 p-4"
  },
  mU = {
    class: "text-10 font-medium uppercase text-white-50"
  },
  gU = {
    class: "flex gap-1 font-accent text-16 font-bold"
  },
  vU = {
    class: "flex w-full rounded-lg border-b border-white-10 bg-black-30 p-4"
  },
  _U = te({
    __name: "DropListCard",
    props: {
      campaign: {},
      playerActive: {
        type: Boolean
      },
      isEmpty: {
        type: Boolean
      }
    },
    setup(e) {
      const {
        t
      } = Fe(), n = e, r = L(() => n.campaign.campaign_currency !== "EUR"), s = L(() => n.campaign.total_prize_pool_cents_in_campaign_currency ? r.value ? zp(n.campaign.total_prize_pool_cents_in_player_currency || 0) : m9(n.campaign.total_prize_pool_cents_in_campaign_currency || 0) : null), a = L(() => n.campaign.total_prize_pool_cents_in_campaign_currency ? r.value ? Rt(n.campaign.total_prize_pool_cents_in_player_currency || 0) : Gn(n.campaign.total_prize_pool_cents_in_campaign_currency || 0) : null);
      return (o, i) => (g(), G(u(Jp), {
        class: "mx-3 mb-4 overflow-hidden rounded-3xl border border-white-10 bg-gray-lighter"
      }, {
        default: V(() => [$(u(N9), {
          class: "flex items-center border-b-0 border-l-0 border-t-0"
        }, {
          default: V(() => [m("div", iU, [u(Il)(o.campaign.skin, o.campaign.custom_header_url) ? (g(), k("img", {
            key: 0,
            class: "relative w-full",
            src: u(Il)(o.campaign.skin, o.campaign.custom_header_url),
            alt: "Drop Img"
          }, null, 8, lU)) : z("", !0), u(Il)(o.campaign.skin, o.campaign.custom_header_url) ? z("", !0) : (g(), k("img", uU)), $(jc, {
            class: "absolute left-2 top-2 flex items-center justify-center gap-2 rounded-full bg-gray-lighter px-4 py-2 text-yellow"
          }, {
            default: V(() => [m("span", cU, R(o.campaign.join_rule === u(Xp).Paid ? u(t)("drop.join.join_pro_badge") : u(t)("drop.join.badge")), 1)]),
            _: 1
          })])]),
          _: 1
        }), $(u(F9), {
          class: "rounded-b-3xl border-0 border-white-10 p-0"
        }, {
          default: V(() => [m("div", dU, [$(u(Qp), {
            class: we(["text-theme-blue-green h-5 w-5", {
              hidden: !o.playerActive
            }])
          }, null, 8, ["class"]), m("h2", fU, R(o.campaign.public_name), 1)]), m("div", pU, [m("div", hU, [m("div", mU, R(u(t)("drop.general.prize_pool")), 1), m("div", gU, [m("span", null, R(s.value), 1), $(_d, null, {
            default: V(() => [$(yd, null, {
              default: V(() => [$(u(hd))]),
              _: 1
            }), $(bd, null, {
              default: V(() => [m("span", null, R(a.value), 1)]),
              _: 1
            })]),
            _: 1
          })])]), m("div", vU, [$($g, {
            id: o.campaign.id,
            status: o.campaign.status,
            start_at: o.campaign.start_at,
            finish_at: o.campaign.end_at
          }, null, 8, ["id", "status", "start_at", "finish_at"])])])]),
          _: 1
        })]),
        _: 1
      }))
    }
  }),
  yU = {
    class: "flex w-full flex-col"
  },
  bU = ["onClick"],
  Uy = te({
    __name: "DropListCards",
    props: {
      id: {},
      campaigns: {},
      cardMode: {},
      finished: {
        type: Boolean
      }
    },
    setup(e) {
      const t = e,
        n = Mr(),
        r = s => {
          Cn.push({
            name: "drop",
            params: {
              ...n.params,
              id: s == null ? void 0 : s.id
            }
          })
        };
      return (s, a) => (g(), k("div", yU, [(g(!0), k(Ee, null, Je(t.campaigns, o => (g(), k("div", {
        key: o.id,
        onClick: i => r(o)
      }, [s.cardMode === "full" ? (g(), G(_U, {
        key: 0,
        playerActive: o.player_joined,
        campaign: o
      }, null, 8, ["playerActive", "campaign"])) : z("", !0), s.cardMode === "compact" ? (g(), G(eU, {
        key: 1,
        campaign: o,
        isSubsribed: o.player_joined,
        status: o.status,
        finished: s.finished,
        isSelected: `${o.id}` === s.id
      }, null, 8, ["campaign", "isSubsribed", "status", "finished", "isSelected"])) : z("", !0)], 8, bU))), 128))]))
    }
  }),
  wU = [ut.Promoting, ut.Ongoing, ut.Archived],
  CU = e => e.sort((t, n) => {
    const r = {
        [ut.Ongoing]: 0,
        [ut.Promoting]: 1,
        [ut.Archived]: 2
      },
      s = r[t.status] ?? 99,
      a = r[n.status] ?? 99;
    if (s !== a) return s - a;
    if (t.status === ut.Promoting) {
      const o = t.start_at ? new Date(t.start_at).getTime() : 0,
        i = n.start_at ? new Date(n.start_at).getTime() : 0;
      return o - i
    }
    if (t.status === ut.Ongoing) {
      const o = t.end_at ? new Date(t.end_at).getTime() : 0,
        i = n.end_at ? new Date(n.end_at).getTime() : 0;
      return o - i
    }
    if (t.status === ut.Archived) {
      const o = t.end_at ? new Date(t.end_at).getTime() : 0;
      return (n.end_at ? new Date(n.end_at).getTime() : 0) - o
    }
    return 0
  }),
  Mg = () => ns({
    queryKey: ["drops"],
    queryFn: () => Zx(),
    select: e => {
      const t = e.filter(n => {
        if (wU.includes(n.status)) return !0
      });
      return CU(t)
    },
    refetchInterval: 60 * 1e3,
    placeholderData: ts,
    staleTime: 60 * 1e3
  }),
  xU = {
    class: "relative flex h-fit min-h-80 w-full flex-col items-center pb-16 sm:pb-0"
  },
  kU = {
    key: 0,
    class: "sticky top-0 z-[56] flex h-12 w-full items-center justify-center rounded-t-xl border-b border-white-10 bg-gray-lighter"
  },
  SU = {
    class: "flex items-center justify-between gap-2"
  },
  EU = {
    class: "text-transform-theme-none-uppercase text-theme-white-yellow text-center font-accent text-24 font-bold"
  },
  TU = {
    key: 1,
    class: "flex w-full"
  },
  AU = {
    key: 2,
    class: "flex w-full flex-1 items-center justify-center"
  },
  PU = {
    key: 3,
    class: "flex w-full flex-1 justify-center pt-4 sm:pt-0"
  },
  IU = {
    key: 4,
    class: "flex w-full flex-col"
  },
  $U = {
    class: "w-full p-3 text-12 font-medium uppercase text-gray-lightest md:p-4 md:text-13 lg:p-5 lg:text-17"
  },
  MU = {
    key: 1,
    class: "flex w-full justify-center py-4 sm:py-0"
  },
  OU = {
    key: 2,
    class: "w-full p-3 text-12 font-medium uppercase text-gray-lightest md:p-4 md:text-13 lg:p-5 lg:text-17"
  },
  DU = {
    key: 5,
    class: "flex w-full flex-1 justify-center pt-4 sm:pt-0"
  },
  LU = te({
    __name: "DropList",
    props: {
      id: {}
    },
    setup(e) {
      const {
        t
      } = Fe(), {
        data: n,
        isLoading: r,
        error: s
      } = Mg(), a = U(!1), o = d => {
        d.currentTarget.scrollTop > 48 ? a.value = !0 : a.value = !1
      }, i = Tr("(min-width: 568px)"), l = L(() => {
        var f;
        return (f = n.value) != null && f.length ? n.value.filter(p => p.status !== ut.Archived) : []
      }), c = L(() => {
        var f;
        return (f = n.value) != null && f.length ? n.value.filter(p => p.status === ut.Archived) : []
      });
      return Ge(() => {
        Jt({
          payload: {
            eventName: "lobby_drops_open",
            eventData: {
              player_id: wn.value
            }
          }
        })
      }), (d, f) => (g(), G(u(Jn), {
        class: "h-full w-full p-0",
        handleScroll: o
      }, {
        default: V(() => [m("div", xU, [u(i) ? z("", !0) : (g(), k("div", kU, [m("div", SU, [m("h1", EU, R(u(t)("drop.title")), 1)]), $(u(pr), {
          class: "absolute right-1 top-1 cursor-pointer hover:scale-95 sm:hidden",
          onClick: u(js)
        }, null, 8, ["onClick"])])), u(i) ? z("", !0) : (g(), k("div", TU, [$(Zp, {
          class: "mx-2 mb-0 mt-4 w-full py-2"
        })])), u(r) ? (g(), k("div", AU, [$(u(Ka))])) : u(s) ? (g(), k("div", PU, [$(u(Pi), {
          isRounded: !u(i),
          title: u(t)("common.error.list_title"),
          subTitle: u(t)("common.error.sub_title")
        }, null, 8, ["isRounded", "title", "subTitle"])])) : u(n) ? (g(), k("div", IU, [m("div", $U, R(u(t)("common.event_list.active_title")), 1), l.value.length ? (g(), G(Uy, {
          key: 0,
          id: d.id,
          campaigns: l.value,
          cardMode: u(i) ? "compact" : "full",
          finished: !1
        }, null, 8, ["id", "campaigns", "cardMode"])) : (g(), k("div", MU, [$(u(Pi), {
          isRounded: !u(i),
          title: u(t)("common.event_list.empty.title"),
          subTitle: u(t)("common.event_list.empty.sub_title")
        }, null, 8, ["isRounded", "title", "subTitle"])])), c.value.length ? (g(), k("div", OU, R(u(t)("common.event_list.ended_title")), 1)) : z("", !0), c.value.length ? (g(), G(Uy, {
          key: 3,
          id: d.id,
          campaigns: c.value,
          cardMode: "compact",
          finished: !0
        }, null, 8, ["id", "campaigns"])) : z("", !0)])) : (g(), k("div", DU, [$(u(Pi), {
          isRounded: !u(i),
          title: u(t)("common.event_list.empty.title"),
          subTitle: u(t)("common.event_list.empty.sub_title")
        }, null, 8, ["isRounded", "title", "subTitle"])]))])]),
        _: 1
      }))
    }
  }),
  RU = () => E0({
    mutationKey: ["joinDrop"],
    mutationFn: e => Xx(e),
    onSuccess: async () => {
      Eb(), await $t.invalidateQueries({
        queryKey: ["drops"]
      }), await $t.invalidateQueries({
        queryKey: ["dropDetails"]
      })
    },
    onError: e => ({
      status: e.status || null,
      message: e.message || "An unknown error occurred",
      code: e.code
    })
  }),
  NU = {
    key: 0,
    class: "mx-4 mt-4"
  },
  FU = {
    class: "text-center font-accent text-16 font-bold text-white"
  },
  BU = {
    key: 0,
    class: "text-center text-10 leading-multiline text-gray-lightest"
  },
  jU = {
    key: 0,
    class: "pt-2 text-center font-accent text-13 text-red-600"
  },
  HU = {
    class: "mx-4 mt-4"
  },
  VU = {
    class: "flex w-full items-center gap-3"
  },
  UU = {
    key: 0
  },
  zU = {
    key: 1
  },
  YU = {
    class: "flex grow border-b border-white-10 p-4"
  },
  WU = {
    key: 1,
    class: "flex w-full items-center justify-center text-20 font-bold uppercase"
  },
  GU = {
    class: "relative flex justify-between"
  },
  QU = {
    key: 0,
    class: "flex w-full flex-col items-center p-4"
  },
  qU = {
    class: "font-accent text-18 font-bold text-white"
  },
  KU = {
    class: "text-14 uppercase text-gray-400"
  },
  ZU = {
    key: 1,
    class: "absolute left-1/2 h-full w-px bg-white-10"
  },
  JU = {
    class: "flex w-full flex-col items-center p-4"
  },
  XU = {
    class: "flex gap-1 font-accent text-18 font-bold text-white"
  },
  ez = {
    class: "text-14 uppercase text-gray-400"
  },
  tz = ["src"],
  nz = {
    class: "flex items-center justify-between"
  },
  rz = {
    class: "flex items-center justify-start text-gray-lightest"
  },
  sz = {
    class: "ml-3 whitespace-pre-wrap text-10 uppercase leading-multiline"
  },
  az = {
    class: "text-right font-accent text-20 font-bold text-white"
  },
  oz = {
    key: 0,
    class: "text-right text-10 leading-multiline text-gray-lightest"
  },
  iz = {
    class: "mx-4 mt-4 flex items-center gap-4"
  },
  lz = te({
    __name: "DropGeneralInformation",
    props: {
      campaign: {}
    },
    setup(e) {
      const {
        t
      } = Fe(), {
        mutate: n,
        isError: r,
        error: s,
        isPending: a
      } = RU(), o = e, i = L(() => o.campaign.joining_fee_cents_in_player_currency ? T0.value >= o.campaign.joining_fee_cents_in_player_currency : !0), l = L(() => !o.campaign || o.campaign.status != ut.Ongoing ? !1 : !o.campaign.player_joined), c = L(() => o.campaign.join_rule === Xp.Manual), d = () => {
        var P, N;
        n(o.campaign.id), Jt({
          payload: {
            eventName: "lobby_drops_click_join",
            eventData: {
              player_id: wn.value,
              campaign_id: (P = o.campaign) == null ? void 0 : P.id,
              campaign_status: (N = o.campaign) == null ? void 0 : N.status
            }
          }
        })
      }, f = L(() => a.value || !i.value ? "processing" : "link"), p = L(() => {
        var P, N;
        return i.value ? r.value && s.value.code ? (Jt({
          payload: {
            eventName: "lobby_drops_error",
            eventData: {
              player_id: wn.value,
              error_code: s.value.code,
              campaign_id: (P = o.campaign) == null ? void 0 : P.id,
              campaign_status: (N = o.campaign) == null ? void 0 : N.status
            }
          }
        }), t("drop.join.errors.CAMP_SUBSCRIPTION_PAYMENT_ERROR")) : null : t("drop.join.join_balance_error")
      }), h = L(() => o.campaign.prize_pool.prizes.reduce((P, N) => P += N.remaining_count, 0)), _ = L(() => o.campaign.prize_pool_type === e1.Progressive && h.value === 0 ? "_progressive" : ""), v = L(() => o.campaign.campaign_currency !== "EUR"), C = L(() => o.campaign.campaign_currency !== Kn.currency), y = L(() => o.campaign.prize_pool.total_prize_pool_cents_in_campaign_currency ? v.value ? zp(o.campaign.prize_pool.total_prize_pool_cents_in_player_currency || 0) : m9(o.campaign.prize_pool.total_prize_pool_cents_in_campaign_currency || 0) : null), b = L(() => o.campaign.prize_pool.total_prize_pool_cents_in_campaign_currency ? v.value ? Rt(o.campaign.prize_pool.total_prize_pool_cents_in_player_currency || 0) : Gn(o.campaign.prize_pool.total_prize_pool_cents_in_campaign_currency || 0) : null), w = L(() => o.campaign.joining_fee_cents_in_campaign_currency ? v.value ? Rt(o.campaign.joining_fee_cents_in_player_currency || 0) : Gn(o.campaign.joining_fee_cents_in_campaign_currency || 0) : null), x = L(() => C.value && o.campaign.joining_fee_cents_in_campaign_currency ? Rt(o.campaign.joining_fee_cents_in_player_currency || 0) : null), E = () => {
        var P, N;
        Jt({
          payload: {
            eventName: "lobby_drops_how_to",
            eventData: {
              player_id: wn.value,
              campaign_id: (P = o.campaign) == null ? void 0 : P.id,
              campaign_status: (N = o.campaign) == null ? void 0 : N.status
            }
          }
        })
      }, S = () => {
        var P, N;
        Jt({
          payload: {
            eventName: "lobby_drops_prizes_open",
            eventData: {
              player_id: wn.value,
              campaign_id: (P = o.campaign) == null ? void 0 : P.id,
              campaign_status: (N = o.campaign) == null ? void 0 : N.status
            }
          }
        })
      }, T = L(() => o.campaign.min_bet_cents_in_campaign_currency ? v.value ? Rt(o.campaign.min_bet_cents_in_player_currency || 0) : Gn(o.campaign.min_bet_cents_in_campaign_currency || 0) : null), j = L(() => C.value && o.campaign.min_bet_cents_in_campaign_currency ? Rt(o.campaign.min_bet_cents_in_player_currency || 0) : null);
      return (P, N) => {
        const ne = x5("smooth-scroll");
        return g(), k(Ee, null, [l.value ? (g(), k(Ee, {
          key: 0
        }, [c.value ? (g(), k("div", NU, [$(qt, {
          variant: u(a) ? "processing" : "link",
          onClick: d
        }, {
          default: V(() => [Ye(R(u(a) ? u(t)("drop.join.loading") : u(t)("drop.join.button")), 1)]),
          _: 1
        }, 8, ["variant"])])) : (g(), G(u(Bt), {
          key: 1,
          class: "gap-0 py-3"
        }, {
          default: V(() => [m("div", null, [m("p", FU, R(u(t)("drop.join.join_pro_title")) + " " + R(w.value), 1), x.value ? (g(), k("p", BU, R(x.value), 1)) : z("", !0)]), p.value ? (g(), k("div", jU, R(p.value), 1)) : z("", !0), m("div", HU, [$(qt, {
            variant: f.value,
            onClick: d
          }, {
            default: V(() => [Ye(R(u(a) ? u(t)("drop.join.loading") : u(t)("drop.join.join_pro_button")), 1)]),
            _: 1
          }, 8, ["variant"])])]),
          _: 1
        }))], 64)) : z("", !0), P.campaign.player_joined ? (g(), G(u(Bt), {
          key: 1,
          class: "text-theme-white-opacity py-3"
        }, {
          default: V(() => [m("div", VU, [$(u(Wp), {
            class: "text-theme-blue-green"
          }), P.campaign.status === u(ut).Archived ? (g(), k("span", UU, R(u(t)("drop.general.passive_player")), 1)) : (g(), k("span", zU, R(u(t)(`drop.general.active_player${_.value}`)), 1))])]),
          _: 1
        })) : z("", !0), $(u(Bt), {
          class: "gap-0 p-0 sm:border-2 sm:border-yellow"
        }, {
          default: V(() => [m("div", YU, [P.campaign.status === u(ut).Ongoing || P.campaign.status === u(ut).Promoting ? (g(), G($g, {
            key: 0,
            id: P.campaign.id,
            status: P.campaign.status,
            start_at: P.campaign.start_at,
            finish_at: P.campaign.end_at
          }, null, 8, ["id", "status", "start_at", "finish_at"])) : (g(), k("div", WU, R(u(t)("common.event_finished")), 1))]), m("div", GU, [P.campaign.status !== u(ut).Archived ? (g(), k("div", QU, [m("div", qU, R(h.value), 1), m("div", KU, R(u(t)("drop.general.left")), 1)])) : z("", !0), P.campaign.status !== u(ut).Archived ? (g(), k("div", ZU)) : z("", !0), m("div", JU, [m("div", XU, [m("span", null, R(y.value), 1), $(_d, null, {
            default: V(() => [$(yd, null, {
              default: V(() => [$(u(hd))]),
              _: 1
            }), $(bd, null, {
              default: V(() => [m("span", null, R(b.value), 1)]),
              _: 1
            })]),
            _: 1
          })]), m("div", ez, R(u(t)("drop.general.prize_pool")), 1)])]), u(Do) !== "_dark" ? (g(), k("img", {
            key: 0,
            src: u(nU)(),
            alt: "PrizePool clock icon",
            class: "absolute -left-4 -top-4 h-16 w-16"
          }, null, 8, tz)) : z("", !0)]),
          _: 1
        }), T.value ? (g(), G(u(Bt), {
          key: 2,
          class: "py-3"
        }, {
          default: V(() => [m("div", nz, [m("div", rz, [$(u(x9)), m("p", sz, R(u(t)("common.min_bet")), 1)]), m("div", null, [m("p", az, "≥ " + R(T.value), 1), j.value ? (g(), k("p", oz, R(j.value), 1)) : z("", !0)])])]),
          _: 1
        })) : z("", !0), m("div", iz, [u(rd) ? z("", !0) : Tn((g(), G(qt, {
          key: 0,
          as: "a",
          href: "#dropRules",
          variant: "linkSecondary",
          onClick: E
        }, {
          default: V(() => [Ye(R(u(t)("drop.general.rules_button")), 1)]),
          _: 1
        })), [
          [ne, {
            duration: 500,
            offset: -50,
            container: "#dropDetails"
          }]
        ]), Tn((g(), G(qt, {
          as: "a",
          href: "#dropPrizePool",
          variant: "linkSecondary",
          onClick: S
        }, {
          default: V(() => [Ye(R(u(t)("drop.general.prizes_button")), 1)]),
          _: 1
        })), [
          [ne, {
            duration: 500,
            offset: -50,
            container: "#dropDetails"
          }]
        ])])], 64)
      }
    }
  }),
  uz = {
    class: "text-center font-accent font-bold"
  },
  cz = {
    class: "text-theme-dark-yellow text-24"
  },
  dz = {
    key: 0,
    class: "text-10 font-medium opacity-50"
  },
  fz = {
    class: "flex items-center justify-between pb-2 text-10 font-medium uppercase opacity-50"
  },
  pz = {
    class: "text-end"
  },
  hz = {
    class: "font-bold"
  },
  mz = {
    key: 0,
    class: "font-medium"
  },
  zy = 5,
  gz = te({
    __name: "DropUserWins",
    props: {
      campaign: {}
    },
    setup(e) {
      const {
        t
      } = Fe(), n = e, r = U(!1), s = L(() => r.value ? n.campaign.player_wins_info : n.campaign.player_wins_info.slice(0, zy)), a = f => f.replace(/([a-z])([A-Z])/g, "$1 $2"), o = () => {
        var f, p;
        Jt({
          payload: {
            eventName: r.value ? "lobby_drops_players_my_wins_closed" : "lobby_drops_players_my_wins_open",
            eventData: {
              player_id: wn.value,
              campaign_id: (f = n.campaign) == null ? void 0 : f.id,
              campaign_status: (p = n.campaign) == null ? void 0 : p.status
            }
          }
        }), r.value = !r.value
      }, i = L(() => n.campaign.campaign_currency !== "EUR"), l = L(() => n.campaign.campaign_currency !== Kn.currency), c = L(() => {
        if (i.value) {
          const f = n.campaign.player_wins_info.reduce((p, h) => p += h.amount_cents_in_player_currency, 0);
          return Rt(f)
        } else {
          const f = n.campaign.player_wins_info.reduce((p, h) => p += h.amount_cents_in_campaign_currency, 0);
          return Gn(f)
        }
      }), d = L(() => {
        const f = n.campaign.player_wins_info.reduce((p, h) => p += h.amount_cents_in_player_currency, 0);
        return Rt(f)
      });
      return (f, p) => s.value.length ? (g(), G(u(Bt), {
        key: 0,
        colored: !0,
        class: "text-theme-black-white"
      }, {
        default: V(() => {
          var h;
          return [m("div", uz, [$(u(Za), {
            variant: "blackNoneTransform"
          }, {
            default: V(() => [Ye(R(u(t)("drop.user_wins.title")), 1)]),
            _: 1
          }), m("h2", cz, R(c.value), 1), l.value ? (g(), k("p", dz, R(d.value), 1)) : z("", !0)]), m("div", null, [m("div", fz, [m("p", null, R(u(t)("drop.user_wins.column_date")) + " • " + R(u(t)("drop.user_wins.column_time")), 1), m("p", null, R(u(t)("drop.user_wins.column_value")) + " • " + R(u(t)("drop.user_wins.column_game")), 1)]), (g(!0), k(Ee, null, Je(s.value, _ => (g(), k("div", {
            key: _.created_at,
            class: "box-border flex items-center justify-between border-t border-black-10 pb-2 pt-2 text-13"
          }, [m("div", null, [m("p", null, R(u(ta)(_.created_at).short), 1), m("p", null, R(u(ta)(_.created_at).time), 1)]), m("div", pz, [m("p", hz, R(i.value ? u(Rt)(_.amount_cents_in_player_currency) : u(Gn)(_.amount_cents_in_campaign_currency)), 1), l.value ? (g(), k("p", mz, R(u(Rt)(_.amount_cents_in_player_currency)), 1)) : z("", !0), m("p", null, R(a(_.game_identifier)), 1)])]))), 128))]), ((h = f.campaign.player_wins_info) == null ? void 0 : h.length) > zy ? (g(), G(u(qt), {
            key: 0,
            onClick: o,
            variant: "ghost"
          }, {
            default: V(() => [Ye(R(r.value ? u(t)("common.button.roll_up") : u(t)("common.button.show_more")), 1)]),
            _: 1
          })) : z("", !0)]
        }),
        _: 1
      })) : z("", !0)
    }
  }),
  vz = {
    class: "flex w-full items-center justify-center"
  },
  _z = {
    class: "flex items-center justify-between pb-2 text-10 font-medium uppercase text-gray-lightest"
  },
  yz = {
    class: "text-left leading-multiline"
  },
  bz = {
    key: 0,
    class: "text-gray-lightest"
  },
  wz = {
    class: "text-end font-bold"
  },
  Cz = {
    class: "text-gray-lightest"
  },
  xz = ["src"],
  kz = te({
    __name: "DropPrizePool",
    props: {
      campaign: {}
    },
    setup(e) {
      const {
        t
      } = Fe(), n = e, r = L(() => n.campaign.prize_pool_type === e1.Progressive ? "_progressive" : ""), s = L(() => n.campaign.campaign_currency !== "EUR"), a = L(() => n.campaign.campaign_currency !== Kn.currency);
      return (o, i) => (g(), G(u(Bt), {
        id: "dropPrizePool"
      }, {
        default: V(() => [m("div", vz, [$(u(Za), {
          variant: "whiteNoneTransform"
        }, {
          default: V(() => [Ye(R(u(t)(`drop.prize_pool.title${r.value}`)), 1)]),
          _: 1
        })]), m("div", null, [m("div", _z, [m("p", null, R(u(t)("drop.prize_pool.column_prizes")), 1), Ye(" " + R(u(t)(`drop.prize_pool.column_left${r.value}`)), 1)]), (g(!0), k(Ee, null, Je(o.campaign.prize_pool.prizes, (l, c) => (g(), k("div", {
          key: c,
          class: "box-border flex justify-between border-t border-white-10 pb-2 pt-2 text-left text-13 text-white"
        }, [m("div", yz, [m("p", null, R(s.value ? u(Rt)(l.amount_cents_in_player_currency || 0) : u(Gn)(l.amount_cents_in_campaign_currency || 0)), 1), a.value ? (g(), k("p", bz, R(u(Rt)(l.amount_cents_in_player_currency || 0)), 1)) : z("", !0)]), m("div", wz, [m("span", null, R(l.remaining_count), 1), m("span", Cz, "/" + R(l.total_count), 1)])]))), 128))]), u(Do) !== "_dark" ? (g(), k("img", {
          key: 0,
          src: u(rU)(),
          alt: "PrizePool clock icon",
          class: "absolute -left-4 -top-5 h-16 w-16"
        }, null, 8, xz)) : z("", !0)]),
        _: 1
      }))
    }
  }),
  Sz = {
    class: "flex w-full items-center justify-center"
  },
  Ez = {
    class: "flex flex-col gap-4"
  },
  Tz = {
    class: "flex-1 leading-multiline"
  },
  Az = {
    class: "flex flex-col gap-4"
  },
  Pz = {
    class: "font-bold"
  },
  Iz = {
    class: "flex flex-col gap-4"
  },
  $z = {
    class: "font-bold"
  },
  Mz = {
    class: "list-disc pl-6"
  },
  Oz = {
    class: "flex flex-col gap-4"
  },
  Dz = {
    class: "font-bold"
  },
  Lz = {
    class: "list-decimal pl-6"
  },
  Rz = {
    class: "flex flex-col gap-4"
  },
  Nz = {
    class: "font-bold"
  },
  Fz = {
    class: "list-disc pl-6"
  },
  Bz = {
    key: 0,
    class: "flex flex-col gap-4"
  },
  jz = ["src"],
  Hz = te({
    __name: "DropRules",
    props: {
      campaign: {}
    },
    setup(e) {
      const {
        t
      } = Fe(), n = e, r = L(() => {
        const h = [];
        return h.push({
          iconType: "IconPrize",
          text: t("drop.rules.spin")
        }), h.push({
          iconType: "IconGear",
          text: t("drop.rules.rtp")
        }), h.push({
          iconType: "IconStar",
          text: t("drop.rules.bet")
        }), h.push({
          iconType: "IconList",
          text: t("drop.rules.goal")
        }), h
      }), s = U(!1), a = () => {
        var h, _;
        Jt({
          payload: {
            eventName: s.value ? "lobby_drops_how_to_closed" : "lobby_drops_how_to_open",
            eventData: {
              player_id: wn.value,
              campaign_id: (h = n.campaign) == null ? void 0 : h.id,
              campaign_status: (_ = n.campaign) == null ? void 0 : _.status
            }
          }
        }), s.value = !s.value
      }, o = L(() => n.campaign.campaign_currency !== "EUR"), i = L(() => n.campaign.campaign_currency !== Kn.currency), l = L(() => n.campaign.prize_pool.total_prize_pool_cents_in_campaign_currency ? o.value ? Rt(n.campaign.prize_pool.total_prize_pool_cents_in_player_currency || 0) : Gn(n.campaign.prize_pool.total_prize_pool_cents_in_campaign_currency || 0) : null), c = L(() => {
        if (o.value) {
          const h = Math.max(...n.campaign.prize_pool.prizes.map(({
            amount_cents_in_player_currency: _
          }) => _));
          return Rt(h)
        } else {
          const h = Math.max(...n.campaign.prize_pool.prizes.map(({
            amount_cents_in_campaign_currency: _
          }) => _));
          return Gn(h)
        }
      }), d = L(() => {
        const h = Math.max(...n.campaign.prize_pool.prizes.map(({
          amount_cents_in_player_currency: _
        }) => _));
        return Rt(h)
      }), f = L(() => n.campaign.prize_pool.prizes.reduce((h, _) => h += _.total_count, 0)), p = L(() => n.campaign.max_wins_per_player && n.campaign.max_wins_per_player > 0 ? t("drop.rules.max_wins_per_player", {
        value: n.campaign.max_wins_per_player
      }) : t("drop.rules.details.conditions.limit"));
      return (h, _) => (g(), G(u(Bt), {
        id: "dropRules",
        class: "text-theme-white-opacity"
      }, {
        default: V(() => {
          var v, C, y, b, w, x, E;
          return [m("div", Sz, [$(u(Za), null, {
            default: V(() => [Ye(R(u(t)("drop.rules.title")), 1)]),
            _: 1
          })]), m("div", Ez, [(g(!0), k(Ee, null, Je(r.value, ({
            iconType: S,
            text: T
          }) => (g(), k("div", {
            key: T,
            class: "flex items-start justify-start gap-4 text-left text-13"
          }, [$(u(j9), {
            iconType: S
          }, null, 8, ["iconType"]), m("p", Tz, R(T), 1)]))), 128))]), m("div", {
            class: we(["flex flex-col gap-6 text-left text-13 leading-multiline", {
              hidden: !s.value
            }])
          }, [m("div", Az, [m("p", Pz, R(u(t)("drop.rules.details.title")), 1), m("p", null, R(u(t)("drop.rules.details.description", {
            name: (v = h.campaign) == null ? void 0 : v.public_name,
            from: u(ta)((C = h.campaign) == null ? void 0 : C.start_at).full,
            to: u(ta)((y = h.campaign) == null ? void 0 : y.end_at).full
          })), 1), m("p", null, R(u(t)("drop.rules.details.agreement")), 1)]), m("div", Iz, [m("p", $z, R(u(t)("drop.rules.details.summary.title", {
            value: ((b = h.campaign) == null ? void 0 : b.public_name) || ""
          })) + ": ", 1), m("ul", Mz, [m("li", null, R(u(t)("drop.rules.details.summary.total", {
            value: l.value
          })), 1), m("li", null, R(u(t)("drop.rules.details.summary.max", {
            value: i.value ? `${c.value} (${d.value})` : c.value
          })), 1), m("li", null, R(u(t)("drop.rules.details.summary.amount", {
            value: f.value
          })), 1), m("li", null, R(u(t)("drop.rules.details.summary.delay")), 1)])]), m("div", Oz, [m("p", Dz, R(u(t)("drop.rules.details.conditions.title", {
            value: ((w = h.campaign) == null ? void 0 : w.public_name) || ""
          })) + ": ", 1), m("ul", Lz, [m("li", null, R(u(t)("drop.rules.details.conditions.join")), 1), m("li", null, R(u(t)("drop.rules.details.conditions.spin")), 1), m("li", null, R(u(t)("drop.rules.details.conditions.bet")), 1), m("li", null, R(p.value), 1), m("li", null, R(u(t)("drop.rules.details.conditions.free")), 1)])]), m("div", Rz, [m("p", Nz, R(u(t)("drop.rules.details.prizes.title", {
            value: ((x = h.campaign) == null ? void 0 : x.public_name) || ""
          })), 1), m("div", null, [m("p", null, R(u(t)("drop.rules.details.prizes.amount")) + ":", 1), m("ul", Fz, [(g(!0), k(Ee, null, Je((E = h.campaign) == null ? void 0 : E.prize_pool.prizes, (S, T) => (g(), k("li", {
            key: T
          }, R(S.total_count) + " - " + R(i.value ? `${o.value?u(Rt)(S.amount_cents_in_player_currency):u(Gn)(S.amount_cents_in_campaign_currency)} (${u(Rt)(S.amount_cents_in_player_currency)})` : o.value ? u(Rt)(S.amount_cents_in_player_currency) : u(Gn)(S.amount_cents_in_campaign_currency)), 1))), 128))])])]), n.campaign.prize_pool_type === u(e1).Progressive ? (g(), k("div", Bz, [m("p", null, R(u(t)("drop.rules.details.progressive")), 1)])) : z("", !0)], 2), $(u(qt), {
            onClick: a
          }, {
            default: V(() => [Ye(R(s.value ? u(t)("common.button.roll_up") : u(t)("common.button.show_more")), 1)]),
            _: 1
          }), u(Do) !== "_dark" ? (g(), k("img", {
            key: 0,
            src: u(sU)(),
            alt: "PrizePool clock icon",
            class: "absolute -right-4 -top-4 h-16 w-16"
          }, null, 8, jz)) : z("", !0)]
        }),
        _: 1
      }))
    }
  }),
  Vz = {
    class: "flex w-full items-center justify-center"
  },
  Uz = {
    class: "flex items-center justify-between pb-2 text-10 font-medium text-gray-lightest"
  },
  zz = {
    class: "flex items-center gap-3 align-middle"
  },
  Yz = {
    class: "text-left"
  },
  Wz = {
    class: "font-bold lowercase"
  },
  Gz = {
    class: "text-gray-lightest"
  },
  Qz = {
    class: "text-end font-bold"
  },
  qz = ["src"],
  Kz = ["src"],
  Yy = 5,
  Zz = te({
    __name: "DropTopWins",
    props: {
      campaign: {}
    },
    setup(e) {
      const {
        t
      } = Fe(), n = e, r = U(!1), s = L(() => r.value ? n.campaign.recent_wins_info : n.campaign.recent_wins_info.slice(0, Yy)), a = L(() => n.campaign.campaign_currency !== "EUR"), o = () => {
        var i, l;
        Jt({
          payload: {
            eventName: r.value ? "lobby_drops_players_wins_closed" : "lobby_drops_players_wins_open",
            eventData: {
              player_id: wn.value,
              campaign_id: (i = n.campaign) == null ? void 0 : i.id,
              campaign_status: (l = n.campaign) == null ? void 0 : l.status
            }
          }
        }), r.value = !r.value
      };
      return (i, l) => {
        var c;
        return i.campaign.recent_wins_info && ((c = i.campaign.recent_wins_info) == null ? void 0 : c.length) > 0 ? (g(), G(u(Bt), {
          key: 0,
          class: "mb-5"
        }, {
          default: V(() => {
            var d;
            return [m("div", Vz, [$(u(Za), {
              variant: "whiteNoneTransform"
            }, {
              default: V(() => [Ye(R(u(t)("drop.top_wins.title")), 1)]),
              _: 1
            })]), m("div", null, [m("div", Uz, [m("p", null, R(u(t)("drop.top_wins.column_id")) + " • " + R(u(t)("drop.top_wins.column_date")) + " • " + R(u(t)("drop.top_wins.column_time")), 1), m("p", null, R(u(t)("drop.top_wins.column_prize")), 1)]), (g(!0), k(Ee, null, Je(s.value, f => (g(), k("div", {
              key: f.created_at,
              class: "box-border flex items-center justify-between border-t border-white-10 pb-2 pt-2 text-13 text-white"
            }, [m("div", zz, [m("div", Yz, [m("span", Wz, R(u(t)("drop.top_wins.column_id")) + " " + R(f.player_nickname), 1), l[0] || (l[0] = m("br", null, null, -1)), m("span", Gz, R(u(ta)(f.created_at).short) + " " + R(u(ta)(f.created_at).time), 1)])]), m("div", Qz, [m("span", null, R(a.value ? u(Rt)(f.amount_cents_in_player_currency) : u(Gn)(f.amount_cents_in_campaign_currency)), 1)])]))), 128))]), ((d = i.campaign.recent_wins_info) == null ? void 0 : d.length) > Yy ? (g(), G(u(qt), {
              key: 0,
              onClick: o
            }, {
              default: V(() => [Ye(R(r.value ? u(t)("common.button.roll_up") : u(t)("common.button.show_more")), 1)]),
              _: 1
            })) : z("", !0), u(Do) !== "_dark" ? (g(), k("img", {
              key: 1,
              src: u(aU)(),
              alt: "PrizePool clock icon",
              class: "absolute -left-4 -top-4 h-16 w-16"
            }, null, 8, qz)) : z("", !0), u(Do) !== "_dark" ? (g(), k("img", {
              key: 2,
              src: u(oU)(),
              alt: "PrizePool clock icon",
              class: "absolute -bottom-6 -right-4 h-16 w-16"
            }, null, 8, Kz)) : z("", !0)]
          }),
          _: 1
        })) : z("", !0)
      }
    }
  }),
  Jz = e => ns({
    queryKey: ["dropDetails", e],
    queryFn: () => Jx(e.value),
    enabled: L(() => !!e.value),
    refetchInterval: 60 * 1e3,
    placeholderData: ts,
    staleTime: 60 * 1e3
  }),
  Xz = {
    key: 0
  },
  eY = {
    key: 1
  },
  tY = {
    class: "mb-4 flex h-fit min-w-[auto!important] flex-col"
  },
  nY = {
    class: "relative w-full"
  },
  rY = ["src"],
  sY = {
    key: 1,
    class: "h-auto w-full",
    src: Pg,
    alt: "Drop Img"
  },
  aY = {
    class: "text-theme-white-yellow mt-6 text-center font-accent text-24 font-bold"
  },
  oY = te({
    __name: "DropDetails",
    props: {
      id: {}
    },
    setup(e) {
      const t = e,
        n = Mr(),
        r = L(() => t.id),
        {
          data: s,
          isLoading: a,
          error: o
        } = Jz(r);

      function i() {
        Cn.push({
          name: "drop",
          params: {
            ...n.params,
            id: ""
          }
        })
      }
      const l = U(!1),
        c = p => {
          p.currentTarget.scrollTop > 48 ? l.value = !0 : l.value = !1
        },
        d = Tr("(min-width: 568px)");
      Ne(() => s.value, (p, h) => {
        !(p != null && p.id) || p.id === (h == null ? void 0 : h.id) || (p.status === ut.Paused && i(), Jt({
          payload: {
            eventName: "lobby_drops_campaign_open",
            eventData: {
              player_id: wn.value,
              campaign_id: p.id,
              campaign_status: p.status
            }
          }
        }))
      }, {
        immediate: !0
      });
      const f = (p, h) => {
        var _, v;
        Jt({
          payload: {
            eventName: "lobby_drops_games_open",
            eventData: {
              player_id: wn.value,
              campaign_id: (_ = s.value) == null ? void 0 : _.id,
              campaign_status: (v = s.value) == null ? void 0 : v.status,
              game: h
            }
          }
        }), js(), Mb(p)
      };
      return (p, h) => u(a) ? (g(), k("div", Xz, [$(u(Pl), {
        isLoading: !0,
        handleBack: i,
        handleClose: u(js)
      }, null, 8, ["handleClose"])])) : u(o) ? (g(), k("div", eY, [$(u(Pl), {
        isError: !0,
        handleBack: i,
        handleClose: u(js)
      }, null, 8, ["handleClose"])])) : !u(s) || u(s).status === u(ut).Paused ? (g(), G(u(Pl), {
        key: 2,
        handleBack: i,
        handleClose: u(js)
      }, null, 8, ["handleClose"])) : (g(), G(u(Jn), {
        key: 3,
        id: "dropDetails",
        handleScroll: c,
        class: we(["h-full", {
          "rounded-xl": !u(d)
        }])
      }, {
        default: V(() => [m("div", tY, [Tn($(u(B9), {
          handleBack: i,
          handleClose: u(js),
          title: u(s).public_name
        }, {
          default: V(() => [$(u(Gp), {
            class: "text-yellow"
          })]),
          _: 1
        }, 8, ["handleClose", "title"]), [
          [wl, l.value]
        ]), m("div", nY, [u(Il)(u(s).skin, u(s).custom_header_url) ? (g(), k("img", {
          key: 0,
          class: "h-auto w-full",
          src: u(Il)(u(s).skin, u(s).custom_header_url),
          alt: "Drop Img"
        }, null, 8, rY)) : z("", !0), u(Il)(u(s).skin, u(s).custom_header_url) ? z("", !0) : (g(), k("img", sY)), $(u(Yp), {
          class: "absolute left-1 top-1 cursor-pointer hover:scale-95 sm:hidden",
          onClick: i
        }), $(u(pr), {
          class: "absolute right-1 top-1 cursor-pointer hover:scale-95 sm:hidden",
          onClick: u(js)
        }, null, 8, ["onClick"])]), m("h1", aY, R(u(s).public_name), 1), $(lz, {
          campaign: u(s)
        }, null, 8, ["campaign"]), $(u(Ym), {
          "game-identifiers": u(s).game_identifiers,
          "event-id": u(s).id,
          "query-source": "drops",
          "send-event-opening": f
        }, null, 8, ["game-identifiers", "event-id"]), $(gz, {
          campaign: u(s)
        }, null, 8, ["campaign"]), $(kz, {
          campaign: u(s)
        }, null, 8, ["campaign"]), u(rd) ? z("", !0) : (g(), G(Hz, {
          key: 0,
          campaign: u(s)
        }, null, 8, ["campaign"])), $(Zz, {
          campaign: u(s)
        }, null, 8, ["campaign"])])]),
        _: 1
      }, 8, ["class"]))
    }
  }),
  iY = te({
    __name: "DropPage",
    props: {
      id: {}
    },
    setup(e) {
      const t = e,
        n = Tr("(min-width: 568px)"),
        r = Mr(),
        s = L(() => t.id),
        {
          data: a,
          isFetching: o,
          isFetched: i
        } = Mg(),
        l = L(() => n.value ? !1 : s.value),
        c = L(() => n.value ? !1 : !s.value),
        d = f => {
          const p = f.find(h => h.status === ut.Ongoing) || f.find(h => h.status === ut.Promoting) || f.find(h => h.status === ut.Archived);
          return (p == null ? void 0 : p.id) || 0
        };
      return Ne(() => [s.value, n.value, a.value, i.value, o.value], () => {
        if (!(!i.value || o.value) && !s.value && n.value && a.value && a.value.length) {
          const f = d(a.value);
          f && Cn.push({
            name: "drop",
            params: {
              ...r.params,
              id: f
            }
          })
        }
      }, {
        immediate: !0
      }), (f, p) => (g(), G(vd, {
        id: f.id,
        isActivePath: "/lobby/drop"
      }, {
        default: V(() => [$(LU, {
          id: f.id,
          class: we(["relative w-full rounded-bl-xl sm:w-2/6", {
            hidden: l.value
          }])
        }, null, 8, ["id", "class"]), m("div", {
          class: we(["relative w-full sm:w-4/6 sm:border-l sm:border-white-10 sm:pr-0", {
            hidden: c.value
          }])
        }, [$(oY, {
          id: f.id
        }, null, 8, ["id"])], 2)]),
        _: 1
      }, 8, ["id"]))
    }
  }),
  Wy = "https://drops-skins.bgaming-network.com",
  z9 = () => Do.value === "_dark" ? `${Wy}/challenge/challenge-sp.png` : `${Wy}/challenge/challenge_new.png`;
var tt = (e => (e.Ongoing = "ongoing", e.Planned = "planned", e.Sync = "result_calculating", e.Finished = "finished", e.Cancelled = "cancelled", e))(tt || {});
const lY = {
    key: 0
  },
  uY = {
    key: 0
  },
  cY = {
    key: 1,
    class: "flex grow flex-col items-center justify-center gap-1 text-10 font-medium text-gray-lightest lg:text-14"
  },
  dY = {
    key: 0,
    class: "flex h-7 items-baseline gap-1"
  },
  fY = {
    class: "font-accent text-20 font-bold text-white lg:text-28"
  },
  pY = {
    class: "font-accent text-20 font-bold text-white lg:text-28"
  },
  hY = {
    class: "font-accent text-20 font-bold text-white lg:text-28"
  },
  mY = {
    key: 1,
    class: "flex h-7 items-baseline gap-1"
  },
  gY = {
    class: "font-accent text-20 font-bold text-white lg:text-28"
  },
  vY = {
    class: "font-accent text-20 font-bold text-white lg:text-28"
  },
  _Y = {
    class: "font-accent text-20 font-bold text-white lg:text-28"
  },
  yY = {
    class: "flex items-center gap-2 uppercase"
  },
  t1 = te({
    __name: "ChallengeTimer",
    props: {
      id: {},
      status: {},
      isCompactMode: {
        type: Boolean
      },
      start_at: {},
      finish_at: {},
      isSelected: {
        type: Boolean
      }
    },
    setup(e) {
      const {
        t
      } = Fe(), n = e;
      let r = U(!1);
      const s = L(() => {
          switch (n.status) {
            case tt.Ongoing:
              return t("common.event_timer.end_title");
            case tt.Planned:
              return t("common.event_timer.start_title");
            default:
              return ""
          }
        }),
        a = L(() => {
          switch (n.status) {
            case tt.Ongoing:
              return t("common.event_status.active");
            case tt.Planned:
              return t("common.event_status.planned");
            default:
              return ""
          }
        }),
        o = U({
          days: 0,
          hours: 0,
          minutes: 0,
          seconds: 0
        }),
        i = () => {
          const f = new Date(n.status === tt.Ongoing ? n.finish_at : n.start_at),
            p = new Date,
            h = f.getTime() - p.getTime(),
            _ = Math.floor(h / (1e3 * 60 * 60 * 24)),
            v = Math.floor(h % (1e3 * 60 * 60 * 24) / (1e3 * 60 * 60)),
            C = Math.floor(h % (1e3 * 60 * 60) / (1e3 * 60)),
            y = Math.floor(h % (1e3 * 60) / 1e3);
          return {
            days: _,
            hours: v,
            minutes: C,
            seconds: y
          }
        },
        l = () => {
          if (n.status === tt.Finished) return !1;
          const f = new Date().getTime(),
            p = n.status === tt.Ongoing ? n.finish_at : n.start_at;
          return f > new Date(p).getTime()
        },
        c = () => {
          const f = i();
          if ((n.status === tt.Ongoing || n.status === tt.Planned) && l()) {
            sk(), r.value = !0;
            return
          }
          r.value = !1, !(f.seconds < 0) && (o.value = f)
        };
      let d = null;
      return Ge(() => {
        c(), d = setInterval(c, 1e3)
      }), en(() => {
        d && clearInterval(d)
      }), Ne(() => [n.start_at, n.finish_at], () => {
        c(), d && clearInterval(d), d = setInterval(c, 1e3)
      }), (f, p) => u(r) ? (g(), G(u(V9), {
        key: 0,
        isSelected: !!f.isSelected,
        isCompact: !!f.isCompactMode
      }, null, 8, ["isSelected", "isCompact"])) : (g(), k(Ee, {
        key: 1
      }, [f.isCompactMode ? (g(), k("div", lY, [m("div", {
        class: we(["flex min-h-[18px] flex-wrap items-center text-12 uppercase md:text-13 lg:text-14", {
          "text-green": f.status === u(tt).Ongoing && !f.isSelected,
          "text-violet": f.status === u(tt).Planned && !f.isSelected,
          "text-gray": f.isSelected,
          "opacity-25": f.status === u(tt).Finished || f.status === u(tt).Sync
        }])
      }, [f.status !== u(tt).Finished ? (g(), k("div", uY, R(a.value) + " • ", 1)) : z("", !0), m("div", null, R(u(ta)(f.start_at, u(Kn).locale).full) + " - " + R(u(ta)(f.finish_at, u(Kn).locale).full), 1)], 2)])) : (g(), k("div", cY, [o.value.days > 0 ? (g(), k("p", dY, [m("span", fY, R(o.value.days), 1), p[0] || (p[0] = m("span", null, "d", -1)), p[1] || (p[1] = m("span", {
        class: "pb-1 text-11"
      }, ":", -1)), m("span", pY, R(o.value.hours.toString().padStart(2, "0")), 1), p[2] || (p[2] = m("span", null, "h", -1)), p[3] || (p[3] = m("span", {
        class: "pb-1 text-11"
      }, ":", -1)), m("span", hY, R(o.value.minutes.toString().padStart(2, "0")), 1), p[4] || (p[4] = m("span", null, "m", -1))])) : (g(), k("p", mY, [m("span", gY, R(o.value.hours.toString().padStart(2, "0")), 1), p[5] || (p[5] = m("span", null, "h", -1)), p[6] || (p[6] = m("span", {
        class: "pb-1 text-11"
      }, ":", -1)), m("span", vY, R(o.value.minutes.toString().padStart(2, "0")), 1), p[7] || (p[7] = m("span", null, "m", -1)), p[8] || (p[8] = m("span", {
        class: "pb-1 text-11"
      }, ":", -1)), m("span", _Y, R(o.value.seconds.toString().padStart(2, "0")), 1), p[9] || (p[9] = m("span", null, "s", -1))])), m("div", yY, [m("span", {
        class: we({
          "text-green": f.status === u(tt).Ongoing,
          "text-violet": f.status === u(tt).Planned
        })
      }, R(f.status === u(tt).Ongoing ? u(t)("common.event_status.active") : f.status === u(tt).Planned ? u(t)("common.event_status.planned") : ""), 3), p[10] || (p[10] = m("span", null, "•", -1)), m("span", null, R(s.value), 1)])]))], 64))
    }
  }),
  bY = {
    class: "relative w-full"
  },
  wY = ["src"],
  CY = {
    class: "absolute left-2 top-2 flex gap-2"
  },
  xY = {
    class: "text-12 font-normal uppercase md:text-20"
  },
  kY = {
    class: "flex items-center gap-3 px-3 py-3"
  },
  SY = {
    class: "font-accent text-20 font-bold"
  },
  EY = {
    class: "flex justify-between gap-2.5 px-3 pb-3"
  },
  TY = {
    key: 0,
    class: "flex w-full flex-col items-center gap-1 rounded-lg border-b border-white-10 bg-black-30 p-4"
  },
  AY = {
    class: "text-10 font-medium uppercase text-white-50"
  },
  PY = {
    class: "flex gap-1 font-accent text-16 font-bold"
  },
  IY = {
    class: "flex w-full rounded-lg border-b border-white-10 bg-black-30 p-4"
  },
  $Y = te({
    __name: "ChallengeListCard",
    props: {
      challenge: {},
      playerActive: {
        type: Boolean
      },
      isEmpty: {
        type: Boolean
      }
    },
    setup(e) {
      const {
        t
      } = Fe(), n = e, r = () => n.challenge.image_url ? n.challenge.image_url : z9(), s = L(() => n.challenge.prize_pool_cents_in_player_currency ? zp(n.challenge.prize_pool_cents_in_player_currency || 0) : null), a = L(() => Rt(n.challenge.prize_pool_cents_in_player_currency || 0));
      return (o, i) => (g(), G(u(Jp), {
        class: "mx-3 mb-4 overflow-hidden rounded-3xl border border-white-10 bg-gray-lighter"
      }, {
        default: V(() => [$(u(N9), {
          class: "flex items-center border-b-0 border-l-0 border-t-0"
        }, {
          default: V(() => [m("div", bY, [m("img", {
            src: r(),
            alt: "Event",
            class: "relative w-full"
          }, null, 8, wY), m("div", CY, [o.challenge.privacy === u(bn).Private ? (g(), G(jc, {
            key: 0,
            class: "flex items-center justify-center rounded-full bg-gray-lighter px-2 py-2 text-yellow"
          }, {
            default: V(() => [$(u(C9), {
              class: "text-yellow"
            })]),
            _: 1
          })) : z("", !0), $(jc, {
            class: "flex items-center justify-center rounded-full bg-gray-lighter px-4 py-2 text-yellow"
          }, {
            default: V(() => [m("span", xY, R(o.challenge.fee > 0 ? u(t)("challenge.join.join_pro_badge") : u(t)("challenge.join.badge")), 1)]),
            _: 1
          })])])]),
          _: 1
        }), $(u(F9), {
          class: "rounded-b-3xl border-0 border-white-10 p-0"
        }, {
          default: V(() => [m("div", kY, [$(u(Qp), {
            class: we(["text-theme-blue-green h-5 w-5", {
              hidden: !o.playerActive
            }])
          }, null, 8, ["class"]), m("h2", SY, R(o.challenge.name), 1)]), m("div", EY, [s.value ? (g(), k("div", TY, [m("div", AY, R(u(t)("drop.general.prize_pool")), 1), m("div", PY, [m("span", null, R(s.value), 1), $(u(_d), null, {
            default: V(() => [$(u(yd), null, {
              default: V(() => [$(u(hd))]),
              _: 1
            }), $(u(bd), null, {
              default: V(() => [m("span", null, R(a.value), 1)]),
              _: 1
            })]),
            _: 1
          })])])) : z("", !0), m("div", IY, [$(t1, {
            id: o.challenge.id,
            status: o.challenge.status,
            start_at: o.challenge.start_at,
            finish_at: o.challenge.finish_at
          }, null, 8, ["id", "status", "start_at", "finish_at"])])])]),
          _: 1
        })]),
        _: 1
      }))
    }
  }),
  MY = {
    class: "flex items-center justify-between gap-2"
  },
  OY = {
    class: "flex flex-col gap-1"
  },
  DY = {
    class: "flex-end flex gap-2 self-stretch"
  },
  LY = te({
    __name: "ChallengeListCardCompact",
    props: {
      challenge: {},
      playerActive: {
        type: Boolean
      },
      isSelected: {
        type: Boolean
      }
    },
    setup(e) {
      const {
        t
      } = Fe();
      return (n, r) => (g(), G(u(Jp), {
        class: we(["mx-4 mb-4 cursor-pointer gap-0 overflow-hidden border-t border-white-10 p-3 sm:mx-0 sm:mb-0 sm:rounded-none", {
          "bg-gray-lighter": !n.isSelected,
          "bg-yellow text-black": n.isSelected,
          "bg-opacity-50": n.challenge.status === u(tt).Finished || n.challenge.status === u(tt).Sync
        }])
      }, {
        default: V(() => [m("div", MY, [m("div", OY, [m("h2", {
          class: we(["text-14 font-bold md:text-16 lg:text-18", {
            "opacity-50": n.challenge.status === u(tt).Finished || n.challenge.status === u(tt).Sync
          }])
        }, R(n.challenge.name), 3), n.challenge.status === u(tt).Ongoing || n.challenge.status === u(tt).Planned ? (g(), k("h2", {
          key: 0,
          class: we(["text-12 uppercase opacity-50 md:text-13 lg:text-14", {
            "text-white-50": !n.isSelected,
            "text-gray": n.isSelected
          }])
        }, R(n.challenge.fee > 0 ? u(t)("challenge.join.join_pro_badge") : u(t)("challenge.join.badge")), 3)) : z("", !0), $(t1, {
          id: n.challenge.id,
          status: n.challenge.status,
          isCompactMode: !0,
          start_at: n.challenge.start_at,
          finish_at: n.challenge.finish_at,
          isSelected: n.isSelected
        }, null, 8, ["id", "status", "start_at", "finish_at", "isSelected"])]), m("div", DY, [(n.challenge.status === u(tt).Ongoing || n.challenge.status === u(tt).Planned) && n.challenge.privacy === u(bn).Private ? (g(), G(u(C9), {
          key: 0,
          class: we(["h-6 w-6", {
            "text-yellow": !n.isSelected
          }])
        }, null, 8, ["class"])) : z("", !0), !n.isSelected && n.playerActive ? (g(), G(u(Qp), {
          key: 1,
          class: we(["text-theme-blue-green h-5 w-5", {
            "text-gray": n.isSelected
          }])
        }, null, 8, ["class"])) : z("", !0), n.isSelected && n.playerActive ? (g(), G(u(Wp), {
          key: 2,
          class: we(["h-5 w-5 text-gray", {
            "text-opacity-50": n.challenge.status === u(tt).Finished || n.challenge.status === u(tt).Sync
          }])
        }, null, 8, ["class"])) : z("", !0)])])]),
        _: 1
      }, 8, ["class"]))
    }
  }),
  RY = {
    class: "flex w-full flex-col"
  },
  NY = ["onClick"],
  Gy = te({
    __name: "ChallengeListCards",
    props: {
      id: {},
      challenges: {},
      cardMode: {}
    },
    setup(e) {
      const t = e,
        n = Mr(),
        r = Hn("challenge"),
        s = () => {
          r != null && r.isLeaderboardPage && (r.isLeaderboardPage.value = !1)
        },
        a = o => {
          s(), Cn.push({
            name: "challenge",
            params: {
              ...n.params,
              id: o.id
            }
          })
        };
      return (o, i) => (g(), k("div", RY, [(g(!0), k(Ee, null, Je(t.challenges, l => (g(), k("div", {
        key: l.id,
        onClick: c => a(l)
      }, [o.cardMode === "full" ? (g(), G($Y, {
        key: 0,
        playerActive: l.player_active,
        challenge: l
      }, null, 8, ["playerActive", "challenge"])) : z("", !0), o.cardMode === "compact" ? (g(), G(LY, {
        key: 1,
        playerActive: l.player_active,
        challenge: l,
        isSelected: `${l.id}` === o.id
      }, null, 8, ["playerActive", "challenge", "isSelected"])) : z("", !0)], 8, NY))), 128))]))
    }
  }),
  Y9 = e => {
    const t = Ob(e, 300),
      n = L(() => t.value.length === 0 || t.value.length > zh),
      r = U(xl);
    Ne(t, () => {
      r.value = xl
    });
    const s = ns({
      queryKey: ["challengeSearchPagination", t, r],
      queryFn: () => t.value.length === 0 || t.value.length > zh ? Ib({
        page: 1,
        per_page: r.value,
        search: t.value,
        status: "active"
      }) : Promise.resolve([]),
      refetchInterval: 30 * 1e3,
      placeholderData: ts,
      staleTime: 30 * 1e3,
      enabled: n
    });
    return {
      ...s,
      loadMore: () => {
        Sb.value >= r.value && (r.value += xl, s.refetch())
      },
      perPage: r
    }
  },
  W9 = e => {
    const t = Ob(e, 300),
      n = L(() => t.value.length === 0 || t.value.length > zh);
    return ns({
      queryKey: ["challengeFinishedSearchPagination", t],
      queryFn: () => Ib({
        page: 1,
        per_page: xl,
        search: e.value,
        status: "finished"
      }),
      refetchInterval: 30 * 1e3,
      placeholderData: ts,
      staleTime: 30 * 1e3,
      enabled: n
    })
  },
  FY = {
    class: "relative flex h-fit min-h-80 w-full flex-col items-center pb-16 sm:pb-0"
  },
  BY = {
    key: 0,
    class: "sticky left-0 top-0 z-10 hidden h-full w-full border-b border-white-10 bg-gray sm:block"
  },
  jY = {
    class: "flex items-center justify-between gap-2"
  },
  HY = {
    class: "text-transform-theme-none-uppercase text-theme-white-yellow text-center font-accent text-24 font-bold"
  },
  VY = {
    key: 3,
    class: "flex w-full flex-1 items-center justify-center"
  },
  UY = {
    key: 4,
    class: "flex w-full flex-1 justify-center pt-4 sm:pt-0"
  },
  zY = {
    class: "w-full p-3 text-12 font-medium uppercase text-gray-lightest md:p-4 md:text-13 lg:p-5 lg:text-17"
  },
  YY = {
    key: 0,
    class: "flex w-full justify-center py-4 sm:py-0"
  },
  WY = {
    key: 1,
    class: "w-full p-3 text-12 font-medium uppercase text-gray-lightest md:p-4 md:text-13 lg:p-5 lg:text-17"
  },
  GY = {
    key: 6,
    class: "flex w-full flex-1 justify-center pt-4 sm:pt-0"
  },
  QY = {
    key: 7,
    class: "sticky bottom-4 left-0 z-[2] flex w-full items-center justify-center pt-1"
  },
  qY = {
    class: "text-13 font-bold uppercase md:text-15"
  },
  KY = {
    key: 0,
    class: "fixed bottom-[5rem] flex w-full items-center justify-center"
  },
  ZY = {
    class: "text-15 font-bold uppercase"
  },
  G9 = te({
    __name: "ChallengeList",
    props: {
      id: {}
    },
    setup(e) {
      const {
        data: t
      } = Kp(), {
        data: n
      } = A0(), {
        t: r
      } = Fe(), s = Tr("(min-width: 568px)"), {
        isLoading: a,
        error: o,
        data: i,
        loadMore: l
      } = Y9(Cr), {
        data: c
      } = W9(Cr), d = U(!1), f = U(null), p = L(() => i.value || []), h = p9(async () => {
        l()
      }, 300), _ = x => {
        if (x.currentTarget.scrollTop > 48 ? d.value = !0 : d.value = !1, !f.value) return;
        const T = f.value.getBoundingClientRect(),
          j = window.innerHeight;
        T.top >= 0 && T.top <= j && h()
      }, v = () => {
        Cn.push({
          name: "create_challenge"
        })
      }, C = U(!1), y = () => {
        Tc(), C.value = !C.value
      }, b = L(() => C.value || !t.value), w = () => {
        Tc(), ps()
      };
      return Ge(() => {
        Jt({
          payload: {
            eventName: "lobby_challenges_open",
            eventData: {
              player_id: wn.value
            }
          }
        })
      }), (x, E) => (g(), G(u(Jn), {
        class: "h-full w-full p-0",
        handleScroll: _
      }, {
        default: V(() => [m("div", FY, [u(n) ? (g(), k("div", BY, [$(u(Al), {
          class: "absolute left-3 top-4 text-16 leading-4 text-white-30"
        }), Tn(m("input", {
          "onUpdate:modelValue": E[0] || (E[0] = S => Ht(Cr) ? Cr.value = S : null),
          type: "text",
          placeholder: "Search",
          class: "bg-theme-gray-dark hidden h-full w-full items-center justify-start gap-2 py-4 pl-10 pr-4 text-13 focus:outline-none sm:inline-flex"
        }, null, 512), [
          [Mi, u(Cr)]
        ])])) : z("", !0), u(s) ? z("", !0) : (g(), k("div", {
          key: 1,
          class: we(["sticky top-0 z-[56] flex h-12 w-full items-center justify-center rounded-t-xl border-b border-white-10 bg-gray-lighter", b.value ? "" : "border-b border-white-10"])
        }, [m("div", jY, [m("h1", HY, R(u(r)("challenge.title")), 1)]), $(u(pr), {
          class: "absolute right-1 top-1 cursor-pointer hover:scale-95 sm:hidden",
          onClick: w
        })], 2)), u(s) ? z("", !0) : (g(), k("div", {
          key: 2,
          class: we(["flex w-full", b.value ? "sticky top-11 z-10 border-b border-white-10 bg-gray pb-2" : ""])
        }, [$(Zp, {
          class: "mx-2 mb-0 mt-1 w-full py-2",
          isSearch: !0,
          isOpenedSearch: C.value,
          toggleSearch: y
        }, null, 8, ["isOpenedSearch"])], 2)), u(a) ? (g(), k("div", VY, [$(u(Ka))])) : u(o) ? (g(), k("div", UY, [$(u(Pi), {
          isRounded: !u(s),
          title: u(r)("common.error.list_title"),
          subTitle: u(r)("common.error.sub_title")
        }, null, 8, ["isRounded", "title", "subTitle"])])) : p.value && p.value.length || u(c) && u(c).length ? (g(), k("div", {
          key: 5,
          class: we(["flex w-full flex-col", u(n) && "pb-14 sm:pb-6"])
        }, [m("div", zY, R(u(r)("common.event_list.active_title")), 1), $(Gy, {
          id: x.id,
          challenges: p.value ? p.value : [],
          cardMode: u(s) ? "compact" : "full"
        }, null, 8, ["id", "challenges", "cardMode"]), p.value && p.value.length ? z("", !0) : (g(), k("div", YY, [$(u(Pi), {
          isRounded: !u(s),
          title: u(r)("common.event_list.empty.title"),
          subTitle: u(r)("common.event_list.empty.sub_title")
        }, null, 8, ["isRounded", "title", "subTitle"])])), m("div", {
          ref_key: "finishedChallengesRef",
          ref: f
        }, null, 512), u(c) && u(c).length ? (g(), k("div", WY, R(u(r)("common.event_list.ended_title")), 1)) : z("", !0), $(Gy, {
          id: x.id,
          challenges: u(c) ? u(c) : [],
          cardMode: "compact"
        }, null, 8, ["id", "challenges"])], 2)) : (g(), k("div", GY, [$(u(Pi), {
          isRounded: !u(s),
          title: u(r)("common.event_list.empty.title"),
          subTitle: u(r)("common.event_list.empty.sub_title")
        }, null, 8, ["isRounded", "title", "subTitle"])])), u(n) && u(s) ? (g(), k("div", QY, [$(jc, {
          class: "cursor-pointer px-4 py-2 shadow-[0_0_4px_rgba(0,0,0,0.25)] md:px-8 md:py-3",
          variant: "large",
          onClick: v
        }, {
          default: V(() => [m("span", qY, R(u(r)("challenge.p2p.title")), 1)]),
          _: 1
        })])) : z("", !0)]), u(n) && !u(s) ? (g(), k("div", KY, [$(jc, {
          class: "cursor-pointer px-8 py-3 shadow-[0_0_4px_rgba(0,0,0,0.25)]",
          variant: "large",
          onClick: v
        }, {
          default: V(() => [m("span", ZY, R(u(r)("challenge.p2p.title")), 1)]),
          _: 1
        })])) : z("", !0)]),
        _: 1
      }))
    }
  }),
  JY = te({
    __name: "PaginationCell",
    props: {
      page: {},
      active: {
        type: Boolean
      }
    },
    setup(e) {
      return (t, n) => (g(), k("div", {
        class: we(["flex h-9 w-9 items-center justify-center rounded text-13", {
          "bg-theme-white_opacity-yellow cursor-default font-bold text-black": t.active,
          "cursor-default": !t.page,
          "cursor-pointer": !t.active && t.page
        }])
      }, R(t.page || "..."), 3))
    }
  }),
  XY = {
    key: 0,
    class: "flex items-center justify-center"
  },
  eW = te({
    __name: "Pagination",
    props: J6({
      total: {},
      perPage: {}
    }, {
      page: {
        default: 1,
        required: !0,
        type: Number
      },
      pageModifiers: {}
    }),
    emits: ["update:page"],
    setup(e) {
      const t = e,
        n = Cw(e, "page"),
        r = L(() => {
          const a = t.total % t.perPage > 0 ? Math.floor(t.total / t.perPage) + 1 : Math.floor(t.total / t.perPage),
            o = 7,
            i = Math.floor(o / 2);
          return a <= o ? Array.from({
            length: a
          }, (l, c) => c + 1) : n.value <= i + 1 ? [...Array.from({
            length: 5
          }, (l, c) => c + 1), null, a] : n.value > a - i ? [1, null, ...Array.from({
            length: 5
          }, (l, c) => a - 4 + c)] : [1, null, n.value - 1, n.value, n.value + 1, null, a]
        }),
        s = a => {
          a && (n.value = a)
        };
      return (a, o) => r.value && r.value.length > 1 ? (g(), k("div", XY, [(g(!0), k(Ee, null, Je(r.value, (i, l) => (g(), G(JY, {
        key: l,
        page: i,
        active: i === n.value,
        onClick: c => s(i)
      }, null, 8, ["page", "active", "onClick"]))), 128))])) : z("", !0)
    }
  }),
  Q9 = (e, t) => ns({
    queryKey: ["challengeLeaderboard", e, t],
    queryFn: () => lk({
      id: e.value,
      page: t.value
    }),
    enabled: L(() => !!e.value),
    refetchInterval: 30 * 1e3,
    placeholderData: ts,
    staleTime: 30 * 1e3
  }),
  tW = {
    class: "ml-2"
  },
  nW = {
    class: "ml-2 flex-shrink-0"
  },
  rW = {
    key: 1,
    class: "flex"
  },
  sW = {
    class: "mr-2 flex"
  },
  aW = {
    class: "mr-2"
  },
  bf = te({
    __name: "ChallengeLeaderboardPlayer",
    props: {
      isCurrent: {
        type: Boolean
      },
      player: {},
      prize: {}
    },
    emits: ["setUserElement"],
    setup(e, {
      emit: t
    }) {
      const n = e,
        r = U(!1),
        s = L(() => {
          var l, c;
          return r.value ? (l = n == null ? void 0 : n.player) == null ? void 0 : l.code : ((c = n == null ? void 0 : n.player) == null ? void 0 : c.code.slice(0, -4)) + "****"
        }),
        a = L(() => n.player.hasOwnProperty("max_multiplier") ? n.player.max_multiplier ? `×${n.player.max_multiplier}` : "x0" : n.player.hasOwnProperty("bets_sum") ? n.player.bets_sum ? `${n.player.bets_sum}` : "0" : n.player.hasOwnProperty("top_multiplier_sum") ? n.player.top_multiplier_sum ? `×${n.player.top_multiplier_sum}` : "x0" : n.player.hasOwnProperty("multipliers_sum") ? n.player.multipliers_sum ? `×${n.player.multipliers_sum}` : "x0" : "-"),
        o = U(null),
        i = t;
      return Ge(() => {
        n.isCurrent && i("setUserElement", o.value)
      }), (l, c) => (g(), k(Ee, null, [m("div", {
        ref_key: "playerDiv",
        ref: o,
        class: we(["flex h-8 items-center justify-end rounded-l-md text-13 font-bold", {
          "bg-theme-white-dark text-theme-dark-yellow": l.isCurrent
        }])
      }, [m("div", tW, R(l.player && l.player.rank ? l.player.rank : "-"), 1)], 2), m("div", {
        class: we(["flex h-8 items-center justify-start text-13", {
          "bg-theme-white-dark text-theme-dark-yellow": l.isCurrent
        }])
      }, [m("div", nW, [l.isCurrent ? (g(), k("div", {
        key: 0,
        class: "flex cursor-pointer",
        onClick: c[0] || (c[0] = d => r.value = !r.value)
      }, [m("span", null, R(s.value), 1), r.value ? (g(), G(u(KN), {
        key: 1,
        class: "ml-2"
      })) : (g(), G(u(WN), {
        key: 0,
        class: "ml-2"
      }))])) : (g(), k("div", rW, R(l.player.code), 1))])], 2), m("div", {
        class: we(["flex h-8 items-center justify-end text-13 font-bold", {
          "bg-theme-white-dark text-theme-dark-yellow": l.isCurrent
        }])
      }, [m("div", sW, R(a.value), 1)], 2), m("div", {
        class: we(["flex h-8 items-center justify-end rounded-r-md pr-4 text-13 font-bold", {
          "bg-theme-white-dark text-theme-dark-yellow": l.isCurrent
        }])
      }, [m("div", aW, R(l.prize), 1)], 2)], 64))
    }
  }),
  oW = {
    key: 0,
    class: "absolute left-0 top-[62px] z-[1] w-full"
  },
  iW = {
    class: "bg-theme-white-none col-span-4 rounded-md"
  },
  lW = {
    class: "grid grid-cols-[1fr_6fr_4fr_4fr] text-black"
  },
  uW = {
    key: 0,
    class: "absolute col-span-4 h-4 w-full"
  },
  cW = {
    class: "bg-theme-white-none col-span-4 rounded-md"
  },
  dW = {
    class: "grid grid-cols-[1fr_6fr_4fr_4fr]"
  },
  q9 = te({
    __name: "ChallengeLeaderboardPlayers",
    props: {
      players: {},
      current: {},
      prize_places: {},
      category: {},
      total: {},
      full: {
        type: Boolean
      }
    },
    setup(e) {
      const t = e,
        n = L(() => {
          var b;
          return (b = t.players[0]) == null ? void 0 : b.rank
        }),
        r = L(() => {
          var b;
          return (b = t.players[t.players.length - 1]) == null ? void 0 : b.rank
        }),
        s = L(() => {
          var b;
          return (b = t.current) == null ? void 0 : b.rank
        }),
        a = b => {
          const w = t.prize_places.find(E => E.place === b);
          return t.category === ln.P2P ? `${(w==null?void 0:w.prize)||0}` : Rt(Number((w == null ? void 0 : w.prize) || 0), !0)
        },
        o = L(() => t.full ? t.players : t.players.slice(0, 10)),
        i = U(null),
        l = L(() => n.value === void 0 || r.value === void 0 || s.value === void 0),
        c = L(() => {
          if (l.value) return !1;
          const b = s.value;
          return b >= n.value && b <= r.value
        }),
        d = L(() => {
          if (!t.full || l.value) return null;
          if (i.value) return i.value;
          const b = s.value,
            w = n.value,
            x = r.value;
          return b === 0 ? "bottom" : b <= w ? "top" : b >= x ? "bottom" : null
        }),
        f = U(),
        p = U(),
        h = U(null),
        _ = () => {
          var E, S, T;
          const b = (E = f.value) == null ? void 0 : E.getBoundingClientRect().y,
            w = (S = p.value) == null ? void 0 : S.getBoundingClientRect().y,
            x = (T = h.value) == null ? void 0 : T.getBoundingClientRect();
          if (b === void 0 || w === void 0 || !x) {
            i.value = null;
            return
          }
          if (x.top < b) {
            i.value = "top";
            return
          }
          if (x.bottom > w) {
            i.value = "bottom";
            return
          }
          i.value = "middle"
        },
        v = () => {
          c.value ? _() : h.value = null
        };
      Ne(() => t.players, () => {
        c.value ? _() : (i.value = null, h.value = null)
      });
      const C = b => {
          h.value = b, _()
        },
        y = L(() => t.full ? t.total > Vh ? "max-h-[calc(100vh-214px)] sm:max-h-[calc(100vh-272px)]" : "max-h-[calc(100vh-154px)] sm:max-h-[calc(100vh-212px)]" : "max-h-[330px]");
      return (b, w) => (g(), k(Ee, null, [d.value === "top" && b.current ? (g(), k("div", oW, [m("div", iW, [m("div", lW, [$(bf, {
        prize: a(b.current.rank),
        "is-current": !0,
        player: b.current
      }, null, 8, ["prize", "player"])])]), w[0] || (w[0] = m("div", {
        class: "bg-theme-yellow-none col-span-4 flex h-6 items-baseline justify-center"
      }, "...", -1))])) : z("", !0), m("div", {
        ref_key: "topElement",
        ref: f
      }, null, 512), $(u(Jn), {
        darkTheme: !0,
        handleScroll: v,
        class: "relative"
      }, {
        default: V(() => [m("div", {
          class: we(["grid grid-cols-[1fr_6fr_4fr_4fr]", y.value])
        }, [d.value === "top" && b.current ? (g(), k(Ee, {
          key: 0
        }, [w[1] || (w[1] = m("div", {
          class: "col-span-4 h-7"
        }, null, -1)), w[2] || (w[2] = m("div", {
          class: "col-span-4 h-7"
        }, null, -1))], 64)) : z("", !0), (g(!0), k(Ee, null, Je(o.value, x => {
          var E, S, T;
          return g(), k("div", {
            key: x.rank,
            class: "relative contents"
          }, [$(bf, {
            prize: a(x.rank),
            player: (E = b.current) != null && E.rank && x.rank === b.current.rank ? b.current : x,
            isCurrent: !!((S = b.current) != null && S.rank && x.rank === b.current.rank),
            onSetUserElement: C
          }, null, 8, ["prize", "player", "isCurrent"]), w[3] || (w[3] = m("div", {
            class: "col-span-4 border-b border-black-10 opacity-50"
          }, null, -1)), (T = b.current) != null && T.rank && x.rank === b.current.rank ? (g(), k("div", uW)) : z("", !0)])
        }), 128)), d.value === "bottom" && b.current ? (g(), k(Ee, {
          key: 1
        }, [w[4] || (w[4] = m("div", {
          class: "col-span-4 h-7"
        }, null, -1)), w[5] || (w[5] = m("div", {
          class: "col-span-4 h-7"
        }, null, -1))], 64)) : z("", !0)], 2)]),
        _: 1
      }), m("div", {
        ref_key: "bottomElement",
        ref: p
      }, null, 512), d.value === "bottom" && b.current ? (g(), k("div", {
        key: 1,
        class: we(["absolute left-0 z-[1] w-full", t.total > u(Vh) ? "bottom-[62px]" : "bottom-0"])
      }, [w[6] || (w[6] = m("div", {
        class: "bg-theme-yellow-none col-span-4 flex h-6 items-baseline justify-center"
      }, "...", -1)), m("div", cW, [m("div", dW, [$(bf, {
        prize: a(b.current.rank),
        "is-current": !0,
        player: b.current
      }, null, 8, ["prize", "player"])])])], 2)) : z("", !0)], 64))
    }
  }),
  fW = {
    class: "flex h-full items-center justify-center"
  },
  pW = {
    class: "m-6 flex w-full flex-col items-center justify-center gap-3 text-center"
  },
  hW = {
    class: "font-accent text-18 font-bold text-gray"
  },
  mW = {
    class: "font-accent text-13 font-normal text-gray"
  },
  gW = te({
    __name: "ChallengeLeaderboardEmpty",
    setup(e) {
      const {
        t
      } = Fe();
      return (n, r) => (g(), k("div", fW, [m("div", pW, [m("div", null, [$(u(qR), {
        class: "h-24 w-24 text-black-30"
      })]), m("div", hW, [m("h1", null, R(u(t)("common.error.leaderboard_title")), 1)]), m("div", mW, [m("p", null, R(u(t)("common.error.sub_title")), 1)])])]))
    }
  }),
  Og = e => ns({
    queryKey: ["challengeDetails", e],
    queryFn: () => uk(e.value),
    select: t => (t.image_url = t.custom_header_url || t.image_url, t),
    enabled: L(() => !!e.value),
    refetchInterval: 60 * 1e3,
    placeholderData: ts,
    staleTime: 60 * 1e3
  }),
  vW = {
    class: "relative flex h-full w-full flex-col"
  },
  _W = {
    key: 0,
    class: "flex min-h-20 w-full flex-1 items-center justify-center"
  },
  yW = {
    key: 1,
    class: "flex w-full flex-1 justify-center pt-4 sm:pt-0"
  },
  bW = {
    class: "grid grid-cols-[1fr_6fr_4fr_4fr]"
  },
  wW = {
    class: "flex h-8 items-center justify-end text-10 uppercase opacity-50"
  },
  CW = {
    class: "flex h-8 items-center justify-start text-10 uppercase opacity-50"
  },
  xW = {
    class: "ml-2"
  },
  kW = {
    class: "flex h-8 items-center justify-end text-10 uppercase opacity-50"
  },
  SW = {
    class: "mr-2"
  },
  EW = {
    class: "flex h-8 items-center justify-end pr-4 text-10 uppercase opacity-50"
  },
  TW = {
    class: "mr-2"
  },
  AW = {
    class: "col-span-4"
  },
  PW = te({
    __name: "ChallengeLeaderboardPage",
    props: {
      id: {}
    },
    setup(e) {
      const t = e,
        {
          t: n
        } = Fe(),
        r = U(1),
        s = L(() => t.id),
        {
          isLoading: a,
          error: o,
          data: i
        } = Og(s),
        {
          isLoading: l,
          error: c,
          data: d
        } = Q9(s, r),
        f = L(() => {
          var v, C, y;
          return ((v = i.value) == null ? void 0 : v.challenge_type) === ht.BetsSum ? "_bets" : ((C = i.value) == null ? void 0 : C.challenge_type) === ht.TopMultiplierSum || ((y = i.value) == null ? void 0 : y.challenge_type) === ht.MultipliersSum ? "_mult" : ""
        }),
        p = L(() => {
          var y;
          const C = ((y = i.value) == null ? void 0 : y.category) === ln.P2P ? ", %" : `, ${Li.code}`;
          return `${n("challenge.leaderboard.prize")}${C}`
        }),
        h = Hn("challenge"),
        _ = () => {
          var v, C;
          h != null && h.isLeaderboardPage && (h.isLeaderboardPage.value = !1, Jt({
            payload: {
              eventName: "lobby_challenges_full_leaderboard_closed",
              eventData: {
                player_id: wn.value,
                challenge_id: (v = i.value) == null ? void 0 : v.id,
                challenge_status: (C = i.value) == null ? void 0 : C.status
              }
            }
          }))
        };
      return (v, C) => (g(), G(u(Jn), {
        class: "text-theme-dark-white flex h-full flex-col"
      }, {
        default: V(() => [$(u(Bt), {
          colored: !0,
          class: "mb-4 gap-3 px-2"
        }, {
          default: V(() => [m("div", vW, [$(u(qa), {
            class: "text-theme-black-white absolute -top-2 right-1 cursor-pointer",
            onClick: _
          }), $(u(Za), {
            variant: "blackNoneTransform",
            class: "mb-2"
          }, {
            default: V(() => [Ye(R(u(n)("challenge.leaderboard.title_full")), 1)]),
            _: 1
          }), u(l) || u(a) ? (g(), k("div", _W, [$(u(Ka), {
            isSecondary: !0
          })])) : u(c) || u(o) || !u(d) || !u(i) ? (g(), k("div", yW, [$(gW)])) : (g(), k(Ee, {
            key: 2
          }, [m("div", bW, [m("div", wW, [m("div", null, R(u(n)("challenge.leaderboard.column_rank")), 1)]), m("div", CW, [m("div", xW, R(u(n)("challenge.leaderboard.column_id")), 1)]), m("div", kW, [m("div", SW, R(u(n)(`challenge.leaderboard.column_result${f.value}`)), 1)]), m("div", EW, [m("div", TW, R(p.value), 1)]), C[1] || (C[1] = m("div", {
            class: "col-span-4 border-b border-black-10 opacity-50"
          }, null, -1))]), $(q9, {
            prize_places: u(i).prize_places,
            category: u(i).category,
            players: u(d).top,
            current: u(d).current_player,
            full: !0,
            total: u(d).total_participants_count
          }, null, 8, ["prize_places", "category", "players", "current", "total"]), m("div", AW, [$(eW, {
            class: "my-4",
            total: u(d).total_participants_count,
            page: r.value,
            "onUpdate:page": C[0] || (C[0] = y => r.value = y),
            "per-page": 100
          }, null, 8, ["total", "page"])])], 64))])]),
          _: 1
        })]),
        _: 1
      }))
    }
  }),
  Dg = "./assets/triangleInfo.png",
  IW = () => E0({
    mutationKey: ["joinChallenge"],
    mutationFn: ({
      id: e,
      join_code: t,
      game_identifier: n
    }) => ck(e, t, n),
    onSuccess: async () => {
      Eb(), await $t.invalidateQueries({
        queryKey: ["challenges"]
      }), await $t.invalidateQueries({
        queryKey: ["challengeSearchPagination"]
      }), await $t.invalidateQueries({
        queryKey: ["challengeFinishedSearchPagination"]
      }), await $t.invalidateQueries({
        queryKey: ["challengeDetails"]
      }), await $t.invalidateQueries({
        queryKey: ["challengeLeaderboard"]
      })
    },
    onError: (e, t) => (Jt({
      payload: {
        eventName: "lobby_challenges_error",
        eventData: {
          player_id: wn.value,
          challenge_id: t.id,
          challenge_status: t == null ? void 0 : t.status,
          game_identifier: t.game_identifier,
          error_code: e.code
        }
      }
    }), {
      status: e.status || null,
      message: e.message || "An unknown error occurred",
      code: e.code
    })
  }),
  $W = {
    key: 0,
    class: "mx-4 mt-4"
  },
  MW = {
    key: 0,
    class: "mb-5 text-center text-13 font-normal text-red-500"
  },
  OW = {
    key: 1,
    class: "mb-5 text-center text-13 font-normal text-red-500"
  },
  DW = {
    class: "flex items-center justify-center"
  },
  LW = {
    class: "w-full"
  },
  RW = {
    key: 0,
    class: "color-white mb-5 text-center font-accent text-18 font-bold"
  },
  NW = {
    key: 1,
    class: "mb-5"
  },
  FW = ["onUpdate:modelValue", "onInput", "onKeydown"],
  BW = {
    key: 2,
    class: "color-white mb-5 text-center font-accent text-18 font-bold"
  },
  jW = {
    key: 3,
    class: "mb-5 text-center text-13 font-normal text-red-500"
  },
  HW = {
    key: 4,
    class: "mb-5 text-center text-13 font-normal text-red-500"
  },
  Q1 = 5,
  VW = te({
    __name: "ChallengeJoinCode",
    props: {
      id: {},
      isAutoJoin: {
        type: Boolean
      },
      joinCode: {},
      fee: {},
      isEnoughMoneyToJoin: {
        type: Boolean
      },
      challenge: {}
    },
    setup(e) {
      const t = e,
        {
          t: n
        } = Fe(),
        r = U(["", "", "", "", ""]),
        s = U(""),
        a = U([]),
        o = L(() => t.id),
        {
          isLoading: i
        } = Og(o),
        {
          mutate: l,
          isPending: c,
          error: d,
          reset: f
        } = IW(),
        p = L(() => c.value || i.value),
        h = L(() => p.value || !t.isEnoughMoneyToJoin ? "processing" : "link"),
        _ = L(() => s.value.length !== Q1 && !t.isAutoJoin),
        v = L(() => p.value ? n("challenge.join.loading") : t.fee ? n("challenge.join.join_pro_button") : t.isAutoJoin ? n("challenge.join.button_auto") : n("challenge.join.button")),
        C = j => {
          if (!j) return n("challenge.join.error.default");
          const N = `challenge.join.error.${j}`,
            ne = n(N);
          return ne === N ? n("challenge.join.error.default") : ne
        },
        y = L(() => {
          if (d.value) return C(d.value.code)
        }),
        b = () => {
          s.value = "", r.value = ["", "", "", "", ""], a.value = [], f()
        },
        w = () => {
          var P, N, ne, Y;
          Jt({
            payload: {
              eventName: "lobby_challenges_click_join",
              eventData: {
                player_id: wn.value,
                challenge_id: (P = t.challenge) == null ? void 0 : P.id,
                challenge_status: (N = t.challenge) == null ? void 0 : N.status,
                challenge_join_type: ((ne = t.challenge) == null ? void 0 : ne.privacy) === bn.Private ? "invite_code" : "for_free"
              }
            }
          });
          const j = t.isAutoJoin && t.joinCode ? t.joinCode : s.value;
          l({
            id: o.value,
            join_code: j,
            game_identifier: Kn.identifier,
            status: (Y = t.challenge) == null ? void 0 : Y.status
          })
        },
        x = () => {
          s.value = r.value.join("").toUpperCase()
        },
        E = (j, P) => {
          const ne = j.target.value;
          ne.length >= 2 || (r.value[P] = ne, r.value[P].length === 1 && (P < r.value.length - 1 ? a.value[P + 1].focus() : a.value[P].blur()), x())
        },
        S = (j, P) => {
          P.key === "Backspace" && j > 0 && r.value[j] === "" && a.value[j - 1].focus()
        },
        T = j => {
          var N;
          const P = (N = j.clipboardData) == null ? void 0 : N.getData("text").substring(0, Q1);
          P && P.length === Q1 && (r.value = P.split(""), a.value[r.value.length - 1].focus(), x(), j.preventDefault())
        };
      return Ne(() => o.value, () => {
        b()
      }), (j, P) => j.isAutoJoin && !j.fee ? (g(), k("div", $W, [y.value ? (g(), k("p", MW, R(y.value), 1)) : j.isEnoughMoneyToJoin ? z("", !0) : (g(), k("p", OW, R(u(n)("challenge.join.join_balance_error")), 1)), $(qt, {
        variant: h.value,
        onClick: w
      }, {
        default: V(() => [Ye(R(v.value), 1)]),
        _: 1
      }, 8, ["variant"])])) : (g(), G(u(Bt), {
        key: 1
      }, {
        default: V(() => [m("div", DW, [m("div", LW, [j.isAutoJoin ? z("", !0) : (g(), k("p", RW, R(u(n)("challenge.join.title")), 1)), j.isAutoJoin ? z("", !0) : (g(), k("div", NW, [m("form", {
          onSubmit: Er(w, ["prevent"]),
          class: "flex items-center justify-center gap-2"
        }, [(g(!0), k(Ee, null, Je(r.value, (N, ne) => Tn((g(), k("input", {
          class: we(["color-white border-theme-rounded-xl-sm w-12 border border-[rgba(0,0,0,0.10)] bg-black-10 py-4 text-center font-accent text-24 font-bold uppercase shadow-[inset_2px_4px_2px_2px_rgba(0,0,0,0.10),inset_0_-1px_0_0_rgba(200,200,200,0.30)] focus:outline-none", {
            "shadow-none border-red-500": y.value
          }]),
          key: ne,
          "onUpdate:modelValue": Y => r.value[ne] = Y,
          maxlength: "1",
          onInput: Y => E(Y, ne),
          onKeydown: Z5(Y => S(ne, Y), ["backspace"]),
          onPaste: T,
          type: "text",
          ref_for: !0,
          ref_key: "inputRefs",
          ref: a
        }, null, 42, FW)), [
          [Mi, r.value[ne]]
        ])), 128))], 32)])), j.fee ? (g(), k("p", BW, R(u(n)("challenge.join.fee")) + " " + R(j.fee), 1)) : z("", !0), y.value ? (g(), k("p", jW, R(y.value), 1)) : j.isEnoughMoneyToJoin ? z("", !0) : (g(), k("p", HW, R(u(n)("challenge.join.join_balance_error")), 1)), $(qt, {
          variant: h.value,
          disabled: _.value,
          onClick: w
        }, {
          default: V(() => [Ye(R(v.value), 1)]),
          _: 1
        }, 8, ["variant", "disabled"])])])]),
        _: 1
      }))
    }
  }),
  UW = {
    class: "flex w-full items-center gap-3"
  },
  zW = {
    key: 0
  },
  YW = {
    key: 1
  },
  WW = {
    class: "flex w-full items-center gap-3 whitespace-pre-wrap text-orange"
  },
  GW = {
    key: 2
  },
  QW = {
    class: "relative flex justify-between"
  },
  qW = {
    key: 0,
    class: "flex w-full flex-col items-center justify-center gap-1 p-4"
  },
  KW = {
    class: "font-accent text-20 font-bold text-white"
  },
  ZW = {
    class: "text-10 uppercase text-gray-400"
  },
  JW = {
    key: 1,
    class: "absolute left-1/2 h-full w-px bg-white-10"
  },
  XW = {
    class: "flex w-full flex-col items-center p-4"
  },
  eG = {
    key: 1
  },
  tG = {
    class: "flex items-center justify-center text-20 font-bold uppercase"
  },
  nG = {
    key: 0,
    class: "mt-2 flex items-center justify-center text-10 font-medium uppercase text-white-50"
  },
  rG = {
    key: 2,
    class: "mt-2 w-full border-t border-white-10 text-center"
  },
  sG = {
    class: "mt-2 flex justify-center gap-1 font-accent text-20 font-bold text-white lg:text-28"
  },
  aG = {
    class: "text-14 uppercase text-gray-400"
  },
  oG = {
    key: 3
  },
  iG = {
    class: "flex items-center justify-between"
  },
  lG = {
    class: "flex items-center justify-start text-gray-lightest"
  },
  uG = {
    class: "ml-3 whitespace-pre-wrap text-10 uppercase leading-multiline"
  },
  cG = {
    class: "text-right font-accent text-20 font-bold text-white"
  },
  dG = {
    class: "flex items-center justify-between"
  },
  fG = {
    class: "flex items-center justify-start text-gray-lightest"
  },
  pG = {
    class: "ml-3 whitespace-pre-wrap text-10 uppercase leading-multiline"
  },
  hG = {
    class: "text-right font-accent text-20 font-bold text-white"
  },
  mG = {
    key: 4,
    class: "mx-4 mt-4 flex items-center gap-4"
  },
  gG = te({
    __name: "ChallengeGeneralInformation",
    props: {
      id: {},
      challenge: {},
      leaderboard: {}
    },
    setup(e) {
      const {
        t
      } = Fe(), n = e, r = L(() => n.challenge.fee_cents_in_player_currency ? T0.value >= n.challenge.fee_cents_in_player_currency : !0), s = L(() => n.leaderboard.current_player ? n.challenge.spin_limit - n.leaderboard.current_player.spin_count : n.challenge.spin_limit || 0), a = L(() => n.challenge.prize_pool_cents_in_player_currency ? zp(n.challenge.prize_pool_cents_in_player_currency || 0) : null), o = L(() => Rt(n.challenge.prize_pool_cents_in_player_currency || 0)), i = L(() => n.challenge.fee_cents_in_player_currency ? Rt(n.challenge.fee_cents_in_player_currency || 0) : null), l = L(() => n.challenge.min_bet_cents_in_player_currency ? Rt(n.challenge.min_bet_cents_in_player_currency || 0) : null);
      return (c, d) => {
        const f = x5("smooth-scroll");
        return g(), k(Ee, null, [c.challenge.player_active ? (g(), G(u(Bt), {
          key: 0,
          class: "text-theme-white-opacity py-3"
        }, {
          default: V(() => [m("div", UW, [$(u(Wp), {
            class: "text-theme-blue-green"
          }), c.challenge.status === u(tt).Finished ? (g(), k("span", zW, R(u(t)("challenge.general.passive_player")), 1)) : (g(), k("span", YW, R(u(t)("challenge.general.active_player")), 1))])]),
          _: 1
        })) : z("", !0), c.challenge.spin_limit && c.challenge.player_active && !s.value ? (g(), G(u(Bt), {
          key: 1,
          class: "py-3 text-left"
        }, {
          default: V(() => [m("div", WW, [$(u(RN)), m("span", null, R(u(t)("challenge.general.limit_message")), 1)])]),
          _: 1
        })) : z("", !0), !c.challenge.player_active && c.challenge.status !== u(tt).Finished && c.challenge.status !== u(tt).Sync && c.challenge.status !== u(tt).Cancelled ? (g(), k("div", GW, [$(VW, {
          id: c.id,
          isAutoJoin: c.challenge.privacy === u(bn).Public,
          joinCode: c.challenge.join_code,
          fee: i.value,
          isEnoughMoneyToJoin: r.value,
          challenge: c.challenge
        }, null, 8, ["id", "isAutoJoin", "joinCode", "fee", "isEnoughMoneyToJoin", "challenge"])])) : z("", !0), $(u(Bt), {
          class: "gap-0 p-0"
        }, {
          default: V(() => [m("div", QW, [c.challenge.spin_limit && c.challenge.player_active ? (g(), k("div", qW, [m("div", KW, R(s.value), 1), m("div", ZW, R(u(t)("challenge.general.left")), 1)])) : z("", !0), c.challenge.spin_limit && c.challenge.player_active ? (g(), k("div", JW)) : z("", !0), m("div", XW, [c.challenge.status === u(tt).Ongoing || c.challenge.status === u(tt).Planned ? (g(), G(t1, {
            key: 0,
            id: c.challenge.id,
            status: c.challenge.status,
            start_at: c.challenge.start_at,
            finish_at: c.challenge.finish_at
          }, null, 8, ["id", "status", "start_at", "finish_at"])) : (g(), k("div", eG, [m("div", tG, R(u(t)("common.event_finished")), 1), c.challenge.status === u(tt).Sync ? (g(), k("div", nG, R(u(t)("challenge.general.sync_message")), 1)) : z("", !0)])), a.value ? (g(), k("div", rG, [m("div", sG, [m("span", null, R(a.value), 1), $(u(_d), null, {
            default: V(() => [$(u(yd), null, {
              default: V(() => [$(u(hd))]),
              _: 1
            }), $(u(bd), null, {
              default: V(() => [m("span", null, R(o.value), 1)]),
              _: 1
            })]),
            _: 1
          })]), m("div", aG, R(u(t)("drop.general.prize_pool")), 1)])) : z("", !0)])])]),
          _: 1
        }), c.challenge.status !== u(tt).Finished ? (g(), k("div", oG, [l.value ? (g(), G(u(Bt), {
          key: 0,
          class: "py-3"
        }, {
          default: V(() => [m("div", iG, [m("div", lG, [$(u(x9)), m("p", uG, R(u(t)("common.min_bet")), 1)]), m("div", null, [m("p", cG, "≥ " + R(l.value), 1)])])]),
          _: 1
        })) : z("", !0), c.challenge.spin_limit ? (g(), G(u(Bt), {
          key: 1,
          class: "py-3"
        }, {
          default: V(() => [m("div", dG, [m("div", fG, [$(u(eF)), m("p", pG, R(u(t)("challenge.general.spin_limit")), 1)]), m("div", null, [m("p", hG, R(c.challenge.spin_limit), 1)])])]),
          _: 1
        })) : z("", !0)])) : z("", !0), c.challenge.player_active ? (g(), k("div", mG, [Tn((g(), G(qt, {
          as: "a",
          href: "#challengeRules",
          variant: "link"
        }, {
          default: V(() => [Ye(R(u(t)("challenge.general.rules_button")), 1)]),
          _: 1
        })), [
          [f, {
            duration: 500,
            offset: -50,
            container: "#challengeDetails"
          }]
        ])])) : z("", !0)], 64)
      }
    }
  }),
  vG = {
    class: "grid grid-cols-[1fr_6fr_4fr_4fr]"
  },
  _G = {
    class: "flex h-8 items-center justify-end text-10 uppercase opacity-50"
  },
  yG = {
    class: "flex h-8 items-center justify-start text-10 uppercase opacity-50"
  },
  bG = {
    class: "ml-2"
  },
  wG = {
    class: "flex h-8 items-center justify-end text-10 uppercase opacity-50"
  },
  CG = {
    class: "mr-2"
  },
  xG = {
    class: "flex h-8 items-center justify-end pr-4 text-10 uppercase opacity-50"
  },
  kG = {
    class: "mr-2"
  },
  SG = {
    key: 1,
    class: "mb-2 text-center text-13"
  },
  EG = {
    class: "bg-theme-white-dark col-span-4 rounded-md"
  },
  TG = {
    class: "flex h-8 w-full items-start justify-center uppercase"
  },
  AG = {
    class: "mx-2 flex w-full items-center border-b border-black-10 py-2 text-13 font-bold opacity-50"
  },
  PG = {
    class: "text-theme-dark-yellow grid grid-cols-[1fr_6fr_4fr_4fr]"
  },
  IG = te({
    __name: "ChallengeLeaderboard",
    props: {
      id: {},
      isLoading: {
        type: Boolean
      },
      status: {},
      data: {},
      challengeType: {},
      prize_places: {},
      category: {},
      challenge: {}
    },
    setup(e) {
      const t = e,
        {
          t: n
        } = Fe(),
        r = L(() => t.challengeType === ht.BetsSum ? "_bets" : t.challengeType === ht.TopMultiplierSum || t.challengeType === ht.MultipliersSum ? "_mult" : ""),
        s = d => {
          const f = t.prize_places.find(h => h.place === d);
          return t.category === ln.P2P ? `${(f==null?void 0:f.prize)||0}` : Rt(Number((f == null ? void 0 : f.prize) || 0), !0)
        },
        a = L(() => {
          const f = t.category === ln.P2P ? ", %" : `, ${Li.code}`;
          return `${n("challenge.leaderboard.prize")}${f}`
        }),
        o = Hn("challenge"),
        i = () => {
          var d, f;
          Jt({
            payload: {
              eventName: "lobby_challenges_full_leaderboard",
              eventData: {
                player_id: wn.value,
                challenge_id: (d = t.challenge) == null ? void 0 : d.id,
                challenge_status: (f = t.challenge) == null ? void 0 : f.status
              }
            }
          }), o != null && o.isLeaderboardPage && (o.isLeaderboardPage.value = !0)
        },
        l = L(() => {
          var d, f, p, h;
          return ((f = (d = t == null ? void 0 : t.data) == null ? void 0 : d.current_player) == null ? void 0 : f.rank) === 0 || ((h = (p = t == null ? void 0 : t.data) == null ? void 0 : p.current_player) == null ? void 0 : h.rank) > hv
        }),
        c = L(() => t.status === tt.Finished ? "challenge.leaderboard.title_player" : "challenge.leaderboard.title");
      return (d, f) => (g(), G(u(Bt), {
        colored: !0,
        class: "text-theme-dark-white gap-0 px-2"
      }, {
        default: V(() => [$(u(Za), {
          variant: "blackNoneTransform",
          class: "mb-2"
        }, {
          default: V(() => [Ye(R(u(n)(c.value)), 1)]),
          _: 1
        }), !d.isLoading && d.data && d.data.total_participants_count > 0 ? (g(), k(Ee, {
          key: 0
        }, [m("div", vG, [m("div", _G, [m("div", null, R(u(n)("challenge.leaderboard.column_rank")), 1)]), m("div", yG, [m("div", bG, R(u(n)("challenge.leaderboard.column_id")), 1)]), m("div", wG, [m("div", CG, R(u(n)(`challenge.leaderboard.column_result${r.value}`)), 1)]), m("div", xG, [m("div", kG, R(a.value), 1)]), f[0] || (f[0] = m("div", {
          class: "col-span-4 border-b border-black-10 opacity-50"
        }, null, -1))]), $(q9, {
          prize_places: d.prize_places,
          category: d.category,
          players: d.data.top,
          current: d.data.current_player,
          total: d.data.total_participants_count
        }, null, 8, ["prize_places", "category", "players", "current", "total"])], 64)) : (g(), k("div", SG, R(u(n)("challenge.leaderboard.no_data")), 1)), l.value ? (g(), k(Ee, {
          key: 2
        }, [f[1] || (f[1] = m("div", {
          class: "col-span-4 my-3 flex h-1 items-center justify-center"
        }, [m("div", {
          class: "mb-2"
        }, "...")], -1)), m("div", EG, [m("div", TG, [m("div", AG, [m("div", null, R(u(n)("challenge.leaderboard.title_player")), 1)])]), m("div", PG, [$(bf, {
          prize: s(d.data.current_player.rank),
          isCurrent: !0,
          player: d.data.current_player
        }, null, 8, ["prize", "player"])])])], 64)) : z("", !0), d.data && d.data.total_participants_count > u(hv) ? (g(), G(qt, {
          key: 3,
          variant: "ghost",
          onClick: i,
          class: "mt-2"
        }, {
          default: V(() => [Ye(R(u(n)("challenge.leaderboard.button")), 1)]),
          _: 1
        })) : z("", !0)]),
        _: 1
      }))
    }
  }),
  $G = 1,
  MG = 3e3,
  Aa = {
    ADD_TOAST: "ADD_TOAST",
    UPDATE_TOAST: "UPDATE_TOAST",
    DISMISS_TOAST: "DISMISS_TOAST",
    REMOVE_TOAST: "REMOVE_TOAST"
  };
let q1 = 0;

function OG() {
  return q1 = (q1 + 1) % Number.MAX_VALUE, q1.toString()
}
const K1 = new Map;

function Qy(e) {
  if (K1.has(e)) return;
  const t = setTimeout(() => {
    K1.delete(e), dc({
      type: Aa.REMOVE_TOAST,
      toastId: e
    })
  }, MG);
  K1.set(e, t)
}
const as = U({
  toasts: []
});

function dc(e) {
  switch (e.type) {
    case Aa.ADD_TOAST:
      as.value.toasts = [e.toast, ...as.value.toasts].slice(0, $G);
      break;
    case Aa.UPDATE_TOAST:
      as.value.toasts = as.value.toasts.map(t => t.id === e.toast.id ? {
        ...t,
        ...e.toast
      } : t);
      break;
    case Aa.DISMISS_TOAST: {
      const {
        toastId: t
      } = e;
      t ? Qy(t) : as.value.toasts.forEach(n => {
        Qy(n.id)
      }), as.value.toasts = as.value.toasts.map(n => n.id === t || t === void 0 ? {
        ...n,
        open: !1
      } : n);
      break
    }
    case Aa.REMOVE_TOAST:
      e.toastId === void 0 ? as.value.toasts = [] : as.value.toasts = as.value.toasts.filter(t => t.id !== e.toastId);
      break
  }
}

function K9() {
  return {
    toasts: L(() => as.value.toasts),
    toast: DG,
    dismiss: e => dc({
      type: Aa.DISMISS_TOAST,
      toastId: e
    })
  }
}

function DG(e) {
  const t = OG(),
    n = s => dc({
      type: Aa.UPDATE_TOAST,
      toast: {
        ...s,
        id: t
      }
    }),
    r = () => dc({
      type: Aa.DISMISS_TOAST,
      toastId: t
    });
  return dc({
    type: Aa.ADD_TOAST,
    toast: {
      ...e,
      id: t,
      open: !0,
      onOpenChange: s => {
        s || r()
      }
    }
  }), {
    id: t,
    dismiss: r,
    update: n
  }
}
const LG = {
    class: "flex w-full items-center justify-center"
  },
  RG = {
    class: "text-theme-white-opacity text-justify font-accent text-13 font-normal"
  },
  NG = {
    class: "mt-4 flex w-full items-center justify-center"
  },
  FG = {
    class: "text-center font-accent font-bold text-yellow"
  },
  BG = te({
    __name: "ChallengePlayerCode",
    props: {
      player_code: {},
      challenge: {}
    },
    setup(e) {
      const {
        t
      } = Fe(), n = e, {
        toast: r,
        toasts: s,
        dismiss: a
      } = K9(), o = L(() => n.player_code.slice(0, -4) + "****"), i = () => {
        var c, d;
        Jt({
          payload: {
            eventName: "lobby_challenges_copy_code",
            eventData: {
              player_id: wn.value,
              challenge_id: (c = n.challenge) == null ? void 0 : c.id,
              challenge_status: (d = n.challenge) == null ? void 0 : d.status
            }
          }
        });
        const l = document.createElement("textarea");
        l.value = n.player_code, document.body.appendChild(l), l.select();
        try {
          document.execCommand("copy"), r({
            description: t("challenge.playerCode.toast")
          })
        } catch (f) {
          console.warn("error copy code: ", f)
        } finally {
          document.body.removeChild(l), l.remove()
        }
      };
      return en(() => {
        if (s.value.length > 0) {
          const l = s.value.find(c => c.description === t("challenge.playerCode.toast"));
          l && a(l.id)
        }
      }), (l, c) => (g(), G(u(Bt), null, {
        default: V(() => [m("div", LG, [$(Za, null, {
          default: V(() => [Ye(R(u(t)("challenge.playerCode.title")), 1)]),
          _: 1
        })]), m("div", null, [m("p", RG, R(u(t)("challenge.playerCode.message")), 1), m("div", NG, [m("h2", FG, R(o.value), 1)])]), $(qt, {
          onClick: i
        }, {
          default: V(() => [Ye(R(u(t)("challenge.playerCode.button")), 1)]),
          _: 1
        })]),
        _: 1
      }))
    }
  }),
  qy = te({
    __name: "ChallengeRules",
    props: {
      challenge: {}
    },
    setup(e) {
      const {
        t
      } = Fe(), n = e, r = (o, i = {}) => t(`challenge.rules.${o}`, i), s = L(() => n.challenge.category === ln.P2P), a = L(() => {
        const o = [];
        return [{
          text: r("fee", {
            value: Rt(n.challenge.fee_cents_in_player_currency || 0)
          }),
          iconType: "IconBet",
          isEnabled: !!n.challenge.fee_cents_in_player_currency
        }, {
          text: r("goal"),
          iconType: "IconGoal",
          isEnabled: n.challenge.challenge_type === ht.MaxMultiplier
        }, {
          text: r("goal_bets", {
            value: Rt(n.challenge.bets_sum_point_to_player_currency_cents || 0)
          }),
          iconType: "IconGoal",
          isEnabled: n.challenge.challenge_type === ht.BetsSum
        }, {
          text: r("goal_mult", {
            value: n.challenge.top_multiplier_count
          }),
          iconType: "IconGoal",
          isEnabled: n.challenge.challenge_type === ht.TopMultiplierSum
        }, {
          text: r("goal_sum"),
          iconType: "IconGoal",
          isEnabled: n.challenge.challenge_type === ht.MultipliersSum
        }, {
          text: r("winner"),
          iconType: "IconWinner",
          isEnabled: n.challenge.challenge_type === ht.MaxMultiplier
        }, {
          text: r("winner_bets"),
          iconType: "IconWinner",
          isEnabled: n.challenge.challenge_type === ht.BetsSum
        }, {
          text: r("winner_mult"),
          iconType: "IconWinner",
          isEnabled: n.challenge.challenge_type === ht.TopMultiplierSum
        }, {
          text: r("winner_sum"),
          iconType: "IconWinner",
          isEnabled: n.challenge.challenge_type === ht.MultipliersSum
        }, {
          text: r("id"),
          iconType: "IconId",
          isEnabled: !0
        }, {
          text: r("bet"),
          iconType: "IconBet",
          isEnabled: !n.challenge.min_bet_cents_in_player_currency
        }, {
          text: `${r("bet_eur",{value:Rt(n.challenge.min_bet_cents_in_player_currency||0)})}`,
          iconType: "IconBet",
          isEnabled: !!n.challenge.min_bet_cents_in_player_currency
        }, {
          text: r("spin"),
          iconType: "IconSpin",
          isEnabled: n.challenge.feature_condition === Pr.Allowed
        }, {
          text: r("spin_feature"),
          iconType: "IconSpin",
          isEnabled: n.challenge.feature_condition === Pr.OnlyFeature
        }, {
          text: r("spin_denied"),
          iconType: "IconSpin",
          isEnabled: n.challenge.feature_condition === Pr.DeniedBuy
        }, {
          text: r("limit"),
          iconType: "IconSpinCount",
          isEnabled: !n.challenge.spin_limit
        }, {
          text: r("limit_on", {
            value: n.challenge.spin_limit
          }),
          iconType: "IconSpinCount",
          isEnabled: !!n.challenge.spin_limit
        }, {
          text: r("one_participant"),
          iconType: "IconUser",
          isEnabled: s.value
        }, {
          text: r("fewer_participant"),
          iconType: "IconUser",
          isEnabled: s.value
        }, {
          text: r("prizes_distribution"),
          iconType: "IconWinner",
          isEnabled: s.value
        }, {
          text: r("opened_after_start"),
          iconType: "IconTimer",
          isEnabled: s.value && n.challenge.joining_rule === As.AllowAfterStart
        }, {
          text: r("closed_after_start"),
          iconType: "IconTimer",
          isEnabled: s.value && n.challenge.joining_rule === As.DenyAfterStart
        }, {
          text: r("limit_participants"),
          iconType: "IconUser",
          isEnabled: !!n.challenge.participants_limit
        }].forEach(({
          text: l,
          iconType: c,
          isEnabled: d
        }) => {
          d && o.push({
            iconType: c,
            text: l
          })
        }), o
      });
      return (o, i) => (g(), G(u(H9), {
        rulesList: a.value,
        challenge: o.challenge,
        id: "challengeRules"
      }, null, 8, ["rulesList", "challenge"]))
    }
  }),
  jG = {
    class: "absolute bottom-0 left-0 right-0 top-0 z-[57] flex w-full items-center justify-center bg-[rgba(33,35,48,0.90)] sm:items-center"
  },
  HG = {
    class: "relative my-5 mt-2 box-border w-full max-w-[400px] rounded-xl border border-white-10 bg-gray-lighter p-4 sm:mt-5 sm:h-auto sm:p-4 md:mt-5 md:p-10 lg:mt-2"
  },
  VG = {
    class: "mt-28 flex items-center justify-center sm:mt-4 md:mt-11"
  },
  UG = {
    key: 0,
    class: "mt-4 text-center font-accent text-24 font-bold leading-[120%] sm:mt-4 sm:text-16 md:mt-7 md:text-24"
  },
  zG = {
    key: 1,
    class: "mt-2 text-center text-16 font-normal"
  },
  YG = {
    key: 2,
    class: "mt-32 flex w-full items-center justify-center gap-2 sm:mt-8 sm:gap-5 md:mt-20"
  },
  WG = te({
    __name: "ChallengeModal",
    props: {
      title: {},
      subtitle: {},
      buttonName: {},
      action: {
        type: Function
      },
      close: {
        type: Function
      }
    },
    setup(e) {
      const {
        t
      } = Fe(), n = e, r = Mr(), s = () => {
        Cn.push({
          name: "challenge",
          params: {
            ...r.params,
            id: ""
          }
        })
      }, a = () => {
        n.close ? n.close() : s()
      }, o = () => {
        n.action ? n.action() : s()
      };
      return (i, l) => (g(), k("div", jG, [m("div", HG, [$(u(qa), {
        class: "absolute right-3 top-3 cursor-pointer",
        onClick: a
      }), m("div", VG, [ie(i.$slots, "default")]), i.title ? (g(), k("div", UG, R(u(t)(i.title)), 1)) : z("", !0), i.subtitle ? (g(), k("div", zG, R(u(t)(i.subtitle)), 1)) : z("", !0), i.buttonName ? (g(), k("div", YG, [$(qt, {
        variant: "primary",
        class: "px-1 py-2 sm:text-12 lg:text-15",
        onClick: o
      }, {
        default: V(() => [Ye(R(u(t)(i.buttonName)), 1)]),
        _: 1
      })])) : z("", !0)])]))
    }
  }),
  GG = {
    key: 0
  },
  QG = {
    key: 1
  },
  qG = {
    class: "mb-4 flex h-fit min-w-[auto!important] flex-col"
  },
  KG = {
    class: "relative w-full"
  },
  ZG = ["src"],
  JG = {
    class: "text-theme-white-yellow mt-6 text-center font-accent text-24 font-bold"
  },
  XG = {
    class: "text-center font-accent text-18 font-bold capitalize text-white"
  },
  eQ = {
    class: "text-center font-accent text-18 font-normal text-white"
  },
  tQ = te({
    __name: "ChallengeDetails",
    props: {
      id: {}
    },
    setup(e) {
      const t = e,
        {
          t: n
        } = Fe(),
        r = U(1),
        s = Mr(),
        a = L(() => t.id),
        {
          isLoading: o,
          error: i,
          data: l
        } = Og(a),
        {
          isLoading: c,
          error: d,
          data: f
        } = Q9(a, r);

      function p() {
        Cn.push({
          name: "challenge",
          params: {
            ...s.params,
            id: ""
          }
        })
      }
      const h = U(!1),
        _ = E => {
          E.currentTarget.scrollTop > 48 ? h.value = !0 : h.value = !1
        },
        v = Tr("(min-width: 568px)"),
        C = L(() => {
          var T, j, P;
          const E = ((T = l.value) == null ? void 0 : T.joining_rule) === As.DenyAfterStart,
            S = ((j = l.value) == null ? void 0 : j.status) === tt.Ongoing;
          return E && S && !((P = l.value) != null && P.player_active)
        }),
        y = L(() => {
          if (!l.value) return !1;
          const {
            participants_count: E,
            participants_limit: S,
            status: T,
            player_active: j
          } = l.value;
          return !S || !(T === tt.Ongoing || T === tt.Planned) || !!j ? !1 : E === S
        }),
        b = L(() => {
          var j, P, N, ne;
          const E = ((j = l.value) == null ? void 0 : j.status) === tt.Ongoing || ((P = l.value) == null ? void 0 : P.status) === tt.Planned,
            S = ((N = l.value) == null ? void 0 : N.category) === ln.P2P,
            T = !C.value && !y.value;
          return S && E && !((ne = l.value) != null && ne.player_active) && T
        }),
        w = () => {
          var E, S;
          return (E = l.value) != null && E.image_url ? (S = l.value) == null ? void 0 : S.image_url : z9()
        };
      Ne(l, (E, S) => {
        E != null && E.id && E.id !== (S == null ? void 0 : S.id) && Jt({
          payload: {
            eventName: "lobby_challenges_challenge_open",
            eventData: {
              player_id: wn.value,
              challenge_id: E.id,
              challenge_status: E.status
            }
          }
        })
      }, {
        immediate: !1
      });
      const x = (E, S) => {
        var T, j;
        Jt({
          payload: {
            eventName: "lobby_challenges_games_open",
            eventData: {
              player_id: wn.value,
              challenge_id: (T = l == null ? void 0 : l.value) == null ? void 0 : T.id,
              challenge_status: (j = l == null ? void 0 : l.value) == null ? void 0 : j.status,
              game: S
            }
          }
        }), ps(), ak(E)
      };
      return (E, S) => {
        var T;
        return g(), k(Ee, null, [u(o) || u(c) ? (g(), k("div", GG, [$(u(Pl), {
          isLoading: !0,
          handleBack: p,
          handleClose: u(ps)
        }, null, 8, ["handleClose"])])) : u(i) || u(d) ? (g(), k("div", QG, [$(u(Pl), {
          isError: !0,
          handleBack: p,
          handleClose: u(ps)
        }, null, 8, ["handleClose"])])) : !u(l) || !u(f) ? (g(), G(u(Pl), {
          key: 2,
          handleBack: p,
          handleClose: u(ps)
        }, null, 8, ["handleClose"])) : (g(), G(u(Jn), {
          key: 3,
          id: "challengeDetails",
          handleScroll: _,
          class: we(["h-full", {
            "rounded-xl": !u(v)
          }])
        }, {
          default: V(() => {
            var j, P, N;
            return [m("div", qG, [Tn($(u(B9), {
              handleBack: p,
              handleClose: u(ps),
              title: (j = u(l)) == null ? void 0 : j.name
            }, {
              default: V(() => [$(u(md), {
                class: "text-yellow"
              })]),
              _: 1
            }, 8, ["handleClose", "title"]), [
              [wl, h.value]
            ]), m("div", KG, [m("img", {
              class: "h-auto w-full",
              src: w(),
              alt: "Challenge Img"
            }, null, 8, ZG), $(u(Yp), {
              class: "absolute left-1 top-1 cursor-pointer hover:scale-95 sm:hidden",
              onClick: p
            }), $(u(pr), {
              class: "absolute right-1 top-1 cursor-pointer hover:scale-95 sm:hidden",
              onClick: u(ps)
            }, null, 8, ["onClick"])]), m("h1", JG, R((P = u(l)) == null ? void 0 : P.name), 1), C.value || y.value ? (g(), k(Ee, {
              key: 0
            }, [$(u(Bt), {
              class: "flex items-center justify-center"
            }, {
              default: V(() => [m("p", XG, R(u(n)("challenge.p2p.cant_join_challenge_title")), 1), m("p", eQ, R(C.value ? u(n)("challenge.p2p.cant_join_challenge_subtitle") : u(n)("challenge.join.error.107")), 1)]),
              _: 1
            }), $(u(Bt), null, {
              default: V(() => [$(t1, {
                id: u(l).id,
                status: u(l).status,
                start_at: u(l).start_at,
                finish_at: u(l).finish_at
              }, null, 8, ["id", "status", "start_at", "finish_at"])]),
              _: 1
            }), $(u(Ym), {
              "game-identifiers": u(l).game_identifiers,
              "event-id": u(l).id,
              "query-source": "challenge",
              "send-event-opening": x
            }, null, 8, ["game-identifiers", "event-id"])], 64)) : (g(), k(Ee, {
              key: 1
            }, [b.value ? (g(), G(qy, {
              key: 0,
              challenge: u(l)
            }, null, 8, ["challenge"])) : z("", !0), $(gG, {
              id: E.id,
              challenge: u(l),
              leaderboard: u(f)
            }, null, 8, ["id", "challenge", "leaderboard"]), $(IG, {
              id: E.id,
              isLoading: u(c),
              data: u(f),
              challengeType: u(l).challenge_type,
              prize_places: u(l).prize_places,
              category: u(l).category,
              status: u(l).status,
              challenge: u(l)
            }, null, 8, ["id", "isLoading", "data", "challengeType", "prize_places", "category", "status", "challenge"]), $(u(Ym), {
              "game-identifiers": u(l).game_identifiers,
              "event-id": u(l).id,
              "query-source": "challenge",
              "send-event-opening": x
            }, null, 8, ["game-identifiers", "event-id"]), b.value ? z("", !0) : (g(), G(qy, {
              key: 1,
              challenge: u(l)
            }, null, 8, ["challenge"])), (N = u(f).current_player) != null && N.code ? (g(), G(BG, {
              key: 2,
              player_code: u(f).current_player.code,
              challenge: u(l)
            }, null, 8, ["player_code", "challenge"])) : z("", !0)], 64))])]
          }),
          _: 1
        }, 8, ["class"])), ((T = u(l)) == null ? void 0 : T.status) === u(tt).Cancelled ? (g(), G(WG, {
          key: 4,
          title: "challenge.modals.cancelled.title",
          subtitle: "challenge.modals.cancelled.subtitle",
          buttonName: "challenge.p2p.got_it"
        }, {
          default: V(() => S[0] || (S[0] = [m("img", {
            class: "h-auto w-[120px] sm:w-[60px] md:w-[120px]",
            src: Dg,
            alt: "triangleInfo Img"
          }, null, -1)])),
          _: 1,
          __: [0]
        })) : z("", !0)], 64)
      }
    }
  }),
  nQ = te({
    __name: "ChallengePage",
    props: {
      id: {}
    },
    setup(e) {
      const t = e,
        n = Tr("(min-width: 568px)"),
        r = Mr(),
        s = L(() => t.id),
        a = U(!1),
        o = L(() => n.value ? !1 : s.value),
        i = L(() => n.value ? !1 : !s.value);
      xi("challenge", {
        isLeaderboardPage: a
      });
      const {
        data: l
      } = Y9(Cr), {
        data: c
      } = W9(Cr), d = L(() => {
        var p, h;
        return ((h = (p = l.value) == null ? void 0 : p[0]) == null ? void 0 : h.id) ?? null
      }), f = L(() => {
        var p, h;
        return ((h = (p = c.value) == null ? void 0 : p[0]) == null ? void 0 : h.id) ?? null
      });
      return gn(() => {
        if (!s.value && n.value) {
          const p = d.value ?? f.value;
          p && Cn.push({
            name: "challenge",
            params: {
              ...r.params,
              id: p
            }
          })
        }
      }), (p, h) => (g(), G(vd, {
        id: p.id,
        isActivePath: "/lobby/challenge"
      }, {
        default: V(() => [$(G9, {
          id: p.id,
          class: we(["relative w-full rounded-bl-xl sm:w-2/6", {
            hidden: o.value
          }])
        }, null, 8, ["id", "class"]), m("div", {
          class: we(["relative w-full sm:w-4/6 sm:border-l sm:border-white-10 sm:pr-0", {
            hidden: i.value
          }])
        }, [(g(), G(Kr(a.value ? PW : tQ), {
          id: p.id
        }, null, 8, ["id"]))], 2)]),
        _: 1
      }, 8, ["id"]))
    }
  }),
  rQ = {
    class: "absolute right-0 top-0 z-[57] h-full w-full bg-gray"
  },
  sQ = {
    class: "relative"
  },
  aQ = {
    class: "text-center font-accent text-24 font-bold text-white"
  },
  oQ = ["onClick"],
  iQ = ["src"],
  lQ = te({
    __name: "ChallengeImgEdit",
    props: {
      changeCurrentImg: {
        type: Function
      },
      closeImgEdit: {
        type: Function
      },
      challengeImages: {},
      currentImgUrl: {}
    },
    setup(e) {
      const t = e,
        {
          t: n
        } = Fe(),
        r = s => {
          t.changeCurrentImg(s), t.closeImgEdit()
        };
      return (s, a) => (g(), k("div", rQ, [$(u(Jn), {
        class: "h-full w-full px-4 pb-20 pt-2 sm:pb-2"
      }, {
        default: V(() => [m("div", sQ, [m("h1", aQ, R(u(n)("challenge.p2p.change_image")), 1), $(u(pr), {
          class: "absolute -top-1 right-0 cursor-pointer",
          onClick: s.closeImgEdit
        }, null, 8, ["onClick"])]), (g(!0), k(Ee, null, Je(s.challengeImages, o => (g(), k("div", {
          key: o.id,
          class: "relative mt-4 cursor-pointer",
          onClick: i => r(o.url)
        }, [m("img", {
          class: "h-auto w-full rounded-xl",
          src: o.url,
          alt: "Challenge Img"
        }, null, 8, iQ), s.currentImgUrl === o.url ? (g(), G(u(VF), {
          key: 0,
          class: "absolute right-1 top-1 h-10 w-10 cursor-pointer"
        })) : z("", !0)], 8, oQ))), 128))]),
        _: 1
      })]))
    }
  }),
  uQ = {
    class: "relative flex items-center gap-x-4"
  },
  cQ = {
    class: "text-16 font-bold"
  },
  dQ = {
    key: 0,
    class: "text-13"
  },
  hr = te({
    __name: "ChallengeTooltip",
    props: {
      title: {},
      substring: {},
      offset: {}
    },
    setup(e) {
      return (t, n) => (g(), k("div", uQ, [$(u(_d), null, {
        default: V(() => [$(u(FA), null, {
          default: V(() => [m("h2", cQ, R(t.title), 1)]),
          _: 1
        }), $(u(yd), null, {
          default: V(() => [$(u(hd), {
            class: "text-white-30"
          })]),
          _: 1
        }), $(u(bd), {
          align: "start",
          collisionPadding: 10,
          alignOffset: t.offset || 0,
          class: "rounded-xl border border-white-10 bg-gray-lighter fill-gray-lighter px-4 py-5 font-normal text-white"
        }, {
          default: V(() => [t.substring ? (g(), k("p", dQ, R(t.substring), 1)) : ie(t.$slots, "default", {
            key: 1
          })]),
          _: 3
        }, 8, ["alignOffset"])]),
        _: 3
      })]))
    }
  }),
  fQ = {
    class: "flex flex-col"
  },
  pQ = ["src"],
  hQ = 12,
  mQ = te({
    __name: "ChallengeImageField",
    setup(e) {
      const {
        t
      } = Fe(), n = "https://drops-skins.bgaming-network.com", r = U(!1), s = Array.from({
        length: hQ
      }, (i, l) => ({
        id: l + 1,
        url: `${n}/p2p/challenge${l+1}.png`
      }));
      ue.image_url = `${n}/p2p/challenge1.png`;
      const a = () => {
          r.value = !1
        },
        o = i => {
          ue.image_url = i
        };
      return (i, l) => (g(), k("div", fQ, [$(hr, {
        title: u(t)("challenge.p2p.challenge_image"),
        substring: u(t)("challenge.p2p.tooltip.image")
      }, null, 8, ["title", "substring"]), m("div", {
        class: "relative mt-2",
        onClick: l[0] || (l[0] = c => r.value = !0)
      }, [m("img", {
        class: "h-auto w-full rounded-xl",
        src: u(ue).image_url,
        alt: "Challenge Img"
      }, null, 8, pQ), $(u(WF), {
        class: "absolute right-1 top-1 h-10 w-10 cursor-pointer"
      })]), r.value ? (g(), G(lQ, {
        key: 0,
        "change-current-img": o,
        "close-img-edit": a,
        "current-img-url": u(ue).image_url,
        "challenge-images": u(s)
      }, null, 8, ["current-img-url", "challenge-images"])) : z("", !0)]))
    }
  }),
  gQ = {
    key: 0,
    class: "sticky top-0 z-[56] flex h-12 w-full items-center justify-center rounded-t-xl border-b border-white-10 bg-gray-lighter"
  },
  vQ = {
    class: "flex items-center justify-between gap-2"
  },
  _Q = {
    class: "text-theme-white-yellow text-center font-accent text-24 font-bold"
  },
  yQ = {
    key: 1,
    class: "relative my-2 flex items-center justify-center"
  },
  bQ = {
    class: "text-center font-accent text-24 font-bold text-white"
  },
  wQ = te({
    __name: "ChallengeTitle",
    setup(e) {
      const {
        t
      } = Fe(), n = Tr("(min-width: 568px)"), r = () => {
        bt.leavePath = "/lobby/challenge", bt.leave = !0
      };
      return (s, a) => u(n) ? (g(), k("div", yQ, [m("h1", bQ, R(u(t)("challenge.p2p.title")), 1), $(u(pr), {
        class: "absolute right-2 translate-y-0.5 transform cursor-pointer",
        onClick: r
      })])) : (g(), k("div", gQ, [m("div", vQ, [m("h1", _Q, R(u(t)("challenge.p2p.title")), 1)]), $(u(pr), {
        class: "absolute right-1 top-1 cursor-pointer hover:scale-95 sm:hidden",
        onClick: r
      })]))
    }
  }),
  CQ = ["id", "value", "checked"],
  xQ = ["for"],
  kQ = {
    key: 0,
    class: "h-2 w-2 rounded-full bg-[#212330]"
  },
  SQ = {
    class: "ml-2.5"
  },
  EQ = {
    class: "text-16 font-bold"
  },
  ys = te({
    __name: "ChallengeRadio",
    props: {
      value: {
        default: ""
      },
      modelValue: {
        default: ""
      },
      id: {
        default: ""
      },
      title: {
        default: ""
      },
      description: {
        default: ""
      }
    },
    emits: ["update:modelValue"],
    setup(e, {
      emit: t
    }) {
      const n = e,
        r = t;

      function s() {
        r("update:modelValue", n.value)
      }
      const a = L(() => n.modelValue === n.value);
      return (o, i) => (g(), k("div", {
        class: we(["flex", {
          "opacity-50": !a.value
        }])
      }, [m("input", {
        class: "hidden",
        type: "radio",
        id: o.id,
        value: o.value,
        checked: a.value,
        onChange: s
      }, null, 40, CQ), m("label", {
        class: "flex cursor-pointer",
        for: o.id
      }, [m("div", {
        class: we([{
          "bg-gradient-to-t from-[#FFE142] via-[#FFCD00] to-[#FFC700]": a.value,
          "bg-[#171922] shadow-[inset_0px_2px_0px_rgba(0,0,0,0.25),inset_0px_-1px_0px_rgba(255,255,255,0.15)]": !a.value
        }, "flex h-4 w-4 items-center justify-start gap-2 rounded-xl p-1"])
      }, [a.value ? (g(), k("div", kQ)) : z("", !0)], 2), m("div", SQ, [m("h3", EQ, R(o.title), 1), ie(o.$slots, "default"), o.description ? (g(), k("p", {
        key: 0,
        class: we(["text-13 font-normal leading-5", {
          "mt-1": o.title
        }])
      }, R(o.description), 3)) : z("", !0)])], 8, xQ)], 2))
    }
  }),
  TQ = {
    class: "mt-2 box-border rounded-xl border border-white-10 bg-gray-lighter py-3 pl-4 pr-4"
  },
  AQ = {
    class: "text-13 font-normal"
  },
  PQ = {
    class: "text-13 font-normal"
  },
  IQ = {
    class: "text-13 font-normal"
  },
  $Q = {
    class: "text-13 font-normal"
  },
  MQ = {
    class: "text-13 font-normal"
  },
  OQ = {
    class: "text-13 font-normal"
  },
  DQ = te({
    __name: "ChallengeModeFiled",
    setup(e) {
      const {
        t
      } = Fe();
      return Ne(() => ue.category, () => ue.fee = null), (n, r) => (g(), k("div", null, [$(hr, {
        title: u(t)("challenge.p2p.challenge_mode"),
        substring: u(t)("challenge.p2p.tooltip.mode")
      }, null, 8, ["title", "substring"]), m("div", TQ, [$(ys, {
        class: "mb-2 pt-2",
        id: "challengeModeP2P",
        modelValue: u(ue).category,
        "onUpdate:modelValue": r[0] || (r[0] = s => u(ue).category = s),
        title: u(t)("challenge.p2p.mode_options.friends.title"),
        value: u(ln).P2P
      }, {
        default: V(() => [m("li", null, [m("span", AQ, R(u(t)("challenge.p2p.mode_options.friends.option_organizer")), 1)]), m("li", null, [m("span", PQ, R(u(t)("challenge.p2p.mode_options.friends.option_participant")), 1)]), m("li", null, [m("span", IQ, R(u(t)("challenge.p2p.mode_options.friends.option_prize_pool")), 1)])]),
        _: 1
      }, 8, ["modelValue", "title", "value"]), $(ys, {
        class: "pt-2",
        id: "challengeModeInfluencer",
        modelValue: u(ue).category,
        "onUpdate:modelValue": r[1] || (r[1] = s => u(ue).category = s),
        title: u(t)("challenge.p2p.mode_options.influencer.title"),
        value: u(ln).Influencer
      }, {
        default: V(() => [m("li", null, [m("span", $Q, R(u(t)("challenge.p2p.mode_options.influencer.option_organizer")), 1)]), m("li", null, [m("span", MQ, R(u(t)("challenge.p2p.mode_options.influencer.option_participant")), 1)]), m("li", null, [m("span", OQ, R(u(t)("challenge.p2p.mode_options.influencer.option_prize_pool")), 1)])]),
        _: 1
      }, 8, ["modelValue", "title", "value"])])]))
    }
  }),
  LQ = {
    class: "mt-2 box-border rounded-xl border border-white-10 bg-gray-lighter py-3 pl-4 pr-4"
  },
  RQ = te({
    __name: "ChallengeTypeFiled",
    setup(e) {
      const {
        t
      } = Fe();
      return (n, r) => (g(), k("div", null, [$(hr, {
        title: u(t)("challenge.p2p.challenge_type"),
        substring: u(t)("challenge.p2p.tooltip.type")
      }, null, 8, ["title", "substring"]), m("div", LQ, [$(ys, {
        class: "mb-2 pt-2",
        id: "challengeTypeMax",
        modelValue: u(ue).challenge_type,
        "onUpdate:modelValue": r[0] || (r[0] = s => u(ue).challenge_type = s),
        title: u(t)("challenge.p2p.type_options.max_multiplayer"),
        value: u(ht).MaxMultiplier
      }, null, 8, ["modelValue", "title", "value"]), $(ys, {
        class: "mb-2 pt-2",
        id: "challengeTypeTop",
        modelValue: u(ue).challenge_type,
        "onUpdate:modelValue": r[1] || (r[1] = s => u(ue).challenge_type = s),
        title: u(t)("challenge.p2p.type_options.top_multiplayer_sum"),
        value: u(ht).TopMultiplierSum
      }, null, 8, ["modelValue", "title", "value"]), $(ys, {
        class: "mb-2 pt-2",
        id: "challengeTypeBets",
        modelValue: u(ue).challenge_type,
        "onUpdate:modelValue": r[2] || (r[2] = s => u(ue).challenge_type = s),
        title: u(t)("challenge.p2p.type_options.bets_sum"),
        value: u(ht).BetsSum
      }, null, 8, ["modelValue", "title", "value"]), $(ys, {
        class: "mb-2 pt-2",
        id: "challengeTypeSum",
        modelValue: u(ue).challenge_type,
        "onUpdate:modelValue": r[3] || (r[3] = s => u(ue).challenge_type = s),
        title: u(t)("challenge.p2p.type_options.multiplayers_sum"),
        value: u(ht).MultipliersSum
      }, null, 8, ["modelValue", "title", "value"])])]))
    }
  }),
  Z9 = 6048e5,
  NQ = 864e5,
  FQ = 6e4,
  J9 = 36e5,
  BQ = 1e3,
  Ky = Symbol.for("constructDateFrom");

function Lt(e, t) {
  return typeof e == "function" ? e(t) : e && typeof e == "object" && Ky in e ? e[Ky](t) : e instanceof Date ? new e.constructor(t) : new Date(t)
}

function Ke(e, t) {
  return Lt(t || e, e)
}

function vs(e, t, n) {
  const r = Ke(e, n == null ? void 0 : n.in);
  return isNaN(t) ? Lt((n == null ? void 0 : n.in) || e, NaN) : (t && r.setDate(r.getDate() + t), r)
}

function ws(e, t, n) {
  const r = Ke(e, n == null ? void 0 : n.in);
  if (isNaN(t)) return Lt(e, NaN);
  if (!t) return r;
  const s = r.getDate(),
    a = Lt(e, r.getTime());
  a.setMonth(r.getMonth() + t + 1, 0);
  const o = a.getDate();
  return s >= o ? a : (r.setFullYear(a.getFullYear(), a.getMonth(), s), r)
}

function X9(e, t, n) {
  const {
    years: r = 0,
    months: s = 0,
    weeks: a = 0,
    days: o = 0,
    hours: i = 0,
    minutes: l = 0,
    seconds: c = 0
  } = t, d = Ke(e, n == null ? void 0 : n.in), f = s || r ? ws(d, s + r * 12) : d, p = o || a ? vs(f, o + a * 7) : f, h = l + i * 60, v = (c + h * 60) * 1e3;
  return Lt(e, +p + v)
}

function jQ(e, t, n) {
  return Lt(e, +Ke(e) + t)
}

function HQ(e, t, n) {
  return jQ(e, t * J9)
}
let VQ = {};

function Ji() {
  return VQ
}

function Ps(e, t) {
  var i, l, c, d;
  const n = Ji(),
    r = (t == null ? void 0 : t.weekStartsOn) ?? ((l = (i = t == null ? void 0 : t.locale) == null ? void 0 : i.options) == null ? void 0 : l.weekStartsOn) ?? n.weekStartsOn ?? ((d = (c = n.locale) == null ? void 0 : c.options) == null ? void 0 : d.weekStartsOn) ?? 0,
    s = Ke(e, t == null ? void 0 : t.in),
    a = s.getDay(),
    o = (a < r ? 7 : 0) + a - r;
  return s.setDate(s.getDate() - o), s.setHours(0, 0, 0, 0), s
}

function iu(e, t) {
  return Ps(e, {
    ...t,
    weekStartsOn: 1
  })
}

function e7(e, t) {
  const n = Ke(e, t == null ? void 0 : t.in),
    r = n.getFullYear(),
    s = Lt(n, 0);
  s.setFullYear(r + 1, 0, 4), s.setHours(0, 0, 0, 0);
  const a = iu(s),
    o = Lt(n, 0);
  o.setFullYear(r, 0, 4), o.setHours(0, 0, 0, 0);
  const i = iu(o);
  return n.getTime() >= a.getTime() ? r + 1 : n.getTime() >= i.getTime() ? r : r - 1
}

function ap(e) {
  const t = Ke(e),
    n = new Date(Date.UTC(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours(), t.getMinutes(), t.getSeconds(), t.getMilliseconds()));
  return n.setUTCFullYear(t.getFullYear()), +e - +n
}

function wd(e, ...t) {
  const n = Lt.bind(null, t.find(r => typeof r == "object"));
  return t.map(n)
}

function Zy(e, t) {
  const n = Ke(e, t == null ? void 0 : t.in);
  return n.setHours(0, 0, 0, 0), n
}

function t7(e, t, n) {
  const [r, s] = wd(n == null ? void 0 : n.in, e, t), a = Zy(r), o = Zy(s), i = +a - ap(a), l = +o - ap(o);
  return Math.round((i - l) / NQ)
}

function UQ(e, t) {
  const n = e7(e, t),
    r = Lt(e, 0);
  return r.setFullYear(n, 0, 4), r.setHours(0, 0, 0, 0), iu(r)
}

function zQ(e, t, n) {
  return ws(e, t * 3, n)
}

function Lg(e, t, n) {
  return ws(e, t * 12, n)
}

function Jy(e, t) {
  const n = +Ke(e) - +Ke(t);
  return n < 0 ? -1 : n > 0 ? 1 : n
}

function n7(e) {
  return e instanceof Date || typeof e == "object" && Object.prototype.toString.call(e) === "[object Date]"
}

function fc(e) {
  return !(!n7(e) && typeof e != "number" || isNaN(+Ke(e)))
}

function Xy(e, t) {
  const n = Ke(e, t == null ? void 0 : t.in);
  return Math.trunc(n.getMonth() / 3) + 1
}

function YQ(e, t, n) {
  const [r, s] = wd(n == null ? void 0 : n.in, e, t);
  return r.getFullYear() - s.getFullYear()
}

function WQ(e, t, n) {
  const [r, s] = wd(n == null ? void 0 : n.in, e, t), a = Jy(r, s), o = Math.abs(YQ(r, s));
  r.setFullYear(1584), s.setFullYear(1584);
  const i = Jy(r, s) === -a,
    l = a * (o - +i);
  return l === 0 ? 0 : l
}

function r7(e, t) {
  const [n, r] = wd(e, t.start, t.end);
  return {
    start: n,
    end: r
  }
}

function s7(e, t) {
  const {
    start: n,
    end: r
  } = r7(t == null ? void 0 : t.in, e);
  let s = +n > +r;
  const a = s ? +n : +r,
    o = s ? r : n;
  o.setHours(0, 0, 0, 0);
  let i = 1;
  const l = [];
  for (; + o <= a;) l.push(Lt(n, o)), o.setDate(o.getDate() + i), o.setHours(0, 0, 0, 0);
  return s ? l.reverse() : l
}

function fi(e, t) {
  const n = Ke(e, t == null ? void 0 : t.in),
    r = n.getMonth(),
    s = r - r % 3;
  return n.setMonth(s, 1), n.setHours(0, 0, 0, 0), n
}

function GQ(e, t) {
  const {
    start: n,
    end: r
  } = r7(t == null ? void 0 : t.in, e);
  let s = +n > +r;
  const a = s ? +fi(n) : +fi(r);
  let o = fi(s ? r : n),
    i = 1;
  const l = [];
  for (; + o <= a;) l.push(Lt(n, o)), o = zQ(o, i);
  return s ? l.reverse() : l
}

function QQ(e, t) {
  const n = Ke(e, t == null ? void 0 : t.in);
  return n.setDate(1), n.setHours(0, 0, 0, 0), n
}

function a7(e, t) {
  const n = Ke(e, t == null ? void 0 : t.in),
    r = n.getFullYear();
  return n.setFullYear(r + 1, 0, 0), n.setHours(23, 59, 59, 999), n
}

function Hc(e, t) {
  const n = Ke(e, t == null ? void 0 : t.in);
  return n.setFullYear(n.getFullYear(), 0, 1), n.setHours(0, 0, 0, 0), n
}

function o7(e, t) {
  var i, l, c, d;
  const n = Ji(),
    r = (t == null ? void 0 : t.weekStartsOn) ?? ((l = (i = t == null ? void 0 : t.locale) == null ? void 0 : i.options) == null ? void 0 : l.weekStartsOn) ?? n.weekStartsOn ?? ((d = (c = n.locale) == null ? void 0 : c.options) == null ? void 0 : d.weekStartsOn) ?? 0,
    s = Ke(e, t == null ? void 0 : t.in),
    a = s.getDay(),
    o = (a < r ? -7 : 0) + 6 - (a - r);
  return s.setDate(s.getDate() + o), s.setHours(23, 59, 59, 999), s
}

function e3(e, t) {
  const n = Ke(e, t == null ? void 0 : t.in),
    r = n.getMonth(),
    s = r - r % 3 + 3;
  return n.setMonth(s, 0), n.setHours(23, 59, 59, 999), n
}
const qQ = {
    lessThanXSeconds: {
      one: "less than a second",
      other: "less than {{count}} seconds"
    },
    xSeconds: {
      one: "1 second",
      other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
      one: "less than a minute",
      other: "less than {{count}} minutes"
    },
    xMinutes: {
      one: "1 minute",
      other: "{{count}} minutes"
    },
    aboutXHours: {
      one: "about 1 hour",
      other: "about {{count}} hours"
    },
    xHours: {
      one: "1 hour",
      other: "{{count}} hours"
    },
    xDays: {
      one: "1 day",
      other: "{{count}} days"
    },
    aboutXWeeks: {
      one: "about 1 week",
      other: "about {{count}} weeks"
    },
    xWeeks: {
      one: "1 week",
      other: "{{count}} weeks"
    },
    aboutXMonths: {
      one: "about 1 month",
      other: "about {{count}} months"
    },
    xMonths: {
      one: "1 month",
      other: "{{count}} months"
    },
    aboutXYears: {
      one: "about 1 year",
      other: "about {{count}} years"
    },
    xYears: {
      one: "1 year",
      other: "{{count}} years"
    },
    overXYears: {
      one: "over 1 year",
      other: "over {{count}} years"
    },
    almostXYears: {
      one: "almost 1 year",
      other: "almost {{count}} years"
    }
  },
  KQ = (e, t, n) => {
    let r;
    const s = qQ[e];
    return typeof s == "string" ? r = s : t === 1 ? r = s.one : r = s.other.replace("{{count}}", t.toString()), n != null && n.addSuffix ? n.comparison && n.comparison > 0 ? "in " + r : r + " ago" : r
  };

function Z1(e) {
  return (t = {}) => {
    const n = t.width ? String(t.width) : e.defaultWidth;
    return e.formats[n] || e.formats[e.defaultWidth]
  }
}
const ZQ = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
  },
  JQ = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
  },
  XQ = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
  },
  eq = {
    date: Z1({
      formats: ZQ,
      defaultWidth: "full"
    }),
    time: Z1({
      formats: JQ,
      defaultWidth: "full"
    }),
    dateTime: Z1({
      formats: XQ,
      defaultWidth: "full"
    })
  },
  tq = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
  },
  nq = (e, t, n, r) => tq[e];

function Yu(e) {
  return (t, n) => {
    const r = n != null && n.context ? String(n.context) : "standalone";
    let s;
    if (r === "formatting" && e.formattingValues) {
      const o = e.defaultFormattingWidth || e.defaultWidth,
        i = n != null && n.width ? String(n.width) : o;
      s = e.formattingValues[i] || e.formattingValues[o]
    } else {
      const o = e.defaultWidth,
        i = n != null && n.width ? String(n.width) : e.defaultWidth;
      s = e.values[i] || e.values[o]
    }
    const a = e.argumentCallback ? e.argumentCallback(t) : t;
    return s[a]
  }
}
const rq = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
  },
  sq = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
  },
  aq = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
  },
  oq = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
  },
  iq = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    }
  },
  lq = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    }
  },
  uq = (e, t) => {
    const n = Number(e),
      r = n % 100;
    if (r > 20 || r < 10) switch (r % 10) {
      case 1:
        return n + "st";
      case 2:
        return n + "nd";
      case 3:
        return n + "rd"
    }
    return n + "th"
  },
  cq = {
    ordinalNumber: uq,
    era: Yu({
      values: rq,
      defaultWidth: "wide"
    }),
    quarter: Yu({
      values: sq,
      defaultWidth: "wide",
      argumentCallback: e => e - 1
    }),
    month: Yu({
      values: aq,
      defaultWidth: "wide"
    }),
    day: Yu({
      values: oq,
      defaultWidth: "wide"
    }),
    dayPeriod: Yu({
      values: iq,
      defaultWidth: "wide",
      formattingValues: lq,
      defaultFormattingWidth: "wide"
    })
  };

function Wu(e) {
  return (t, n = {}) => {
    const r = n.width,
      s = r && e.matchPatterns[r] || e.matchPatterns[e.defaultMatchWidth],
      a = t.match(s);
    if (!a) return null;
    const o = a[0],
      i = r && e.parsePatterns[r] || e.parsePatterns[e.defaultParseWidth],
      l = Array.isArray(i) ? fq(i, f => f.test(o)) : dq(i, f => f.test(o));
    let c;
    c = e.valueCallback ? e.valueCallback(l) : l, c = n.valueCallback ? n.valueCallback(c) : c;
    const d = t.slice(o.length);
    return {
      value: c,
      rest: d
    }
  }
}

function dq(e, t) {
  for (const n in e)
    if (Object.prototype.hasOwnProperty.call(e, n) && t(e[n])) return n
}

function fq(e, t) {
  for (let n = 0; n < e.length; n++)
    if (t(e[n])) return n
}

function pq(e) {
  return (t, n = {}) => {
    const r = t.match(e.matchPattern);
    if (!r) return null;
    const s = r[0],
      a = t.match(e.parsePattern);
    if (!a) return null;
    let o = e.valueCallback ? e.valueCallback(a[0]) : a[0];
    o = n.valueCallback ? n.valueCallback(o) : o;
    const i = t.slice(s.length);
    return {
      value: o,
      rest: i
    }
  }
}
const hq = /^(\d+)(th|st|nd|rd)?/i,
  mq = /\d+/i,
  gq = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
  },
  vq = {
    any: [/^b/i, /^(a|c)/i]
  },
  _q = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
  },
  yq = {
    any: [/1/i, /2/i, /3/i, /4/i]
  },
  bq = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
  },
  wq = {
    narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
    any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
  },
  Cq = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
  },
  xq = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
  },
  kq = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
  },
  Sq = {
    any: {
      am: /^a/i,
      pm: /^p/i,
      midnight: /^mi/i,
      noon: /^no/i,
      morning: /morning/i,
      afternoon: /afternoon/i,
      evening: /evening/i,
      night: /night/i
    }
  },
  Eq = {
    ordinalNumber: pq({
      matchPattern: hq,
      parsePattern: mq,
      valueCallback: e => parseInt(e, 10)
    }),
    era: Wu({
      matchPatterns: gq,
      defaultMatchWidth: "wide",
      parsePatterns: vq,
      defaultParseWidth: "any"
    }),
    quarter: Wu({
      matchPatterns: _q,
      defaultMatchWidth: "wide",
      parsePatterns: yq,
      defaultParseWidth: "any",
      valueCallback: e => e + 1
    }),
    month: Wu({
      matchPatterns: bq,
      defaultMatchWidth: "wide",
      parsePatterns: wq,
      defaultParseWidth: "any"
    }),
    day: Wu({
      matchPatterns: Cq,
      defaultMatchWidth: "wide",
      parsePatterns: xq,
      defaultParseWidth: "any"
    }),
    dayPeriod: Wu({
      matchPatterns: kq,
      defaultMatchWidth: "any",
      parsePatterns: Sq,
      defaultParseWidth: "any"
    })
  },
  i7 = {
    code: "en-US",
    formatDistance: KQ,
    formatLong: eq,
    formatRelative: nq,
    localize: cq,
    match: Eq,
    options: {
      weekStartsOn: 0,
      firstWeekContainsDate: 1
    }
  };

function Tq(e, t) {
  const n = Ke(e, t == null ? void 0 : t.in);
  return t7(n, Hc(n)) + 1
}

function Rg(e, t) {
  const n = Ke(e, t == null ? void 0 : t.in),
    r = +iu(n) - +UQ(n);
  return Math.round(r / Z9) + 1
}

function Ng(e, t) {
  var d, f, p, h;
  const n = Ke(e, t == null ? void 0 : t.in),
    r = n.getFullYear(),
    s = Ji(),
    a = (t == null ? void 0 : t.firstWeekContainsDate) ?? ((f = (d = t == null ? void 0 : t.locale) == null ? void 0 : d.options) == null ? void 0 : f.firstWeekContainsDate) ?? s.firstWeekContainsDate ?? ((h = (p = s.locale) == null ? void 0 : p.options) == null ? void 0 : h.firstWeekContainsDate) ?? 1,
    o = Lt((t == null ? void 0 : t.in) || e, 0);
  o.setFullYear(r + 1, 0, a), o.setHours(0, 0, 0, 0);
  const i = Ps(o, t),
    l = Lt((t == null ? void 0 : t.in) || e, 0);
  l.setFullYear(r, 0, a), l.setHours(0, 0, 0, 0);
  const c = Ps(l, t);
  return +n >= +i ? r + 1 : +n >= +c ? r : r - 1
}

function Aq(e, t) {
  var i, l, c, d;
  const n = Ji(),
    r = (t == null ? void 0 : t.firstWeekContainsDate) ?? ((l = (i = t == null ? void 0 : t.locale) == null ? void 0 : i.options) == null ? void 0 : l.firstWeekContainsDate) ?? n.firstWeekContainsDate ?? ((d = (c = n.locale) == null ? void 0 : c.options) == null ? void 0 : d.firstWeekContainsDate) ?? 1,
    s = Ng(e, t),
    a = Lt((t == null ? void 0 : t.in) || e, 0);
  return a.setFullYear(s, 0, r), a.setHours(0, 0, 0, 0), Ps(a, t)
}

function Fg(e, t) {
  const n = Ke(e, t == null ? void 0 : t.in),
    r = +Ps(n, t) - +Aq(n, t);
  return Math.round(r / Z9) + 1
}

function Pt(e, t) {
  const n = e < 0 ? "-" : "",
    r = Math.abs(e).toString().padStart(t, "0");
  return n + r
}
const so = {
    y(e, t) {
      const n = e.getFullYear(),
        r = n > 0 ? n : 1 - n;
      return Pt(t === "yy" ? r % 100 : r, t.length)
    },
    M(e, t) {
      const n = e.getMonth();
      return t === "M" ? String(n + 1) : Pt(n + 1, 2)
    },
    d(e, t) {
      return Pt(e.getDate(), t.length)
    },
    a(e, t) {
      const n = e.getHours() / 12 >= 1 ? "pm" : "am";
      switch (t) {
        case "a":
        case "aa":
          return n.toUpperCase();
        case "aaa":
          return n;
        case "aaaaa":
          return n[0];
        case "aaaa":
        default:
          return n === "am" ? "a.m." : "p.m."
      }
    },
    h(e, t) {
      return Pt(e.getHours() % 12 || 12, t.length)
    },
    H(e, t) {
      return Pt(e.getHours(), t.length)
    },
    m(e, t) {
      return Pt(e.getMinutes(), t.length)
    },
    s(e, t) {
      return Pt(e.getSeconds(), t.length)
    },
    S(e, t) {
      const n = t.length,
        r = e.getMilliseconds(),
        s = Math.trunc(r * Math.pow(10, n - 3));
      return Pt(s, t.length)
    }
  },
  al = {
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  t3 = {
    G: function(e, t, n) {
      const r = e.getFullYear() > 0 ? 1 : 0;
      switch (t) {
        case "G":
        case "GG":
        case "GGG":
          return n.era(r, {
            width: "abbreviated"
          });
        case "GGGGG":
          return n.era(r, {
            width: "narrow"
          });
        case "GGGG":
        default:
          return n.era(r, {
            width: "wide"
          })
      }
    },
    y: function(e, t, n) {
      if (t === "yo") {
        const r = e.getFullYear(),
          s = r > 0 ? r : 1 - r;
        return n.ordinalNumber(s, {
          unit: "year"
        })
      }
      return so.y(e, t)
    },
    Y: function(e, t, n, r) {
      const s = Ng(e, r),
        a = s > 0 ? s : 1 - s;
      if (t === "YY") {
        const o = a % 100;
        return Pt(o, 2)
      }
      return t === "Yo" ? n.ordinalNumber(a, {
        unit: "year"
      }) : Pt(a, t.length)
    },
    R: function(e, t) {
      const n = e7(e);
      return Pt(n, t.length)
    },
    u: function(e, t) {
      const n = e.getFullYear();
      return Pt(n, t.length)
    },
    Q: function(e, t, n) {
      const r = Math.ceil((e.getMonth() + 1) / 3);
      switch (t) {
        case "Q":
          return String(r);
        case "QQ":
          return Pt(r, 2);
        case "Qo":
          return n.ordinalNumber(r, {
            unit: "quarter"
          });
        case "QQQ":
          return n.quarter(r, {
            width: "abbreviated",
            context: "formatting"
          });
        case "QQQQQ":
          return n.quarter(r, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQ":
        default:
          return n.quarter(r, {
            width: "wide",
            context: "formatting"
          })
      }
    },
    q: function(e, t, n) {
      const r = Math.ceil((e.getMonth() + 1) / 3);
      switch (t) {
        case "q":
          return String(r);
        case "qq":
          return Pt(r, 2);
        case "qo":
          return n.ordinalNumber(r, {
            unit: "quarter"
          });
        case "qqq":
          return n.quarter(r, {
            width: "abbreviated",
            context: "standalone"
          });
        case "qqqqq":
          return n.quarter(r, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqq":
        default:
          return n.quarter(r, {
            width: "wide",
            context: "standalone"
          })
      }
    },
    M: function(e, t, n) {
      const r = e.getMonth();
      switch (t) {
        case "M":
        case "MM":
          return so.M(e, t);
        case "Mo":
          return n.ordinalNumber(r + 1, {
            unit: "month"
          });
        case "MMM":
          return n.month(r, {
            width: "abbreviated",
            context: "formatting"
          });
        case "MMMMM":
          return n.month(r, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMM":
        default:
          return n.month(r, {
            width: "wide",
            context: "formatting"
          })
      }
    },
    L: function(e, t, n) {
      const r = e.getMonth();
      switch (t) {
        case "L":
          return String(r + 1);
        case "LL":
          return Pt(r + 1, 2);
        case "Lo":
          return n.ordinalNumber(r + 1, {
            unit: "month"
          });
        case "LLL":
          return n.month(r, {
            width: "abbreviated",
            context: "standalone"
          });
        case "LLLLL":
          return n.month(r, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLL":
        default:
          return n.month(r, {
            width: "wide",
            context: "standalone"
          })
      }
    },
    w: function(e, t, n, r) {
      const s = Fg(e, r);
      return t === "wo" ? n.ordinalNumber(s, {
        unit: "week"
      }) : Pt(s, t.length)
    },
    I: function(e, t, n) {
      const r = Rg(e);
      return t === "Io" ? n.ordinalNumber(r, {
        unit: "week"
      }) : Pt(r, t.length)
    },
    d: function(e, t, n) {
      return t === "do" ? n.ordinalNumber(e.getDate(), {
        unit: "date"
      }) : so.d(e, t)
    },
    D: function(e, t, n) {
      const r = Tq(e);
      return t === "Do" ? n.ordinalNumber(r, {
        unit: "dayOfYear"
      }) : Pt(r, t.length)
    },
    E: function(e, t, n) {
      const r = e.getDay();
      switch (t) {
        case "E":
        case "EE":
        case "EEE":
          return n.day(r, {
            width: "abbreviated",
            context: "formatting"
          });
        case "EEEEE":
          return n.day(r, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEEE":
          return n.day(r, {
            width: "short",
            context: "formatting"
          });
        case "EEEE":
        default:
          return n.day(r, {
            width: "wide",
            context: "formatting"
          })
      }
    },
    e: function(e, t, n, r) {
      const s = e.getDay(),
        a = (s - r.weekStartsOn + 8) % 7 || 7;
      switch (t) {
        case "e":
          return String(a);
        case "ee":
          return Pt(a, 2);
        case "eo":
          return n.ordinalNumber(a, {
            unit: "day"
          });
        case "eee":
          return n.day(s, {
            width: "abbreviated",
            context: "formatting"
          });
        case "eeeee":
          return n.day(s, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeeee":
          return n.day(s, {
            width: "short",
            context: "formatting"
          });
        case "eeee":
        default:
          return n.day(s, {
            width: "wide",
            context: "formatting"
          })
      }
    },
    c: function(e, t, n, r) {
      const s = e.getDay(),
        a = (s - r.weekStartsOn + 8) % 7 || 7;
      switch (t) {
        case "c":
          return String(a);
        case "cc":
          return Pt(a, t.length);
        case "co":
          return n.ordinalNumber(a, {
            unit: "day"
          });
        case "ccc":
          return n.day(s, {
            width: "abbreviated",
            context: "standalone"
          });
        case "ccccc":
          return n.day(s, {
            width: "narrow",
            context: "standalone"
          });
        case "cccccc":
          return n.day(s, {
            width: "short",
            context: "standalone"
          });
        case "cccc":
        default:
          return n.day(s, {
            width: "wide",
            context: "standalone"
          })
      }
    },
    i: function(e, t, n) {
      const r = e.getDay(),
        s = r === 0 ? 7 : r;
      switch (t) {
        case "i":
          return String(s);
        case "ii":
          return Pt(s, t.length);
        case "io":
          return n.ordinalNumber(s, {
            unit: "day"
          });
        case "iii":
          return n.day(r, {
            width: "abbreviated",
            context: "formatting"
          });
        case "iiiii":
          return n.day(r, {
            width: "narrow",
            context: "formatting"
          });
        case "iiiiii":
          return n.day(r, {
            width: "short",
            context: "formatting"
          });
        case "iiii":
        default:
          return n.day(r, {
            width: "wide",
            context: "formatting"
          })
      }
    },
    a: function(e, t, n) {
      const s = e.getHours() / 12 >= 1 ? "pm" : "am";
      switch (t) {
        case "a":
        case "aa":
          return n.dayPeriod(s, {
            width: "abbreviated",
            context: "formatting"
          });
        case "aaa":
          return n.dayPeriod(s, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "aaaaa":
          return n.dayPeriod(s, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return n.dayPeriod(s, {
            width: "wide",
            context: "formatting"
          })
      }
    },
    b: function(e, t, n) {
      const r = e.getHours();
      let s;
      switch (r === 12 ? s = al.noon : r === 0 ? s = al.midnight : s = r / 12 >= 1 ? "pm" : "am", t) {
        case "b":
        case "bb":
          return n.dayPeriod(s, {
            width: "abbreviated",
            context: "formatting"
          });
        case "bbb":
          return n.dayPeriod(s, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "bbbbb":
          return n.dayPeriod(s, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return n.dayPeriod(s, {
            width: "wide",
            context: "formatting"
          })
      }
    },
    B: function(e, t, n) {
      const r = e.getHours();
      let s;
      switch (r >= 17 ? s = al.evening : r >= 12 ? s = al.afternoon : r >= 4 ? s = al.morning : s = al.night, t) {
        case "B":
        case "BB":
        case "BBB":
          return n.dayPeriod(s, {
            width: "abbreviated",
            context: "formatting"
          });
        case "BBBBB":
          return n.dayPeriod(s, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return n.dayPeriod(s, {
            width: "wide",
            context: "formatting"
          })
      }
    },
    h: function(e, t, n) {
      if (t === "ho") {
        let r = e.getHours() % 12;
        return r === 0 && (r = 12), n.ordinalNumber(r, {
          unit: "hour"
        })
      }
      return so.h(e, t)
    },
    H: function(e, t, n) {
      return t === "Ho" ? n.ordinalNumber(e.getHours(), {
        unit: "hour"
      }) : so.H(e, t)
    },
    K: function(e, t, n) {
      const r = e.getHours() % 12;
      return t === "Ko" ? n.ordinalNumber(r, {
        unit: "hour"
      }) : Pt(r, t.length)
    },
    k: function(e, t, n) {
      let r = e.getHours();
      return r === 0 && (r = 24), t === "ko" ? n.ordinalNumber(r, {
        unit: "hour"
      }) : Pt(r, t.length)
    },
    m: function(e, t, n) {
      return t === "mo" ? n.ordinalNumber(e.getMinutes(), {
        unit: "minute"
      }) : so.m(e, t)
    },
    s: function(e, t, n) {
      return t === "so" ? n.ordinalNumber(e.getSeconds(), {
        unit: "second"
      }) : so.s(e, t)
    },
    S: function(e, t) {
      return so.S(e, t)
    },
    X: function(e, t, n) {
      const r = e.getTimezoneOffset();
      if (r === 0) return "Z";
      switch (t) {
        case "X":
          return r3(r);
        case "XXXX":
        case "XX":
          return ii(r);
        case "XXXXX":
        case "XXX":
        default:
          return ii(r, ":")
      }
    },
    x: function(e, t, n) {
      const r = e.getTimezoneOffset();
      switch (t) {
        case "x":
          return r3(r);
        case "xxxx":
        case "xx":
          return ii(r);
        case "xxxxx":
        case "xxx":
        default:
          return ii(r, ":")
      }
    },
    O: function(e, t, n) {
      const r = e.getTimezoneOffset();
      switch (t) {
        case "O":
        case "OO":
        case "OOO":
          return "GMT" + n3(r, ":");
        case "OOOO":
        default:
          return "GMT" + ii(r, ":")
      }
    },
    z: function(e, t, n) {
      const r = e.getTimezoneOffset();
      switch (t) {
        case "z":
        case "zz":
        case "zzz":
          return "GMT" + n3(r, ":");
        case "zzzz":
        default:
          return "GMT" + ii(r, ":")
      }
    },
    t: function(e, t, n) {
      const r = Math.trunc(+e / 1e3);
      return Pt(r, t.length)
    },
    T: function(e, t, n) {
      return Pt(+e, t.length)
    }
  };

function n3(e, t = "") {
  const n = e > 0 ? "-" : "+",
    r = Math.abs(e),
    s = Math.trunc(r / 60),
    a = r % 60;
  return a === 0 ? n + String(s) : n + String(s) + t + Pt(a, 2)
}

function r3(e, t) {
  return e % 60 === 0 ? (e > 0 ? "-" : "+") + Pt(Math.abs(e) / 60, 2) : ii(e, t)
}

function ii(e, t = "") {
  const n = e > 0 ? "-" : "+",
    r = Math.abs(e),
    s = Pt(Math.trunc(r / 60), 2),
    a = Pt(r % 60, 2);
  return n + s + t + a
}
const s3 = (e, t) => {
    switch (e) {
      case "P":
        return t.date({
          width: "short"
        });
      case "PP":
        return t.date({
          width: "medium"
        });
      case "PPP":
        return t.date({
          width: "long"
        });
      case "PPPP":
      default:
        return t.date({
          width: "full"
        })
    }
  },
  l7 = (e, t) => {
    switch (e) {
      case "p":
        return t.time({
          width: "short"
        });
      case "pp":
        return t.time({
          width: "medium"
        });
      case "ppp":
        return t.time({
          width: "long"
        });
      case "pppp":
      default:
        return t.time({
          width: "full"
        })
    }
  },
  Pq = (e, t) => {
    const n = e.match(/(P+)(p+)?/) || [],
      r = n[1],
      s = n[2];
    if (!s) return s3(e, t);
    let a;
    switch (r) {
      case "P":
        a = t.dateTime({
          width: "short"
        });
        break;
      case "PP":
        a = t.dateTime({
          width: "medium"
        });
        break;
      case "PPP":
        a = t.dateTime({
          width: "long"
        });
        break;
      case "PPPP":
      default:
        a = t.dateTime({
          width: "full"
        });
        break
    }
    return a.replace("{{date}}", s3(r, t)).replace("{{time}}", l7(s, t))
  },
  Wm = {
    p: l7,
    P: Pq
  },
  Iq = /^D+$/,
  $q = /^Y+$/,
  Mq = ["D", "DD", "YY", "YYYY"];

function u7(e) {
  return Iq.test(e)
}

function c7(e) {
  return $q.test(e)
}

function Gm(e, t, n) {
  const r = Oq(e, t, n);
  if (console.warn(r), Mq.includes(e)) throw new RangeError(r)
}

function Oq(e, t, n) {
  const r = e[0] === "Y" ? "years" : "days of the month";
  return `Use \`${e.toLowerCase()}\` instead of \`${e}\` (in \`${t}\`) for formatting ${r} to the input \`${n}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`
}
const Dq = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g,
  Lq = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g,
  Rq = /^'([^]*?)'?$/,
  Nq = /''/g,
  Fq = /[a-zA-Z]/;

function Js(e, t, n) {
  var d, f, p, h, _, v, C, y;
  const r = Ji(),
    s = (n == null ? void 0 : n.locale) ?? r.locale ?? i7,
    a = (n == null ? void 0 : n.firstWeekContainsDate) ?? ((f = (d = n == null ? void 0 : n.locale) == null ? void 0 : d.options) == null ? void 0 : f.firstWeekContainsDate) ?? r.firstWeekContainsDate ?? ((h = (p = r.locale) == null ? void 0 : p.options) == null ? void 0 : h.firstWeekContainsDate) ?? 1,
    o = (n == null ? void 0 : n.weekStartsOn) ?? ((v = (_ = n == null ? void 0 : n.locale) == null ? void 0 : _.options) == null ? void 0 : v.weekStartsOn) ?? r.weekStartsOn ?? ((y = (C = r.locale) == null ? void 0 : C.options) == null ? void 0 : y.weekStartsOn) ?? 0,
    i = Ke(e, n == null ? void 0 : n.in);
  if (!fc(i)) throw new RangeError("Invalid time value");
  let l = t.match(Lq).map(b => {
    const w = b[0];
    if (w === "p" || w === "P") {
      const x = Wm[w];
      return x(b, s.formatLong)
    }
    return b
  }).join("").match(Dq).map(b => {
    if (b === "''") return {
      isToken: !1,
      value: "'"
    };
    const w = b[0];
    if (w === "'") return {
      isToken: !1,
      value: Bq(b)
    };
    if (t3[w]) return {
      isToken: !0,
      value: b
    };
    if (w.match(Fq)) throw new RangeError("Format string contains an unescaped latin alphabet character `" + w + "`");
    return {
      isToken: !1,
      value: b
    }
  });
  s.localize.preprocessor && (l = s.localize.preprocessor(i, l));
  const c = {
    firstWeekContainsDate: a,
    weekStartsOn: o,
    locale: s
  };
  return l.map(b => {
    if (!b.isToken) return b.value;
    const w = b.value;
    (!(n != null && n.useAdditionalWeekYearTokens) && c7(w) || !(n != null && n.useAdditionalDayOfYearTokens) && u7(w)) && Gm(w, t, String(e));
    const x = t3[w[0]];
    return x(i, w, s.localize, c)
  }).join("")
}

function Bq(e) {
  const t = e.match(Rq);
  return t ? t[1].replace(Nq, "'") : e
}

function jq(e, t) {
  return Ke(e, t == null ? void 0 : t.in).getDay()
}

function Hq(e, t) {
  const n = Ke(e, t == null ? void 0 : t.in),
    r = n.getFullYear(),
    s = n.getMonth(),
    a = Lt(n, 0);
  return a.setFullYear(r, s + 1, 0), a.setHours(0, 0, 0, 0), a.getDate()
}

function Vq() {
  return Object.assign({}, Ji())
}

function za(e, t) {
  return Ke(e, t == null ? void 0 : t.in).getHours()
}

function Uq(e, t) {
  const n = Ke(e, t == null ? void 0 : t.in).getDay();
  return n === 0 ? 7 : n
}

function Uo(e, t) {
  return Ke(e, t == null ? void 0 : t.in).getMinutes()
}

function ft(e, t) {
  return Ke(e, t == null ? void 0 : t.in).getMonth()
}

function lu(e) {
  return Ke(e).getSeconds()
}

function Xe(e, t) {
  return Ke(e, t == null ? void 0 : t.in).getFullYear()
}

function uu(e, t) {
  return +Ke(e) > +Ke(t)
}

function Vc(e, t) {
  return +Ke(e) < +Ke(t)
}

function ml(e, t) {
  return +Ke(e) == +Ke(t)
}

function zq(e, t) {
  const n = Yq(t) ? new t(0) : Lt(t, 0);
  return n.setFullYear(e.getFullYear(), e.getMonth(), e.getDate()), n.setHours(e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()), n
}

function Yq(e) {
  var t;
  return typeof e == "function" && ((t = e.prototype) == null ? void 0 : t.constructor) === e
}
const Wq = 10;
class d7 {
  constructor() {
    Re(this, "subPriority", 0)
  }
  validate(t, n) {
    return !0
  }
}
class Gq extends d7 {
  constructor(t, n, r, s, a) {
    super(), this.value = t, this.validateValue = n, this.setValue = r, this.priority = s, a && (this.subPriority = a)
  }
  validate(t, n) {
    return this.validateValue(t, this.value, n)
  }
  set(t, n, r) {
    return this.setValue(t, n, this.value, r)
  }
}
class Qq extends d7 {
  constructor(n, r) {
    super();
    Re(this, "priority", Wq);
    Re(this, "subPriority", -1);
    this.context = n || (s => Lt(r, s))
  }
  set(n, r) {
    return r.timestampIsSet ? n : Lt(n, zq(n, this.context))
  }
}
class St {
  run(t, n, r, s) {
    const a = this.parse(t, n, r, s);
    return a ? {
      setter: new Gq(a.value, this.validate, this.set, this.priority, this.subPriority),
      rest: a.rest
    } : null
  }
  validate(t, n, r) {
    return !0
  }
}
class qq extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 140);
    Re(this, "incompatibleTokens", ["R", "u", "t", "T"])
  }
  parse(n, r, s) {
    switch (r) {
      case "G":
      case "GG":
      case "GGG":
        return s.era(n, {
          width: "abbreviated"
        }) || s.era(n, {
          width: "narrow"
        });
      case "GGGGG":
        return s.era(n, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return s.era(n, {
          width: "wide"
        }) || s.era(n, {
          width: "abbreviated"
        }) || s.era(n, {
          width: "narrow"
        })
    }
  }
  set(n, r, s) {
    return r.era = s, n.setFullYear(s, 0, 1), n.setHours(0, 0, 0, 0), n
  }
}
const hn = {
    month: /^(1[0-2]|0?\d)/,
    date: /^(3[0-1]|[0-2]?\d)/,
    dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
    week: /^(5[0-3]|[0-4]?\d)/,
    hour23h: /^(2[0-3]|[0-1]?\d)/,
    hour24h: /^(2[0-4]|[0-1]?\d)/,
    hour11h: /^(1[0-1]|0?\d)/,
    hour12h: /^(1[0-2]|0?\d)/,
    minute: /^[0-5]?\d/,
    second: /^[0-5]?\d/,
    singleDigit: /^\d/,
    twoDigits: /^\d{1,2}/,
    threeDigits: /^\d{1,3}/,
    fourDigits: /^\d{1,4}/,
    anyDigitsSigned: /^-?\d+/,
    singleDigitSigned: /^-?\d/,
    twoDigitsSigned: /^-?\d{1,2}/,
    threeDigitsSigned: /^-?\d{1,3}/,
    fourDigitsSigned: /^-?\d{1,4}/
  },
  Hs = {
    basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
    basic: /^([+-])(\d{2})(\d{2})|Z/,
    basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
    extended: /^([+-])(\d{2}):(\d{2})|Z/,
    extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
  };

function mn(e, t) {
  return e && {
    value: t(e.value),
    rest: e.rest
  }
}

function nn(e, t) {
  const n = t.match(e);
  return n ? {
    value: parseInt(n[0], 10),
    rest: t.slice(n[0].length)
  } : null
}

function Vs(e, t) {
  const n = t.match(e);
  if (!n) return null;
  if (n[0] === "Z") return {
    value: 0,
    rest: t.slice(1)
  };
  const r = n[1] === "+" ? 1 : -1,
    s = n[2] ? parseInt(n[2], 10) : 0,
    a = n[3] ? parseInt(n[3], 10) : 0,
    o = n[5] ? parseInt(n[5], 10) : 0;
  return {
    value: r * (s * J9 + a * FQ + o * BQ),
    rest: t.slice(n[0].length)
  }
}

function f7(e) {
  return nn(hn.anyDigitsSigned, e)
}

function un(e, t) {
  switch (e) {
    case 1:
      return nn(hn.singleDigit, t);
    case 2:
      return nn(hn.twoDigits, t);
    case 3:
      return nn(hn.threeDigits, t);
    case 4:
      return nn(hn.fourDigits, t);
    default:
      return nn(new RegExp("^\\d{1," + e + "}"), t)
  }
}

function op(e, t) {
  switch (e) {
    case 1:
      return nn(hn.singleDigitSigned, t);
    case 2:
      return nn(hn.twoDigitsSigned, t);
    case 3:
      return nn(hn.threeDigitsSigned, t);
    case 4:
      return nn(hn.fourDigitsSigned, t);
    default:
      return nn(new RegExp("^-?\\d{1," + e + "}"), t)
  }
}

function Bg(e) {
  switch (e) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0
  }
}

function p7(e, t) {
  const n = t > 0,
    r = n ? t : 1 - t;
  let s;
  if (r <= 50) s = e || 100;
  else {
    const a = r + 50,
      o = Math.trunc(a / 100) * 100,
      i = e >= a % 100;
    s = e + o - (i ? 100 : 0)
  }
  return n ? s : 1 - s
}

function h7(e) {
  return e % 400 === 0 || e % 4 === 0 && e % 100 !== 0
}
class Kq extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 130);
    Re(this, "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"])
  }
  parse(n, r, s) {
    const a = o => ({
      year: o,
      isTwoDigitYear: r === "yy"
    });
    switch (r) {
      case "y":
        return mn(un(4, n), a);
      case "yo":
        return mn(s.ordinalNumber(n, {
          unit: "year"
        }), a);
      default:
        return mn(un(r.length, n), a)
    }
  }
  validate(n, r) {
    return r.isTwoDigitYear || r.year > 0
  }
  set(n, r, s) {
    const a = n.getFullYear();
    if (s.isTwoDigitYear) {
      const i = p7(s.year, a);
      return n.setFullYear(i, 0, 1), n.setHours(0, 0, 0, 0), n
    }
    const o = !("era" in r) || r.era === 1 ? s.year : 1 - s.year;
    return n.setFullYear(o, 0, 1), n.setHours(0, 0, 0, 0), n
  }
}
class Zq extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 130);
    Re(this, "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"])
  }
  parse(n, r, s) {
    const a = o => ({
      year: o,
      isTwoDigitYear: r === "YY"
    });
    switch (r) {
      case "Y":
        return mn(un(4, n), a);
      case "Yo":
        return mn(s.ordinalNumber(n, {
          unit: "year"
        }), a);
      default:
        return mn(un(r.length, n), a)
    }
  }
  validate(n, r) {
    return r.isTwoDigitYear || r.year > 0
  }
  set(n, r, s, a) {
    const o = Ng(n, a);
    if (s.isTwoDigitYear) {
      const l = p7(s.year, o);
      return n.setFullYear(l, 0, a.firstWeekContainsDate), n.setHours(0, 0, 0, 0), Ps(n, a)
    }
    const i = !("era" in r) || r.era === 1 ? s.year : 1 - s.year;
    return n.setFullYear(i, 0, a.firstWeekContainsDate), n.setHours(0, 0, 0, 0), Ps(n, a)
  }
}
class Jq extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 130);
    Re(this, "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"])
  }
  parse(n, r) {
    return op(r === "R" ? 4 : r.length, n)
  }
  set(n, r, s) {
    const a = Lt(n, 0);
    return a.setFullYear(s, 0, 4), a.setHours(0, 0, 0, 0), iu(a)
  }
}
class Xq extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 130);
    Re(this, "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"])
  }
  parse(n, r) {
    return op(r === "u" ? 4 : r.length, n)
  }
  set(n, r, s) {
    return n.setFullYear(s, 0, 1), n.setHours(0, 0, 0, 0), n
  }
}
class eK extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 120);
    Re(this, "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"])
  }
  parse(n, r, s) {
    switch (r) {
      case "Q":
      case "QQ":
        return un(r.length, n);
      case "Qo":
        return s.ordinalNumber(n, {
          unit: "quarter"
        });
      case "QQQ":
        return s.quarter(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.quarter(n, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQQ":
        return s.quarter(n, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return s.quarter(n, {
          width: "wide",
          context: "formatting"
        }) || s.quarter(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.quarter(n, {
          width: "narrow",
          context: "formatting"
        })
    }
  }
  validate(n, r) {
    return r >= 1 && r <= 4
  }
  set(n, r, s) {
    return n.setMonth((s - 1) * 3, 1), n.setHours(0, 0, 0, 0), n
  }
}
class tK extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 120);
    Re(this, "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"])
  }
  parse(n, r, s) {
    switch (r) {
      case "q":
      case "qq":
        return un(r.length, n);
      case "qo":
        return s.ordinalNumber(n, {
          unit: "quarter"
        });
      case "qqq":
        return s.quarter(n, {
          width: "abbreviated",
          context: "standalone"
        }) || s.quarter(n, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqqq":
        return s.quarter(n, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return s.quarter(n, {
          width: "wide",
          context: "standalone"
        }) || s.quarter(n, {
          width: "abbreviated",
          context: "standalone"
        }) || s.quarter(n, {
          width: "narrow",
          context: "standalone"
        })
    }
  }
  validate(n, r) {
    return r >= 1 && r <= 4
  }
  set(n, r, s) {
    return n.setMonth((s - 1) * 3, 1), n.setHours(0, 0, 0, 0), n
  }
}
class nK extends St {
  constructor() {
    super(...arguments);
    Re(this, "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]);
    Re(this, "priority", 110)
  }
  parse(n, r, s) {
    const a = o => o - 1;
    switch (r) {
      case "M":
        return mn(nn(hn.month, n), a);
      case "MM":
        return mn(un(2, n), a);
      case "Mo":
        return mn(s.ordinalNumber(n, {
          unit: "month"
        }), a);
      case "MMM":
        return s.month(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.month(n, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMMM":
        return s.month(n, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return s.month(n, {
          width: "wide",
          context: "formatting"
        }) || s.month(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.month(n, {
          width: "narrow",
          context: "formatting"
        })
    }
  }
  validate(n, r) {
    return r >= 0 && r <= 11
  }
  set(n, r, s) {
    return n.setMonth(s, 1), n.setHours(0, 0, 0, 0), n
  }
}
class rK extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 110);
    Re(this, "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"])
  }
  parse(n, r, s) {
    const a = o => o - 1;
    switch (r) {
      case "L":
        return mn(nn(hn.month, n), a);
      case "LL":
        return mn(un(2, n), a);
      case "Lo":
        return mn(s.ordinalNumber(n, {
          unit: "month"
        }), a);
      case "LLL":
        return s.month(n, {
          width: "abbreviated",
          context: "standalone"
        }) || s.month(n, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLLL":
        return s.month(n, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return s.month(n, {
          width: "wide",
          context: "standalone"
        }) || s.month(n, {
          width: "abbreviated",
          context: "standalone"
        }) || s.month(n, {
          width: "narrow",
          context: "standalone"
        })
    }
  }
  validate(n, r) {
    return r >= 0 && r <= 11
  }
  set(n, r, s) {
    return n.setMonth(s, 1), n.setHours(0, 0, 0, 0), n
  }
}

function sK(e, t, n) {
  const r = Ke(e, n == null ? void 0 : n.in),
    s = Fg(r, n) - t;
  return r.setDate(r.getDate() - s * 7), Ke(r, n == null ? void 0 : n.in)
}
class aK extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 100);
    Re(this, "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"])
  }
  parse(n, r, s) {
    switch (r) {
      case "w":
        return nn(hn.week, n);
      case "wo":
        return s.ordinalNumber(n, {
          unit: "week"
        });
      default:
        return un(r.length, n)
    }
  }
  validate(n, r) {
    return r >= 1 && r <= 53
  }
  set(n, r, s, a) {
    return Ps(sK(n, s, a), a)
  }
}

function oK(e, t, n) {
  const r = Ke(e, n == null ? void 0 : n.in),
    s = Rg(r, n) - t;
  return r.setDate(r.getDate() - s * 7), r
}
class iK extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 100);
    Re(this, "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"])
  }
  parse(n, r, s) {
    switch (r) {
      case "I":
        return nn(hn.week, n);
      case "Io":
        return s.ordinalNumber(n, {
          unit: "week"
        });
      default:
        return un(r.length, n)
    }
  }
  validate(n, r) {
    return r >= 1 && r <= 53
  }
  set(n, r, s) {
    return iu(oK(n, s))
  }
}
const lK = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
  uK = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
class cK extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 90);
    Re(this, "subPriority", 1);
    Re(this, "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"])
  }
  parse(n, r, s) {
    switch (r) {
      case "d":
        return nn(hn.date, n);
      case "do":
        return s.ordinalNumber(n, {
          unit: "date"
        });
      default:
        return un(r.length, n)
    }
  }
  validate(n, r) {
    const s = n.getFullYear(),
      a = h7(s),
      o = n.getMonth();
    return a ? r >= 1 && r <= uK[o] : r >= 1 && r <= lK[o]
  }
  set(n, r, s) {
    return n.setDate(s), n.setHours(0, 0, 0, 0), n
  }
}
class dK extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 90);
    Re(this, "subpriority", 1);
    Re(this, "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"])
  }
  parse(n, r, s) {
    switch (r) {
      case "D":
      case "DD":
        return nn(hn.dayOfYear, n);
      case "Do":
        return s.ordinalNumber(n, {
          unit: "date"
        });
      default:
        return un(r.length, n)
    }
  }
  validate(n, r) {
    const s = n.getFullYear();
    return h7(s) ? r >= 1 && r <= 366 : r >= 1 && r <= 365
  }
  set(n, r, s) {
    return n.setMonth(0, s), n.setHours(0, 0, 0, 0), n
  }
}

function jg(e, t, n) {
  var f, p, h, _;
  const r = Ji(),
    s = (n == null ? void 0 : n.weekStartsOn) ?? ((p = (f = n == null ? void 0 : n.locale) == null ? void 0 : f.options) == null ? void 0 : p.weekStartsOn) ?? r.weekStartsOn ?? ((_ = (h = r.locale) == null ? void 0 : h.options) == null ? void 0 : _.weekStartsOn) ?? 0,
    a = Ke(e, n == null ? void 0 : n.in),
    o = a.getDay(),
    l = (t % 7 + 7) % 7,
    c = 7 - s,
    d = t < 0 || t > 6 ? t - (o + c) % 7 : (l + c) % 7 - (o + c) % 7;
  return vs(a, d, n)
}
class fK extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 90);
    Re(this, "incompatibleTokens", ["D", "i", "e", "c", "t", "T"])
  }
  parse(n, r, s) {
    switch (r) {
      case "E":
      case "EE":
      case "EEE":
        return s.day(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.day(n, {
          width: "short",
          context: "formatting"
        }) || s.day(n, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEE":
        return s.day(n, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return s.day(n, {
          width: "short",
          context: "formatting"
        }) || s.day(n, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEE":
      default:
        return s.day(n, {
          width: "wide",
          context: "formatting"
        }) || s.day(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.day(n, {
          width: "short",
          context: "formatting"
        }) || s.day(n, {
          width: "narrow",
          context: "formatting"
        })
    }
  }
  validate(n, r) {
    return r >= 0 && r <= 6
  }
  set(n, r, s, a) {
    return n = jg(n, s, a), n.setHours(0, 0, 0, 0), n
  }
}
class pK extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 90);
    Re(this, "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"])
  }
  parse(n, r, s, a) {
    const o = i => {
      const l = Math.floor((i - 1) / 7) * 7;
      return (i + a.weekStartsOn + 6) % 7 + l
    };
    switch (r) {
      case "e":
      case "ee":
        return mn(un(r.length, n), o);
      case "eo":
        return mn(s.ordinalNumber(n, {
          unit: "day"
        }), o);
      case "eee":
        return s.day(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.day(n, {
          width: "short",
          context: "formatting"
        }) || s.day(n, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeee":
        return s.day(n, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return s.day(n, {
          width: "short",
          context: "formatting"
        }) || s.day(n, {
          width: "narrow",
          context: "formatting"
        });
      case "eeee":
      default:
        return s.day(n, {
          width: "wide",
          context: "formatting"
        }) || s.day(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.day(n, {
          width: "short",
          context: "formatting"
        }) || s.day(n, {
          width: "narrow",
          context: "formatting"
        })
    }
  }
  validate(n, r) {
    return r >= 0 && r <= 6
  }
  set(n, r, s, a) {
    return n = jg(n, s, a), n.setHours(0, 0, 0, 0), n
  }
}
class hK extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 90);
    Re(this, "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"])
  }
  parse(n, r, s, a) {
    const o = i => {
      const l = Math.floor((i - 1) / 7) * 7;
      return (i + a.weekStartsOn + 6) % 7 + l
    };
    switch (r) {
      case "c":
      case "cc":
        return mn(un(r.length, n), o);
      case "co":
        return mn(s.ordinalNumber(n, {
          unit: "day"
        }), o);
      case "ccc":
        return s.day(n, {
          width: "abbreviated",
          context: "standalone"
        }) || s.day(n, {
          width: "short",
          context: "standalone"
        }) || s.day(n, {
          width: "narrow",
          context: "standalone"
        });
      case "ccccc":
        return s.day(n, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return s.day(n, {
          width: "short",
          context: "standalone"
        }) || s.day(n, {
          width: "narrow",
          context: "standalone"
        });
      case "cccc":
      default:
        return s.day(n, {
          width: "wide",
          context: "standalone"
        }) || s.day(n, {
          width: "abbreviated",
          context: "standalone"
        }) || s.day(n, {
          width: "short",
          context: "standalone"
        }) || s.day(n, {
          width: "narrow",
          context: "standalone"
        })
    }
  }
  validate(n, r) {
    return r >= 0 && r <= 6
  }
  set(n, r, s, a) {
    return n = jg(n, s, a), n.setHours(0, 0, 0, 0), n
  }
}

function mK(e, t, n) {
  const r = Ke(e, n == null ? void 0 : n.in),
    s = Uq(r, n),
    a = t - s;
  return vs(r, a, n)
}
class gK extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 90);
    Re(this, "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"])
  }
  parse(n, r, s) {
    const a = o => o === 0 ? 7 : o;
    switch (r) {
      case "i":
      case "ii":
        return un(r.length, n);
      case "io":
        return s.ordinalNumber(n, {
          unit: "day"
        });
      case "iii":
        return mn(s.day(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.day(n, {
          width: "short",
          context: "formatting"
        }) || s.day(n, {
          width: "narrow",
          context: "formatting"
        }), a);
      case "iiiii":
        return mn(s.day(n, {
          width: "narrow",
          context: "formatting"
        }), a);
      case "iiiiii":
        return mn(s.day(n, {
          width: "short",
          context: "formatting"
        }) || s.day(n, {
          width: "narrow",
          context: "formatting"
        }), a);
      case "iiii":
      default:
        return mn(s.day(n, {
          width: "wide",
          context: "formatting"
        }) || s.day(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.day(n, {
          width: "short",
          context: "formatting"
        }) || s.day(n, {
          width: "narrow",
          context: "formatting"
        }), a)
    }
  }
  validate(n, r) {
    return r >= 1 && r <= 7
  }
  set(n, r, s) {
    return n = mK(n, s), n.setHours(0, 0, 0, 0), n
  }
}
class vK extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 80);
    Re(this, "incompatibleTokens", ["b", "B", "H", "k", "t", "T"])
  }
  parse(n, r, s) {
    switch (r) {
      case "a":
      case "aa":
      case "aaa":
        return s.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaaa":
        return s.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return s.dayPeriod(n, {
          width: "wide",
          context: "formatting"
        }) || s.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        })
    }
  }
  set(n, r, s) {
    return n.setHours(Bg(s), 0, 0, 0), n
  }
}
class _K extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 80);
    Re(this, "incompatibleTokens", ["a", "B", "H", "k", "t", "T"])
  }
  parse(n, r, s) {
    switch (r) {
      case "b":
      case "bb":
      case "bbb":
        return s.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbbb":
        return s.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return s.dayPeriod(n, {
          width: "wide",
          context: "formatting"
        }) || s.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        })
    }
  }
  set(n, r, s) {
    return n.setHours(Bg(s), 0, 0, 0), n
  }
}
class yK extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 80);
    Re(this, "incompatibleTokens", ["a", "b", "t", "T"])
  }
  parse(n, r, s) {
    switch (r) {
      case "B":
      case "BB":
      case "BBB":
        return s.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBBB":
        return s.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return s.dayPeriod(n, {
          width: "wide",
          context: "formatting"
        }) || s.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        })
    }
  }
  set(n, r, s) {
    return n.setHours(Bg(s), 0, 0, 0), n
  }
}
class bK extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 70);
    Re(this, "incompatibleTokens", ["H", "K", "k", "t", "T"])
  }
  parse(n, r, s) {
    switch (r) {
      case "h":
        return nn(hn.hour12h, n);
      case "ho":
        return s.ordinalNumber(n, {
          unit: "hour"
        });
      default:
        return un(r.length, n)
    }
  }
  validate(n, r) {
    return r >= 1 && r <= 12
  }
  set(n, r, s) {
    const a = n.getHours() >= 12;
    return a && s < 12 ? n.setHours(s + 12, 0, 0, 0) : !a && s === 12 ? n.setHours(0, 0, 0, 0) : n.setHours(s, 0, 0, 0), n
  }
}
class wK extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 70);
    Re(this, "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"])
  }
  parse(n, r, s) {
    switch (r) {
      case "H":
        return nn(hn.hour23h, n);
      case "Ho":
        return s.ordinalNumber(n, {
          unit: "hour"
        });
      default:
        return un(r.length, n)
    }
  }
  validate(n, r) {
    return r >= 0 && r <= 23
  }
  set(n, r, s) {
    return n.setHours(s, 0, 0, 0), n
  }
}
class CK extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 70);
    Re(this, "incompatibleTokens", ["h", "H", "k", "t", "T"])
  }
  parse(n, r, s) {
    switch (r) {
      case "K":
        return nn(hn.hour11h, n);
      case "Ko":
        return s.ordinalNumber(n, {
          unit: "hour"
        });
      default:
        return un(r.length, n)
    }
  }
  validate(n, r) {
    return r >= 0 && r <= 11
  }
  set(n, r, s) {
    return n.getHours() >= 12 && s < 12 ? n.setHours(s + 12, 0, 0, 0) : n.setHours(s, 0, 0, 0), n
  }
}
class xK extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 70);
    Re(this, "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"])
  }
  parse(n, r, s) {
    switch (r) {
      case "k":
        return nn(hn.hour24h, n);
      case "ko":
        return s.ordinalNumber(n, {
          unit: "hour"
        });
      default:
        return un(r.length, n)
    }
  }
  validate(n, r) {
    return r >= 1 && r <= 24
  }
  set(n, r, s) {
    const a = s <= 24 ? s % 24 : s;
    return n.setHours(a, 0, 0, 0), n
  }
}
class kK extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 60);
    Re(this, "incompatibleTokens", ["t", "T"])
  }
  parse(n, r, s) {
    switch (r) {
      case "m":
        return nn(hn.minute, n);
      case "mo":
        return s.ordinalNumber(n, {
          unit: "minute"
        });
      default:
        return un(r.length, n)
    }
  }
  validate(n, r) {
    return r >= 0 && r <= 59
  }
  set(n, r, s) {
    return n.setMinutes(s, 0, 0), n
  }
}
class SK extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 50);
    Re(this, "incompatibleTokens", ["t", "T"])
  }
  parse(n, r, s) {
    switch (r) {
      case "s":
        return nn(hn.second, n);
      case "so":
        return s.ordinalNumber(n, {
          unit: "second"
        });
      default:
        return un(r.length, n)
    }
  }
  validate(n, r) {
    return r >= 0 && r <= 59
  }
  set(n, r, s) {
    return n.setSeconds(s, 0), n
  }
}
class EK extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 30);
    Re(this, "incompatibleTokens", ["t", "T"])
  }
  parse(n, r) {
    const s = a => Math.trunc(a * Math.pow(10, -r.length + 3));
    return mn(un(r.length, n), s)
  }
  set(n, r, s) {
    return n.setMilliseconds(s), n
  }
}
class TK extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 10);
    Re(this, "incompatibleTokens", ["t", "T", "x"])
  }
  parse(n, r) {
    switch (r) {
      case "X":
        return Vs(Hs.basicOptionalMinutes, n);
      case "XX":
        return Vs(Hs.basic, n);
      case "XXXX":
        return Vs(Hs.basicOptionalSeconds, n);
      case "XXXXX":
        return Vs(Hs.extendedOptionalSeconds, n);
      case "XXX":
      default:
        return Vs(Hs.extended, n)
    }
  }
  set(n, r, s) {
    return r.timestampIsSet ? n : Lt(n, n.getTime() - ap(n) - s)
  }
}
class AK extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 10);
    Re(this, "incompatibleTokens", ["t", "T", "X"])
  }
  parse(n, r) {
    switch (r) {
      case "x":
        return Vs(Hs.basicOptionalMinutes, n);
      case "xx":
        return Vs(Hs.basic, n);
      case "xxxx":
        return Vs(Hs.basicOptionalSeconds, n);
      case "xxxxx":
        return Vs(Hs.extendedOptionalSeconds, n);
      case "xxx":
      default:
        return Vs(Hs.extended, n)
    }
  }
  set(n, r, s) {
    return r.timestampIsSet ? n : Lt(n, n.getTime() - ap(n) - s)
  }
}
class PK extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 40);
    Re(this, "incompatibleTokens", "*")
  }
  parse(n) {
    return f7(n)
  }
  set(n, r, s) {
    return [Lt(n, s * 1e3), {
      timestampIsSet: !0
    }]
  }
}
class IK extends St {
  constructor() {
    super(...arguments);
    Re(this, "priority", 20);
    Re(this, "incompatibleTokens", "*")
  }
  parse(n) {
    return f7(n)
  }
  set(n, r, s) {
    return [Lt(n, s), {
      timestampIsSet: !0
    }]
  }
}
const $K = {
    G: new qq,
    y: new Kq,
    Y: new Zq,
    R: new Jq,
    u: new Xq,
    Q: new eK,
    q: new tK,
    M: new nK,
    L: new rK,
    w: new aK,
    I: new iK,
    d: new cK,
    D: new dK,
    E: new fK,
    e: new pK,
    c: new hK,
    i: new gK,
    a: new vK,
    b: new _K,
    B: new yK,
    h: new bK,
    H: new wK,
    K: new CK,
    k: new xK,
    m: new kK,
    s: new SK,
    S: new EK,
    X: new TK,
    x: new AK,
    t: new PK,
    T: new IK
  },
  MK = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g,
  OK = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g,
  DK = /^'([^]*?)'?$/,
  LK = /''/g,
  RK = /\S/,
  NK = /[a-zA-Z]/;

function Qm(e, t, n, r) {
  var C, y, b, w, x, E, S, T;
  const s = () => Lt((r == null ? void 0 : r.in) || n, NaN),
    a = Vq(),
    o = (r == null ? void 0 : r.locale) ?? a.locale ?? i7,
    i = (r == null ? void 0 : r.firstWeekContainsDate) ?? ((y = (C = r == null ? void 0 : r.locale) == null ? void 0 : C.options) == null ? void 0 : y.firstWeekContainsDate) ?? a.firstWeekContainsDate ?? ((w = (b = a.locale) == null ? void 0 : b.options) == null ? void 0 : w.firstWeekContainsDate) ?? 1,
    l = (r == null ? void 0 : r.weekStartsOn) ?? ((E = (x = r == null ? void 0 : r.locale) == null ? void 0 : x.options) == null ? void 0 : E.weekStartsOn) ?? a.weekStartsOn ?? ((T = (S = a.locale) == null ? void 0 : S.options) == null ? void 0 : T.weekStartsOn) ?? 0;
  if (!t) return e ? s() : Ke(n, r == null ? void 0 : r.in);
  const c = {
      firstWeekContainsDate: i,
      weekStartsOn: l,
      locale: o
    },
    d = [new Qq(r == null ? void 0 : r.in, n)],
    f = t.match(OK).map(j => {
      const P = j[0];
      if (P in Wm) {
        const N = Wm[P];
        return N(j, o.formatLong)
      }
      return j
    }).join("").match(MK),
    p = [];
  for (let j of f) {
    !(r != null && r.useAdditionalWeekYearTokens) && c7(j) && Gm(j, t, e), !(r != null && r.useAdditionalDayOfYearTokens) && u7(j) && Gm(j, t, e);
    const P = j[0],
      N = $K[P];
    if (N) {
      const {
        incompatibleTokens: ne
      } = N;
      if (Array.isArray(ne)) {
        const _e = p.find(Q => ne.includes(Q.token) || Q.token === P);
        if (_e) throw new RangeError(`The format string mustn't contain \`${_e.fullToken}\` and \`${j}\` at the same time`)
      } else if (N.incompatibleTokens === "*" && p.length > 0) throw new RangeError(`The format string mustn't contain \`${j}\` and any other token at the same time`);
      p.push({
        token: P,
        fullToken: j
      });
      const Y = N.run(e, j, o.match, c);
      if (!Y) return s();
      d.push(Y.setter), e = Y.rest
    } else {
      if (P.match(NK)) throw new RangeError("Format string contains an unescaped latin alphabet character `" + P + "`");
      if (j === "''" ? j = "'" : P === "'" && (j = FK(j)), e.indexOf(j) === 0) e = e.slice(j.length);
      else return s()
    }
  }
  if (e.length > 0 && RK.test(e)) return s();
  const h = d.map(j => j.priority).sort((j, P) => P - j).filter((j, P, N) => N.indexOf(j) === P).map(j => d.filter(P => P.priority === j).sort((P, N) => N.subPriority - P.subPriority)).map(j => j[0]);
  let _ = Ke(n, r == null ? void 0 : r.in);
  if (isNaN(+_)) return s();
  const v = {};
  for (const j of h) {
    if (!j.validate(_, c)) return s();
    const P = j.set(_, v, c);
    Array.isArray(P) ? (_ = P[0], Object.assign(v, P[1])) : _ = P
  }
  return _
}

function FK(e) {
  return e.match(DK)[1].replace(LK, "'")
}

function a3(e, t, n) {
  const [r, s] = wd(n == null ? void 0 : n.in, e, t);
  return +fi(r) == +fi(s)
}

function BK(e, t, n) {
  return vs(e, -t, n)
}

function m7(e, t, n) {
  const r = Ke(e, n == null ? void 0 : n.in),
    s = r.getFullYear(),
    a = r.getDate(),
    o = Lt(e, 0);
  o.setFullYear(s, t, 15), o.setHours(0, 0, 0, 0);
  const i = Hq(o);
  return r.setMonth(t, Math.min(a, i)), r
}

function jt(e, t, n) {
  let r = Ke(e, n == null ? void 0 : n.in);
  return isNaN(+r) ? Lt(e, NaN) : (t.year != null && r.setFullYear(t.year), t.month != null && (r = m7(r, t.month)), t.date != null && r.setDate(t.date), t.hours != null && r.setHours(t.hours), t.minutes != null && r.setMinutes(t.minutes), t.seconds != null && r.setSeconds(t.seconds), t.milliseconds != null && r.setMilliseconds(t.milliseconds), r)
}

function jK(e, t, n) {
  const r = Ke(e, n == null ? void 0 : n.in);
  return r.setHours(t), r
}

function g7(e, t, n) {
  const r = Ke(e, n == null ? void 0 : n.in);
  return r.setMilliseconds(t), r
}

function HK(e, t, n) {
  const r = Ke(e, n == null ? void 0 : n.in);
  return r.setMinutes(t), r
}

function v7(e, t, n) {
  const r = Ke(e, n == null ? void 0 : n.in);
  return r.setSeconds(t), r
}

function zs(e, t, n) {
  const r = Ke(e, n == null ? void 0 : n.in);
  return isNaN(+r) ? Lt(e, NaN) : (r.setFullYear(t), r)
}

function cu(e, t, n) {
  return ws(e, -t, n)
}

function VK(e, t, n) {
  const {
    years: r = 0,
    months: s = 0,
    weeks: a = 0,
    days: o = 0,
    hours: i = 0,
    minutes: l = 0,
    seconds: c = 0
  } = t, d = cu(e, s + r * 12, n), f = BK(d, o + a * 7, n), p = l + i * 60, _ = (c + p * 60) * 1e3;
  return Lt(e, +f - _)
}

function _7(e, t, n) {
  return Lg(e, -t, n)
}

function Du() {
  const e = K6();
  return g(), k("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32",
    fill: "currentColor",
    "aria-hidden": "true",
    class: "dp__icon",
    role: "img",
    ...e
  }, [m("path", {
    d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z"
  }), m("path", {
    d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
  }), m("path", {
    d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
  }), m("path", {
    d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z"
  })])
}
Du.compatConfig = {
  MODE: 3
};

function y7() {
  return g(), k("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32",
    fill: "currentColor",
    "aria-hidden": "true",
    class: "dp__icon",
    role: "img"
  }, [m("path", {
    d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z"
  }), m("path", {
    d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
  })])
}
y7.compatConfig = {
  MODE: 3
};

function Hg() {
  return g(), k("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32",
    fill: "currentColor",
    "aria-hidden": "true",
    class: "dp__icon",
    role: "img"
  }, [m("path", {
    d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
  })])
}
Hg.compatConfig = {
  MODE: 3
};

function Vg() {
  return g(), k("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32",
    fill: "currentColor",
    "aria-hidden": "true",
    class: "dp__icon",
    role: "img"
  }, [m("path", {
    d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z"
  })])
}
Vg.compatConfig = {
  MODE: 3
};

function Ug() {
  return g(), k("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32",
    fill: "currentColor",
    "aria-hidden": "true",
    class: "dp__icon",
    role: "img"
  }, [m("path", {
    d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z"
  }), m("path", {
    d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
  })])
}
Ug.compatConfig = {
  MODE: 3
};

function zg() {
  return g(), k("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32",
    fill: "currentColor",
    "aria-hidden": "true",
    class: "dp__icon",
    role: "img"
  }, [m("path", {
    d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
  })])
}
zg.compatConfig = {
  MODE: 3
};

function Yg() {
  return g(), k("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32",
    fill: "currentColor",
    "aria-hidden": "true",
    class: "dp__icon",
    role: "img"
  }, [m("path", {
    d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
  })])
}
Yg.compatConfig = {
  MODE: 3
};
const Ir = (e, t) => t ? new Date(e.toLocaleString("en-US", {
    timeZone: t
  })) : new Date(e),
  Wg = (e, t, n) => qm(e, t, n) || Te(),
  UK = (e, t, n) => {
    const r = t.dateInTz ? Ir(new Date(e), t.dateInTz) : Te(e);
    return n ? mr(r, !0) : r
  },
  qm = (e, t, n) => {
    if (!e) return null;
    const r = n ? mr(Te(e), !0) : Te(e);
    return t ? t.exactMatch ? UK(e, t, n) : Ir(r, t.timezone) : r
  },
  zK = (e, t) => {
    if (!e) return 0;
    const n = new Date,
      r = new Date(n.toLocaleString("en-US", {
        timeZone: "UTC"
      })),
      s = new Date(n.toLocaleString("en-US", {
        timeZone: e
      })),
      a = (t ?? s).getTimezoneOffset() / 60;
    return (+r - +s) / (1e3 * 60 * 60) - a
  };
var os = (e => (e.month = "month", e.year = "year", e))(os || {}),
  is = (e => (e.top = "top", e.bottom = "bottom", e))(is || {}),
  Ii = (e => (e.header = "header", e.calendar = "calendar", e.timePicker = "timePicker", e))(Ii || {}),
  Yn = (e => (e.month = "month", e.year = "year", e.calendar = "calendar", e.time = "time", e.minutes = "minutes", e.hours = "hours", e.seconds = "seconds", e))(Yn || {});
const YK = ["timestamp", "date", "iso"];
var tr = (e => (e.up = "up", e.down = "down", e.left = "left", e.right = "right", e))(tr || {}),
  Gt = (e => (e.arrowUp = "ArrowUp", e.arrowDown = "ArrowDown", e.arrowLeft = "ArrowLeft", e.arrowRight = "ArrowRight", e.enter = "Enter", e.space = " ", e.esc = "Escape", e.tab = "Tab", e.home = "Home", e.end = "End", e.pageUp = "PageUp", e.pageDown = "PageDown", e))(Gt || {});

function o3(e) {
  return t => new Intl.DateTimeFormat(e, {
    weekday: "short",
    timeZone: "UTC"
  }).format(new Date(`2017-01-0${t}T00:00:00+00:00`)).slice(0, 2)
}

function WK(e) {
  return t => Js(Ir(new Date(`2017-01-0${t}T00:00:00+00:00`), "UTC"), "EEEEEE", {
    locale: e
  })
}
const GK = (e, t, n) => {
    const r = [1, 2, 3, 4, 5, 6, 7];
    let s;
    if (e !== null) try {
      s = r.map(WK(e))
    } catch {
      s = r.map(o3(t))
    } else s = r.map(o3(t));
    const a = s.slice(0, n),
      o = s.slice(n + 1, s.length);
    return [s[n]].concat(...o).concat(...a)
  },
  Gg = (e, t, n) => {
    const r = [];
    for (let s = +e[0]; s <= +e[1]; s++) r.push({
      value: +s,
      text: x7(s, t)
    });
    return n ? r.reverse() : r
  },
  b7 = (e, t, n) => {
    const r = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map(a => {
      const o = a < 10 ? `0${a}` : a;
      return new Date(`2017-${o}-01T00:00:00+00:00`)
    });
    if (e !== null) try {
      const a = n === "long" ? "LLLL" : "LLL";
      return r.map((o, i) => {
        const l = Js(Ir(o, "UTC"), a, {
          locale: e
        });
        return {
          text: l.charAt(0).toUpperCase() + l.substring(1),
          value: i
        }
      })
    } catch {}
    const s = new Intl.DateTimeFormat(t, {
      month: n,
      timeZone: "UTC"
    });
    return r.map((a, o) => {
      const i = s.format(a);
      return {
        text: i.charAt(0).toUpperCase() + i.substring(1),
        value: o
      }
    })
  },
  QK = e => [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11][e],
  Sn = e => {
    const t = u(e);
    return t != null && t.$el ? t == null ? void 0 : t.$el : t
  },
  qK = e => ({
    type: "dot",
    ...e ?? {}
  }),
  w7 = e => Array.isArray(e) ? !!e[0] && !!e[1] : !1,
  Qg = {
    prop: e => `"${e}" prop must be enabled!`,
    dateArr: e => `You need to use array as "model-value" binding in order to support "${e}"`
  },
  Pn = e => e,
  i3 = e => e === 0 ? e : !e || isNaN(+e) ? null : +e,
  l3 = e => e === null,
  C7 = e => {
    if (e) return [...e.querySelectorAll("input, button, select, textarea, a[href]")][0]
  },
  KK = e => {
    const t = [],
      n = r => r.filter(s => s);
    for (let r = 0; r < e.length; r += 3) {
      const s = [e[r], e[r + 1], e[r + 2]];
      t.push(n(s))
    }
    return t
  },
  Uc = (e, t, n) => {
    const r = n != null,
      s = t != null;
    if (!r && !s) return !1;
    const a = +n,
      o = +t;
    return r && s ? +e > a || +e < o : r ? +e > a : s ? +e < o : !1
  },
  du = (e, t) => KK(e).map(n => n.map(r => {
    const {
      active: s,
      disabled: a,
      isBetween: o,
      highlighted: i
    } = t(r);
    return {
      ...r,
      active: s,
      disabled: a,
      className: {
        dp__overlay_cell_active: s,
        dp__overlay_cell: !s,
        dp__overlay_cell_disabled: a,
        dp__overlay_cell_pad: !0,
        dp__overlay_cell_active_disabled: a && s,
        dp__cell_in_between: o,
        "dp--highlighted": i
      }
    }
  })),
  $o = (e, t, n = !1) => {
    e && t.allowStopPropagation && (n && e.stopImmediatePropagation(), e.stopPropagation())
  },
  ZK = () => ["a[href]", "area[href]", "input:not([disabled]):not([type='hidden'])", "select:not([disabled])", "textarea:not([disabled])", "button:not([disabled])", "[tabindex]:not([tabindex='-1'])", "[data-datepicker-instance]"].join(", ");

function JK(e, t) {
  let n = [...document.querySelectorAll(ZK())];
  n = n.filter(s => !e.contains(s) || s.hasAttribute("data-datepicker-instance"));
  const r = n.indexOf(e);
  if (r >= 0 && (t ? r - 1 >= 0 : r + 1 <= n.length)) return n[r + (t ? -1 : 1)]
}
const Km = (e, t) => e == null ? void 0 : e.querySelector(`[data-dp-element="${t}"]`),
  x7 = (e, t) => new Intl.NumberFormat(t, {
    useGrouping: !1,
    style: "decimal"
  }).format(e),
  qg = e => Js(e, "dd-MM-yyyy"),
  J1 = e => Array.isArray(e),
  ip = (e, t) => t.get(qg(e)),
  XK = (e, t) => e ? t ? t instanceof Map ? !!ip(e, t) : t(Te(e)) : !1 : !0,
  ur = (e, t, n = !1, r) => {
    if (e.key === Gt.enter || e.key === Gt.space) return n && e.preventDefault(), t();
    if (r) return r(e)
  },
  u3 = () => ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].some(e => navigator.userAgent.includes(e)) || navigator.userAgent.includes("Mac") && "ontouchend" in document,
  c3 = (e, t, n, r, s, a) => {
    const o = Qm(e, t.slice(0, e.length), new Date, {
      locale: a
    });
    return fc(o) && n7(o) ? r || s ? o : jt(o, {
      hours: +n.hours,
      minutes: +(n == null ? void 0 : n.minutes),
      seconds: +(n == null ? void 0 : n.seconds),
      milliseconds: 0
    }) : null
  },
  eZ = (e, t, n, r, s, a) => {
    const o = Array.isArray(n) ? n[0] : n;
    if (typeof t == "string") return c3(e, t, o, r, s, a);
    if (Array.isArray(t)) {
      let i = null;
      for (const l of t)
        if (i = c3(e, l, o, r, s, a), i) break;
      return i
    }
    return typeof t == "function" ? t(e) : null
  },
  Te = e => e ? new Date(e) : new Date,
  tZ = (e, t, n) => {
    if (t) {
      const s = (e.getMonth() + 1).toString().padStart(2, "0"),
        a = e.getDate().toString().padStart(2, "0"),
        o = e.getHours().toString().padStart(2, "0"),
        i = e.getMinutes().toString().padStart(2, "0"),
        l = n ? e.getSeconds().toString().padStart(2, "0") : "00";
      return `${e.getFullYear()}-${s}-${a}T${o}:${i}:${l}.000Z`
    }
    const r = Date.UTC(e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes(), e.getUTCSeconds());
    return new Date(r).toISOString()
  },
  mr = (e, t) => {
    const n = Te(JSON.parse(JSON.stringify(e))),
      r = jt(n, {
        hours: 0,
        minutes: 0,
        seconds: 0,
        milliseconds: 0
      });
    return t ? QQ(r) : r
  },
  Mo = (e, t, n, r) => {
    let s = e ? Te(e) : Te();
    return (t || t === 0) && (s = jK(s, +t)), (n || n === 0) && (s = HK(s, +n)), (r || r === 0) && (s = v7(s, +r)), g7(s, 0)
  },
  on = (e, t) => !e || !t ? !1 : Vc(mr(e), mr(t)),
  mt = (e, t) => !e || !t ? !1 : ml(mr(e), mr(t)),
  fn = (e, t) => !e || !t ? !1 : uu(mr(e), mr(t)),
  n1 = (e, t, n) => e != null && e[0] && e != null && e[1] ? fn(n, e[0]) && on(n, e[1]) : e != null && e[0] && t ? fn(n, e[0]) && on(n, t) || on(n, e[0]) && fn(n, t) : !1,
  _s = e => {
    const t = jt(new Date(e), {
      date: 1
    });
    return mr(t)
  },
  X1 = (e, t, n) => t && (n || n === 0) ? Object.fromEntries(["hours", "minutes", "seconds"].map(r => r === t ? [r, n] : [r, isNaN(+e[r]) ? void 0 : +e[r]])) : {
    hours: isNaN(+e.hours) ? void 0 : +e.hours,
    minutes: isNaN(+e.minutes) ? void 0 : +e.minutes,
    seconds: isNaN(+e.seconds) ? void 0 : +e.seconds
  },
  $i = e => ({
    hours: za(e),
    minutes: Uo(e),
    seconds: lu(e)
  }),
  k7 = (e, t) => {
    if (t) {
      const n = Xe(Te(t));
      if (n > e) return 12;
      if (n === e) return ft(Te(t))
    }
  },
  S7 = (e, t) => {
    if (t) {
      const n = Xe(Te(t));
      return n < e ? -1 : n === e ? ft(Te(t)) : void 0
    }
  },
  fu = e => {
    if (e) return Xe(Te(e))
  },
  E7 = (e, t) => {
    const n = fn(e, t) ? t : e,
      r = fn(t, e) ? t : e;
    return s7({
      start: n,
      end: r
    })
  },
  nZ = e => {
    const t = ws(e, 1);
    return {
      month: ft(t),
      year: Xe(t)
    }
  },
  _a = (e, t) => {
    const n = Ps(e, {
        weekStartsOn: +t
      }),
      r = o7(e, {
        weekStartsOn: +t
      });
    return [n, r]
  },
  T7 = (e, t) => {
    const n = {
      hours: za(Te()),
      minutes: Uo(Te()),
      seconds: t ? lu(Te()) : 0
    };
    return Object.assign(n, e)
  },
  Po = (e, t, n) => [jt(Te(e), {
    date: 1
  }), jt(Te(), {
    month: t,
    year: n,
    date: 1
  })],
  Pa = (e, t, n) => {
    let r = e ? Te(e) : Te();
    return (t || t === 0) && (r = m7(r, t)), n && (r = zs(r, n)), r
  },
  A7 = (e, t, n, r, s) => {
    if (!r || s && !t || !s && !n) return !1;
    const a = s ? ws(e, 1) : cu(e, 1),
      o = [ft(a), Xe(a)];
    return s ? !sZ(...o, t) : !rZ(...o, n)
  },
  rZ = (e, t, n) => on(...Po(n, e, t)) || mt(...Po(n, e, t)),
  sZ = (e, t, n) => fn(...Po(n, e, t)) || mt(...Po(n, e, t)),
  P7 = (e, t, n, r, s, a, o) => {
    if (typeof t == "function" && !o) return t(e);
    const i = n ? {
      locale: n
    } : void 0;
    return Array.isArray(e) ? `${Js(e[0],a,i)}${s&&!e[1]?"":r}${e[1]?Js(e[1],a,i):""}` : Js(e, a, i)
  },
  ol = e => {
    if (e) return null;
    throw new Error(Qg.prop("partial-range"))
  },
  ef = (e, t) => {
    if (t) return e();
    throw new Error(Qg.prop("range"))
  },
  Zm = e => Array.isArray(e) ? fc(e[0]) && (e[1] ? fc(e[1]) : !0) : e ? fc(e) : !1,
  aZ = (e, t) => jt(t ?? Te(), {
    hours: +e.hours || 0,
    minutes: +e.minutes || 0,
    seconds: +e.seconds || 0
  }),
  eh = (e, t, n, r) => {
    if (!e) return !0;
    if (r) {
      const s = n === "max" ? Vc(e, t) : uu(e, t),
        a = {
          seconds: 0,
          milliseconds: 0
        };
      return s || ml(jt(e, a), jt(t, a))
    }
    return n === "max" ? e.getTime() <= t.getTime() : e.getTime() >= t.getTime()
  },
  th = (e, t, n) => e ? aZ(e, t) : Te(n ?? t),
  d3 = (e, t, n, r, s) => {
    if (Array.isArray(r)) {
      const o = th(e, r[0], t),
        i = th(e, r[1], t);
      return eh(r[0], o, n, !!t) && eh(r[1], i, n, !!t) && s
    }
    const a = th(e, r, t);
    return eh(r, a, n, !!t) && s
  },
  nh = e => jt(Te(), $i(e)),
  oZ = (e, t) => e instanceof Map ? Array.from(e.values()).filter(n => Xe(Te(n)) === t).map(n => ft(n)) : [],
  iZ = (e, t, n) => {
    if (e instanceof Map) {
      const r = Array.from(e.values()).filter(s => Xe(Te(s)) === t).map(s => ft(s));
      return r.length ? r.includes(n) : !0
    }
    return !0
  },
  I7 = (e, t, n) => typeof e == "function" ? e({
    month: t,
    year: n
  }) : !!e.months.find(r => r.month === t && r.year === n),
  Kg = (e, t) => typeof e == "function" ? e(t) : e.years.includes(t),
  $7 = e => Js(e, "yyyy-MM-dd"),
  Gu = xn({
    menuFocused: !1,
    shiftKeyInMenu: !1
  }),
  M7 = () => {
    const e = n => {
        Gu.menuFocused = n
      },
      t = n => {
        Gu.shiftKeyInMenu !== n && (Gu.shiftKeyInMenu = n)
      };
    return {
      control: L(() => ({
        shiftKeyInMenu: Gu.shiftKeyInMenu,
        menuFocused: Gu.menuFocused
      })),
      setMenuFocused: e,
      setShiftKey: t
    }
  },
  Yt = xn({
    monthYear: [],
    calendar: [],
    time: [],
    actionRow: [],
    selectionGrid: [],
    timePicker: {
      0: [],
      1: []
    },
    monthPicker: []
  }),
  rh = U(null),
  tf = U(!1),
  sh = U(!1),
  ah = U(!1),
  oh = U(!1),
  Vn = U(0),
  cn = U(0),
  ei = () => {
    const e = L(() => tf.value ? [...Yt.selectionGrid, Yt.actionRow].filter(f => f.length) : sh.value ? [...Yt.timePicker[0], ...Yt.timePicker[1], oh.value ? [] : [rh.value], Yt.actionRow].filter(f => f.length) : ah.value ? [...Yt.monthPicker, Yt.actionRow] : [Yt.monthYear, ...Yt.calendar, Yt.time, Yt.actionRow].filter(f => f.length)),
      t = f => {
        Vn.value = f ? Vn.value + 1 : Vn.value - 1;
        let p = null;
        e.value[cn.value] && (p = e.value[cn.value][Vn.value]), !p && e.value[cn.value + (f ? 1 : -1)] ? (cn.value = cn.value + (f ? 1 : -1), Vn.value = f ? 0 : e.value[cn.value].length - 1) : p || (Vn.value = f ? Vn.value - 1 : Vn.value + 1)
      },
      n = f => {
        cn.value === 0 && !f || cn.value === e.value.length && f || (cn.value = f ? cn.value + 1 : cn.value - 1, e.value[cn.value] ? e.value[cn.value] && !e.value[cn.value][Vn.value] && Vn.value !== 0 && (Vn.value = e.value[cn.value].length - 1) : cn.value = f ? cn.value - 1 : cn.value + 1)
      },
      r = f => {
        let p = null;
        e.value[cn.value] && (p = e.value[cn.value][Vn.value]), p ? p.focus({
          preventScroll: !tf.value
        }) : Vn.value = f ? Vn.value - 1 : Vn.value + 1
      },
      s = () => {
        t(!0), r(!0)
      },
      a = () => {
        t(!1), r(!1)
      },
      o = () => {
        n(!1), r(!0)
      },
      i = () => {
        n(!0), r(!0)
      },
      l = (f, p) => {
        Yt[p] = f
      },
      c = (f, p) => {
        Yt[p] = f
      },
      d = () => {
        Vn.value = 0, cn.value = 0
      };
    return {
      buildMatrix: l,
      buildMultiLevelMatrix: c,
      setTimePickerBackRef: f => {
        rh.value = f
      },
      setSelectionGrid: f => {
        tf.value = f, d(), f || (Yt.selectionGrid = [])
      },
      setTimePicker: (f, p = !1) => {
        sh.value = f, oh.value = p, d(), f || (Yt.timePicker[0] = [], Yt.timePicker[1] = [])
      },
      setTimePickerElements: (f, p = 0) => {
        Yt.timePicker[p] = f
      },
      arrowRight: s,
      arrowLeft: a,
      arrowUp: o,
      arrowDown: i,
      clearArrowNav: () => {
        Yt.monthYear = [], Yt.calendar = [], Yt.time = [], Yt.actionRow = [], Yt.selectionGrid = [], Yt.timePicker[0] = [], Yt.timePicker[1] = [], tf.value = !1, sh.value = !1, oh.value = !1, ah.value = !1, d(), rh.value = null
      },
      setMonthPicker: f => {
        ah.value = f, d()
      },
      refSets: Yt
    }
  },
  f3 = e => ({
    menuAppearTop: "dp-menu-appear-top",
    menuAppearBottom: "dp-menu-appear-bottom",
    open: "dp-slide-down",
    close: "dp-slide-up",
    next: "calendar-next",
    previous: "calendar-prev",
    vNext: "dp-slide-up",
    vPrevious: "dp-slide-down",
    ...e ?? {}
  }),
  lZ = e => ({
    toggleOverlay: "Toggle overlay",
    menu: "Datepicker menu",
    input: "Datepicker input",
    openTimePicker: "Open time picker",
    closeTimePicker: "Close time Picker",
    incrementValue: t => `Increment ${t}`,
    decrementValue: t => `Decrement ${t}`,
    openTpOverlay: t => `Open ${t} overlay`,
    amPmButton: "Switch AM/PM mode",
    openYearsOverlay: "Open years overlay",
    openMonthsOverlay: "Open months overlay",
    nextMonth: "Next month",
    prevMonth: "Previous month",
    nextYear: "Next year",
    prevYear: "Previous year",
    day: void 0,
    weekDay: void 0,
    clearInput: "Clear value",
    calendarIcon: "Calendar icon",
    timePicker: "Time picker",
    monthPicker: t => `Month picker${t?" overlay":""}`,
    yearPicker: t => `Year picker${t?" overlay":""}`,
    timeOverlay: t => `${t} overlay`,
    ...e ?? {}
  }),
  p3 = e => e ? typeof e == "boolean" ? e ? 2 : 0 : +e >= 2 ? +e : 2 : 0,
  uZ = e => {
    const t = typeof e == "object" && e,
      n = {
        static: !0,
        solo: !1
      };
    if (!e) return {
      ...n,
      count: p3(!1)
    };
    const r = t ? e : {},
      s = t ? r.count ?? !0 : e,
      a = p3(s);
    return Object.assign(n, r, {
      count: a
    })
  },
  cZ = (e, t, n) => e || (typeof n == "string" ? n : t),
  dZ = e => typeof e == "boolean" ? e ? f3({}) : !1 : f3(e),
  fZ = e => {
    const t = {
      enterSubmit: !0,
      tabSubmit: !0,
      openMenu: "open",
      selectOnFocus: !1,
      rangeSeparator: " - "
    };
    return typeof e == "object" ? {
      ...t,
      ...e ?? {},
      enabled: !0
    } : {
      ...t,
      enabled: e
    }
  },
  pZ = e => ({
    months: [],
    years: [],
    times: {
      hours: [],
      minutes: [],
      seconds: []
    },
    ...e ?? {}
  }),
  hZ = e => ({
    showSelect: !0,
    showCancel: !0,
    showNow: !1,
    showPreview: !0,
    ...e ?? {}
  }),
  mZ = e => {
    const t = {
      input: !1
    };
    return typeof e == "object" ? {
      ...t,
      ...e ?? {},
      enabled: !0
    } : {
      enabled: e,
      ...t
    }
  },
  gZ = e => ({
    allowStopPropagation: !0,
    closeOnScroll: !1,
    modeHeight: 255,
    allowPreventDefault: !1,
    closeOnClearValue: !0,
    closeOnAutoApply: !0,
    noSwipe: !1,
    keepActionRow: !1,
    onClickOutside: void 0,
    tabOutClosesMenu: !0,
    arrowLeft: void 0,
    keepViewOnOffsetClick: !1,
    timeArrowHoldThreshold: 0,
    shadowDom: !1,
    mobileBreakpoint: 600,
    setDateOnMenuClose: !1,
    ...e ?? {}
  }),
  vZ = e => {
    const t = {
      dates: Array.isArray(e) ? e.map(n => Te(n)) : [],
      years: [],
      months: [],
      quarters: [],
      weeks: [],
      weekdays: [],
      options: {
        highlightDisabled: !1
      }
    };
    return typeof e == "function" ? e : {
      ...t,
      ...e ?? {}
    }
  },
  _Z = e => typeof e == "object" ? {
    type: (e == null ? void 0 : e.type) ?? "local",
    hideOnOffsetDates: (e == null ? void 0 : e.hideOnOffsetDates) ?? !1
  } : {
    type: e,
    hideOnOffsetDates: !1
  },
  yZ = e => {
    const t = {
      noDisabledRange: !1,
      showLastInRange: !0,
      minMaxRawRange: !1,
      partialRange: !0,
      disableTimeRangeValidation: !1,
      maxRange: void 0,
      minRange: void 0,
      autoRange: void 0,
      fixedStart: !1,
      fixedEnd: !1
    };
    return typeof e == "object" ? {
      enabled: !0,
      ...t,
      ...e
    } : {
      enabled: e,
      ...t
    }
  },
  bZ = e => e ? typeof e == "string" ? {
    timezone: e,
    exactMatch: !1,
    dateInTz: void 0,
    emitTimezone: void 0,
    convertModel: !0
  } : {
    timezone: e.timezone,
    exactMatch: e.exactMatch ?? !1,
    dateInTz: e.dateInTz ?? void 0,
    emitTimezone: e.emitTimezone ?? void 0,
    convertModel: e.convertModel ?? !0
  } : {
    timezone: void 0,
    exactMatch: !1,
    emitTimezone: void 0
  },
  ih = (e, t, n) => new Map(e.map(r => {
    const s = Wg(r, t, n);
    return [qg(s), s]
  })),
  wZ = (e, t) => e.length ? new Map(e.map(n => {
    const r = Wg(n.date, t);
    return [qg(r), n]
  })) : null,
  CZ = e => {
    var t;
    return {
      minDate: qm(e.minDate, e.timezone, e.isSpecific),
      maxDate: qm(e.maxDate, e.timezone, e.isSpecific),
      disabledDates: J1(e.disabledDates) ? ih(e.disabledDates, e.timezone, e.isSpecific) : e.disabledDates,
      allowedDates: J1(e.allowedDates) ? ih(e.allowedDates, e.timezone, e.isSpecific) : null,
      highlight: typeof e.highlight == "object" && J1((t = e.highlight) == null ? void 0 : t.dates) ? ih(e.highlight.dates, e.timezone) : e.highlight,
      markers: wZ(e.markers, e.timezone)
    }
  },
  xZ = e => typeof e == "boolean" ? {
    enabled: e,
    dragSelect: !0,
    limit: null
  } : {
    enabled: !!e,
    limit: e.limit ? +e.limit : null,
    dragSelect: e.dragSelect ?? !0
  },
  kZ = e => ({
    ...Object.fromEntries(Object.keys(e).map(t => {
      const n = t,
        r = e[n],
        s = typeof e[n] == "string" ? {
          [r]: !0
        } : Object.fromEntries(r.map(a => [a, !0]));
      return [t, s]
    }))
  }),
  tn = e => {
    const t = () => {
        const S = e.enableSeconds ? ":ss" : "",
          T = e.enableMinutes ? ":mm" : "";
        return e.is24 ? `HH${T}${S}` : `hh${T}${S} aa`
      },
      n = () => {
        var S;
        return e.format ? e.format : e.monthPicker ? "MM/yyyy" : e.timePicker ? t() : e.weekPicker ? `${((S=C.value)==null?void 0:S.type)==="iso"?"RR":"ww"}-yyyy` : e.yearPicker ? "yyyy" : e.quarterPicker ? "QQQ/yyyy" : e.enableTimePicker ? `MM/dd/yyyy, ${t()}` : "MM/dd/yyyy"
      },
      r = S => T7(S, e.enableSeconds),
      s = () => x.value.enabled ? e.startTime && Array.isArray(e.startTime) ? [r(e.startTime[0]), r(e.startTime[1])] : null : e.startTime && !Array.isArray(e.startTime) ? r(e.startTime) : null,
      a = L(() => uZ(e.multiCalendars)),
      o = L(() => s()),
      i = L(() => lZ(e.ariaLabels)),
      l = L(() => pZ(e.filters)),
      c = L(() => dZ(e.transitions)),
      d = L(() => hZ(e.actionRow)),
      f = L(() => cZ(e.previewFormat, e.format, n())),
      p = L(() => fZ(e.textInput)),
      h = L(() => mZ(e.inline)),
      _ = L(() => gZ(e.config)),
      v = L(() => vZ(e.highlight)),
      C = L(() => _Z(e.weekNumbers)),
      y = L(() => bZ(e.timezone)),
      b = L(() => xZ(e.multiDates)),
      w = L(() => CZ({
        minDate: e.minDate,
        maxDate: e.maxDate,
        disabledDates: e.disabledDates,
        allowedDates: e.allowedDates,
        highlight: v.value,
        markers: e.markers,
        timezone: y.value,
        isSpecific: e.monthPicker || e.yearPicker || e.quarterPicker
      })),
      x = L(() => yZ(e.range)),
      E = L(() => kZ(e.ui));
    return {
      defaultedTransitions: c,
      defaultedMultiCalendars: a,
      defaultedStartTime: o,
      defaultedAriaLabels: i,
      defaultedFilters: l,
      defaultedActionRow: d,
      defaultedPreviewFormat: f,
      defaultedTextInput: p,
      defaultedInline: h,
      defaultedConfig: _,
      defaultedHighlight: v,
      defaultedWeekNumbers: C,
      defaultedRange: x,
      propDates: w,
      defaultedTz: y,
      defaultedMultiDates: b,
      defaultedUI: E,
      getDefaultPattern: n,
      getDefaultStartTime: s
    }
  },
  SZ = (e, t, n) => {
    const r = U(),
      {
        defaultedTextInput: s,
        defaultedRange: a,
        defaultedTz: o,
        defaultedMultiDates: i,
        getDefaultPattern: l
      } = tn(t),
      c = U(""),
      d = zl(t, "format"),
      f = zl(t, "formatLocale");
    Ne(r, () => {
      typeof t.onInternalModelChange == "function" && e("internal-model-change", r.value, Ce(!0))
    }, {
      deep: !0
    }), Ne(a, (D, pe) => {
      D.enabled !== pe.enabled && (r.value = null)
    }), Ne(d, () => {
      de()
    });
    const p = D => o.value.timezone && o.value.convertModel ? Ir(D, o.value.timezone) : D,
      h = D => {
        if (o.value.timezone && o.value.convertModel) {
          const pe = zK(o.value.timezone, D);
          return HQ(D, pe)
        }
        return D
      },
      _ = (D, pe, ye = !1) => P7(D, t.format, t.formatLocale, s.value.rangeSeparator, t.modelAuto, pe ?? l(), ye),
      v = D => D ? t.modelType ? ae(D) : {
        hours: za(D),
        minutes: Uo(D),
        seconds: t.enableSeconds ? lu(D) : 0
      } : null,
      C = D => t.modelType ? ae(D) : {
        month: ft(D),
        year: Xe(D)
      },
      y = D => Array.isArray(D) ? i.value.enabled ? D.map(pe => b(pe, zs(Te(), pe))) : ef(() => [zs(Te(), D[0]), D[1] ? zs(Te(), D[1]) : ol(a.value.partialRange)], a.value.enabled) : zs(Te(), +D),
      b = (D, pe) => (typeof D == "string" || typeof D == "number") && t.modelType ? se(D) : pe,
      w = D => Array.isArray(D) ? [b(D[0], Mo(null, +D[0].hours, +D[0].minutes, D[0].seconds)), b(D[1], Mo(null, +D[1].hours, +D[1].minutes, D[1].seconds))] : b(D, Mo(null, D.hours, D.minutes, D.seconds)),
      x = D => {
        const pe = jt(Te(), {
          date: 1
        });
        return Array.isArray(D) ? i.value.enabled ? D.map(ye => b(ye, Pa(pe, +ye.month, +ye.year))) : ef(() => [b(D[0], Pa(pe, +D[0].month, +D[0].year)), b(D[1], D[1] ? Pa(pe, +D[1].month, +D[1].year) : ol(a.value.partialRange))], a.value.enabled) : b(D, Pa(pe, +D.month, +D.year))
      },
      E = D => {
        if (Array.isArray(D)) return D.map(pe => se(pe));
        throw new Error(Qg.dateArr("multi-dates"))
      },
      S = D => {
        if (Array.isArray(D) && a.value.enabled) {
          const pe = D[0],
            ye = D[1];
          return [Te(Array.isArray(pe) ? pe[0] : null), Array.isArray(ye) && ye.length ? Te(ye[0]) : null]
        }
        return Te(D[0])
      },
      T = D => t.modelAuto ? Array.isArray(D) ? [se(D[0]), se(D[1])] : t.autoApply ? [se(D)] : [se(D), null] : Array.isArray(D) ? ef(() => D[1] ? [se(D[0]), D[1] ? se(D[1]) : ol(a.value.partialRange)] : [se(D[0])], a.value.enabled) : se(D),
      j = () => {
        Array.isArray(r.value) && a.value.enabled && r.value.length === 1 && r.value.push(ol(a.value.partialRange))
      },
      P = () => {
        const D = r.value;
        return [ae(D[0]), D[1] ? ae(D[1]) : ol(a.value.partialRange)]
      },
      N = () => r.value[1] ? P() : ae(Pn(r.value[0])),
      ne = () => (r.value || []).map(D => ae(D)),
      Y = (D = !1) => (D || j(), t.modelAuto ? N() : i.value.enabled ? ne() : Array.isArray(r.value) ? ef(() => P(), a.value.enabled) : ae(Pn(r.value))),
      _e = D => !D || Array.isArray(D) && !D.length ? null : t.timePicker ? w(Pn(D)) : t.monthPicker ? x(Pn(D)) : t.yearPicker ? y(Pn(D)) : i.value.enabled ? E(Pn(D)) : t.weekPicker ? S(Pn(D)) : T(Pn(D)),
      Q = D => {
        const pe = _e(D);
        Zm(Pn(pe)) ? (r.value = Pn(pe), de()) : (r.value = null, c.value = "")
      },
      re = () => {
        const D = pe => Js(pe, s.value.format);
        return `${D(r.value[0])} ${s.value.rangeSeparator} ${r.value[1]?D(r.value[1]):""}`
      },
      J = () => n.value && r.value ? Array.isArray(r.value) ? re() : Js(r.value, s.value.format) : _(r.value),
      ee = () => r.value ? i.value.enabled ? r.value.map(D => _(D)).join("; ") : s.value.enabled && typeof s.value.format == "string" ? J() : _(r.value) : "",
      de = () => {
        !t.format || typeof t.format == "string" || s.value.enabled && typeof s.value.format == "string" ? c.value = ee() : c.value = t.format(r.value)
      },
      se = D => {
        if (t.utc) {
          const pe = new Date(D);
          return t.utc === "preserve" ? new Date(pe.getTime() + pe.getTimezoneOffset() * 6e4) : pe
        }
        return t.modelType ? YK.includes(t.modelType) ? p(new Date(D)) : t.modelType === "format" && (typeof t.format == "string" || !t.format) ? p(Qm(D, l(), new Date, {
          locale: f.value
        })) : p(Qm(D, t.modelType, new Date, {
          locale: f.value
        })) : p(new Date(D))
      },
      ae = D => D ? t.utc ? tZ(D, t.utc === "preserve", t.enableSeconds) : t.modelType ? t.modelType === "timestamp" ? +h(D) : t.modelType === "iso" ? h(D).toISOString() : t.modelType === "format" && (typeof t.format == "string" || !t.format) ? _(h(D)) : _(h(D), t.modelType, !0) : h(D) : "",
      ke = (D, pe = !1, ye = !1) => {
        if (ye) return D;
        if (e("update:model-value", D), o.value.emitTimezone && pe) {
          const Ae = Array.isArray(D) ? D.map(fe => Ir(Pn(fe), o.value.emitTimezone)) : Ir(Pn(D), o.value.emitTimezone);
          e("update:model-timezone-value", Ae)
        }
      },
      be = D => Array.isArray(r.value) ? i.value.enabled ? r.value.map(pe => D(pe)) : [D(r.value[0]), r.value[1] ? D(r.value[1]) : ol(a.value.partialRange)] : D(Pn(r.value)),
      ge = () => {
        if (Array.isArray(r.value)) {
          const D = _a(r.value[0], t.weekStart),
            pe = r.value[1] ? _a(r.value[1], t.weekStart) : [];
          return [D.map(ye => Te(ye)), pe.map(ye => Te(ye))]
        }
        return _a(r.value, t.weekStart).map(D => Te(D))
      },
      H = (D, pe) => ke(Pn(be(D)), !1, pe),
      oe = D => {
        const pe = ge();
        return D ? pe : e("update:model-value", ge())
      },
      Ce = (D = !1) => (D || de(), t.monthPicker ? H(C, D) : t.timePicker ? H(v, D) : t.yearPicker ? H(Xe, D) : t.weekPicker ? oe(D) : ke(Y(D), !0, D));
    return {
      inputValue: c,
      internalModelValue: r,
      checkBeforeEmit: () => r.value ? a.value.enabled ? a.value.partialRange ? r.value.length >= 1 : r.value.length === 2 : !!r.value : !1,
      parseExternalModelValue: Q,
      formatInputValue: de,
      emitModelValue: Ce
    }
  },
  EZ = (e, t) => {
    const {
      defaultedFilters: n,
      propDates: r
    } = tn(e), {
      validateMonthYearInRange: s
    } = ti(e), a = (d, f) => {
      let p = d;
      return n.value.months.includes(ft(p)) ? (p = f ? ws(d, 1) : cu(d, 1), a(p, f)) : p
    }, o = (d, f) => {
      let p = d;
      return n.value.years.includes(Xe(p)) ? (p = f ? Lg(d, 1) : _7(d, 1), o(p, f)) : p
    }, i = (d, f = !1) => {
      const p = jt(Te(), {
        month: e.month,
        year: e.year
      });
      let h = d ? ws(p, 1) : cu(p, 1);
      e.disableYearSelect && (h = zs(h, e.year));
      let _ = ft(h),
        v = Xe(h);
      n.value.months.includes(_) && (h = a(h, d), _ = ft(h), v = Xe(h)), n.value.years.includes(v) && (h = o(h, d), v = Xe(h)), s(_, v, d, e.preventMinMaxNavigation) && l(_, v, f)
    }, l = (d, f, p) => {
      t("update-month-year", {
        month: d,
        year: f,
        fromNav: p
      })
    }, c = L(() => d => A7(jt(Te(), {
      month: e.month,
      year: e.year
    }), r.value.maxDate, r.value.minDate, e.preventMinMaxNavigation, d));
    return {
      handleMonthYearChange: i,
      isDisabled: c,
      updateMonthYear: l
    }
  },
  r1 = {
    multiCalendars: {
      type: [Boolean, Number, String, Object],
      default: void 0
    },
    modelValue: {
      type: [String, Date, Array, Object, Number],
      default: null
    },
    modelType: {
      type: String,
      default: null
    },
    position: {
      type: String,
      default: "center"
    },
    dark: {
      type: Boolean,
      default: !1
    },
    format: {
      type: [String, Function],
      default: () => null
    },
    autoPosition: {
      type: [Boolean, String],
      default: !0
    },
    altPosition: {
      type: Function,
      default: null
    },
    transitions: {
      type: [Boolean, Object],
      default: !0
    },
    formatLocale: {
      type: Object,
      default: null
    },
    utc: {
      type: [Boolean, String],
      default: !1
    },
    ariaLabels: {
      type: Object,
      default: () => ({})
    },
    offset: {
      type: [Number, String],
      default: 10
    },
    hideNavigation: {
      type: Array,
      default: () => []
    },
    timezone: {
      type: [String, Object],
      default: null
    },
    vertical: {
      type: Boolean,
      default: !1
    },
    disableMonthYearSelect: {
      type: Boolean,
      default: !1
    },
    disableYearSelect: {
      type: Boolean,
      default: !1
    },
    dayClass: {
      type: Function,
      default: null
    },
    yearRange: {
      type: Array,
      default: () => [1900, 2100]
    },
    enableTimePicker: {
      type: Boolean,
      default: !0
    },
    autoApply: {
      type: Boolean,
      default: !1
    },
    disabledDates: {
      type: [Array, Function],
      default: () => []
    },
    monthNameFormat: {
      type: String,
      default: "short"
    },
    startDate: {
      type: [Date, String],
      default: null
    },
    startTime: {
      type: [Object, Array],
      default: null
    },
    hideOffsetDates: {
      type: Boolean,
      default: !1
    },
    noToday: {
      type: Boolean,
      default: !1
    },
    disabledWeekDays: {
      type: Array,
      default: () => []
    },
    allowedDates: {
      type: Array,
      default: null
    },
    nowButtonLabel: {
      type: String,
      default: "Now"
    },
    markers: {
      type: Array,
      default: () => []
    },
    escClose: {
      type: Boolean,
      default: !0
    },
    spaceConfirm: {
      type: Boolean,
      default: !0
    },
    monthChangeOnArrows: {
      type: Boolean,
      default: !0
    },
    presetDates: {
      type: Array,
      default: () => []
    },
    flow: {
      type: Array,
      default: () => []
    },
    partialFlow: {
      type: Boolean,
      default: !1
    },
    preventMinMaxNavigation: {
      type: Boolean,
      default: !1
    },
    reverseYears: {
      type: Boolean,
      default: !1
    },
    weekPicker: {
      type: Boolean,
      default: !1
    },
    filters: {
      type: Object,
      default: () => ({})
    },
    arrowNavigation: {
      type: Boolean,
      default: !1
    },
    highlight: {
      type: [Function, Object],
      default: null
    },
    teleport: {
      type: [Boolean, String, Object],
      default: null
    },
    teleportCenter: {
      type: Boolean,
      default: !1
    },
    locale: {
      type: String,
      default: "en-Us"
    },
    weekNumName: {
      type: String,
      default: "W"
    },
    weekStart: {
      type: [Number, String],
      default: 1
    },
    weekNumbers: {
      type: [String, Function, Object],
      default: null
    },
    monthChangeOnScroll: {
      type: [Boolean, String],
      default: !0
    },
    dayNames: {
      type: [Function, Array],
      default: null
    },
    monthPicker: {
      type: Boolean,
      default: !1
    },
    customProps: {
      type: Object,
      default: null
    },
    yearPicker: {
      type: Boolean,
      default: !1
    },
    modelAuto: {
      type: Boolean,
      default: !1
    },
    selectText: {
      type: String,
      default: "Select"
    },
    cancelText: {
      type: String,
      default: "Cancel"
    },
    previewFormat: {
      type: [String, Function],
      default: () => ""
    },
    multiDates: {
      type: [Object, Boolean],
      default: !1
    },
    ignoreTimeValidation: {
      type: Boolean,
      default: !1
    },
    minDate: {
      type: [Date, String],
      default: null
    },
    maxDate: {
      type: [Date, String],
      default: null
    },
    minTime: {
      type: Object,
      default: null
    },
    maxTime: {
      type: Object,
      default: null
    },
    name: {
      type: String,
      default: null
    },
    placeholder: {
      type: String,
      default: ""
    },
    hideInputIcon: {
      type: Boolean,
      default: !1
    },
    clearable: {
      type: Boolean,
      default: !0
    },
    state: {
      type: Boolean,
      default: null
    },
    required: {
      type: Boolean,
      default: !1
    },
    autocomplete: {
      type: String,
      default: "off"
    },
    timePicker: {
      type: Boolean,
      default: !1
    },
    enableSeconds: {
      type: Boolean,
      default: !1
    },
    is24: {
      type: Boolean,
      default: !0
    },
    noHoursOverlay: {
      type: Boolean,
      default: !1
    },
    noMinutesOverlay: {
      type: Boolean,
      default: !1
    },
    noSecondsOverlay: {
      type: Boolean,
      default: !1
    },
    hoursGridIncrement: {
      type: [String, Number],
      default: 1
    },
    minutesGridIncrement: {
      type: [String, Number],
      default: 5
    },
    secondsGridIncrement: {
      type: [String, Number],
      default: 5
    },
    hoursIncrement: {
      type: [Number, String],
      default: 1
    },
    minutesIncrement: {
      type: [Number, String],
      default: 1
    },
    secondsIncrement: {
      type: [Number, String],
      default: 1
    },
    range: {
      type: [Boolean, Object],
      default: !1
    },
    uid: {
      type: String,
      default: null
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    readonly: {
      type: Boolean,
      default: !1
    },
    inline: {
      type: [Boolean, Object],
      default: !1
    },
    textInput: {
      type: [Boolean, Object],
      default: !1
    },
    sixWeeks: {
      type: [Boolean, String],
      default: !1
    },
    actionRow: {
      type: Object,
      default: () => ({})
    },
    focusStartDate: {
      type: Boolean,
      default: !1
    },
    disabledTimes: {
      type: [Function, Array],
      default: void 0
    },
    timePickerInline: {
      type: Boolean,
      default: !1
    },
    calendar: {
      type: Function,
      default: null
    },
    config: {
      type: Object,
      default: void 0
    },
    quarterPicker: {
      type: Boolean,
      default: !1
    },
    yearFirst: {
      type: Boolean,
      default: !1
    },
    loading: {
      type: Boolean,
      default: !1
    },
    onInternalModelChange: {
      type: [Function, Object],
      default: null
    },
    enableMinutes: {
      type: Boolean,
      default: !0
    },
    ui: {
      type: Object,
      default: () => ({})
    }
  },
  Is = {
    ...r1,
    shadow: {
      type: Boolean,
      default: !1
    },
    flowStep: {
      type: Number,
      default: 0
    },
    internalModelValue: {
      type: [Date, Array],
      default: null
    },
    noOverlayFocus: {
      type: Boolean,
      default: !1
    },
    collapse: {
      type: Boolean,
      default: !1
    },
    menuWrapRef: {
      type: Object,
      default: null
    },
    getInputRect: {
      type: Function,
      default: () => ({})
    },
    isTextInputDate: {
      type: Boolean,
      default: !1
    },
    isMobile: {
      type: Boolean,
      default: void 0
    }
  },
  TZ = ["title"],
  AZ = ["disabled"],
  PZ = te({
    compatConfig: {
      MODE: 3
    },
    __name: "ActionRow",
    props: {
      menuMount: {
        type: Boolean,
        default: !1
      },
      calendarWidth: {
        type: Number,
        default: 0
      },
      ...Is
    },
    emits: ["close-picker", "select-date", "select-now", "invalid-select"],
    setup(e, {
      emit: t
    }) {
      const n = t,
        r = e,
        {
          defaultedActionRow: s,
          defaultedPreviewFormat: a,
          defaultedMultiCalendars: o,
          defaultedTextInput: i,
          defaultedInline: l,
          defaultedRange: c,
          defaultedMultiDates: d
        } = tn(r),
        {
          isTimeValid: f,
          isMonthValid: p
        } = ti(r),
        {
          buildMatrix: h
        } = ei(),
        _ = U(null),
        v = U(null),
        C = U(!1),
        y = U({}),
        b = U(null),
        w = U(null);
      Ge(() => {
        r.arrowNavigation && h([Sn(_), Sn(v)], "actionRow"), x(), window.addEventListener("resize", x)
      }), en(() => {
        window.removeEventListener("resize", x)
      });
      const x = () => {
          C.value = !1, setTimeout(() => {
            var Q, re;
            const J = (Q = b.value) == null ? void 0 : Q.getBoundingClientRect(),
              ee = (re = w.value) == null ? void 0 : re.getBoundingClientRect();
            J && ee && (y.value.maxWidth = `${ee.width-J.width-20}px`), C.value = !0
          }, 0)
        },
        E = L(() => c.value.enabled && !c.value.partialRange && r.internalModelValue ? r.internalModelValue.length === 2 : !0),
        S = L(() => !f.value(r.internalModelValue) || !p.value(r.internalModelValue) || !E.value),
        T = () => {
          const Q = a.value;
          return r.timePicker || r.monthPicker, Q(Pn(r.internalModelValue))
        },
        j = () => {
          const Q = r.internalModelValue;
          return o.value.count > 0 ? `${P(Q[0])} - ${P(Q[1])}` : [P(Q[0]), P(Q[1])]
        },
        P = Q => P7(Q, a.value, r.formatLocale, i.value.rangeSeparator, r.modelAuto, a.value),
        N = L(() => !r.internalModelValue || !r.menuMount ? "" : typeof a.value == "string" ? Array.isArray(r.internalModelValue) ? r.internalModelValue.length === 2 && r.internalModelValue[1] ? j() : d.value.enabled ? r.internalModelValue.map(Q => `${P(Q)}`) : r.modelAuto ? `${P(r.internalModelValue[0])}` : `${P(r.internalModelValue[0])} -` : P(r.internalModelValue) : T()),
        ne = () => d.value.enabled ? "; " : " - ",
        Y = L(() => Array.isArray(N.value) ? N.value.join(ne()) : N.value),
        _e = () => {
          f.value(r.internalModelValue) && p.value(r.internalModelValue) && E.value ? n("select-date") : n("invalid-select")
        };
      return (Q, re) => (g(), k("div", {
        ref_key: "actionRowRef",
        ref: w,
        class: "dp__action_row"
      }, [Q.$slots["action-row"] ? ie(Q.$slots, "action-row", Nt(Le({
        key: 0
      }, {
        internalModelValue: Q.internalModelValue,
        disabled: S.value,
        selectDate: () => Q.$emit("select-date"),
        closePicker: () => Q.$emit("close-picker")
      }))) : (g(), k(Ee, {
        key: 1
      }, [u(s).showPreview ? (g(), k("div", {
        key: 0,
        class: "dp__selection_preview",
        title: Y.value,
        style: Mt(y.value)
      }, [Q.$slots["action-preview"] && C.value ? ie(Q.$slots, "action-preview", {
        key: 0,
        value: Q.internalModelValue
      }) : z("", !0), !Q.$slots["action-preview"] && C.value ? (g(), k(Ee, {
        key: 1
      }, [Ye(R(Y.value), 1)], 64)) : z("", !0)], 12, TZ)) : z("", !0), m("div", {
        ref_key: "actionBtnContainer",
        ref: b,
        class: "dp__action_buttons",
        "data-dp-element": "action-row"
      }, [Q.$slots["action-buttons"] ? ie(Q.$slots, "action-buttons", {
        key: 0,
        value: Q.internalModelValue
      }) : z("", !0), Q.$slots["action-buttons"] ? z("", !0) : (g(), k(Ee, {
        key: 1
      }, [!u(l).enabled && u(s).showCancel ? (g(), k("button", {
        key: 0,
        ref_key: "cancelButtonRef",
        ref: _,
        type: "button",
        class: "dp__action_button dp__action_cancel",
        onClick: re[0] || (re[0] = J => Q.$emit("close-picker")),
        onKeydown: re[1] || (re[1] = J => u(ur)(J, () => Q.$emit("close-picker")))
      }, R(Q.cancelText), 545)) : z("", !0), u(s).showNow ? (g(), k("button", {
        key: 1,
        type: "button",
        class: "dp__action_button dp__action_cancel",
        onClick: re[2] || (re[2] = J => Q.$emit("select-now")),
        onKeydown: re[3] || (re[3] = J => u(ur)(J, () => Q.$emit("select-now")))
      }, R(Q.nowButtonLabel), 33)) : z("", !0), u(s).showSelect ? (g(), k("button", {
        key: 2,
        ref_key: "selectButtonRef",
        ref: v,
        type: "button",
        class: "dp__action_button dp__action_select",
        disabled: S.value,
        "data-test-id": "select-button",
        onKeydown: re[4] || (re[4] = J => u(ur)(J, () => _e())),
        onClick: _e
      }, R(Q.selectText), 41, AZ)) : z("", !0)], 64))], 512)], 64))], 512))
    }
  }),
  IZ = ["role", "aria-label", "tabindex"],
  $Z = {
    class: "dp__selection_grid_header"
  },
  MZ = ["aria-selected", "aria-disabled", "data-test-id", "onClick", "onKeydown", "onMouseover"],
  OZ = ["aria-label"],
  Cd = te({
    __name: "SelectionOverlay",
    props: {
      items: {},
      type: {},
      isLast: {
        type: Boolean
      },
      arrowNavigation: {
        type: Boolean
      },
      skipButtonRef: {
        type: Boolean
      },
      headerRefs: {},
      hideNavigation: {},
      escClose: {
        type: Boolean
      },
      useRelative: {
        type: Boolean
      },
      height: {},
      textInput: {
        type: [Boolean, Object]
      },
      config: {},
      noOverlayFocus: {
        type: Boolean
      },
      focusValue: {},
      menuWrapRef: {},
      ariaLabels: {},
      overlayLabel: {}
    },
    emits: ["selected", "toggle", "reset-flow", "hover-value"],
    setup(e, {
      expose: t,
      emit: n
    }) {
      const {
        setSelectionGrid: r,
        buildMultiLevelMatrix: s,
        setMonthPicker: a
      } = ei(), o = n, i = e, {
        defaultedAriaLabels: l,
        defaultedTextInput: c,
        defaultedConfig: d
      } = tn(i), {
        hideNavigationButtons: f
      } = o1(), p = U(!1), h = U(null), _ = U(null), v = U([]), C = U(), y = U(null), b = U(0), w = U(null);
      f0(() => {
        h.value = null
      }), Ge(() => {
        Ot().then(() => ne()), i.noOverlayFocus || E(), x(!0)
      }), en(() => x(!1));
      const x = be => {
          var ge;
          i.arrowNavigation && ((ge = i.headerRefs) != null && ge.length ? a(be) : r(be))
        },
        E = () => {
          var be;
          const ge = Sn(_);
          ge && (c.value.enabled || (h.value ? (be = h.value) == null || be.focus({
            preventScroll: !0
          }) : ge.focus({
            preventScroll: !0
          })), p.value = ge.clientHeight < ge.scrollHeight)
        },
        S = L(() => ({
          dp__overlay: !0,
          "dp--overlay-absolute": !i.useRelative,
          "dp--overlay-relative": i.useRelative
        })),
        T = L(() => i.useRelative ? {
          height: `${i.height}px`,
          width: "var(--dp-menu-min-width)"
        } : void 0),
        j = L(() => ({
          dp__overlay_col: !0
        })),
        P = L(() => ({
          dp__btn: !0,
          dp__button: !0,
          dp__overlay_action: !0,
          dp__over_action_scroll: p.value,
          dp__button_bottom: i.isLast
        })),
        N = L(() => {
          var be, ge;
          return {
            dp__overlay_container: !0,
            dp__container_flex: ((be = i.items) == null ? void 0 : be.length) <= 6,
            dp__container_block: ((ge = i.items) == null ? void 0 : ge.length) > 6
          }
        });
      Ne(() => i.items, () => ne(!1), {
        deep: !0
      });
      const ne = (be = !0) => {
          Ot().then(() => {
            const ge = Sn(h),
              H = Sn(_),
              oe = Sn(y),
              Ce = Sn(w),
              D = oe ? oe.getBoundingClientRect().height : 0;
            H && (H.getBoundingClientRect().height ? b.value = H.getBoundingClientRect().height - D : b.value = d.value.modeHeight - D), ge && Ce && be && (Ce.scrollTop = ge.offsetTop - Ce.offsetTop - (b.value / 2 - ge.getBoundingClientRect().height) - D)
          })
        },
        Y = be => {
          be.disabled || o("selected", be.value)
        },
        _e = () => {
          o("toggle"), o("reset-flow")
        },
        Q = () => {
          i.escClose && _e()
        },
        re = (be, ge, H, oe) => {
          be && ((ge.active || ge.value === i.focusValue) && (h.value = be), i.arrowNavigation && (Array.isArray(v.value[H]) ? v.value[H][oe] = be : v.value[H] = [be], J()))
        },
        J = () => {
          var be, ge;
          const H = (be = i.headerRefs) != null && be.length ? [i.headerRefs].concat(v.value) : v.value.concat([i.skipButtonRef ? [] : [y.value]]);
          s(Pn(H), (ge = i.headerRefs) != null && ge.length ? "monthPicker" : "selectionGrid")
        },
        ee = be => {
          i.arrowNavigation || $o(be, d.value, !0)
        },
        de = be => {
          C.value = be, o("hover-value", be)
        },
        se = () => {
          if (_e(), !i.isLast) {
            const be = Km(i.menuWrapRef ?? null, "action-row");
            if (be) {
              const ge = C7(be);
              ge == null || ge.focus()
            }
          }
        },
        ae = be => {
          switch (be.key) {
            case Gt.esc:
              return Q();
            case Gt.arrowLeft:
              return ee(be);
            case Gt.arrowRight:
              return ee(be);
            case Gt.arrowUp:
              return ee(be);
            case Gt.arrowDown:
              return ee(be);
            default:
              return
          }
        },
        ke = be => {
          if (be.key === Gt.enter) return _e();
          if (be.key === Gt.tab) return se()
        };
      return t({
        focusGrid: E
      }), (be, ge) => {
        var H;
        return g(), k("div", {
          ref_key: "gridWrapRef",
          ref: _,
          class: we(S.value),
          style: Mt(T.value),
          role: be.useRelative ? void 0 : "dialog",
          "aria-label": be.overlayLabel,
          tabindex: be.useRelative ? void 0 : "0",
          onKeydown: ae,
          onClick: ge[0] || (ge[0] = Er(() => {}, ["prevent"]))
        }, [m("div", {
          ref_key: "containerRef",
          ref: w,
          class: we(N.value),
          style: Mt({
            "--dp-overlay-height": `${b.value}px`
          }),
          role: "grid"
        }, [m("div", $Z, [ie(be.$slots, "header")]), be.$slots.overlay ? ie(be.$slots, "overlay", {
          key: 0
        }) : (g(!0), k(Ee, {
          key: 1
        }, Je(be.items, (oe, Ce) => (g(), k("div", {
          key: Ce,
          class: we(["dp__overlay_row", {
            dp__flex_row: be.items.length >= 3
          }]),
          role: "row"
        }, [(g(!0), k(Ee, null, Je(oe, (D, pe) => (g(), k("div", {
          key: D.value,
          ref_for: !0,
          ref: ye => re(ye, D, Ce, pe),
          role: "gridcell",
          class: we(j.value),
          "aria-selected": D.active || void 0,
          "aria-disabled": D.disabled || void 0,
          tabindex: "0",
          "data-test-id": D.text,
          onClick: Er(ye => Y(D), ["prevent"]),
          onKeydown: ye => u(ur)(ye, () => Y(D), !0),
          onMouseover: ye => de(D.value)
        }, [m("div", {
          class: we(D.className)
        }, [be.$slots.item ? ie(be.$slots, "item", {
          key: 0,
          item: D
        }) : z("", !0), be.$slots.item ? z("", !0) : (g(), k(Ee, {
          key: 1
        }, [Ye(R(D.text), 1)], 64))], 2)], 42, MZ))), 128))], 2))), 128))], 6), be.$slots["button-icon"] ? Tn((g(), k("button", {
          key: 0,
          ref_key: "toggleButton",
          ref: y,
          type: "button",
          "aria-label": (H = u(l)) == null ? void 0 : H.toggleOverlay,
          class: we(P.value),
          tabindex: "0",
          onClick: _e,
          onKeydown: ke
        }, [ie(be.$slots, "button-icon")], 42, OZ)), [
          [wl, !u(f)(be.hideNavigation, be.type)]
        ]) : z("", !0)], 46, IZ)
      }
    }
  }),
  DZ = ["data-dp-mobile"],
  s1 = te({
    __name: "InstanceWrap",
    props: {
      multiCalendars: {},
      stretch: {
        type: Boolean
      },
      collapse: {
        type: Boolean
      },
      isMobile: {
        type: Boolean
      }
    },
    setup(e) {
      const t = e,
        n = L(() => t.multiCalendars > 0 ? [...Array(t.multiCalendars).keys()] : [0]),
        r = L(() => ({
          dp__instance_calendar: t.multiCalendars > 0
        }));
      return (s, a) => (g(), k("div", {
        class: we({
          dp__menu_inner: !s.stretch,
          "dp--menu--inner-stretched": s.stretch,
          dp__flex_display: s.multiCalendars > 0,
          "dp--flex-display-collapsed": s.collapse
        }),
        "data-dp-mobile": s.isMobile
      }, [(g(!0), k(Ee, null, Je(n.value, (o, i) => (g(), k("div", {
        key: o,
        class: we(r.value)
      }, [ie(s.$slots, "default", {
        instance: o,
        index: i
      })], 2))), 128))], 10, DZ))
    }
  }),
  LZ = ["data-dp-element", "aria-label", "aria-disabled"],
  pc = te({
    compatConfig: {
      MODE: 3
    },
    __name: "ArrowBtn",
    props: {
      ariaLabel: {},
      elName: {},
      disabled: {
        type: Boolean
      }
    },
    emits: ["activate", "set-ref"],
    setup(e, {
      emit: t
    }) {
      const n = t,
        r = U(null);
      return Ge(() => n("set-ref", r)), (s, a) => (g(), k("button", {
        ref_key: "elRef",
        ref: r,
        type: "button",
        "data-dp-element": s.elName,
        class: "dp__btn dp--arrow-btn-nav",
        tabindex: "0",
        "aria-label": s.ariaLabel,
        "aria-disabled": s.disabled || void 0,
        onClick: a[0] || (a[0] = o => s.$emit("activate")),
        onKeydown: a[1] || (a[1] = o => u(ur)(o, () => s.$emit("activate"), !0))
      }, [m("span", {
        class: we(["dp__inner_nav", {
          dp__inner_nav_disabled: s.disabled
        }])
      }, [ie(s.$slots, "default")], 2)], 40, LZ))
    }
  }),
  RZ = ["aria-label", "data-test-id"],
  O7 = te({
    __name: "YearModePicker",
    props: {
      ...Is,
      showYearPicker: {
        type: Boolean,
        default: !1
      },
      items: {
        type: Array,
        default: () => []
      },
      instance: {
        type: Number,
        default: 0
      },
      year: {
        type: Number,
        default: 0
      },
      isDisabled: {
        type: Function,
        default: () => !1
      }
    },
    emits: ["toggle-year-picker", "year-select", "handle-year"],
    setup(e, {
      emit: t
    }) {
      const n = t,
        r = e,
        {
          showRightIcon: s,
          showLeftIcon: a
        } = o1(),
        {
          defaultedConfig: o,
          defaultedMultiCalendars: i,
          defaultedAriaLabels: l,
          defaultedTransitions: c,
          defaultedUI: d
        } = tn(r),
        {
          showTransition: f,
          transitionName: p
        } = xd(c),
        h = U(!1),
        _ = (y = !1, b) => {
          h.value = !h.value, n("toggle-year-picker", {
            flow: y,
            show: b
          })
        },
        v = y => {
          h.value = !1, n("year-select", y)
        },
        C = (y = !1) => {
          n("handle-year", y)
        };
      return (y, b) => {
        var w, x, E, S, T;
        return g(), k(Ee, null, [m("div", {
          class: we(["dp--year-mode-picker", {
            "dp--hidden-el": h.value
          }])
        }, [u(a)(u(i), e.instance) ? (g(), G(pc, {
          key: 0,
          ref: "mpPrevIconRef",
          "aria-label": (w = u(l)) == null ? void 0 : w.prevYear,
          disabled: e.isDisabled(!1),
          class: we((x = u(d)) == null ? void 0 : x.navBtnPrev),
          onActivate: b[0] || (b[0] = j => C(!1))
        }, {
          default: V(() => [y.$slots["arrow-left"] ? ie(y.$slots, "arrow-left", {
            key: 0
          }) : z("", !0), y.$slots["arrow-left"] ? z("", !0) : (g(), G(u(Hg), {
            key: 1
          }))]),
          _: 3
        }, 8, ["aria-label", "disabled", "class"])) : z("", !0), m("button", {
          ref: "mpYearButtonRef",
          class: "dp__btn dp--year-select",
          type: "button",
          "aria-label": `${e.year}-${(E=u(l))==null?void 0:E.openYearsOverlay}`,
          "data-test-id": `year-mode-btn-${e.instance}`,
          onClick: b[1] || (b[1] = () => _(!1)),
          onKeydown: b[2] || (b[2] = Z5(() => _(!1), ["enter"]))
        }, [y.$slots.year ? ie(y.$slots, "year", {
          key: 0,
          year: e.year
        }) : z("", !0), y.$slots.year ? z("", !0) : (g(), k(Ee, {
          key: 1
        }, [Ye(R(e.year), 1)], 64))], 40, RZ), u(s)(u(i), e.instance) ? (g(), G(pc, {
          key: 1,
          ref: "mpNextIconRef",
          "aria-label": (S = u(l)) == null ? void 0 : S.nextYear,
          disabled: e.isDisabled(!0),
          class: we((T = u(d)) == null ? void 0 : T.navBtnNext),
          onActivate: b[3] || (b[3] = j => C(!0))
        }, {
          default: V(() => [y.$slots["arrow-right"] ? ie(y.$slots, "arrow-right", {
            key: 0
          }) : z("", !0), y.$slots["arrow-right"] ? z("", !0) : (g(), G(u(Vg), {
            key: 1
          }))]),
          _: 3
        }, 8, ["aria-label", "disabled", "class"])) : z("", !0)], 2), $(zi, {
          name: u(p)(e.showYearPicker),
          css: u(f)
        }, {
          default: V(() => {
            var j, P;
            return [e.showYearPicker ? (g(), G(Cd, {
              key: 0,
              items: e.items,
              "text-input": y.textInput,
              "esc-close": y.escClose,
              config: y.config,
              "is-last": y.autoApply && !u(o).keepActionRow,
              "hide-navigation": y.hideNavigation,
              "aria-labels": y.ariaLabels,
              "overlay-label": (P = (j = u(l)) == null ? void 0 : j.yearPicker) == null ? void 0 : P.call(j, !0),
              type: "year",
              onToggle: _,
              onSelected: b[4] || (b[4] = N => v(N))
            }, Qn({
              "button-icon": V(() => [y.$slots["calendar-icon"] ? ie(y.$slots, "calendar-icon", {
                key: 0
              }) : z("", !0), y.$slots["calendar-icon"] ? z("", !0) : (g(), G(u(Du), {
                key: 1
              }))]),
              _: 2
            }, [y.$slots["year-overlay-value"] ? {
              name: "item",
              fn: V(({
                item: N
              }) => [ie(y.$slots, "year-overlay-value", {
                text: N.text,
                value: N.value
              })]),
              key: "0"
            } : void 0]), 1032, ["items", "text-input", "esc-close", "config", "is-last", "hide-navigation", "aria-labels", "overlay-label"])) : z("", !0)]
          }),
          _: 3
        }, 8, ["name", "css"])], 64)
      }
    }
  }),
  Zg = (e, t, n) => {
    if (t.value && Array.isArray(t.value))
      if (t.value.some(r => mt(e, r))) {
        const r = t.value.filter(s => !mt(s, e));
        t.value = r.length ? r : null
      } else(n && +n > t.value.length || !n) && t.value.push(e);
    else t.value = [e]
  },
  Jg = (e, t, n) => {
    let r = e.value ? e.value.slice() : [];
    return r.length === 2 && r[1] !== null && (r = []), r.length ? (on(t, r[0]) ? r.unshift(t) : r[1] = t, n("range-end", t)) : (r = [t], n("range-start", t)), r
  },
  a1 = (e, t, n, r) => {
    e && (e[0] && e[1] && n && t("auto-apply"), e[0] && !e[1] && r && n && t("auto-apply"))
  },
  D7 = e => {
    Array.isArray(e.value) && e.value.length <= 2 && e.range ? e.modelValue.value = e.value.map(t => Ir(Te(t), e.timezone)) : Array.isArray(e.value) || (e.modelValue.value = Ir(Te(e.value), e.timezone))
  },
  L7 = (e, t, n, r) => Array.isArray(t.value) && (t.value.length === 2 || t.value.length === 1 && r.value.partialRange) ? r.value.fixedStart && (fn(e, t.value[0]) || mt(e, t.value[0])) ? [t.value[0], e] : r.value.fixedEnd && (on(e, t.value[1]) || mt(e, t.value[1])) ? [e, t.value[1]] : (n("invalid-fixed-range", e), t.value) : [],
  R7 = ({
    multiCalendars: e,
    range: t,
    highlight: n,
    propDates: r,
    calendars: s,
    modelValue: a,
    props: o,
    filters: i,
    year: l,
    month: c,
    emit: d
  }) => {
    const f = L(() => Gg(o.yearRange, o.locale, o.reverseYears)),
      p = U([!1]),
      h = L(() => (N, ne) => {
        const Y = jt(_s(new Date), {
            month: c.value(N),
            year: l.value(N)
          }),
          _e = ne ? a7(Y) : Hc(Y);
        return A7(_e, r.value.maxDate, r.value.minDate, o.preventMinMaxNavigation, ne)
      }),
      _ = () => Array.isArray(a.value) && e.value.solo && a.value[1],
      v = () => {
        for (let N = 0; N < e.value.count; N++)
          if (N === 0) s.value[N] = s.value[0];
          else if (N === e.value.count - 1 && _()) s.value[N] = {
          month: ft(a.value[1]),
          year: Xe(a.value[1])
        };
        else {
          const ne = jt(Te(), s.value[N - 1]);
          s.value[N] = {
            month: ft(ne),
            year: Xe(Lg(ne, 1))
          }
        }
      },
      C = N => {
        if (!N) return v();
        const ne = jt(Te(), s.value[N]);
        return s.value[0].year = Xe(_7(ne, e.value.count - 1)), v()
      },
      y = (N, ne) => {
        const Y = WQ(ne, N);
        return t.value.showLastInRange && Y > 1 ? ne : N
      },
      b = N => o.focusStartDate || e.value.solo ? N[0] : N[1] ? y(N[0], N[1]) : N[0],
      w = () => {
        if (a.value) {
          const N = Array.isArray(a.value) ? b(a.value) : a.value;
          s.value[0] = {
            month: ft(N),
            year: Xe(N)
          }
        }
      },
      x = () => {
        w(), e.value.count && v()
      };
    Ne(a, (N, ne) => {
      o.isTextInputDate && JSON.stringify(N ?? {}) !== JSON.stringify(ne ?? {}) && x()
    }), Ge(() => {
      x()
    });
    const E = (N, ne) => {
        s.value[ne].year = N, d("update-month-year", {
          instance: ne,
          year: N,
          month: s.value[ne].month
        }), e.value.count && !e.value.solo && C(ne)
      },
      S = L(() => N => du(f.value, ne => {
        var Y;
        const _e = l.value(N) === ne.value,
          Q = Uc(ne.value, fu(r.value.minDate), fu(r.value.maxDate)) || ((Y = i.value.years) == null ? void 0 : Y.includes(l.value(N))),
          re = Kg(n.value, ne.value);
        return {
          active: _e,
          disabled: Q,
          highlighted: re
        }
      })),
      T = (N, ne) => {
        E(N, ne), P(ne)
      },
      j = (N, ne = !1) => {
        if (!h.value(N, ne)) {
          const Y = ne ? l.value(N) + 1 : l.value(N) - 1;
          E(Y, N)
        }
      },
      P = (N, ne = !1, Y) => {
        ne || d("reset-flow"), Y !== void 0 ? p.value[N] = Y : p.value[N] = !p.value[N], p.value[N] ? d("overlay-toggle", {
          open: !0,
          overlay: Yn.year
        }) : (d("overlay-closed"), d("overlay-toggle", {
          open: !1,
          overlay: Yn.year
        }))
      };
    return {
      isDisabled: h,
      groupedYears: S,
      showYearPicker: p,
      selectYear: E,
      toggleYearPicker: P,
      handleYearSelect: T,
      handleYear: j
    }
  },
  NZ = (e, t) => {
    const {
      defaultedMultiCalendars: n,
      defaultedAriaLabels: r,
      defaultedTransitions: s,
      defaultedConfig: a,
      defaultedRange: o,
      defaultedHighlight: i,
      propDates: l,
      defaultedTz: c,
      defaultedFilters: d,
      defaultedMultiDates: f
    } = tn(e), p = () => {
      e.isTextInputDate && x(Xe(Te(e.startDate)), 0)
    }, {
      modelValue: h,
      year: _,
      month: v,
      calendars: C
    } = kd(e, t, p), y = L(() => b7(e.formatLocale, e.locale, e.monthNameFormat)), b = U(null), {
      checkMinMaxRange: w
    } = ti(e), {
      selectYear: x,
      groupedYears: E,
      showYearPicker: S,
      toggleYearPicker: T,
      handleYearSelect: j,
      handleYear: P,
      isDisabled: N
    } = R7({
      modelValue: h,
      multiCalendars: n,
      range: o,
      highlight: i,
      calendars: C,
      year: _,
      propDates: l,
      month: v,
      filters: d,
      props: e,
      emit: t
    });
    Ge(() => {
      e.startDate && (h.value && e.focusStartDate || !h.value) && x(Xe(Te(e.startDate)), 0)
    });
    const ne = H => H ? {
        month: ft(H),
        year: Xe(H)
      } : {
        month: null,
        year: null
      },
      Y = () => h.value ? Array.isArray(h.value) ? h.value.map(H => ne(H)) : ne(h.value) : ne(),
      _e = (H, oe) => {
        const Ce = C.value[H],
          D = Y();
        return Array.isArray(D) ? D.some(pe => pe.year === (Ce == null ? void 0 : Ce.year) && pe.month === oe) : (Ce == null ? void 0 : Ce.year) === D.year && oe === D.month
      },
      Q = (H, oe, Ce) => {
        var D, pe;
        const ye = Y();
        return Array.isArray(ye) ? _.value(oe) === ((D = ye[Ce]) == null ? void 0 : D.year) && H === ((pe = ye[Ce]) == null ? void 0 : pe.month) : !1
      },
      re = (H, oe) => {
        if (o.value.enabled) {
          const Ce = Y();
          if (Array.isArray(h.value) && Array.isArray(Ce)) {
            const D = Q(H, oe, 0) || Q(H, oe, 1),
              pe = Pa(_s(Te()), H, _.value(oe));
            return n1(h.value, b.value, pe) && !D
          }
          return !1
        }
        return !1
      },
      J = L(() => H => du(y.value, oe => {
        var Ce;
        const D = _e(H, oe.value),
          pe = Uc(oe.value, k7(_.value(H), l.value.minDate), S7(_.value(H), l.value.maxDate)) || oZ(l.value.disabledDates, _.value(H)).includes(oe.value) || ((Ce = d.value.months) == null ? void 0 : Ce.includes(oe.value)) || !iZ(l.value.allowedDates, _.value(H), oe.value),
          ye = re(oe.value, H),
          Ae = I7(i.value, oe.value, _.value(H));
        return {
          active: D,
          disabled: pe,
          isBetween: ye,
          highlighted: Ae
        }
      })),
      ee = (H, oe) => Pa(_s(Te()), H, _.value(oe)),
      de = (H, oe) => {
        const Ce = h.value ? h.value : _s(new Date);
        h.value = Pa(Ce, H, _.value(oe)), t("auto-apply"), t("update-flow-step")
      },
      se = (H, oe) => {
        const Ce = ee(H, oe);
        o.value.fixedEnd || o.value.fixedStart ? h.value = L7(Ce, h, t, o) : h.value ? w(Ce, h.value) && (h.value = Jg(h, ee(H, oe), t)) : h.value = [ee(H, oe)], Ot().then(() => {
          a1(h.value, t, e.autoApply, e.modelAuto)
        })
      },
      ae = (H, oe) => {
        Zg(ee(H, oe), h, f.value.limit), t("auto-apply", !0)
      },
      ke = (H, oe) => (C.value[oe].month = H, ge(oe, C.value[oe].year, H), f.value.enabled ? ae(H, oe) : o.value.enabled ? se(H, oe) : de(H, oe)),
      be = (H, oe) => {
        x(H, oe), ge(oe, H, null)
      },
      ge = (H, oe, Ce) => {
        let D = Ce;
        if (!D && D !== 0) {
          const pe = Y();
          D = Array.isArray(pe) ? pe[H].month : pe.month
        }
        t("update-month-year", {
          instance: H,
          year: oe,
          month: D
        })
      };
    return {
      groupedMonths: J,
      groupedYears: E,
      year: _,
      isDisabled: N,
      defaultedMultiCalendars: n,
      defaultedAriaLabels: r,
      defaultedTransitions: s,
      defaultedConfig: a,
      showYearPicker: S,
      modelValue: h,
      presetDate: (H, oe) => {
        D7({
          value: H,
          modelValue: h,
          range: o.value.enabled,
          timezone: oe ? void 0 : c.value.timezone
        }), t("auto-apply")
      },
      setHoverDate: (H, oe) => {
        b.value = ee(H, oe)
      },
      selectMonth: ke,
      selectYear: be,
      toggleYearPicker: T,
      handleYearSelect: j,
      handleYear: P,
      getModelMonthYear: Y
    }
  },
  FZ = te({
    compatConfig: {
      MODE: 3
    },
    __name: "MonthPicker",
    props: {
      ...Is
    },
    emits: ["update:internal-model-value", "overlay-closed", "reset-flow", "range-start", "range-end", "auto-apply", "update-month-year", "update-flow-step", "mount", "invalid-fixed-range", "overlay-toggle"],
    setup(e, {
      expose: t,
      emit: n
    }) {
      const r = n,
        s = zo(),
        a = Fr(s, "yearMode"),
        o = e;
      Ge(() => {
        o.shadow || r("mount", null)
      });
      const {
        groupedMonths: i,
        groupedYears: l,
        year: c,
        isDisabled: d,
        defaultedMultiCalendars: f,
        defaultedConfig: p,
        showYearPicker: h,
        modelValue: _,
        presetDate: v,
        setHoverDate: C,
        selectMonth: y,
        selectYear: b,
        toggleYearPicker: w,
        handleYearSelect: x,
        handleYear: E,
        getModelMonthYear: S
      } = NZ(o, r);
      return t({
        getSidebarProps: () => ({
          modelValue: _,
          year: c,
          getModelMonthYear: S,
          selectMonth: y,
          selectYear: b,
          handleYear: E
        }),
        presetDate: v,
        toggleYearPicker: T => w(0, T)
      }), (T, j) => (g(), G(s1, {
        "multi-calendars": u(f).count,
        collapse: T.collapse,
        stretch: "",
        "is-mobile": T.isMobile
      }, {
        default: V(({
          instance: P
        }) => [T.$slots["top-extra"] ? ie(T.$slots, "top-extra", {
          key: 0,
          value: T.internalModelValue
        }) : z("", !0), T.$slots["month-year"] ? ie(T.$slots, "month-year", Nt(Le({
          key: 1
        }, {
          year: u(c),
          months: u(i)(P),
          years: u(l)(P),
          selectMonth: u(y),
          selectYear: u(b),
          instance: P
        }))) : (g(), G(Cd, {
          key: 2,
          items: u(i)(P),
          "arrow-navigation": T.arrowNavigation,
          "is-last": T.autoApply && !u(p).keepActionRow,
          "esc-close": T.escClose,
          height: u(p).modeHeight,
          config: T.config,
          "no-overlay-focus": !!(T.noOverlayFocus || T.textInput),
          "use-relative": "",
          type: "month",
          onSelected: N => u(y)(N, P),
          onHoverValue: N => u(C)(N, P)
        }, Qn({
          header: V(() => [$(O7, Le(T.$props, {
            items: u(l)(P),
            instance: P,
            "show-year-picker": u(h)[P],
            year: u(c)(P),
            "is-disabled": N => u(d)(P, N),
            onHandleYear: N => u(E)(P, N),
            onYearSelect: N => u(x)(N, P),
            onToggleYearPicker: N => u(w)(P, N == null ? void 0 : N.flow, N == null ? void 0 : N.show)
          }), Qn({
            _: 2
          }, [Je(u(a), (N, ne) => ({
            name: N,
            fn: V(Y => [ie(T.$slots, N, Nt(Qt(Y)))])
          }))]), 1040, ["items", "instance", "show-year-picker", "year", "is-disabled", "onHandleYear", "onYearSelect", "onToggleYearPicker"])]),
          _: 2
        }, [T.$slots["month-overlay-value"] ? {
          name: "item",
          fn: V(({
            item: N
          }) => [ie(T.$slots, "month-overlay-value", {
            text: N.text,
            value: N.value
          })]),
          key: "0"
        } : void 0]), 1032, ["items", "arrow-navigation", "is-last", "esc-close", "height", "config", "no-overlay-focus", "onSelected", "onHoverValue"]))]),
        _: 3
      }, 8, ["multi-calendars", "collapse", "is-mobile"]))
    }
  }),
  BZ = (e, t) => {
    const n = () => {
        e.isTextInputDate && (d.value = Xe(Te(e.startDate)))
      },
      {
        modelValue: r
      } = kd(e, t, n),
      s = U(null),
      {
        defaultedHighlight: a,
        defaultedMultiDates: o,
        defaultedFilters: i,
        defaultedRange: l,
        propDates: c
      } = tn(e),
      d = U();
    Ge(() => {
      e.startDate && (r.value && e.focusStartDate || !r.value) && (d.value = Xe(Te(e.startDate)))
    });
    const f = v => Array.isArray(r.value) ? r.value.some(C => Xe(C) === v) : r.value ? Xe(r.value) === v : !1,
      p = v => l.value.enabled && Array.isArray(r.value) ? n1(r.value, s.value, _(v)) : !1,
      h = L(() => du(Gg(e.yearRange, e.locale, e.reverseYears), v => {
        const C = f(v.value),
          y = Uc(v.value, fu(c.value.minDate), fu(c.value.maxDate)) || i.value.years.includes(v.value),
          b = p(v.value) && !C,
          w = Kg(a.value, v.value);
        return {
          active: C,
          disabled: y,
          isBetween: b,
          highlighted: w
        }
      })),
      _ = v => zs(_s(Hc(new Date)), v);
    return {
      groupedYears: h,
      modelValue: r,
      focusYear: d,
      setHoverValue: v => {
        s.value = zs(_s(new Date), v)
      },
      selectYear: v => {
        var C;
        if (t("update-month-year", {
            instance: 0,
            year: v
          }), o.value.enabled) return r.value ? Array.isArray(r.value) && (((C = r.value) == null ? void 0 : C.map(y => Xe(y))).includes(v) ? r.value = r.value.filter(y => Xe(y) !== v) : r.value.push(zs(mr(Te()), v))) : r.value = [zs(mr(Hc(Te())), v)], t("auto-apply", !0);
        l.value.enabled ? (r.value = Jg(r, _(v), t), Ot().then(() => {
          a1(r.value, t, e.autoApply, e.modelAuto)
        })) : (r.value = _(v), t("auto-apply"))
      }
    }
  },
  jZ = te({
    compatConfig: {
      MODE: 3
    },
    __name: "YearPicker",
    props: {
      ...Is
    },
    emits: ["update:internal-model-value", "reset-flow", "range-start", "range-end", "auto-apply", "update-month-year"],
    setup(e, {
      expose: t,
      emit: n
    }) {
      const r = n,
        s = e,
        {
          groupedYears: a,
          modelValue: o,
          focusYear: i,
          selectYear: l,
          setHoverValue: c
        } = BZ(s, r),
        {
          defaultedConfig: d
        } = tn(s);
      return t({
        getSidebarProps: () => ({
          modelValue: o,
          selectYear: l
        })
      }), (f, p) => (g(), k("div", null, [f.$slots["top-extra"] ? ie(f.$slots, "top-extra", {
        key: 0,
        value: f.internalModelValue
      }) : z("", !0), f.$slots["month-year"] ? ie(f.$slots, "month-year", Nt(Le({
        key: 1
      }, {
        years: u(a),
        selectYear: u(l)
      }))) : (g(), G(Cd, {
        key: 2,
        items: u(a),
        "is-last": f.autoApply && !u(d).keepActionRow,
        height: u(d).modeHeight,
        config: f.config,
        "no-overlay-focus": !!(f.noOverlayFocus || f.textInput),
        "focus-value": u(i),
        type: "year",
        "use-relative": "",
        onSelected: u(l),
        onHoverValue: u(c)
      }, Qn({
        _: 2
      }, [f.$slots["year-overlay-value"] ? {
        name: "item",
        fn: V(({
          item: h
        }) => [ie(f.$slots, "year-overlay-value", {
          text: h.text,
          value: h.value
        })]),
        key: "0"
      } : void 0]), 1032, ["items", "is-last", "height", "config", "no-overlay-focus", "focus-value", "onSelected", "onHoverValue"]))]))
    }
  }),
  HZ = {
    key: 0,
    class: "dp__time_input"
  },
  VZ = ["data-compact", "data-collapsed"],
  UZ = ["data-test-id", "aria-label", "onKeydown", "onClick", "onMousedown"],
  zZ = ["aria-label", "disabled", "data-test-id", "onKeydown", "onClick"],
  YZ = ["data-test-id", "aria-label", "onKeydown", "onClick", "onMousedown"],
  WZ = {
    key: 0
  },
  GZ = ["aria-label", "data-compact"],
  QZ = te({
    compatConfig: {
      MODE: 3
    },
    __name: "TimeInput",
    props: {
      hours: {
        type: Number,
        default: 0
      },
      minutes: {
        type: Number,
        default: 0
      },
      seconds: {
        type: Number,
        default: 0
      },
      closeTimePickerBtn: {
        type: Object,
        default: null
      },
      order: {
        type: Number,
        default: 0
      },
      disabledTimesConfig: {
        type: Function,
        default: null
      },
      validateTime: {
        type: Function,
        default: () => !1
      },
      ...Is
    },
    emits: ["set-hours", "set-minutes", "update:hours", "update:minutes", "update:seconds", "reset-flow", "mounted", "overlay-closed", "overlay-opened", "am-pm-change"],
    setup(e, {
      expose: t,
      emit: n
    }) {
      const r = n,
        s = e,
        {
          setTimePickerElements: a,
          setTimePickerBackRef: o
        } = ei(),
        {
          defaultedAriaLabels: i,
          defaultedTransitions: l,
          defaultedFilters: c,
          defaultedConfig: d,
          defaultedRange: f,
          defaultedMultiCalendars: p
        } = tn(s),
        {
          transitionName: h,
          showTransition: _
        } = xd(l),
        v = xn({
          hours: !1,
          minutes: !1,
          seconds: !1
        }),
        C = U("AM"),
        y = U(null),
        b = U([]),
        w = U(),
        x = U(!1);
      Ge(() => {
        r("mounted")
      });
      const E = O => jt(new Date, {
          hours: O.hours,
          minutes: O.minutes,
          seconds: s.enableSeconds ? O.seconds : 0,
          milliseconds: 0
        }),
        S = L(() => O => se(O, s[O]) || j(O, s[O])),
        T = L(() => ({
          hours: s.hours,
          minutes: s.minutes,
          seconds: s.seconds
        })),
        j = (O, q) => f.value.enabled && !f.value.disableTimeRangeValidation ? !s.validateTime(O, q) : !1,
        P = (O, q) => {
          if (f.value.enabled && !f.value.disableTimeRangeValidation) {
            const he = q ? +s[`${O}Increment`] : - +s[`${O}Increment`],
              A = s[O] + he;
            return !s.validateTime(O, A)
          }
          return !1
        },
        N = L(() => O => !H(+s[O] + +s[`${O}Increment`], O) || P(O, !0)),
        ne = L(() => O => !H(+s[O] - +s[`${O}Increment`], O) || P(O, !1)),
        Y = (O, q) => X9(jt(Te(), O), q),
        _e = (O, q) => VK(jt(Te(), O), q),
        Q = L(() => ({
          dp__time_col: !0,
          dp__time_col_block: !s.timePickerInline,
          dp__time_col_reg_block: !s.enableSeconds && s.is24 && !s.timePickerInline,
          dp__time_col_reg_inline: !s.enableSeconds && s.is24 && s.timePickerInline,
          dp__time_col_reg_with_button: !s.enableSeconds && !s.is24,
          dp__time_col_sec: s.enableSeconds && s.is24,
          dp__time_col_sec_with_button: s.enableSeconds && !s.is24
        })),
        re = L(() => s.timePickerInline && f.value.enabled && !p.value.count),
        J = L(() => {
          const O = [{
            type: "hours"
          }];
          return s.enableMinutes && O.push({
            type: "",
            separator: !0
          }, {
            type: "minutes"
          }), s.enableSeconds && O.push({
            type: "",
            separator: !0
          }, {
            type: "seconds"
          }), O
        }),
        ee = L(() => J.value.filter(O => !O.separator)),
        de = L(() => O => {
          if (O === "hours") {
            const q = Ae(+s.hours);
            return {
              text: q < 10 ? `0${q}` : `${q}`,
              value: q
            }
          }
          return {
            text: s[O] < 10 ? `0${s[O]}` : `${s[O]}`,
            value: s[O]
          }
        }),
        se = (O, q) => {
          var he;
          if (!s.disabledTimesConfig) return !1;
          const A = s.disabledTimesConfig(s.order, O === "hours" ? q : void 0);
          return A[O] ? !!((he = A[O]) != null && he.includes(q)) : !0
        },
        ae = (O, q) => q !== "hours" || C.value === "AM" ? O : O + 12,
        ke = O => {
          const q = s.is24 ? 24 : 12,
            he = O === "hours" ? q : 60,
            A = +s[`${O}GridIncrement`],
            F = O === "hours" && !s.is24 ? A : 0,
            K = [];
          for (let B = F; B < he; B += A) K.push({
            value: s.is24 ? B : ae(B, O),
            text: B < 10 ? `0${B}` : `${B}`
          });
          return O === "hours" && !s.is24 && K.unshift({
            value: C.value === "PM" ? 12 : 0,
            text: "12"
          }), du(K, B => ({
            active: !1,
            disabled: c.value.times[O].includes(B.value) || !H(B.value, O) || se(O, B.value) || j(O, B.value)
          }))
        },
        be = O => O >= 0 ? O : 59,
        ge = O => O >= 0 ? O : 23,
        H = (O, q) => {
          const he = s.minTime ? E(X1(s.minTime)) : null,
            A = s.maxTime ? E(X1(s.maxTime)) : null,
            F = E(X1(T.value, q, q === "minutes" || q === "seconds" ? be(O) : ge(O)));
          return he && A ? (Vc(F, A) || ml(F, A)) && (uu(F, he) || ml(F, he)) : he ? uu(F, he) || ml(F, he) : A ? Vc(F, A) || ml(F, A) : !0
        },
        oe = O => s[`no${O[0].toUpperCase()+O.slice(1)}Overlay`],
        Ce = O => {
          oe(O) || (v[O] = !v[O], v[O] ? (x.value = !0, r("overlay-opened", O)) : (x.value = !1, r("overlay-closed", O)))
        },
        D = O => O === "hours" ? za : O === "minutes" ? Uo : lu,
        pe = () => {
          w.value && clearTimeout(w.value)
        },
        ye = (O, q = !0, he) => {
          const A = q ? Y : _e,
            F = q ? +s[`${O}Increment`] : - +s[`${O}Increment`];
          H(+s[O] + F, O) && r(`update:${O}`, D(O)(A({
            [O]: +s[O]
          }, {
            [O]: +s[`${O}Increment`]
          }))), !(he != null && he.keyboard) && d.value.timeArrowHoldThreshold && (w.value = setTimeout(() => {
            ye(O, q)
          }, d.value.timeArrowHoldThreshold))
        },
        Ae = O => s.is24 ? O : (O >= 12 ? C.value = "PM" : C.value = "AM", QK(O)),
        fe = () => {
          C.value === "PM" ? (C.value = "AM", r("update:hours", s.hours - 12)) : (C.value = "PM", r("update:hours", s.hours + 12)), r("am-pm-change", C.value)
        },
        I = O => {
          v[O] = !0
        },
        M = (O, q, he) => {
          if (O && s.arrowNavigation) {
            Array.isArray(b.value[q]) ? b.value[q][he] = O : b.value[q] = [O];
            const A = b.value.reduce((F, K) => K.map((B, ce) => [...F[ce] || [], K[ce]]), []);
            o(s.closeTimePickerBtn), y.value && (A[1] = A[1].concat(y.value)), a(A, s.order)
          }
        },
        W = (O, q) => (Ce(O), r(`update:${O}`, q));
      return t({
        openChildCmp: I
      }), (O, q) => {
        var he;
        return O.disabled ? z("", !0) : (g(), k("div", HZ, [(g(!0), k(Ee, null, Je(J.value, (A, F) => {
          var K, B, ce;
          return g(), k("div", {
            key: F,
            class: we(Q.value),
            "data-compact": re.value && !O.enableSeconds,
            "data-collapsed": re.value && O.enableSeconds
          }, [A.separator ? (g(), k(Ee, {
            key: 0
          }, [x.value ? z("", !0) : (g(), k(Ee, {
            key: 0
          }, [Ye(":")], 64))], 64)) : (g(), k(Ee, {
            key: 1
          }, [m("button", {
            ref_for: !0,
            ref: le => M(le, F, 0),
            type: "button",
            class: we({
              dp__btn: !0,
              dp__inc_dec_button: !O.timePickerInline,
              dp__inc_dec_button_inline: O.timePickerInline,
              dp__tp_inline_btn_top: O.timePickerInline,
              dp__inc_dec_button_disabled: N.value(A.type),
              "dp--hidden-el": x.value
            }),
            "data-test-id": `${A.type}-time-inc-btn-${s.order}`,
            "aria-label": (K = u(i)) == null ? void 0 : K.incrementValue(A.type),
            tabindex: "0",
            onKeydown: le => u(ur)(le, () => ye(A.type, !0, {
              keyboard: !0
            }), !0),
            onClick: le => u(d).timeArrowHoldThreshold ? void 0 : ye(A.type, !0),
            onMousedown: le => u(d).timeArrowHoldThreshold ? ye(A.type, !0) : void 0,
            onMouseup: pe
          }, [s.timePickerInline ? (g(), k(Ee, {
            key: 1
          }, [O.$slots["tp-inline-arrow-up"] ? ie(O.$slots, "tp-inline-arrow-up", {
            key: 0
          }) : (g(), k(Ee, {
            key: 1
          }, [q[2] || (q[2] = m("span", {
            class: "dp__tp_inline_btn_bar dp__tp_btn_in_l"
          }, null, -1)), q[3] || (q[3] = m("span", {
            class: "dp__tp_inline_btn_bar dp__tp_btn_in_r"
          }, null, -1))], 64))], 64)) : (g(), k(Ee, {
            key: 0
          }, [O.$slots["arrow-up"] ? ie(O.$slots, "arrow-up", {
            key: 0
          }) : z("", !0), O.$slots["arrow-up"] ? z("", !0) : (g(), G(u(zg), {
            key: 1
          }))], 64))], 42, UZ), m("button", {
            ref_for: !0,
            ref: le => M(le, F, 1),
            type: "button",
            "aria-label": `${de.value(A.type).text}-${(B=u(i))==null?void 0:B.openTpOverlay(A.type)}`,
            class: we({
              dp__time_display: !0,
              dp__time_display_block: !O.timePickerInline,
              dp__time_display_inline: O.timePickerInline,
              "dp--time-invalid": S.value(A.type),
              "dp--time-overlay-btn": !S.value(A.type),
              "dp--hidden-el": x.value
            }),
            disabled: oe(A.type),
            tabindex: "0",
            "data-test-id": `${A.type}-toggle-overlay-btn-${s.order}`,
            onKeydown: le => u(ur)(le, () => Ce(A.type), !0),
            onClick: le => Ce(A.type)
          }, [O.$slots[A.type] ? ie(O.$slots, A.type, {
            key: 0,
            text: de.value(A.type).text,
            value: de.value(A.type).value
          }) : z("", !0), O.$slots[A.type] ? z("", !0) : (g(), k(Ee, {
            key: 1
          }, [Ye(R(de.value(A.type).text), 1)], 64))], 42, zZ), m("button", {
            ref_for: !0,
            ref: le => M(le, F, 2),
            type: "button",
            class: we({
              dp__btn: !0,
              dp__inc_dec_button: !O.timePickerInline,
              dp__inc_dec_button_inline: O.timePickerInline,
              dp__tp_inline_btn_bottom: O.timePickerInline,
              dp__inc_dec_button_disabled: ne.value(A.type),
              "dp--hidden-el": x.value
            }),
            "data-test-id": `${A.type}-time-dec-btn-${s.order}`,
            "aria-label": (ce = u(i)) == null ? void 0 : ce.decrementValue(A.type),
            tabindex: "0",
            onKeydown: le => u(ur)(le, () => ye(A.type, !1, {
              keyboard: !0
            }), !0),
            onClick: le => u(d).timeArrowHoldThreshold ? void 0 : ye(A.type, !1),
            onMousedown: le => u(d).timeArrowHoldThreshold ? ye(A.type, !1) : void 0,
            onMouseup: pe
          }, [s.timePickerInline ? (g(), k(Ee, {
            key: 1
          }, [O.$slots["tp-inline-arrow-down"] ? ie(O.$slots, "tp-inline-arrow-down", {
            key: 0
          }) : (g(), k(Ee, {
            key: 1
          }, [q[4] || (q[4] = m("span", {
            class: "dp__tp_inline_btn_bar dp__tp_btn_in_l"
          }, null, -1)), q[5] || (q[5] = m("span", {
            class: "dp__tp_inline_btn_bar dp__tp_btn_in_r"
          }, null, -1))], 64))], 64)) : (g(), k(Ee, {
            key: 0
          }, [O.$slots["arrow-down"] ? ie(O.$slots, "arrow-down", {
            key: 0
          }) : z("", !0), O.$slots["arrow-down"] ? z("", !0) : (g(), G(u(Yg), {
            key: 1
          }))], 64))], 42, YZ)], 64))], 10, VZ)
        }), 128)), O.is24 ? z("", !0) : (g(), k("div", WZ, [O.$slots["am-pm-button"] ? ie(O.$slots, "am-pm-button", {
          key: 0,
          toggle: fe,
          value: C.value
        }) : z("", !0), O.$slots["am-pm-button"] ? z("", !0) : (g(), k("button", {
          key: 1,
          ref_key: "amPmButton",
          ref: y,
          type: "button",
          class: "dp__pm_am_button",
          role: "button",
          "aria-label": (he = u(i)) == null ? void 0 : he.amPmButton,
          tabindex: "0",
          "data-compact": re.value,
          onClick: fe,
          onKeydown: q[0] || (q[0] = A => u(ur)(A, () => fe(), !0))
        }, R(C.value), 41, GZ))])), (g(!0), k(Ee, null, Je(ee.value, (A, F) => (g(), G(zi, {
          key: F,
          name: u(h)(v[A.type]),
          css: u(_)
        }, {
          default: V(() => {
            var K, B;
            return [v[A.type] ? (g(), G(Cd, {
              key: 0,
              items: ke(A.type),
              "is-last": O.autoApply && !u(d).keepActionRow,
              "esc-close": O.escClose,
              type: A.type,
              "text-input": O.textInput,
              config: O.config,
              "arrow-navigation": O.arrowNavigation,
              "aria-labels": O.ariaLabels,
              "overlay-label": (B = (K = u(i)).timeOverlay) == null ? void 0 : B.call(K, A.type),
              onSelected: ce => W(A.type, ce),
              onToggle: ce => Ce(A.type),
              onResetFlow: q[1] || (q[1] = ce => O.$emit("reset-flow"))
            }, Qn({
              "button-icon": V(() => [O.$slots["clock-icon"] ? ie(O.$slots, "clock-icon", {
                key: 0
              }) : z("", !0), O.$slots["clock-icon"] ? z("", !0) : (g(), G(Kr(O.timePickerInline ? u(Du) : u(Ug)), {
                key: 1
              }))]),
              _: 2
            }, [O.$slots[`${A.type}-overlay-value`] ? {
              name: "item",
              fn: V(({
                item: ce
              }) => [ie(O.$slots, `${A.type}-overlay-value`, {
                text: ce.text,
                value: ce.value
              })]),
              key: "0"
            } : void 0, O.$slots[`${A.type}-overlay-header`] ? {
              name: "header",
              fn: V(() => [ie(O.$slots, `${A.type}-overlay-header`, {
                toggle: () => Ce(A.type)
              })]),
              key: "1"
            } : void 0]), 1032, ["items", "is-last", "esc-close", "type", "text-input", "config", "arrow-navigation", "aria-labels", "overlay-label", "onSelected", "onToggle"])) : z("", !0)]
          }),
          _: 2
        }, 1032, ["name", "css"]))), 128))]))
      }
    }
  }),
  qZ = ["data-dp-mobile"],
  KZ = ["aria-label", "tabindex"],
  ZZ = ["role", "aria-label", "tabindex"],
  JZ = ["aria-label"],
  N7 = te({
    compatConfig: {
      MODE: 3
    },
    __name: "TimePicker",
    props: {
      hours: {
        type: [Number, Array],
        default: 0
      },
      minutes: {
        type: [Number, Array],
        default: 0
      },
      seconds: {
        type: [Number, Array],
        default: 0
      },
      disabledTimesConfig: {
        type: Function,
        default: null
      },
      validateTime: {
        type: Function,
        default: () => !1
      },
      ...Is
    },
    emits: ["update:hours", "update:minutes", "update:seconds", "mount", "reset-flow", "overlay-opened", "overlay-closed", "am-pm-change"],
    setup(e, {
      expose: t,
      emit: n
    }) {
      const r = n,
        s = e,
        {
          buildMatrix: a,
          setTimePicker: o
        } = ei(),
        i = zo(),
        {
          defaultedTransitions: l,
          defaultedAriaLabels: c,
          defaultedTextInput: d,
          defaultedConfig: f,
          defaultedRange: p
        } = tn(s),
        {
          transitionName: h,
          showTransition: _
        } = xd(l),
        {
          hideNavigationButtons: v
        } = o1(),
        C = U(null),
        y = U(null),
        b = U([]),
        w = U(null),
        x = U(!1);
      Ge(() => {
        r("mount"), !s.timePicker && s.arrowNavigation ? a([Sn(C.value)], "time") : o(!0, s.timePicker)
      });
      const E = L(() => p.value.enabled && s.modelAuto ? w7(s.internalModelValue) : !0),
        S = U(!1),
        T = se => ({
          hours: Array.isArray(s.hours) ? s.hours[se] : s.hours,
          minutes: Array.isArray(s.minutes) ? s.minutes[se] : s.minutes,
          seconds: Array.isArray(s.seconds) ? s.seconds[se] : s.seconds
        }),
        j = L(() => {
          const se = [];
          if (p.value.enabled)
            for (let ae = 0; ae < 2; ae++) se.push(T(ae));
          else se.push(T(0));
          return se
        }),
        P = (se, ae = !1, ke = "") => {
          ae || r("reset-flow"), S.value = se, r(se ? "overlay-opened" : "overlay-closed", Yn.time), s.arrowNavigation && o(se), Ot(() => {
            ke !== "" && b.value[0] && b.value[0].openChildCmp(ke)
          })
        },
        N = L(() => ({
          dp__btn: !0,
          dp__button: !0,
          dp__button_bottom: s.autoApply && !f.value.keepActionRow
        })),
        ne = Fr(i, "timePicker"),
        Y = (se, ae, ke) => p.value.enabled ? ae === 0 ? [se, j.value[1][ke]] : [j.value[0][ke], se] : se,
        _e = se => {
          r("update:hours", se)
        },
        Q = se => {
          r("update:minutes", se)
        },
        re = se => {
          r("update:seconds", se)
        },
        J = () => {
          if (w.value && !d.value.enabled && !s.noOverlayFocus) {
            const se = C7(w.value);
            se && se.focus({
              preventScroll: !0
            })
          }
        },
        ee = se => {
          x.value = !1, r("overlay-closed", se)
        },
        de = se => {
          x.value = !0, r("overlay-opened", se)
        };
      return t({
        toggleTimePicker: P
      }), (se, ae) => {
        var ke;
        return g(), k("div", {
          class: "dp--tp-wrap",
          "data-dp-mobile": se.isMobile
        }, [!se.timePicker && !se.timePickerInline ? Tn((g(), k("button", {
          key: 0,
          ref_key: "openTimePickerBtn",
          ref: C,
          type: "button",
          class: we({
            ...N.value,
            "dp--hidden-el": S.value
          }),
          "aria-label": (ke = u(c)) == null ? void 0 : ke.openTimePicker,
          tabindex: se.noOverlayFocus ? void 0 : 0,
          "data-test-id": "open-time-picker-btn",
          onKeydown: ae[0] || (ae[0] = be => u(ur)(be, () => P(!0))),
          onClick: ae[1] || (ae[1] = be => P(!0))
        }, [se.$slots["clock-icon"] ? ie(se.$slots, "clock-icon", {
          key: 0
        }) : z("", !0), se.$slots["clock-icon"] ? z("", !0) : (g(), G(u(Ug), {
          key: 1
        }))], 42, KZ)), [
          [wl, !u(v)(se.hideNavigation, "time")]
        ]) : z("", !0), $(zi, {
          name: u(h)(S.value),
          css: u(_) && !se.timePickerInline
        }, {
          default: V(() => {
            var be, ge;
            return [S.value || se.timePicker || se.timePickerInline ? (g(), k("div", {
              key: 0,
              ref_key: "overlayRef",
              ref: w,
              role: se.timePickerInline ? void 0 : "dialog",
              class: we({
                dp__overlay: !se.timePickerInline,
                "dp--overlay-absolute": !s.timePicker && !se.timePickerInline,
                "dp--overlay-relative": s.timePicker
              }),
              style: Mt(se.timePicker ? {
                height: `${u(f).modeHeight}px`
              } : void 0),
              "aria-label": (be = u(c)) == null ? void 0 : be.timePicker,
              tabindex: se.timePickerInline ? void 0 : 0
            }, [m("div", {
              class: we(se.timePickerInline ? "dp__time_picker_inline_container" : "dp__overlay_container dp__container_flex dp__time_picker_overlay_container"),
              style: {
                display: "flex"
              }
            }, [se.$slots["time-picker-overlay"] ? ie(se.$slots, "time-picker-overlay", {
              key: 0,
              hours: e.hours,
              minutes: e.minutes,
              seconds: e.seconds,
              setHours: _e,
              setMinutes: Q,
              setSeconds: re
            }) : z("", !0), se.$slots["time-picker-overlay"] ? z("", !0) : (g(), k("div", {
              key: 1,
              class: we(se.timePickerInline ? "dp__flex" : "dp__overlay_row dp__flex_row")
            }, [(g(!0), k(Ee, null, Je(j.value, (H, oe) => Tn((g(), G(QZ, Le({
              key: oe,
              ref_for: !0
            }, {
              ...se.$props,
              order: oe,
              hours: H.hours,
              minutes: H.minutes,
              seconds: H.seconds,
              closeTimePickerBtn: y.value,
              disabledTimesConfig: e.disabledTimesConfig,
              disabled: oe === 0 ? u(p).fixedStart : u(p).fixedEnd
            }, {
              ref_for: !0,
              ref_key: "timeInputRefs",
              ref: b,
              "validate-time": (Ce, D) => e.validateTime(Ce, Y(D, oe, Ce)),
              "onUpdate:hours": Ce => _e(Y(Ce, oe, "hours")),
              "onUpdate:minutes": Ce => Q(Y(Ce, oe, "minutes")),
              "onUpdate:seconds": Ce => re(Y(Ce, oe, "seconds")),
              onMounted: J,
              onOverlayClosed: ee,
              onOverlayOpened: de,
              onAmPmChange: ae[2] || (ae[2] = Ce => se.$emit("am-pm-change", Ce))
            }), Qn({
              _: 2
            }, [Je(u(ne), (Ce, D) => ({
              name: Ce,
              fn: V(pe => [ie(se.$slots, Ce, Le({
                ref_for: !0
              }, pe))])
            }))]), 1040, ["validate-time", "onUpdate:hours", "onUpdate:minutes", "onUpdate:seconds"])), [
              [wl, oe === 0 ? !0 : E.value]
            ])), 128))], 2)), !se.timePicker && !se.timePickerInline ? Tn((g(), k("button", {
              key: 2,
              ref_key: "closeTimePickerBtn",
              ref: y,
              type: "button",
              class: we({
                ...N.value,
                "dp--hidden-el": x.value
              }),
              "aria-label": (ge = u(c)) == null ? void 0 : ge.closeTimePicker,
              tabindex: "0",
              onKeydown: ae[3] || (ae[3] = H => u(ur)(H, () => P(!1))),
              onClick: ae[4] || (ae[4] = H => P(!1))
            }, [se.$slots["calendar-icon"] ? ie(se.$slots, "calendar-icon", {
              key: 0
            }) : z("", !0), se.$slots["calendar-icon"] ? z("", !0) : (g(), G(u(Du), {
              key: 1
            }))], 42, JZ)), [
              [wl, !u(v)(se.hideNavigation, "time")]
            ]) : z("", !0)], 2)], 14, ZZ)) : z("", !0)]
          }),
          _: 3
        }, 8, ["name", "css"])], 8, qZ)
      }
    }
  }),
  F7 = (e, t, n, r) => {
    const {
      defaultedRange: s
    } = tn(e), a = (w, x) => Array.isArray(t[w]) ? t[w][x] : t[w], o = w => e.enableSeconds ? Array.isArray(t.seconds) ? t.seconds[w] : t.seconds : 0, i = (w, x) => w ? x !== void 0 ? Mo(w, a("hours", x), a("minutes", x), o(x)) : Mo(w, t.hours, t.minutes, o()) : v7(Te(), o(x)), l = (w, x) => {
      t[w] = x
    }, c = L(() => e.modelAuto && s.value.enabled ? Array.isArray(n.value) ? n.value.length > 1 : !1 : s.value.enabled), d = (w, x) => {
      const E = Object.fromEntries(Object.keys(t).map(S => S === w ? [S, x] : [S, t[S]].slice()));
      if (c.value && !s.value.disableTimeRangeValidation) {
        const S = j => n.value ? Mo(n.value[j], E.hours[j], E.minutes[j], E.seconds[j]) : null,
          T = j => g7(n.value[j], 0);
        return !(mt(S(0), S(1)) && (uu(S(0), T(1)) || Vc(S(1), T(0))))
      }
      return !0
    }, f = (w, x) => {
      d(w, x) && (l(w, x), r && r())
    }, p = w => {
      f("hours", w)
    }, h = w => {
      f("minutes", w)
    }, _ = w => {
      f("seconds", w)
    }, v = (w, x, E, S) => {
      x && p(w), !x && !E && h(w), E && _(w), n.value && S(n.value)
    }, C = w => {
      if (w) {
        const x = Array.isArray(w),
          E = x ? [+w[0].hours, +w[1].hours] : +w.hours,
          S = x ? [+w[0].minutes, +w[1].minutes] : +w.minutes,
          T = x ? [+w[0].seconds, +w[1].seconds] : +w.seconds;
        l("hours", E), l("minutes", S), e.enableSeconds && l("seconds", T)
      }
    }, y = (w, x) => {
      const E = {
        hours: Array.isArray(t.hours) ? t.hours[w] : t.hours,
        disabledArr: []
      };
      return (x || x === 0) && (E.hours = x), Array.isArray(e.disabledTimes) && (E.disabledArr = s.value.enabled && Array.isArray(e.disabledTimes[w]) ? e.disabledTimes[w] : e.disabledTimes), E
    }, b = L(() => (w, x) => {
      var E;
      if (Array.isArray(e.disabledTimes)) {
        const {
          disabledArr: S,
          hours: T
        } = y(w, x), j = S.filter(P => +P.hours === T);
        return ((E = j[0]) == null ? void 0 : E.minutes) === "*" ? {
          hours: [T],
          minutes: void 0,
          seconds: void 0
        } : {
          hours: [],
          minutes: (j == null ? void 0 : j.map(P => +P.minutes)) ?? [],
          seconds: (j == null ? void 0 : j.map(P => P.seconds ? +P.seconds : void 0)) ?? []
        }
      }
      return {
        hours: [],
        minutes: [],
        seconds: []
      }
    });
    return {
      setTime: l,
      updateHours: p,
      updateMinutes: h,
      updateSeconds: _,
      getSetDateTime: i,
      updateTimeValues: v,
      getSecondsValue: o,
      assignStartTime: C,
      validateTime: d,
      disabledTimesConfig: b
    }
  },
  XZ = (e, t) => {
    const n = () => {
        e.isTextInputDate && x()
      },
      {
        modelValue: r,
        time: s
      } = kd(e, t, n),
      {
        defaultedStartTime: a,
        defaultedRange: o,
        defaultedTz: i
      } = tn(e),
      {
        updateTimeValues: l,
        getSetDateTime: c,
        setTime: d,
        assignStartTime: f,
        disabledTimesConfig: p,
        validateTime: h
      } = F7(e, s, r, _);

    function _() {
      t("update-flow-step")
    }
    const v = S => {
        const {
          hours: T,
          minutes: j,
          seconds: P
        } = S;
        return {
          hours: +T,
          minutes: +j,
          seconds: P ? +P : 0
        }
      },
      C = () => {
        if (e.startTime) {
          if (Array.isArray(e.startTime)) {
            const T = v(e.startTime[0]),
              j = v(e.startTime[1]);
            return [jt(Te(), T), jt(Te(), j)]
          }
          const S = v(e.startTime);
          return jt(Te(), S)
        }
        return o.value.enabled ? [null, null] : null
      },
      y = () => {
        if (o.value.enabled) {
          const [S, T] = C();
          r.value = [Ir(c(S, 0), i.value.timezone), Ir(c(T, 1), i.value.timezone)]
        } else r.value = Ir(c(C()), i.value.timezone)
      },
      b = S => Array.isArray(S) ? [$i(Te(S[0])), $i(Te(S[1]))] : [$i(S ?? Te())],
      w = (S, T, j) => {
        d("hours", S), d("minutes", T), d("seconds", e.enableSeconds ? j : 0)
      },
      x = () => {
        const [S, T] = b(r.value);
        return o.value.enabled ? w([S.hours, T.hours], [S.minutes, T.minutes], [S.seconds, T.seconds]) : w(S.hours, S.minutes, S.seconds)
      };
    Ge(() => {
      if (!e.shadow) return f(a.value), r.value ? x() : y()
    });
    const E = () => {
      Array.isArray(r.value) ? r.value = r.value.map((S, T) => S && c(S, T)) : r.value = c(r.value), t("time-update")
    };
    return {
      modelValue: r,
      time: s,
      disabledTimesConfig: p,
      updateTime: (S, T = !0, j = !1) => {
        l(S, T, j, E)
      },
      validateTime: h
    }
  },
  eJ = te({
    compatConfig: {
      MODE: 3
    },
    __name: "TimePickerSolo",
    props: {
      ...Is
    },
    emits: ["update:internal-model-value", "time-update", "am-pm-change", "mount", "reset-flow", "update-flow-step", "overlay-toggle"],
    setup(e, {
      expose: t,
      emit: n
    }) {
      const r = n,
        s = e,
        a = zo(),
        o = Fr(a, "timePicker"),
        i = U(null),
        {
          time: l,
          modelValue: c,
          disabledTimesConfig: d,
          updateTime: f,
          validateTime: p
        } = XZ(s, r);
      return Ge(() => {
        s.shadow || r("mount", null)
      }), t({
        getSidebarProps: () => ({
          modelValue: c,
          time: l,
          updateTime: f
        }),
        toggleTimePicker: (h, _ = !1, v = "") => {
          var C;
          (C = i.value) == null || C.toggleTimePicker(h, _, v)
        }
      }), (h, _) => (g(), G(s1, {
        "multi-calendars": 0,
        stretch: "",
        "is-mobile": h.isMobile
      }, {
        default: V(() => [$(N7, Le({
          ref_key: "tpRef",
          ref: i
        }, h.$props, {
          hours: u(l).hours,
          minutes: u(l).minutes,
          seconds: u(l).seconds,
          "internal-model-value": h.internalModelValue,
          "disabled-times-config": u(d),
          "validate-time": u(p),
          "onUpdate:hours": _[0] || (_[0] = v => u(f)(v)),
          "onUpdate:minutes": _[1] || (_[1] = v => u(f)(v, !1)),
          "onUpdate:seconds": _[2] || (_[2] = v => u(f)(v, !1, !0)),
          onAmPmChange: _[3] || (_[3] = v => h.$emit("am-pm-change", v)),
          onResetFlow: _[4] || (_[4] = v => h.$emit("reset-flow")),
          onOverlayClosed: _[5] || (_[5] = v => h.$emit("overlay-toggle", {
            open: !1,
            overlay: v
          })),
          onOverlayOpened: _[6] || (_[6] = v => h.$emit("overlay-toggle", {
            open: !0,
            overlay: v
          }))
        }), Qn({
          _: 2
        }, [Je(u(o), (v, C) => ({
          name: v,
          fn: V(y => [ie(h.$slots, v, Nt(Qt(y)))])
        }))]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config", "validate-time"])]),
        _: 3
      }, 8, ["is-mobile"]))
    }
  }),
  tJ = {
    class: "dp--header-wrap"
  },
  nJ = {
    key: 0,
    class: "dp__month_year_wrap"
  },
  rJ = {
    key: 0
  },
  sJ = {
    class: "dp__month_year_wrap"
  },
  aJ = ["data-dp-element", "aria-label", "data-test-id", "onClick", "onKeydown"],
  oJ = te({
    compatConfig: {
      MODE: 3
    },
    __name: "DpHeader",
    props: {
      month: {
        type: Number,
        default: 0
      },
      year: {
        type: Number,
        default: 0
      },
      instance: {
        type: Number,
        default: 0
      },
      years: {
        type: Array,
        default: () => []
      },
      months: {
        type: Array,
        default: () => []
      },
      ...Is
    },
    emits: ["update-month-year", "mount", "reset-flow", "overlay-closed", "overlay-opened"],
    setup(e, {
      expose: t,
      emit: n
    }) {
      const r = n,
        s = e,
        {
          defaultedTransitions: a,
          defaultedAriaLabels: o,
          defaultedMultiCalendars: i,
          defaultedFilters: l,
          defaultedConfig: c,
          defaultedHighlight: d,
          propDates: f,
          defaultedUI: p
        } = tn(s),
        {
          transitionName: h,
          showTransition: _
        } = xd(a),
        {
          buildMatrix: v
        } = ei(),
        {
          handleMonthYearChange: C,
          isDisabled: y,
          updateMonthYear: b
        } = EZ(s, r),
        {
          showLeftIcon: w,
          showRightIcon: x
        } = o1(),
        E = U(!1),
        S = U(!1),
        T = U(!1),
        j = U([null, null, null, null]);
      Ge(() => {
        r("mount")
      });
      const P = ge => ({
          get: () => s[ge],
          set: H => {
            const oe = ge === os.month ? os.year : os.month;
            r("update-month-year", {
              [ge]: H,
              [oe]: s[oe]
            }), ge === os.month ? ee(!0) : de(!0)
          }
        }),
        N = L(P(os.month)),
        ne = L(P(os.year)),
        Y = L(() => ge => ({
          month: s.month,
          year: s.year,
          items: ge === os.month ? s.months : s.years,
          instance: s.instance,
          updateMonthYear: b,
          toggle: ge === os.month ? ee : de
        })),
        _e = L(() => s.months.find(H => H.value === s.month) || {
          text: "",
          value: 0
        }),
        Q = L(() => du(s.months, ge => {
          const H = s.month === ge.value,
            oe = Uc(ge.value, k7(s.year, f.value.minDate), S7(s.year, f.value.maxDate)) || l.value.months.includes(ge.value),
            Ce = I7(d.value, ge.value, s.year);
          return {
            active: H,
            disabled: oe,
            highlighted: Ce
          }
        })),
        re = L(() => du(s.years, ge => {
          const H = s.year === ge.value,
            oe = Uc(ge.value, fu(f.value.minDate), fu(f.value.maxDate)) || l.value.years.includes(ge.value),
            Ce = Kg(d.value, ge.value);
          return {
            active: H,
            disabled: oe,
            highlighted: Ce
          }
        })),
        J = (ge, H, oe) => {
          oe !== void 0 ? ge.value = oe : ge.value = !ge.value, ge.value ? (T.value = !0, r("overlay-opened", H)) : (T.value = !1, r("overlay-closed", H))
        },
        ee = (ge = !1, H) => {
          se(ge), J(E, Yn.month, H)
        },
        de = (ge = !1, H) => {
          se(ge), J(S, Yn.year, H)
        },
        se = ge => {
          ge || r("reset-flow")
        },
        ae = (ge, H) => {
          s.arrowNavigation && (j.value[H] = Sn(ge), v(j.value, "monthYear"))
        },
        ke = L(() => {
          var ge, H, oe, Ce, D, pe;
          return [{
            type: os.month,
            index: 1,
            toggle: ee,
            modelValue: N.value,
            updateModelValue: ye => N.value = ye,
            text: _e.value.text,
            showSelectionGrid: E.value,
            items: Q.value,
            ariaLabel: (ge = o.value) == null ? void 0 : ge.openMonthsOverlay,
            overlayLabel: ((oe = (H = o.value).monthPicker) == null ? void 0 : oe.call(H, !0)) ?? void 0
          }, {
            type: os.year,
            index: 2,
            toggle: de,
            modelValue: ne.value,
            updateModelValue: ye => ne.value = ye,
            text: x7(s.year, s.locale),
            showSelectionGrid: S.value,
            items: re.value,
            ariaLabel: (Ce = o.value) == null ? void 0 : Ce.openYearsOverlay,
            overlayLabel: ((pe = (D = o.value).yearPicker) == null ? void 0 : pe.call(D, !0)) ?? void 0
          }]
        }),
        be = L(() => s.disableYearSelect ? [ke.value[0]] : s.yearFirst ? [...ke.value].reverse() : ke.value);
      return t({
        toggleMonthPicker: ee,
        toggleYearPicker: de,
        handleMonthYearChange: C
      }), (ge, H) => {
        var oe, Ce, D, pe, ye, Ae;
        return g(), k("div", tJ, [ge.$slots["month-year"] ? (g(), k("div", nJ, [ie(ge.$slots, "month-year", Nt(Qt({
          month: e.month,
          year: e.year,
          months: e.months,
          years: e.years,
          updateMonthYear: u(b),
          handleMonthYearChange: u(C),
          instance: e.instance
        })))])) : (g(), k(Ee, {
          key: 1
        }, [ge.$slots["top-extra"] ? (g(), k("div", rJ, [ie(ge.$slots, "top-extra", {
          value: ge.internalModelValue
        })])) : z("", !0), m("div", sJ, [u(w)(u(i), e.instance) && !ge.vertical ? (g(), G(pc, {
          key: 0,
          "aria-label": (oe = u(o)) == null ? void 0 : oe.prevMonth,
          disabled: u(y)(!1),
          class: we((Ce = u(p)) == null ? void 0 : Ce.navBtnPrev),
          "el-name": "action-prev",
          onActivate: H[0] || (H[0] = fe => u(C)(!1, !0)),
          onSetRef: H[1] || (H[1] = fe => ae(fe, 0))
        }, {
          default: V(() => [ge.$slots["arrow-left"] ? ie(ge.$slots, "arrow-left", {
            key: 0
          }) : z("", !0), ge.$slots["arrow-left"] ? z("", !0) : (g(), G(u(Hg), {
            key: 1
          }))]),
          _: 3
        }, 8, ["aria-label", "disabled", "class"])) : z("", !0), m("div", {
          class: we(["dp__month_year_wrap", {
            dp__year_disable_select: ge.disableYearSelect
          }])
        }, [(g(!0), k(Ee, null, Je(be.value, (fe, I) => (g(), k(Ee, {
          key: fe.type
        }, [m("button", {
          ref_for: !0,
          ref: M => ae(M, I + 1),
          type: "button",
          "data-dp-element": `overlay-${fe.type}`,
          class: we(["dp__btn dp__month_year_select", {
            "dp--hidden-el": T.value
          }]),
          "aria-label": `${fe.text}-${fe.ariaLabel}`,
          "data-test-id": `${fe.type}-toggle-overlay-${e.instance}`,
          onClick: fe.toggle,
          onKeydown: M => u(ur)(M, () => fe.toggle(), !0)
        }, [ge.$slots[fe.type] ? ie(ge.$slots, fe.type, {
          key: 0,
          text: fe.text,
          value: s[fe.type]
        }) : z("", !0), ge.$slots[fe.type] ? z("", !0) : (g(), k(Ee, {
          key: 1
        }, [Ye(R(fe.text), 1)], 64))], 42, aJ), $(zi, {
          name: u(h)(fe.showSelectionGrid),
          css: u(_)
        }, {
          default: V(() => [fe.showSelectionGrid ? (g(), G(Cd, {
            key: 0,
            items: fe.items,
            "arrow-navigation": ge.arrowNavigation,
            "hide-navigation": ge.hideNavigation,
            "is-last": ge.autoApply && !u(c).keepActionRow,
            "skip-button-ref": !1,
            config: ge.config,
            type: fe.type,
            "header-refs": [],
            "esc-close": ge.escClose,
            "menu-wrap-ref": ge.menuWrapRef,
            "text-input": ge.textInput,
            "aria-labels": ge.ariaLabels,
            "overlay-label": fe.overlayLabel,
            onSelected: fe.updateModelValue,
            onToggle: fe.toggle
          }, Qn({
            "button-icon": V(() => [ge.$slots["calendar-icon"] ? ie(ge.$slots, "calendar-icon", {
              key: 0
            }) : z("", !0), ge.$slots["calendar-icon"] ? z("", !0) : (g(), G(u(Du), {
              key: 1
            }))]),
            _: 2
          }, [ge.$slots[`${fe.type}-overlay-value`] ? {
            name: "item",
            fn: V(({
              item: M
            }) => [ie(ge.$slots, `${fe.type}-overlay-value`, {
              text: M.text,
              value: M.value
            })]),
            key: "0"
          } : void 0, ge.$slots[`${fe.type}-overlay`] ? {
            name: "overlay",
            fn: V(() => [ie(ge.$slots, `${fe.type}-overlay`, Le({
              ref_for: !0
            }, Y.value(fe.type)))]),
            key: "1"
          } : void 0, ge.$slots[`${fe.type}-overlay-header`] ? {
            name: "header",
            fn: V(() => [ie(ge.$slots, `${fe.type}-overlay-header`, {
              toggle: fe.toggle
            })]),
            key: "2"
          } : void 0]), 1032, ["items", "arrow-navigation", "hide-navigation", "is-last", "config", "type", "esc-close", "menu-wrap-ref", "text-input", "aria-labels", "overlay-label", "onSelected", "onToggle"])) : z("", !0)]),
          _: 2
        }, 1032, ["name", "css"])], 64))), 128))], 2), u(w)(u(i), e.instance) && ge.vertical ? (g(), G(pc, {
          key: 1,
          "aria-label": (D = u(o)) == null ? void 0 : D.prevMonth,
          "el-name": "action-prev",
          disabled: u(y)(!1),
          class: we((pe = u(p)) == null ? void 0 : pe.navBtnPrev),
          onActivate: H[2] || (H[2] = fe => u(C)(!1, !0))
        }, {
          default: V(() => [ge.$slots["arrow-up"] ? ie(ge.$slots, "arrow-up", {
            key: 0
          }) : z("", !0), ge.$slots["arrow-up"] ? z("", !0) : (g(), G(u(zg), {
            key: 1
          }))]),
          _: 3
        }, 8, ["aria-label", "disabled", "class"])) : z("", !0), u(x)(u(i), e.instance) ? (g(), G(pc, {
          key: 2,
          ref: "rightIcon",
          "el-name": "action-next",
          disabled: u(y)(!0),
          "aria-label": (ye = u(o)) == null ? void 0 : ye.nextMonth,
          class: we((Ae = u(p)) == null ? void 0 : Ae.navBtnNext),
          onActivate: H[3] || (H[3] = fe => u(C)(!0, !0)),
          onSetRef: H[4] || (H[4] = fe => ae(fe, ge.disableYearSelect ? 2 : 3))
        }, {
          default: V(() => [ge.$slots[ge.vertical ? "arrow-down" : "arrow-right"] ? ie(ge.$slots, ge.vertical ? "arrow-down" : "arrow-right", {
            key: 0
          }) : z("", !0), ge.$slots[ge.vertical ? "arrow-down" : "arrow-right"] ? z("", !0) : (g(), G(Kr(ge.vertical ? u(Yg) : u(Vg)), {
            key: 1
          }))]),
          _: 3
        }, 8, ["disabled", "aria-label", "class"])) : z("", !0)])], 64))])
      }
    }
  }),
  iJ = {
    class: "dp__calendar_header",
    role: "row"
  },
  lJ = {
    key: 0,
    class: "dp__calendar_header_item",
    role: "gridcell"
  },
  uJ = ["aria-label"],
  cJ = {
    key: 0,
    class: "dp__calendar_item dp__week_num",
    role: "gridcell"
  },
  dJ = {
    class: "dp__cell_inner"
  },
  fJ = ["id", "aria-pressed", "aria-disabled", "aria-label", "tabindex", "data-test-id", "onClick", "onTouchend", "onKeydown", "onMouseenter", "onMouseleave", "onMousedown"],
  pJ = te({
    compatConfig: {
      MODE: 3
    },
    __name: "DpCalendar",
    props: {
      mappedDates: {
        type: Array,
        default: () => []
      },
      instance: {
        type: Number,
        default: 0
      },
      month: {
        type: Number,
        default: 0
      },
      year: {
        type: Number,
        default: 0
      },
      ...Is
    },
    emits: ["select-date", "set-hover-date", "handle-scroll", "mount", "handle-swipe", "handle-space", "tooltip-open", "tooltip-close"],
    setup(e, {
      expose: t,
      emit: n
    }) {
      const r = n,
        s = e,
        {
          buildMultiLevelMatrix: a
        } = ei(),
        {
          defaultedTransitions: o,
          defaultedConfig: i,
          defaultedAriaLabels: l,
          defaultedMultiCalendars: c,
          defaultedWeekNumbers: d,
          defaultedMultiDates: f,
          defaultedUI: p
        } = tn(s),
        h = U(null),
        _ = U({
          bottom: "",
          left: "",
          transform: ""
        }),
        v = U([]),
        C = U(null),
        y = U(!0),
        b = U(""),
        w = U({
          startX: 0,
          endX: 0,
          startY: 0,
          endY: 0
        }),
        x = U([]),
        E = U({
          left: "50%"
        }),
        S = U(!1),
        T = L(() => s.calendar ? s.calendar(s.mappedDates) : s.mappedDates),
        j = L(() => s.dayNames ? Array.isArray(s.dayNames) ? s.dayNames : s.dayNames(s.locale, +s.weekStart) : GK(s.formatLocale, s.locale, +s.weekStart));
      Ge(() => {
        r("mount", {
          cmp: "calendar",
          refs: v
        }), i.value.noSwipe || C.value && (C.value.addEventListener("touchstart", ae, {
          passive: !1
        }), C.value.addEventListener("touchend", ke, {
          passive: !1
        }), C.value.addEventListener("touchmove", be, {
          passive: !1
        })), s.monthChangeOnScroll && C.value && C.value.addEventListener("wheel", oe, {
          passive: !1
        })
      });
      const P = fe => fe ? s.vertical ? "vNext" : "next" : s.vertical ? "vPrevious" : "previous",
        N = (fe, I) => {
          if (s.transitions) {
            const M = mr(Pa(Te(), s.month, s.year));
            b.value = fn(mr(Pa(Te(), fe, I)), M) ? o.value[P(!0)] : o.value[P(!1)], y.value = !1, Ot(() => {
              y.value = !0
            })
          }
        },
        ne = L(() => ({
          ...p.value.calendar ?? {}
        })),
        Y = L(() => fe => {
          const I = qK(fe);
          return {
            dp__marker_dot: I.type === "dot",
            dp__marker_line: I.type === "line"
          }
        }),
        _e = L(() => fe => mt(fe, h.value)),
        Q = L(() => ({
          dp__calendar: !0,
          dp__calendar_next: c.value.count > 0 && s.instance !== 0
        })),
        re = L(() => fe => s.hideOffsetDates ? fe.current : !0),
        J = async (fe, I) => {
          const {
            width: M,
            height: W
          } = fe.getBoundingClientRect();
          h.value = I.value;
          let O = {
              left: `${M/2}px`
            },
            q = -50;
          if (await Ot(), x.value[0]) {
            const {
              left: he,
              width: A
            } = x.value[0].getBoundingClientRect();
            he < 0 && (O = {
              left: "0"
            }, q = 0, E.value.left = `${M/2}px`), window.innerWidth < he + A && (O = {
              right: "0"
            }, q = 0, E.value.left = `${A-M/2}px`)
          }
          _.value = {
            bottom: `${W}px`,
            ...O,
            transform: `translateX(${q}%)`
          }
        }, ee = async (fe, I, M) => {
          var W, O, q;
          const he = Sn(v.value[I][M]);
          he && ((W = fe.marker) != null && W.customPosition && (q = (O = fe.marker) == null ? void 0 : O.tooltip) != null && q.length ? _.value = fe.marker.customPosition(he) : await J(he, fe), r("tooltip-open", fe.marker))
        }, de = async (fe, I, M) => {
          var W, O;
          if (S.value && f.value.enabled && f.value.dragSelect) return r("select-date", fe);
          if (r("set-hover-date", fe), (O = (W = fe.marker) == null ? void 0 : W.tooltip) != null && O.length) {
            if (s.hideOffsetDates && !fe.current) return;
            await ee(fe, I, M)
          }
        }, se = fe => {
          h.value && (h.value = null, _.value = JSON.parse(JSON.stringify({
            bottom: "",
            left: "",
            transform: ""
          })), r("tooltip-close", fe.marker))
        }, ae = fe => {
          w.value.startX = fe.changedTouches[0].screenX, w.value.startY = fe.changedTouches[0].screenY
        }, ke = fe => {
          w.value.endX = fe.changedTouches[0].screenX, w.value.endY = fe.changedTouches[0].screenY, ge()
        }, be = fe => {
          s.vertical && !s.inline && fe.preventDefault()
        }, ge = () => {
          const fe = s.vertical ? "Y" : "X";
          Math.abs(w.value[`start${fe}`] - w.value[`end${fe}`]) > 10 && r("handle-swipe", w.value[`start${fe}`] > w.value[`end${fe}`] ? "right" : "left")
        }, H = (fe, I, M) => {
          fe && (Array.isArray(v.value[I]) ? v.value[I][M] = fe : v.value[I] = [fe]), s.arrowNavigation && a(v.value, "calendar")
        }, oe = fe => {
          s.monthChangeOnScroll && (fe.preventDefault(), r("handle-scroll", fe))
        }, Ce = fe => d.value.type === "local" ? Fg(fe.value, {
          weekStartsOn: +s.weekStart
        }) : d.value.type === "iso" ? Rg(fe.value) : typeof d.value.type == "function" ? d.value.type(fe.value) : "", D = fe => {
          const I = fe[0];
          return d.value.hideOnOffsetDates ? fe.some(M => M.current) ? Ce(I) : "" : Ce(I)
        }, pe = (fe, I, M = !0) => {
          M && u3() || !M && !u3() || (!f.value.enabled || i.value.allowPreventDefault) && ($o(fe, i.value), r("select-date", I))
        }, ye = fe => {
          $o(fe, i.value)
        }, Ae = fe => {
          f.value.enabled && f.value.dragSelect ? (S.value = !0, r("select-date", fe)) : f.value.enabled && r("select-date", fe)
        };
      return t({
        triggerTransition: N
      }), (fe, I) => (g(), k("div", {
        class: we(Q.value)
      }, [m("div", {
        ref_key: "calendarWrapRef",
        ref: C,
        class: we(ne.value),
        role: "grid"
      }, [m("div", iJ, [fe.weekNumbers ? (g(), k("div", lJ, R(fe.weekNumName), 1)) : z("", !0), (g(!0), k(Ee, null, Je(j.value, (M, W) => {
        var O, q;
        return g(), k("div", {
          key: W,
          class: "dp__calendar_header_item",
          role: "gridcell",
          "data-test-id": "calendar-header",
          "aria-label": (q = (O = u(l)) == null ? void 0 : O.weekDay) == null ? void 0 : q.call(O, W)
        }, [fe.$slots["calendar-header"] ? ie(fe.$slots, "calendar-header", {
          key: 0,
          day: M,
          index: W
        }) : z("", !0), fe.$slots["calendar-header"] ? z("", !0) : (g(), k(Ee, {
          key: 1
        }, [Ye(R(M), 1)], 64))], 8, uJ)
      }), 128))]), I[2] || (I[2] = m("div", {
        class: "dp__calendar_header_separator"
      }, null, -1)), $(zi, {
        name: b.value,
        css: !!fe.transitions
      }, {
        default: V(() => [y.value ? (g(), k("div", {
          key: 0,
          class: "dp__calendar",
          role: "rowgroup",
          onMouseleave: I[1] || (I[1] = M => S.value = !1)
        }, [(g(!0), k(Ee, null, Je(T.value, (M, W) => (g(), k("div", {
          key: W,
          class: "dp__calendar_row",
          role: "row"
        }, [fe.weekNumbers ? (g(), k("div", cJ, [m("div", dJ, R(D(M.days)), 1)])) : z("", !0), (g(!0), k(Ee, null, Je(M.days, (O, q) => {
          var he, A, F;
          return g(), k("div", {
            id: u($7)(O.value),
            ref_for: !0,
            ref: K => H(K, W, q),
            key: q + W,
            role: "gridcell",
            class: "dp__calendar_item",
            "aria-pressed": (O.classData.dp__active_date || O.classData.dp__range_start || O.classData.dp__range_start) ?? void 0,
            "aria-disabled": O.classData.dp__cell_disabled || void 0,
            "aria-label": (A = (he = u(l)) == null ? void 0 : he.day) == null ? void 0 : A.call(he, O),
            tabindex: !O.current && fe.hideOffsetDates ? void 0 : 0,
            "data-test-id": O.value,
            onClick: Er(K => pe(K, O), ["prevent"]),
            onTouchend: K => pe(K, O, !1),
            onKeydown: K => u(ur)(K, () => fe.$emit("select-date", O)),
            onMouseenter: K => de(O, W, q),
            onMouseleave: K => se(O),
            onMousedown: K => Ae(O),
            onMouseup: I[0] || (I[0] = K => S.value = !1)
          }, [m("div", {
            class: we(["dp__cell_inner", O.classData])
          }, [fe.$slots.day && re.value(O) ? ie(fe.$slots, "day", {
            key: 0,
            day: +O.text,
            date: O.value
          }) : z("", !0), fe.$slots.day ? z("", !0) : (g(), k(Ee, {
            key: 1
          }, [Ye(R(O.text), 1)], 64)), O.marker && re.value(O) ? (g(), k(Ee, {
            key: 2
          }, [fe.$slots.marker ? ie(fe.$slots, "marker", {
            key: 0,
            marker: O.marker,
            day: +O.text,
            date: O.value
          }) : (g(), k("div", {
            key: 1,
            class: we(Y.value(O.marker)),
            style: Mt(O.marker.color ? {
              backgroundColor: O.marker.color
            } : {})
          }, null, 6))], 64)) : z("", !0), _e.value(O.value) ? (g(), k("div", {
            key: 3,
            ref_for: !0,
            ref_key: "activeTooltip",
            ref: x,
            class: "dp__marker_tooltip",
            style: Mt(_.value)
          }, [(F = O.marker) != null && F.tooltip ? (g(), k("div", {
            key: 0,
            class: "dp__tooltip_content",
            onClick: ye
          }, [(g(!0), k(Ee, null, Je(O.marker.tooltip, (K, B) => (g(), k("div", {
            key: B,
            class: "dp__tooltip_text"
          }, [fe.$slots["marker-tooltip"] ? ie(fe.$slots, "marker-tooltip", {
            key: 0,
            tooltip: K,
            day: O.value
          }) : z("", !0), fe.$slots["marker-tooltip"] ? z("", !0) : (g(), k(Ee, {
            key: 1
          }, [m("div", {
            class: "dp__tooltip_mark",
            style: Mt(K.color ? {
              backgroundColor: K.color
            } : {})
          }, null, 4), m("div", null, R(K.text), 1)], 64))]))), 128)), m("div", {
            class: "dp__arrow_bottom_tp",
            style: Mt(E.value)
          }, null, 4)])) : z("", !0)], 4)) : z("", !0)], 2)], 40, fJ)
        }), 128))]))), 128))], 32)) : z("", !0)]),
        _: 3
      }, 8, ["name", "css"])], 2)], 2))
    }
  }),
  h3 = e => Array.isArray(e),
  hJ = (e, t, n, r) => {
    const s = U([]),
      a = U(new Date),
      o = U(),
      i = () => ae(e.isTextInputDate),
      {
        modelValue: l,
        calendars: c,
        time: d,
        today: f
      } = kd(e, t, i),
      {
        defaultedMultiCalendars: p,
        defaultedStartTime: h,
        defaultedRange: _,
        defaultedConfig: v,
        defaultedTz: C,
        propDates: y,
        defaultedMultiDates: b
      } = tn(e),
      {
        validateMonthYearInRange: w,
        isDisabled: x,
        isDateRangeAllowed: E,
        checkMinMaxRange: S
      } = ti(e),
      {
        updateTimeValues: T,
        getSetDateTime: j,
        setTime: P,
        assignStartTime: N,
        validateTime: ne,
        disabledTimesConfig: Y
      } = F7(e, d, l, r),
      _e = L(() => me => c.value[me] ? c.value[me].month : 0),
      Q = L(() => me => c.value[me] ? c.value[me].year : 0),
      re = me => !v.value.keepViewOnOffsetClick || me ? !0 : !o.value,
      J = (me, Ie, qe, xe = !1) => {
        var $e, Ue;
        re(xe) && (c.value[me] || (c.value[me] = {
          month: 0,
          year: 0
        }), c.value[me].month = l3(Ie) ? ($e = c.value[me]) == null ? void 0 : $e.month : Ie, c.value[me].year = l3(qe) ? (Ue = c.value[me]) == null ? void 0 : Ue.year : qe)
      },
      ee = () => {
        e.autoApply && t("select-date")
      };
    Ge(() => {
      e.shadow || (l.value || (fe(), h.value && N(h.value)), ae(!0), e.focusStartDate && e.startDate && fe())
    });
    const de = L(() => {
        var me;
        return (me = e.flow) != null && me.length && !e.partialFlow ? e.flowStep === e.flow.length : !0
      }),
      se = () => {
        e.autoApply && de.value && t("auto-apply", e.partialFlow ? e.flowStep !== e.flow.length : !1)
      },
      ae = (me = !1) => {
        if (l.value) return Array.isArray(l.value) ? (s.value = l.value, D(me)) : ge(l.value, me);
        if (p.value.count && me && !e.startDate) return be(Te(), me)
      },
      ke = () => Array.isArray(l.value) && _.value.enabled ? ft(l.value[0]) === ft(l.value[1] ?? l.value[0]) : !1,
      be = (me = new Date, Ie = !1) => {
        if ((!p.value.count || !p.value.static || Ie) && J(0, ft(me), Xe(me)), p.value.count && (!l.value || ke() || !p.value.solo) && (!p.value.solo || Ie))
          for (let qe = 1; qe < p.value.count; qe++) {
            const xe = jt(Te(), {
                month: _e.value(qe - 1),
                year: Q.value(qe - 1)
              }),
              $e = X9(xe, {
                months: 1
              });
            c.value[qe] = {
              month: ft($e),
              year: Xe($e)
            }
          }
      },
      ge = (me, Ie) => {
        be(me), P("hours", za(me)), P("minutes", Uo(me)), P("seconds", lu(me)), p.value.count && Ie && Ae()
      },
      H = me => {
        if (p.value.count) {
          if (p.value.solo) return 0;
          const Ie = ft(me[0]),
            qe = ft(me[1]);
          return Math.abs(qe - Ie) < p.value.count ? 0 : 1
        }
        return 1
      },
      oe = (me, Ie) => {
        me[1] && _.value.showLastInRange ? be(me[H(me)], Ie) : be(me[0], Ie);
        const qe = (xe, $e) => [xe(me[0]), me[1] ? xe(me[1]) : d[$e][1]];
        P("hours", qe(za, "hours")), P("minutes", qe(Uo, "minutes")), P("seconds", qe(lu, "seconds"))
      },
      Ce = (me, Ie) => {
        if ((_.value.enabled || e.weekPicker) && !b.value.enabled) return oe(me, Ie);
        if (b.value.enabled && Ie) {
          const qe = me[me.length - 1];
          return ge(qe, Ie)
        }
      },
      D = me => {
        const Ie = l.value;
        Ce(Ie, me), p.value.count && p.value.solo && Ae()
      },
      pe = (me, Ie) => {
        const qe = jt(Te(), {
            month: _e.value(Ie),
            year: Q.value(Ie)
          }),
          xe = me < 0 ? ws(qe, 1) : cu(qe, 1);
        w(ft(xe), Xe(xe), me < 0, e.preventMinMaxNavigation) && (J(Ie, ft(xe), Xe(xe)), t("update-month-year", {
          instance: Ie,
          month: ft(xe),
          year: Xe(xe)
        }), p.value.count && !p.value.solo && ye(Ie), n())
      },
      ye = me => {
        for (let Ie = me - 1; Ie >= 0; Ie--) {
          const qe = cu(jt(Te(), {
            month: _e.value(Ie + 1),
            year: Q.value(Ie + 1)
          }), 1);
          J(Ie, ft(qe), Xe(qe))
        }
        for (let Ie = me + 1; Ie <= p.value.count - 1; Ie++) {
          const qe = ws(jt(Te(), {
            month: _e.value(Ie - 1),
            year: Q.value(Ie - 1)
          }), 1);
          J(Ie, ft(qe), Xe(qe))
        }
      },
      Ae = () => {
        if (Array.isArray(l.value) && l.value.length === 2) {
          const me = Te(Te(l.value[1] ? l.value[1] : ws(l.value[0], 1))),
            [Ie, qe] = [ft(l.value[0]), Xe(l.value[0])],
            [xe, $e] = [ft(l.value[1]), Xe(l.value[1])];
          (Ie !== xe || Ie === xe && qe !== $e) && p.value.solo && J(1, ft(me), Xe(me))
        } else l.value && !Array.isArray(l.value) && (J(0, ft(l.value), Xe(l.value)), be(Te()))
      },
      fe = () => {
        e.startDate && (J(0, ft(Te(e.startDate)), Xe(Te(e.startDate))), p.value.count && ye(0))
      },
      I = (me, Ie) => {
        if (e.monthChangeOnScroll) {
          const qe = new Date().getTime() - a.value.getTime(),
            xe = Math.abs(me.deltaY);
          let $e = 500;
          xe > 1 && ($e = 100), xe > 100 && ($e = 0), qe > $e && (a.value = new Date, pe(e.monthChangeOnScroll !== "inverse" ? -me.deltaY : me.deltaY, Ie))
        }
      },
      M = (me, Ie, qe = !1) => {
        e.monthChangeOnArrows && e.vertical === qe && W(me, Ie)
      },
      W = (me, Ie) => {
        pe(me === "right" ? -1 : 1, Ie)
      },
      O = me => {
        if (y.value.markers) return ip(me.value, y.value.markers)
      },
      q = (me, Ie) => {
        switch (e.sixWeeks === !0 ? "append" : e.sixWeeks) {
          case "prepend":
            return [!0, !1];
          case "center":
            return [me == 0, !0];
          case "fair":
            return [me == 0 || Ie > me, !0];
          case "append":
            return [!1, !1];
          default:
            return [!1, !1]
        }
      },
      he = (me, Ie, qe, xe) => {
        if (e.sixWeeks && me.length < 6) {
          const $e = 6 - me.length,
            Ue = (Ie.getDay() + 7 - xe) % 7,
            $s = 6 - (qe.getDay() + 7 - xe) % 7,
            [ss, tl] = q(Ue, $s);
          for (let Lu = 1; Lu <= $e; Lu++)
            if (tl ? !!(Lu % 2) == ss : ss) {
              const Ja = me[0].days[0],
                i1 = A(vs(Ja.value, -7), ft(Ie));
              me.unshift({
                days: i1
              })
            } else {
              const Ja = me[me.length - 1],
                i1 = Ja.days[Ja.days.length - 1],
                U7 = A(vs(i1.value, 1), ft(Ie));
              me.push({
                days: U7
              })
            }
        }
        return me
      },
      A = (me, Ie) => {
        const qe = Te(me),
          xe = [];
        for (let $e = 0; $e < 7; $e++) {
          const Ue = vs(qe, $e),
            $s = ft(Ue) !== Ie;
          xe.push({
            text: e.hideOffsetDates && $s ? "" : Ue.getDate(),
            value: Ue,
            current: !$s,
            classData: {}
          })
        }
        return xe
      },
      F = (me, Ie) => {
        const qe = [],
          xe = new Date(Ie, me),
          $e = new Date(Ie, me + 1, 0),
          Ue = e.weekStart,
          $s = Ps(xe, {
            weekStartsOn: Ue
          }),
          ss = tl => {
            const Lu = A(tl, me);
            if (qe.push({
                days: Lu
              }), !qe[qe.length - 1].days.some(Ja => mt(mr(Ja.value), mr($e)))) {
              const Ja = vs(tl, 7);
              ss(Ja)
            }
          };
        return ss($s), he(qe, xe, $e, Ue)
      },
      K = me => {
        const Ie = Mo(Te(me.value), d.hours, d.minutes, He());
        t("date-update", Ie), b.value.enabled ? Zg(Ie, l, b.value.limit) : l.value = Ie, r(), Ot().then(() => {
          se()
        })
      },
      B = me => _.value.noDisabledRange ? E7(s.value[0], me).some(Ie => x(Ie)) : !1,
      ce = () => {
        s.value = l.value ? l.value.slice() : [], s.value.length === 2 && !(_.value.fixedStart || _.value.fixedEnd) && (s.value = [])
      },
      le = (me, Ie) => {
        const qe = [Te(me.value), vs(Te(me.value), +_.value.autoRange)];
        E(qe) ? (Ie && X(me.value), s.value = qe) : t("invalid-date", me.value)
      },
      X = me => {
        const Ie = ft(Te(me)),
          qe = Xe(Te(me));
        if (J(0, Ie, qe), p.value.count > 0)
          for (let xe = 1; xe < p.value.count; xe++) {
            const $e = nZ(jt(Te(me), {
              year: Q.value(xe - 1),
              month: _e.value(xe - 1)
            }));
            J(xe, $e.month, $e.year)
          }
      },
      ve = me => {
        if (B(me.value) || !S(me.value, l.value, _.value.fixedStart ? 0 : 1)) return t("invalid-date", me.value);
        s.value = L7(Te(me.value), l, t, _)
      },
      Se = (me, Ie) => {
        if (ce(), _.value.autoRange) return le(me, Ie);
        if (_.value.fixedStart || _.value.fixedEnd) return ve(me);
        s.value[0] ? S(Te(me.value), l.value) && !B(me.value) ? on(Te(me.value), Te(s.value[0])) ? (s.value.unshift(Te(me.value)), t("range-end", s.value[0])) : (s.value[1] = Te(me.value), t("range-end", s.value[1])) : (e.autoApply && t("auto-apply-invalid", me.value), t("invalid-date", me.value)) : (s.value[0] = Te(me.value), t("range-start", s.value[0]))
      },
      He = (me = !0) => e.enableSeconds ? Array.isArray(d.seconds) ? me ? d.seconds[0] : d.seconds[1] : d.seconds : 0,
      Ve = me => {
        s.value[me] = Mo(s.value[me], d.hours[me], d.minutes[me], He(me !== 1))
      },
      sn = () => {
        var me, Ie;
        s.value[0] && s.value[1] && +((me = s.value) == null ? void 0 : me[0]) > +((Ie = s.value) == null ? void 0 : Ie[1]) && (s.value.reverse(), t("range-start", s.value[0]), t("range-end", s.value[1]))
      },
      Ut = () => {
        s.value.length && (s.value[0] && !s.value[1] ? Ve(0) : (Ve(0), Ve(1), r()), sn(), l.value = s.value.slice(), a1(s.value, t, e.autoApply, e.modelAuto))
      },
      On = (me, Ie = !1) => {
        if (x(me.value) || !me.current && e.hideOffsetDates) return t("invalid-date", me.value);
        if (o.value = JSON.parse(JSON.stringify(me)), !_.value.enabled) return K(me);
        h3(d.hours) && h3(d.minutes) && !b.value.enabled && (Se(me, Ie), Ut())
      },
      Xn = (me, Ie) => {
        var qe;
        J(me, Ie.month, Ie.year, !0), p.value.count && !p.value.solo && ye(me), t("update-month-year", {
          instance: me,
          month: Ie.month,
          year: Ie.year
        }), n(p.value.solo ? me : void 0);
        const xe = (qe = e.flow) != null && qe.length ? e.flow[e.flowStep] : void 0;
        !Ie.fromNav && (xe === Yn.month || xe === Yn.year) && r()
      },
      oa = (me, Ie) => {
        D7({
          value: me,
          modelValue: l,
          range: _.value.enabled,
          timezone: Ie ? void 0 : C.value.timezone
        }), ee(), e.multiCalendars && Ot().then(() => ae(!0))
      },
      el = () => {
        const me = Wg(Te(), C.value);
        !_.value.enabled && !b.value.enabled ? l.value = me : l.value && Array.isArray(l.value) && l.value[0] ? b.value.enabled ? l.value = [...l.value, me] : l.value = on(me, l.value[0]) ? [me, l.value[0]] : [l.value[0], me] : l.value = [me], ee()
      },
      Dn = () => {
        if (Array.isArray(l.value))
          if (b.value.enabled) {
            const me = vr();
            l.value[l.value.length - 1] = j(me)
          } else l.value = l.value.map((me, Ie) => me && j(me, Ie));
        else l.value = j(l.value);
        t("time-update")
      },
      vr = () => Array.isArray(l.value) && l.value.length ? l.value[l.value.length - 1] : null;
    return {
      calendars: c,
      modelValue: l,
      month: _e,
      year: Q,
      time: d,
      disabledTimesConfig: Y,
      today: f,
      validateTime: ne,
      getCalendarDays: F,
      getMarker: O,
      handleScroll: I,
      handleSwipe: W,
      handleArrow: M,
      selectDate: On,
      updateMonthYear: Xn,
      presetDate: oa,
      selectCurrentDate: el,
      updateTime: (me, Ie = !0, qe = !1) => {
        T(me, Ie, qe, Dn)
      },
      assignMonthAndYear: be
    }
  },
  mJ = {
    key: 0
  },
  gJ = te({
    __name: "DatePicker",
    props: {
      ...Is
    },
    emits: ["tooltip-open", "tooltip-close", "mount", "update:internal-model-value", "update-flow-step", "reset-flow", "auto-apply", "focus-menu", "select-date", "range-start", "range-end", "invalid-fixed-range", "time-update", "am-pm-change", "time-picker-open", "time-picker-close", "recalculate-position", "update-month-year", "auto-apply-invalid", "date-update", "invalid-date", "overlay-toggle"],
    setup(e, {
      expose: t,
      emit: n
    }) {
      const r = n,
        s = e,
        {
          calendars: a,
          month: o,
          year: i,
          modelValue: l,
          time: c,
          disabledTimesConfig: d,
          today: f,
          validateTime: p,
          getCalendarDays: h,
          getMarker: _,
          handleArrow: v,
          handleScroll: C,
          handleSwipe: y,
          selectDate: b,
          updateMonthYear: w,
          presetDate: x,
          selectCurrentDate: E,
          updateTime: S,
          assignMonthAndYear: T
        } = hJ(s, r, ke, be),
        j = zo(),
        {
          setHoverDate: P,
          getDayClassData: N,
          clearHoverDate: ne
        } = OJ(l, s),
        {
          defaultedMultiCalendars: Y
        } = tn(s),
        _e = U([]),
        Q = U([]),
        re = U(null),
        J = Fr(j, "calendar"),
        ee = Fr(j, "monthYear"),
        de = Fr(j, "timePicker"),
        se = I => {
          s.shadow || r("mount", I)
        };
      Ne(a, () => {
        s.shadow || setTimeout(() => {
          r("recalculate-position")
        }, 0)
      }, {
        deep: !0
      }), Ne(Y, (I, M) => {
        I.count - M.count > 0 && T()
      }, {
        deep: !0
      });
      const ae = L(() => I => h(o.value(I), i.value(I)).map(M => ({
        ...M,
        days: M.days.map(W => (W.marker = _(W), W.classData = N(W), W))
      })));

      function ke(I) {
        var M;
        I || I === 0 ? (M = Q.value[I]) == null || M.triggerTransition(o.value(I), i.value(I)) : Q.value.forEach((W, O) => W.triggerTransition(o.value(O), i.value(O)))
      }

      function be() {
        r("update-flow-step")
      }
      const ge = (I, M = !1) => {
          b(I, M), s.spaceConfirm && r("select-date")
        },
        H = (I, M, W = 0) => {
          var O;
          (O = _e.value[W]) == null || O.toggleMonthPicker(I, M)
        },
        oe = (I, M, W = 0) => {
          var O;
          (O = _e.value[W]) == null || O.toggleYearPicker(I, M)
        },
        Ce = (I, M, W) => {
          var O;
          (O = re.value) == null || O.toggleTimePicker(I, M, W)
        },
        D = (I, M) => {
          var W;
          if (!s.range) {
            const O = l.value ? l.value : f,
              q = M ? new Date(M) : O,
              he = I ? Ps(q, {
                weekStartsOn: 1
              }) : o7(q, {
                weekStartsOn: 1
              });
            b({
              value: he,
              current: ft(q) === o.value(0),
              text: "",
              classData: {}
            }), (W = document.getElementById($7(he))) == null || W.focus()
          }
        },
        pe = I => {
          var M;
          (M = _e.value[0]) == null || M.handleMonthYearChange(I, !0)
        },
        ye = I => {
          w(0, {
            month: o.value(0),
            year: i.value(0) + (I ? 1 : -1),
            fromNav: !0
          })
        },
        Ae = (I, M) => {
          I === Yn.time && r(`time-picker-${M?"open":"close"}`), r("overlay-toggle", {
            open: M,
            overlay: I
          })
        },
        fe = I => {
          r("overlay-toggle", {
            open: !1,
            overlay: I
          }), r("focus-menu")
        };
      return t({
        clearHoverDate: ne,
        presetDate: x,
        selectCurrentDate: E,
        toggleMonthPicker: H,
        toggleYearPicker: oe,
        toggleTimePicker: Ce,
        handleArrow: v,
        updateMonthYear: w,
        getSidebarProps: () => ({
          modelValue: l,
          month: o,
          year: i,
          time: c,
          updateTime: S,
          updateMonthYear: w,
          selectDate: b,
          presetDate: x
        }),
        changeMonth: pe,
        changeYear: ye,
        selectWeekDate: D
      }), (I, M) => (g(), k(Ee, null, [$(s1, {
        "multi-calendars": u(Y).count,
        collapse: I.collapse,
        "is-mobile": I.isMobile
      }, {
        default: V(({
          instance: W,
          index: O
        }) => [I.disableMonthYearSelect ? z("", !0) : (g(), G(oJ, Le({
          key: 0,
          ref: q => {
            q && (_e.value[O] = q)
          },
          months: u(b7)(I.formatLocale, I.locale, I.monthNameFormat),
          years: u(Gg)(I.yearRange, I.locale, I.reverseYears),
          month: u(o)(W),
          year: u(i)(W),
          instance: W
        }, I.$props, {
          onMount: M[0] || (M[0] = q => se(u(Ii).header)),
          onResetFlow: M[1] || (M[1] = q => I.$emit("reset-flow")),
          onUpdateMonthYear: q => u(w)(W, q),
          onOverlayClosed: fe,
          onOverlayOpened: M[2] || (M[2] = q => I.$emit("overlay-toggle", {
            open: !0,
            overlay: q
          }))
        }), Qn({
          _: 2
        }, [Je(u(ee), (q, he) => ({
          name: q,
          fn: V(A => [ie(I.$slots, q, Nt(Qt(A)))])
        }))]), 1040, ["months", "years", "month", "year", "instance", "onUpdateMonthYear"])), $(pJ, Le({
          ref: q => {
            q && (Q.value[O] = q)
          },
          "mapped-dates": ae.value(W),
          month: u(o)(W),
          year: u(i)(W),
          instance: W
        }, I.$props, {
          onSelectDate: q => u(b)(q, W !== 1),
          onHandleSpace: q => ge(q, W !== 1),
          onSetHoverDate: M[3] || (M[3] = q => u(P)(q)),
          onHandleScroll: q => u(C)(q, W),
          onHandleSwipe: q => u(y)(q, W),
          onMount: M[4] || (M[4] = q => se(u(Ii).calendar)),
          onResetFlow: M[5] || (M[5] = q => I.$emit("reset-flow")),
          onTooltipOpen: M[6] || (M[6] = q => I.$emit("tooltip-open", q)),
          onTooltipClose: M[7] || (M[7] = q => I.$emit("tooltip-close", q))
        }), Qn({
          _: 2
        }, [Je(u(J), (q, he) => ({
          name: q,
          fn: V(A => [ie(I.$slots, q, Nt(Qt({
            ...A
          })))])
        }))]), 1040, ["mapped-dates", "month", "year", "instance", "onSelectDate", "onHandleSpace", "onHandleScroll", "onHandleSwipe"])]),
        _: 3
      }, 8, ["multi-calendars", "collapse", "is-mobile"]), I.enableTimePicker ? (g(), k("div", mJ, [I.$slots["time-picker"] ? ie(I.$slots, "time-picker", Nt(Le({
        key: 0
      }, {
        time: u(c),
        updateTime: u(S)
      }))) : (g(), G(N7, Le({
        key: 1,
        ref_key: "timePickerRef",
        ref: re
      }, I.$props, {
        hours: u(c).hours,
        minutes: u(c).minutes,
        seconds: u(c).seconds,
        "internal-model-value": I.internalModelValue,
        "disabled-times-config": u(d),
        "validate-time": u(p),
        onMount: M[8] || (M[8] = W => se(u(Ii).timePicker)),
        "onUpdate:hours": M[9] || (M[9] = W => u(S)(W)),
        "onUpdate:minutes": M[10] || (M[10] = W => u(S)(W, !1)),
        "onUpdate:seconds": M[11] || (M[11] = W => u(S)(W, !1, !0)),
        onResetFlow: M[12] || (M[12] = W => I.$emit("reset-flow")),
        onOverlayClosed: M[13] || (M[13] = W => Ae(W, !1)),
        onOverlayOpened: M[14] || (M[14] = W => Ae(W, !0)),
        onAmPmChange: M[15] || (M[15] = W => I.$emit("am-pm-change", W))
      }), Qn({
        _: 2
      }, [Je(u(de), (W, O) => ({
        name: W,
        fn: V(q => [ie(I.$slots, W, Nt(Qt(q)))])
      }))]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config", "validate-time"]))])) : z("", !0)], 64))
    }
  }),
  vJ = (e, t) => {
    const n = U(),
      {
        defaultedMultiCalendars: r,
        defaultedConfig: s,
        defaultedHighlight: a,
        defaultedRange: o,
        propDates: i,
        defaultedFilters: l,
        defaultedMultiDates: c
      } = tn(e),
      {
        modelValue: d,
        year: f,
        month: p,
        calendars: h
      } = kd(e, t),
      {
        isDisabled: _
      } = ti(e),
      {
        selectYear: v,
        groupedYears: C,
        showYearPicker: y,
        isDisabled: b,
        toggleYearPicker: w,
        handleYearSelect: x,
        handleYear: E
      } = R7({
        modelValue: d,
        multiCalendars: r,
        range: o,
        highlight: a,
        calendars: h,
        propDates: i,
        month: p,
        year: f,
        filters: l,
        props: e,
        emit: t
      }),
      S = (re, J) => [re, J].map(ee => Js(ee, "MMMM", {
        locale: e.formatLocale
      })).join("-"),
      T = L(() => re => d.value ? Array.isArray(d.value) ? d.value.some(J => a3(re, J)) : a3(d.value, re) : !1),
      j = re => {
        if (o.value.enabled) {
          if (Array.isArray(d.value)) {
            const J = mt(re, d.value[0]) || mt(re, d.value[1]);
            return n1(d.value, n.value, re) && !J
          }
          return !1
        }
        return !1
      },
      P = (re, J) => re.quarter === Xy(J) && re.year === Xe(J),
      N = re => typeof a.value == "function" ? a.value({
        quarter: Xy(re),
        year: Xe(re)
      }) : !!a.value.quarters.find(J => P(J, re)),
      ne = L(() => re => {
        const J = jt(new Date, {
          year: f.value(re)
        });
        return GQ({
          start: Hc(J),
          end: a7(J)
        }).map(ee => {
          const de = fi(ee),
            se = e3(ee),
            ae = _(ee),
            ke = j(de),
            be = N(de);
          return {
            text: S(de, se),
            value: de,
            active: T.value(de),
            highlighted: be,
            disabled: ae,
            isBetween: ke
          }
        })
      }),
      Y = re => {
        Zg(re, d, c.value.limit), t("auto-apply", !0)
      },
      _e = re => {
        d.value = Jg(d, re, t), a1(d.value, t, e.autoApply, e.modelAuto)
      },
      Q = re => {
        d.value = re, t("auto-apply")
      };
    return {
      defaultedConfig: s,
      defaultedMultiCalendars: r,
      groupedYears: C,
      year: f,
      isDisabled: b,
      quarters: ne,
      showYearPicker: y,
      modelValue: d,
      setHoverDate: re => {
        n.value = re
      },
      selectYear: v,
      selectQuarter: (re, J, ee) => {
        if (!ee) return h.value[J].month = ft(e3(re)), c.value.enabled ? Y(re) : o.value.enabled ? _e(re) : Q(re)
      },
      toggleYearPicker: w,
      handleYearSelect: x,
      handleYear: E
    }
  },
  _J = {
    class: "dp--quarter-items"
  },
  yJ = ["data-test-id", "disabled", "onClick", "onMouseover"],
  bJ = te({
    compatConfig: {
      MODE: 3
    },
    __name: "QuarterPicker",
    props: {
      ...Is
    },
    emits: ["update:internal-model-value", "reset-flow", "overlay-closed", "auto-apply", "range-start", "range-end", "overlay-toggle", "update-month-year"],
    setup(e, {
      expose: t,
      emit: n
    }) {
      const r = n,
        s = e,
        a = zo(),
        o = Fr(a, "yearMode"),
        {
          defaultedMultiCalendars: i,
          defaultedConfig: l,
          groupedYears: c,
          year: d,
          isDisabled: f,
          quarters: p,
          modelValue: h,
          showYearPicker: _,
          setHoverDate: v,
          selectQuarter: C,
          toggleYearPicker: y,
          handleYearSelect: b,
          handleYear: w
        } = vJ(s, r);
      return t({
        getSidebarProps: () => ({
          modelValue: h,
          year: d,
          selectQuarter: C,
          handleYearSelect: b,
          handleYear: w
        })
      }), (x, E) => (g(), G(s1, {
        "multi-calendars": u(i).count,
        collapse: x.collapse,
        stretch: "",
        "is-mobile": x.isMobile
      }, {
        default: V(({
          instance: S
        }) => [m("div", {
          class: "dp-quarter-picker-wrap",
          style: Mt({
            minHeight: `${u(l).modeHeight}px`
          })
        }, [x.$slots["top-extra"] ? ie(x.$slots, "top-extra", {
          key: 0,
          value: x.internalModelValue
        }) : z("", !0), m("div", null, [$(O7, Le(x.$props, {
          items: u(c)(S),
          instance: S,
          "show-year-picker": u(_)[S],
          year: u(d)(S),
          "is-disabled": T => u(f)(S, T),
          onHandleYear: T => u(w)(S, T),
          onYearSelect: T => u(b)(T, S),
          onToggleYearPicker: T => u(y)(S, T == null ? void 0 : T.flow, T == null ? void 0 : T.show)
        }), Qn({
          _: 2
        }, [Je(u(o), (T, j) => ({
          name: T,
          fn: V(P => [ie(x.$slots, T, Nt(Qt(P)))])
        }))]), 1040, ["items", "instance", "show-year-picker", "year", "is-disabled", "onHandleYear", "onYearSelect", "onToggleYearPicker"])]), m("div", _J, [(g(!0), k(Ee, null, Je(u(p)(S), (T, j) => (g(), k("div", {
          key: j
        }, [m("button", {
          type: "button",
          class: we(["dp--qr-btn", {
            "dp--qr-btn-active": T.active,
            "dp--qr-btn-between": T.isBetween,
            "dp--qr-btn-disabled": T.disabled,
            "dp--highlighted": T.highlighted
          }]),
          "data-test-id": T.value,
          disabled: T.disabled,
          onClick: P => u(C)(T.value, S, T.disabled),
          onMouseover: P => u(v)(T.value)
        }, [x.$slots.quarter ? ie(x.$slots, "quarter", {
          key: 0,
          value: T.value,
          text: T.text
        }) : (g(), k(Ee, {
          key: 1
        }, [Ye(R(T.text), 1)], 64))], 42, yJ)]))), 128))])], 4)]),
        _: 3
      }, 8, ["multi-calendars", "collapse", "is-mobile"]))
    }
  }),
  B7 = (e, t) => {
    const n = U(0);
    Ge(() => {
      r(), window.addEventListener("resize", r, {
        passive: !0
      })
    }), en(() => {
      window.removeEventListener("resize", r)
    });
    const r = () => {
      n.value = window.document.documentElement.clientWidth
    };
    return {
      isMobile: L(() => n.value <= e.value.mobileBreakpoint && !t ? !0 : void 0)
    }
  },
  wJ = ["id", "tabindex", "role", "aria-label"],
  CJ = {
    key: 0,
    class: "dp--menu-load-container"
  },
  xJ = {
    key: 1,
    class: "dp--menu-header"
  },
  kJ = ["data-dp-mobile"],
  SJ = {
    key: 0,
    class: "dp__sidebar_left"
  },
  EJ = ["data-dp-mobile"],
  TJ = ["data-test-id", "data-dp-mobile", "onClick", "onKeydown"],
  AJ = {
    key: 2,
    class: "dp__sidebar_right"
  },
  PJ = {
    key: 3,
    class: "dp__action_extra"
  },
  m3 = te({
    compatConfig: {
      MODE: 3
    },
    __name: "DatepickerMenu",
    props: {
      ...r1,
      shadow: {
        type: Boolean,
        default: !1
      },
      openOnTop: {
        type: Boolean,
        default: !1
      },
      internalModelValue: {
        type: [Date, Array],
        default: null
      },
      noOverlayFocus: {
        type: Boolean,
        default: !1
      },
      collapse: {
        type: Boolean,
        default: !1
      },
      getInputRect: {
        type: Function,
        default: () => ({})
      },
      isTextInputDate: {
        type: Boolean,
        default: !1
      }
    },
    emits: ["close-picker", "select-date", "auto-apply", "time-update", "flow-step", "update-month-year", "invalid-select", "update:internal-model-value", "recalculate-position", "invalid-fixed-range", "tooltip-open", "tooltip-close", "time-picker-open", "time-picker-close", "am-pm-change", "range-start", "range-end", "auto-apply-invalid", "date-update", "invalid-date", "overlay-toggle", "menu-blur"],
    setup(e, {
      expose: t,
      emit: n
    }) {
      const r = n,
        s = e,
        a = U(null),
        o = L(() => {
          const {
            openOnTop: B,
            ...ce
          } = s;
          return {
            ...ce,
            isMobile: v.value,
            flowStep: ne.value,
            menuWrapRef: a.value
          }
        }),
        {
          setMenuFocused: i,
          setShiftKey: l,
          control: c
        } = M7(),
        d = zo(),
        {
          defaultedTextInput: f,
          defaultedInline: p,
          defaultedConfig: h,
          defaultedUI: _
        } = tn(s),
        {
          isMobile: v
        } = B7(h, s.shadow),
        C = U(null),
        y = U(0),
        b = U(null),
        w = U(!1),
        x = U(null),
        E = U(!1);
      Ge(() => {
        if (!s.shadow) {
          w.value = !0, S(), window.addEventListener("resize", S);
          const B = Sn(a);
          if (B && !f.value.enabled && !p.value.enabled && (i(!0), de()), B) {
            const ce = le => {
              E.value = !0, h.value.allowPreventDefault && le.preventDefault(), $o(le, h.value, !0)
            };
            B.addEventListener("pointerdown", ce), B.addEventListener("mousedown", ce)
          }
        }
        document.addEventListener("mousedown", K)
      }), en(() => {
        window.removeEventListener("resize", S), document.addEventListener("mousedown", K)
      });
      const S = () => {
          const B = Sn(b);
          B && (y.value = B.getBoundingClientRect().width)
        },
        {
          arrowRight: T,
          arrowLeft: j,
          arrowDown: P,
          arrowUp: N
        } = ei(),
        {
          flowStep: ne,
          updateFlowStep: Y,
          childMount: _e,
          resetFlow: Q,
          handleFlow: re
        } = DJ(s, r, x),
        J = L(() => s.monthPicker ? FZ : s.yearPicker ? jZ : s.timePicker ? eJ : s.quarterPicker ? bJ : gJ),
        ee = L(() => {
          var B;
          if (h.value.arrowLeft) return h.value.arrowLeft;
          const ce = (B = a.value) == null ? void 0 : B.getBoundingClientRect(),
            le = s.getInputRect();
          return (le == null ? void 0 : le.width) < (y == null ? void 0 : y.value) && (le == null ? void 0 : le.left) <= ((ce == null ? void 0 : ce.left) ?? 0) ? `${(le==null?void 0:le.width)/2}px` : (le == null ? void 0 : le.right) >= ((ce == null ? void 0 : ce.right) ?? 0) && (le == null ? void 0 : le.width) < (y == null ? void 0 : y.value) ? `${(y==null?void 0:y.value)-(le==null?void 0:le.width)/2}px` : "50%"
        }),
        de = () => {
          const B = Sn(a);
          B && B.focus({
            preventScroll: !0
          })
        },
        se = L(() => {
          var B;
          return ((B = x.value) == null ? void 0 : B.getSidebarProps()) || {}
        }),
        ae = () => {
          s.openOnTop && r("recalculate-position")
        },
        ke = Fr(d, "action"),
        be = L(() => s.monthPicker || s.yearPicker ? Fr(d, "monthYear") : s.timePicker ? Fr(d, "timePicker") : Fr(d, "shared")),
        ge = L(() => s.openOnTop ? "dp__arrow_bottom" : "dp__arrow_top"),
        H = L(() => ({
          dp__menu_disabled: s.disabled,
          dp__menu_readonly: s.readonly,
          "dp-menu-loading": s.loading
        })),
        oe = L(() => ({
          dp__menu: !0,
          dp__menu_index: !p.value.enabled,
          dp__relative: p.value.enabled,
          ..._.value.menu ?? {}
        })),
        Ce = B => {
          $o(B, h.value, !0)
        },
        D = () => {
          s.escClose && r("close-picker")
        },
        pe = B => {
          if (s.arrowNavigation) {
            if (B === tr.up) return N();
            if (B === tr.down) return P();
            if (B === tr.left) return j();
            if (B === tr.right) return T()
          } else B === tr.left || B === tr.up ? M("handleArrow", tr.left, 0, B === tr.up) : M("handleArrow", tr.right, 0, B === tr.down)
        },
        ye = B => {
          l(B.shiftKey), !s.disableMonthYearSelect && B.code === Gt.tab && B.target.classList.contains("dp__menu") && c.value.shiftKeyInMenu && (B.preventDefault(), $o(B, h.value, !0), r("close-picker"))
        },
        Ae = () => {
          de(), r("time-picker-close")
        },
        fe = B => {
          var ce, le, X;
          (ce = x.value) == null || ce.toggleTimePicker(!1, !1), (le = x.value) == null || le.toggleMonthPicker(!1, !1, B), (X = x.value) == null || X.toggleYearPicker(!1, !1, B)
        },
        I = (B, ce = 0) => {
          var le, X, ve;
          return B === "month" ? (le = x.value) == null ? void 0 : le.toggleMonthPicker(!1, !0, ce) : B === "year" ? (X = x.value) == null ? void 0 : X.toggleYearPicker(!1, !0, ce) : B === "time" ? (ve = x.value) == null ? void 0 : ve.toggleTimePicker(!0, !1) : fe(ce)
        },
        M = (B, ...ce) => {
          var le, X;
          (le = x.value) != null && le[B] && ((X = x.value) == null || X[B](...ce))
        },
        W = () => {
          M("selectCurrentDate")
        },
        O = (B, ce) => {
          M("presetDate", B, ce)
        },
        q = () => {
          M("clearHoverDate")
        },
        he = (B, ce) => {
          M("updateMonthYear", B, ce)
        },
        A = (B, ce) => {
          B.preventDefault(), pe(ce)
        },
        F = B => {
          var ce, le, X;
          if (ye(B), B.key === Gt.home || B.key === Gt.end) return M("selectWeekDate", B.key === Gt.home, B.target.getAttribute("id"));
          switch ((B.key === Gt.pageUp || B.key === Gt.pageDown) && (B.shiftKey ? (M("changeYear", B.key === Gt.pageUp), (ce = Km(a.value, "overlay-year")) == null || ce.focus()) : (M("changeMonth", B.key === Gt.pageUp), (le = Km(a.value, B.key === Gt.pageUp ? "action-prev" : "action-next")) == null || le.focus()), B.target.getAttribute("id") && ((X = a.value) == null || X.focus({
              preventScroll: !0
            }))), B.key) {
            case Gt.esc:
              return D();
            case Gt.arrowLeft:
              return A(B, tr.left);
            case Gt.arrowRight:
              return A(B, tr.right);
            case Gt.arrowUp:
              return A(B, tr.up);
            case Gt.arrowDown:
              return A(B, tr.down);
            default:
              return
          }
        },
        K = B => {
          var ce;
          p.value.enabled && !p.value.input && !((ce = a.value) != null && ce.contains(B.target)) && E.value && (E.value = !1, r("menu-blur"))
        };
      return t({
        updateMonthYear: he,
        switchView: I,
        handleFlow: re
      }), (B, ce) => {
        var le, X, ve;
        return g(), k("div", {
          id: B.uid ? `dp-menu-${B.uid}` : void 0,
          ref_key: "dpMenuRef",
          ref: a,
          tabindex: u(p).enabled ? void 0 : "0",
          role: u(p).enabled ? void 0 : "dialog",
          "aria-label": (le = B.ariaLabels) == null ? void 0 : le.menu,
          class: we(oe.value),
          style: Mt({
            "--dp-arrow-left": ee.value
          }),
          onMouseleave: q,
          onClick: Ce,
          onKeydown: F
        }, [(B.disabled || B.readonly) && u(p).enabled || B.loading ? (g(), k("div", {
          key: 0,
          class: we(H.value)
        }, [B.loading ? (g(), k("div", CJ, ce[19] || (ce[19] = [m("span", {
          class: "dp--menu-loader"
        }, null, -1)]))) : z("", !0)], 2)) : z("", !0), B.$slots["menu-header"] ? (g(), k("div", xJ, [ie(B.$slots, "menu-header")])) : z("", !0), !u(p).enabled && !B.teleportCenter ? (g(), k("div", {
          key: 2,
          class: we(ge.value)
        }, null, 2)) : z("", !0), m("div", {
          ref_key: "innerMenuRef",
          ref: b,
          class: we({
            dp__menu_content_wrapper: ((X = B.presetDates) == null ? void 0 : X.length) || !!B.$slots["left-sidebar"] || !!B.$slots["right-sidebar"],
            "dp--menu-content-wrapper-collapsed": e.collapse && (((ve = B.presetDates) == null ? void 0 : ve.length) || !!B.$slots["left-sidebar"] || !!B.$slots["right-sidebar"])
          }),
          "data-dp-mobile": u(v),
          style: Mt({
            "--dp-menu-width": `${y.value}px`
          })
        }, [B.$slots["left-sidebar"] ? (g(), k("div", SJ, [ie(B.$slots, "left-sidebar", Nt(Qt(se.value)))])) : z("", !0), B.presetDates.length ? (g(), k("div", {
          key: 1,
          class: we({
            "dp--preset-dates-collapsed": e.collapse,
            "dp--preset-dates": !0
          }),
          "data-dp-mobile": u(v)
        }, [(g(!0), k(Ee, null, Je(B.presetDates, (Se, He) => (g(), k(Ee, {
          key: He
        }, [Se.slot ? ie(B.$slots, Se.slot, {
          key: 0,
          presetDate: O,
          label: Se.label,
          value: Se.value
        }) : (g(), k("button", {
          key: 1,
          type: "button",
          style: Mt(Se.style || {}),
          class: we(["dp__btn dp--preset-range", {
            "dp--preset-range-collapsed": e.collapse
          }]),
          "data-test-id": Se.testId ?? void 0,
          "data-dp-mobile": u(v),
          onClick: Er(Ve => O(Se.value, Se.noTz), ["prevent"]),
          onKeydown: Ve => u(ur)(Ve, () => O(Se.value, Se.noTz), !0)
        }, R(Se.label), 47, TJ))], 64))), 128))], 10, EJ)) : z("", !0), m("div", {
          ref_key: "calendarWrapperRef",
          ref: C,
          class: "dp__instance_calendar",
          role: "document"
        }, [(g(), G(Kr(J.value), Le({
          ref_key: "dynCmpRef",
          ref: x
        }, o.value, {
          "flow-step": u(ne),
          onMount: u(_e),
          onUpdateFlowStep: u(Y),
          onResetFlow: u(Q),
          onFocusMenu: de,
          onSelectDate: ce[0] || (ce[0] = Se => B.$emit("select-date")),
          onDateUpdate: ce[1] || (ce[1] = Se => B.$emit("date-update", Se)),
          onTooltipOpen: ce[2] || (ce[2] = Se => B.$emit("tooltip-open", Se)),
          onTooltipClose: ce[3] || (ce[3] = Se => B.$emit("tooltip-close", Se)),
          onAutoApply: ce[4] || (ce[4] = Se => B.$emit("auto-apply", Se)),
          onRangeStart: ce[5] || (ce[5] = Se => B.$emit("range-start", Se)),
          onRangeEnd: ce[6] || (ce[6] = Se => B.$emit("range-end", Se)),
          onInvalidFixedRange: ce[7] || (ce[7] = Se => B.$emit("invalid-fixed-range", Se)),
          onTimeUpdate: ce[8] || (ce[8] = Se => B.$emit("time-update")),
          onAmPmChange: ce[9] || (ce[9] = Se => B.$emit("am-pm-change", Se)),
          onTimePickerOpen: ce[10] || (ce[10] = Se => B.$emit("time-picker-open", Se)),
          onTimePickerClose: Ae,
          onRecalculatePosition: ae,
          onUpdateMonthYear: ce[11] || (ce[11] = Se => B.$emit("update-month-year", Se)),
          onAutoApplyInvalid: ce[12] || (ce[12] = Se => B.$emit("auto-apply-invalid", Se)),
          onInvalidDate: ce[13] || (ce[13] = Se => B.$emit("invalid-date", Se)),
          onOverlayToggle: ce[14] || (ce[14] = Se => B.$emit("overlay-toggle", Se)),
          "onUpdate:internalModelValue": ce[15] || (ce[15] = Se => B.$emit("update:internal-model-value", Se))
        }), Qn({
          _: 2
        }, [Je(be.value, (Se, He) => ({
          name: Se,
          fn: V(Ve => [ie(B.$slots, Se, Nt(Qt({
            ...Ve
          })))])
        }))]), 1040, ["flow-step", "onMount", "onUpdateFlowStep", "onResetFlow"]))], 512), B.$slots["right-sidebar"] ? (g(), k("div", AJ, [ie(B.$slots, "right-sidebar", Nt(Qt(se.value)))])) : z("", !0), B.$slots["action-extra"] ? (g(), k("div", PJ, [B.$slots["action-extra"] ? ie(B.$slots, "action-extra", {
          key: 0,
          selectCurrentDate: W
        }) : z("", !0)])) : z("", !0)], 14, kJ), !B.autoApply || u(h).keepActionRow ? (g(), G(PZ, Le({
          key: 3,
          "menu-mount": w.value
        }, o.value, {
          "calendar-width": y.value,
          onClosePicker: ce[16] || (ce[16] = Se => B.$emit("close-picker")),
          onSelectDate: ce[17] || (ce[17] = Se => B.$emit("select-date")),
          onInvalidSelect: ce[18] || (ce[18] = Se => B.$emit("invalid-select")),
          onSelectNow: W
        }), Qn({
          _: 2
        }, [Je(u(ke), (Se, He) => ({
          name: Se,
          fn: V(Ve => [ie(B.$slots, Se, Nt(Qt({
            ...Ve
          })))])
        }))]), 1040, ["menu-mount", "calendar-width"])) : z("", !0)], 46, wJ)
      }
    }
  });
var pl = (e => (e.center = "center", e.left = "left", e.right = "right", e))(pl || {});
const IJ = ({
    menuRef: e,
    menuRefInner: t,
    inputRef: n,
    pickerWrapperRef: r,
    inline: s,
    emit: a,
    props: o,
    slots: i
  }) => {
    const {
      defaultedConfig: l
    } = tn(o), c = U({}), d = U(!1), f = U({
      top: "0",
      left: "0"
    }), p = U(!1), h = zl(o, "teleportCenter");
    Ne(h, () => {
      f.value = JSON.parse(JSON.stringify({})), E()
    });
    const _ = J => {
        if (o.teleport) {
          const ee = J.getBoundingClientRect();
          return {
            left: ee.left + window.scrollX,
            top: ee.top + window.scrollY
          }
        }
        return {
          top: 0,
          left: 0
        }
      },
      v = (J, ee) => {
        f.value.left = `${J+ee-c.value.width}px`
      },
      C = J => {
        f.value.left = `${J}px`
      },
      y = (J, ee) => {
        o.position === pl.left && C(J), o.position === pl.right && v(J, ee), o.position === pl.center && (f.value.left = `${J+ee/2-c.value.width/2}px`)
      },
      b = J => {
        const {
          width: ee,
          height: de
        } = J.getBoundingClientRect(), {
          top: se,
          left: ae
        } = _(J);
        return {
          top: +se,
          left: +ae,
          width: ee,
          height: de
        }
      },
      w = () => {
        f.value.left = "50%", f.value.top = "50%", f.value.transform = "translate(-50%, -50%)", f.value.position = "fixed", delete f.value.opacity
      },
      x = () => {
        const J = Sn(n);
        f.value = o.altPosition(J)
      },
      E = (J = !0) => {
        var ee;
        if (!s.value.enabled) {
          if (h.value) return w();
          if (o.altPosition !== null) return x();
          if (J) {
            const de = o.teleport ? (ee = t.value) == null ? void 0 : ee.$el : e.value;
            de && (c.value = de.getBoundingClientRect()), a("recalculate-position")
          }
          return Y()
        }
      },
      S = ({
        inputEl: J,
        left: ee,
        width: de
      }) => {
        window.screen.width > 768 && !d.value && y(ee, de), P(J)
      },
      T = J => {
        const {
          top: ee,
          left: de,
          height: se,
          width: ae
        } = b(J);
        f.value.top = `${se+ee+ +o.offset}px`, p.value = !1, d.value || (f.value.left = `${de+ae/2-c.value.width/2}px`), S({
          inputEl: J,
          left: de,
          width: ae
        })
      },
      j = J => {
        const {
          top: ee,
          left: de,
          width: se
        } = b(J);
        f.value.top = `${ee-+o.offset-c.value.height}px`, p.value = !0, S({
          inputEl: J,
          left: de,
          width: se
        })
      },
      P = J => {
        if (o.autoPosition) {
          const {
            left: ee,
            width: de
          } = b(J), {
            left: se,
            right: ae
          } = c.value;
          if (!d.value) {
            if (Math.abs(se) !== Math.abs(ae)) {
              if (se <= 0) return d.value = !0, C(ee);
              if (ae >= document.documentElement.clientWidth) return d.value = !0, v(ee, de)
            }
            return y(ee, de)
          }
        }
      },
      N = () => {
        const J = Sn(n);
        if (J) {
          if (o.autoPosition === is.top) return is.top;
          if (o.autoPosition === is.bottom) return is.bottom;
          const {
            height: ee
          } = c.value, {
            top: de,
            height: se
          } = J.getBoundingClientRect(), ae = window.innerHeight - de - se, ke = de;
          return ee <= ae ? is.bottom : ee > ae && ee <= ke ? is.top : ae >= ke ? is.bottom : is.top
        }
        return is.bottom
      },
      ne = J => N() === is.bottom ? T(J) : j(J),
      Y = () => {
        const J = Sn(n);
        if (J) return o.autoPosition ? ne(J) : T(J)
      },
      _e = function(J) {
        if (J) {
          const ee = J.scrollHeight > J.clientHeight,
            de = window.getComputedStyle(J).overflowY.indexOf("hidden") !== -1;
          return ee && !de
        }
        return !0
      },
      Q = function(J) {
        return !J || J === document.body || J.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? window : _e(J) ? J : Q(J.assignedSlot && l.value.shadowDom ? J.assignedSlot.parentNode : J.parentNode)
      },
      re = J => {
        if (J) switch (o.position) {
          case pl.left:
            return {
              left: 0, transform: "translateX(0)"
            };
          case pl.right:
            return {
              left: `${J.width}px`, transform: "translateX(-100%)"
            };
          default:
            return {
              left: `${J.width/2}px`, transform: "translateX(-50%)"
            }
        }
        return {}
      };
    return {
      openOnTop: p,
      menuStyle: f,
      xCorrect: d,
      setMenuPosition: E,
      getScrollableParent: Q,
      shadowRender: (J, ee) => {
        var de, se, ae;
        const ke = document.createElement("div"),
          be = (de = Sn(n)) == null ? void 0 : de.getBoundingClientRect();
        ke.setAttribute("id", "dp--temp-container");
        const ge = (se = r.value) != null && se.clientWidth ? r.value : document.body;
        ge.append(ke);
        const H = re(be),
          oe = l.value.shadowDom ? Object.keys(i).filter(D => ["right-sidebar", "left-sidebar", "top-extra", "action-extra"].includes(D)) : Object.keys(i),
          Ce = yn(J, {
            ...ee,
            shadow: !0,
            style: {
              opacity: 0,
              position: "absolute",
              ...H
            }
          }, Object.fromEntries(oe.map(D => [D, i[D]])));
        U2(Ce, ke), c.value = (ae = Ce.el) == null ? void 0 : ae.getBoundingClientRect(), U2(null, ke), ge.removeChild(ke)
      }
    }
  },
  ao = [{
    name: "clock-icon",
    use: ["time", "calendar", "shared"]
  }, {
    name: "arrow-left",
    use: ["month-year", "calendar", "shared", "year-mode"]
  }, {
    name: "arrow-right",
    use: ["month-year", "calendar", "shared", "year-mode"]
  }, {
    name: "arrow-up",
    use: ["time", "calendar", "month-year", "shared"]
  }, {
    name: "arrow-down",
    use: ["time", "calendar", "month-year", "shared"]
  }, {
    name: "calendar-icon",
    use: ["month-year", "time", "calendar", "shared", "year-mode"]
  }, {
    name: "day",
    use: ["calendar", "shared"]
  }, {
    name: "month-overlay-value",
    use: ["calendar", "month-year", "shared"]
  }, {
    name: "year-overlay-value",
    use: ["calendar", "month-year", "shared", "year-mode"]
  }, {
    name: "year-overlay",
    use: ["month-year", "shared"]
  }, {
    name: "month-overlay",
    use: ["month-year", "shared"]
  }, {
    name: "month-overlay-header",
    use: ["month-year", "shared"]
  }, {
    name: "year-overlay-header",
    use: ["month-year", "shared"]
  }, {
    name: "hours-overlay-value",
    use: ["calendar", "time", "shared"]
  }, {
    name: "hours-overlay-header",
    use: ["calendar", "time", "shared"]
  }, {
    name: "minutes-overlay-value",
    use: ["calendar", "time", "shared"]
  }, {
    name: "minutes-overlay-header",
    use: ["calendar", "time", "shared"]
  }, {
    name: "seconds-overlay-value",
    use: ["calendar", "time", "shared"]
  }, {
    name: "seconds-overlay-header",
    use: ["calendar", "time", "shared"]
  }, {
    name: "hours",
    use: ["calendar", "time", "shared"]
  }, {
    name: "minutes",
    use: ["calendar", "time", "shared"]
  }, {
    name: "month",
    use: ["calendar", "month-year", "shared"]
  }, {
    name: "year",
    use: ["calendar", "month-year", "shared", "year-mode"]
  }, {
    name: "action-buttons",
    use: ["action"]
  }, {
    name: "action-preview",
    use: ["action"]
  }, {
    name: "calendar-header",
    use: ["calendar", "shared"]
  }, {
    name: "marker-tooltip",
    use: ["calendar", "shared"]
  }, {
    name: "action-extra",
    use: ["menu"]
  }, {
    name: "time-picker-overlay",
    use: ["calendar", "time", "shared"]
  }, {
    name: "am-pm-button",
    use: ["calendar", "time", "shared"]
  }, {
    name: "left-sidebar",
    use: ["menu"]
  }, {
    name: "right-sidebar",
    use: ["menu"]
  }, {
    name: "month-year",
    use: ["month-year", "shared"]
  }, {
    name: "time-picker",
    use: ["menu", "shared"]
  }, {
    name: "action-row",
    use: ["action"]
  }, {
    name: "marker",
    use: ["calendar", "shared"]
  }, {
    name: "quarter",
    use: ["shared"]
  }, {
    name: "top-extra",
    use: ["shared", "month-year"]
  }, {
    name: "tp-inline-arrow-up",
    use: ["shared", "time"]
  }, {
    name: "tp-inline-arrow-down",
    use: ["shared", "time"]
  }, {
    name: "menu-header",
    use: ["menu"]
  }],
  $J = [{
    name: "trigger"
  }, {
    name: "input-icon"
  }, {
    name: "clear-icon"
  }, {
    name: "dp-input"
  }],
  MJ = {
    all: () => ao,
    monthYear: () => ao.filter(e => e.use.includes("month-year")),
    input: () => $J,
    timePicker: () => ao.filter(e => e.use.includes("time")),
    action: () => ao.filter(e => e.use.includes("action")),
    calendar: () => ao.filter(e => e.use.includes("calendar")),
    menu: () => ao.filter(e => e.use.includes("menu")),
    shared: () => ao.filter(e => e.use.includes("shared")),
    yearMode: () => ao.filter(e => e.use.includes("year-mode"))
  },
  Fr = (e, t, n) => {
    const r = [];
    return MJ[t]().forEach(s => {
      e[s.name] && r.push(s.name)
    }), n != null && n.length && n.forEach(s => {
      s.slot && r.push(s.slot)
    }), r
  },
  xd = e => {
    const t = L(() => r => e.value ? r ? e.value.open : e.value.close : ""),
      n = L(() => r => e.value ? r ? e.value.menuAppearTop : e.value.menuAppearBottom : "");
    return {
      transitionName: t,
      showTransition: !!e.value,
      menuTransition: n
    }
  },
  kd = (e, t, n) => {
    const {
      defaultedRange: r,
      defaultedTz: s
    } = tn(e), a = Te(Ir(Te(), s.value.timezone)), o = U([{
      month: ft(a),
      year: Xe(a)
    }]), i = p => {
      const h = {
        hours: za(a),
        minutes: Uo(a),
        seconds: 0
      };
      return r.value.enabled ? [h[p], h[p]] : h[p]
    }, l = xn({
      hours: i("hours"),
      minutes: i("minutes"),
      seconds: i("seconds")
    });
    Ne(r, (p, h) => {
      p.enabled !== h.enabled && (l.hours = i("hours"), l.minutes = i("minutes"), l.seconds = i("seconds"))
    }, {
      deep: !0
    });
    const c = L({
        get: () => e.internalModelValue,
        set: p => {
          !e.readonly && !e.disabled && t("update:internal-model-value", p)
        }
      }),
      d = L(() => p => o.value[p] ? o.value[p].month : 0),
      f = L(() => p => o.value[p] ? o.value[p].year : 0);
    return Ne(c, (p, h) => {
      n && JSON.stringify(p ?? {}) !== JSON.stringify(h ?? {}) && n()
    }, {
      deep: !0
    }), {
      calendars: o,
      time: l,
      modelValue: c,
      month: d,
      year: f,
      today: a
    }
  },
  OJ = (e, t) => {
    const {
      defaultedMultiCalendars: n,
      defaultedMultiDates: r,
      defaultedUI: s,
      defaultedHighlight: a,
      defaultedTz: o,
      propDates: i,
      defaultedRange: l
    } = tn(t), {
      isDisabled: c
    } = ti(t), d = U(null), f = U(Ir(new Date, o.value.timezone)), p = H => {
      !H.current && t.hideOffsetDates || (d.value = H.value)
    }, h = () => {
      d.value = null
    }, _ = H => Array.isArray(e.value) && l.value.enabled && e.value[0] && d.value ? H ? fn(d.value, e.value[0]) : on(d.value, e.value[0]) : !0, v = (H, oe) => {
      const Ce = () => e.value ? oe ? e.value[0] || null : e.value[1] : null,
        D = e.value && Array.isArray(e.value) ? Ce() : null;
      return mt(Te(H.value), D)
    }, C = H => {
      const oe = Array.isArray(e.value) ? e.value[0] : null;
      return H ? !on(d.value ?? null, oe) : !0
    }, y = (H, oe = !0) => (l.value.enabled || t.weekPicker) && Array.isArray(e.value) && e.value.length === 2 ? t.hideOffsetDates && !H.current ? !1 : mt(Te(H.value), e.value[oe ? 0 : 1]) : l.value.enabled ? v(H, oe) && C(oe) || mt(H.value, Array.isArray(e.value) ? e.value[0] : null) && _(oe) : !1, b = (H, oe) => {
      if (Array.isArray(e.value) && e.value[0] && e.value.length === 1) {
        const Ce = mt(H.value, d.value);
        return oe ? fn(e.value[0], H.value) && Ce : on(e.value[0], H.value) && Ce
      }
      return !1
    }, w = H => !e.value || t.hideOffsetDates && !H.current ? !1 : l.value.enabled ? t.modelAuto && Array.isArray(e.value) ? mt(H.value, e.value[0] ? e.value[0] : f.value) : !1 : r.value.enabled && Array.isArray(e.value) ? e.value.some(oe => mt(oe, H.value)) : mt(H.value, e.value ? e.value : f.value), x = H => {
      if (l.value.autoRange || t.weekPicker) {
        if (d.value) {
          if (t.hideOffsetDates && !H.current) return !1;
          const oe = vs(d.value, +l.value.autoRange),
            Ce = _a(Te(d.value), t.weekStart);
          return t.weekPicker ? mt(Ce[1], Te(H.value)) : mt(oe, Te(H.value))
        }
        return !1
      }
      return !1
    }, E = H => {
      if (l.value.autoRange || t.weekPicker) {
        if (d.value) {
          const oe = vs(d.value, +l.value.autoRange);
          if (t.hideOffsetDates && !H.current) return !1;
          const Ce = _a(Te(d.value), t.weekStart);
          return t.weekPicker ? fn(H.value, Ce[0]) && on(H.value, Ce[1]) : fn(H.value, d.value) && on(H.value, oe)
        }
        return !1
      }
      return !1
    }, S = H => {
      if (l.value.autoRange || t.weekPicker) {
        if (d.value) {
          if (t.hideOffsetDates && !H.current) return !1;
          const oe = _a(Te(d.value), t.weekStart);
          return t.weekPicker ? mt(oe[0], H.value) : mt(d.value, H.value)
        }
        return !1
      }
      return !1
    }, T = H => n1(e.value, d.value, H.value), j = () => t.modelAuto && Array.isArray(t.internalModelValue) ? !!t.internalModelValue[0] : !1, P = () => t.modelAuto ? w7(t.internalModelValue) : !0, N = H => {
      if (t.weekPicker) return !1;
      const oe = l.value.enabled ? !y(H) && !y(H, !1) : !0;
      return !c(H.value) && !w(H) && !(!H.current && t.hideOffsetDates) && oe
    }, ne = H => l.value.enabled ? t.modelAuto ? j() && w(H) : !1 : w(H), Y = H => a.value ? XK(H.value, i.value.highlight) : !1, _e = H => {
      const oe = c(H.value);
      return oe && (typeof a.value == "function" ? !a.value(H.value, oe) : !a.value.options.highlightDisabled)
    }, Q = H => {
      var oe;
      return typeof a.value == "function" ? a.value(H.value) : (oe = a.value.weekdays) == null ? void 0 : oe.includes(H.value.getDay())
    }, re = H => (l.value.enabled || t.weekPicker) && (!(n.value.count > 0) || H.current) && P() && !(!H.current && t.hideOffsetDates) && !w(H) ? T(H) : !1, J = H => {
      const {
        isRangeStart: oe,
        isRangeEnd: Ce
      } = ae(H), D = l.value.enabled ? oe || Ce : !1;
      return {
        dp__cell_offset: !H.current,
        dp__pointer: !t.disabled && !(!H.current && t.hideOffsetDates) && !c(H.value),
        dp__cell_disabled: c(H.value),
        dp__cell_highlight: !_e(H) && (Y(H) || Q(H)) && !ne(H) && !D && !S(H) && !(re(H) && t.weekPicker) && !Ce,
        dp__cell_highlight_active: !_e(H) && (Y(H) || Q(H)) && ne(H),
        dp__today: !t.noToday && mt(H.value, f.value) && H.current,
        "dp--past": on(H.value, f.value),
        "dp--future": fn(H.value, f.value)
      }
    }, ee = H => ({
      dp__active_date: ne(H),
      dp__date_hover: N(H)
    }), de = H => {
      if (e.value && !Array.isArray(e.value)) {
        const oe = _a(e.value, t.weekStart);
        return {
          ...be(H),
          dp__range_start: mt(oe[0], H.value),
          dp__range_end: mt(oe[1], H.value),
          dp__range_between_week: fn(H.value, oe[0]) && on(H.value, oe[1])
        }
      }
      return {
        ...be(H)
      }
    }, se = H => {
      if (e.value && Array.isArray(e.value)) {
        const oe = _a(e.value[0], t.weekStart),
          Ce = e.value[1] ? _a(e.value[1], t.weekStart) : [];
        return {
          ...be(H),
          dp__range_start: mt(oe[0], H.value) || mt(Ce[0], H.value),
          dp__range_end: mt(oe[1], H.value) || mt(Ce[1], H.value),
          dp__range_between_week: fn(H.value, oe[0]) && on(H.value, oe[1]) || fn(H.value, Ce[0]) && on(H.value, Ce[1]),
          dp__range_between: fn(H.value, oe[1]) && on(H.value, Ce[0])
        }
      }
      return {
        ...be(H)
      }
    }, ae = H => {
      const oe = n.value.count > 0 ? H.current && y(H) && P() : y(H) && P(),
        Ce = n.value.count > 0 ? H.current && y(H, !1) && P() : y(H, !1) && P();
      return {
        isRangeStart: oe,
        isRangeEnd: Ce
      }
    }, ke = H => {
      const {
        isRangeStart: oe,
        isRangeEnd: Ce
      } = ae(H);
      return {
        dp__range_start: oe,
        dp__range_end: Ce,
        dp__range_between: re(H),
        dp__date_hover: mt(H.value, d.value) && !oe && !Ce && !t.weekPicker,
        dp__date_hover_start: b(H, !0),
        dp__date_hover_end: b(H, !1)
      }
    }, be = H => ({
      ...ke(H),
      dp__cell_auto_range: E(H),
      dp__cell_auto_range_start: S(H),
      dp__cell_auto_range_end: x(H)
    }), ge = H => l.value.enabled ? l.value.autoRange ? be(H) : t.modelAuto ? {
      ...ee(H),
      ...ke(H)
    } : t.weekPicker ? se(H) : ke(H) : t.weekPicker ? de(H) : ee(H);
    return {
      setHoverDate: p,
      clearHoverDate: h,
      getDayClassData: H => t.hideOffsetDates && !H.current ? {} : {
        ...J(H),
        ...ge(H),
        [t.dayClass ? t.dayClass(H.value, t.internalModelValue) : ""]: !0,
        ...s.value.calendarCell ?? {}
      }
    }
  },
  ti = e => {
    const {
      defaultedFilters: t,
      defaultedRange: n,
      propDates: r,
      defaultedMultiDates: s
    } = tn(e), a = Q => r.value.disabledDates ? typeof r.value.disabledDates == "function" ? r.value.disabledDates(Te(Q)) : !!ip(Q, r.value.disabledDates) : !1, o = Q => r.value.maxDate ? e.yearPicker ? Xe(Q) > Xe(r.value.maxDate) : fn(Q, r.value.maxDate) : !1, i = Q => r.value.minDate ? e.yearPicker ? Xe(Q) < Xe(r.value.minDate) : on(Q, r.value.minDate) : !1, l = Q => {
      const re = o(Q),
        J = i(Q),
        ee = a(Q),
        de = t.value.months.map(ge => +ge).includes(ft(Q)),
        se = e.disabledWeekDays.length ? e.disabledWeekDays.some(ge => +ge === jq(Q)) : !1,
        ae = h(Q),
        ke = Xe(Q),
        be = ke < +e.yearRange[0] || ke > +e.yearRange[1];
      return !(re || J || ee || de || be || se || ae)
    }, c = (Q, re) => on(...Po(r.value.minDate, Q, re)) || mt(...Po(r.value.minDate, Q, re)), d = (Q, re) => fn(...Po(r.value.maxDate, Q, re)) || mt(...Po(r.value.maxDate, Q, re)), f = (Q, re, J) => {
      let ee = !1;
      return r.value.maxDate && J && d(Q, re) && (ee = !0), r.value.minDate && !J && c(Q, re) && (ee = !0), ee
    }, p = (Q, re, J, ee) => {
      let de = !1;
      return ee && (r.value.minDate || r.value.maxDate) ? r.value.minDate && r.value.maxDate ? de = f(Q, re, J) : (r.value.minDate && c(Q, re) || r.value.maxDate && d(Q, re)) && (de = !0) : de = !0, de
    }, h = Q => Array.isArray(r.value.allowedDates) && !r.value.allowedDates.length ? !0 : r.value.allowedDates ? !ip(Q, r.value.allowedDates) : !1, _ = Q => !l(Q), v = Q => n.value.noDisabledRange ? !s7({
      start: Q[0],
      end: Q[1]
    }).some(re => _(re)) : !0, C = Q => {
      if (Q) {
        const re = Xe(Q);
        return re >= +e.yearRange[0] && re <= e.yearRange[1]
      }
      return !0
    }, y = (Q, re) => !!(Array.isArray(Q) && Q[re] && (n.value.maxRange || n.value.minRange) && C(Q[re])), b = (Q, re, J = 0) => {
      if (y(re, J) && C(Q)) {
        const ee = t7(Q, re[J]),
          de = E7(re[J], Q),
          se = de.length === 1 ? 0 : de.filter(ke => _(ke)).length,
          ae = Math.abs(ee) - (n.value.minMaxRawRange ? 0 : se);
        if (n.value.minRange && n.value.maxRange) return ae >= +n.value.minRange && ae <= +n.value.maxRange;
        if (n.value.minRange) return ae >= +n.value.minRange;
        if (n.value.maxRange) return ae <= +n.value.maxRange
      }
      return !0
    }, w = () => !e.enableTimePicker || e.monthPicker || e.yearPicker || e.ignoreTimeValidation, x = Q => Array.isArray(Q) ? [Q[0] ? nh(Q[0]) : null, Q[1] ? nh(Q[1]) : null] : nh(Q), E = (Q, re, J) => Q.find(ee => +ee.hours === za(re) && ee.minutes === "*" ? !0 : +ee.minutes === Uo(re) && +ee.hours === za(re)) && J, S = (Q, re, J) => {
      const [ee, de] = Q, [se, ae] = re;
      return !E(ee, se, J) && !E(de, ae, J) && J
    }, T = (Q, re) => {
      const J = Array.isArray(re) ? re : [re];
      return Array.isArray(e.disabledTimes) ? Array.isArray(e.disabledTimes[0]) ? S(e.disabledTimes, J, Q) : !J.some(ee => E(e.disabledTimes, ee, Q)) : Q
    }, j = (Q, re) => {
      const J = Array.isArray(re) ? [$i(re[0]), re[1] ? $i(re[1]) : void 0] : $i(re),
        ee = !e.disabledTimes(J);
      return Q && ee
    }, P = (Q, re) => e.disabledTimes ? Array.isArray(e.disabledTimes) ? T(re, Q) : j(re, Q) : re, N = Q => {
      let re = !0;
      if (!Q || w()) return !0;
      const J = !r.value.minDate && !r.value.maxDate ? x(Q) : Q;
      return (e.maxTime || r.value.maxDate) && (re = d3(e.maxTime, r.value.maxDate, "max", Pn(J), re)), (e.minTime || r.value.minDate) && (re = d3(e.minTime, r.value.minDate, "min", Pn(J), re)), P(Q, re)
    }, ne = Q => {
      if (!e.monthPicker) return !0;
      let re = !0;
      const J = Te(_s(Q));
      if (r.value.minDate && r.value.maxDate) {
        const ee = Te(_s(r.value.minDate)),
          de = Te(_s(r.value.maxDate));
        return fn(J, ee) && on(J, de) || mt(J, ee) || mt(J, de)
      }
      if (r.value.minDate) {
        const ee = Te(_s(r.value.minDate));
        re = fn(J, ee) || mt(J, ee)
      }
      if (r.value.maxDate) {
        const ee = Te(_s(r.value.maxDate));
        re = on(J, ee) || mt(J, ee)
      }
      return re
    }, Y = L(() => Q => !e.enableTimePicker || e.ignoreTimeValidation ? !0 : N(Q)), _e = L(() => Q => e.monthPicker ? Array.isArray(Q) && (n.value.enabled || s.value.enabled) ? !Q.filter(re => !ne(re)).length : ne(Q) : !0);
    return {
      isDisabled: _,
      validateDate: l,
      validateMonthYearInRange: p,
      isDateRangeAllowed: v,
      checkMinMaxRange: b,
      isValidTime: N,
      isTimeValid: Y,
      isMonthValid: _e
    }
  },
  o1 = () => {
    const e = L(() => (r, s) => r == null ? void 0 : r.includes(s)),
      t = L(() => (r, s) => r.count ? r.solo ? !0 : s === 0 : !0),
      n = L(() => (r, s) => r.count ? r.solo ? !0 : s === r.count - 1 : !0);
    return {
      hideNavigationButtons: e,
      showLeftIcon: t,
      showRightIcon: n
    }
  },
  DJ = (e, t, n) => {
    const r = U(0),
      s = xn({
        [Ii.timePicker]: !e.enableTimePicker || e.timePicker || e.monthPicker,
        [Ii.calendar]: !1,
        [Ii.header]: !1
      }),
      a = L(() => e.monthPicker || e.timePicker),
      o = f => {
        var p;
        if ((p = e.flow) != null && p.length) {
          if (!f && a.value) return d();
          s[f] = !0, Object.keys(s).filter(h => !s[h]).length || d()
        }
      },
      i = () => {
        var f, p;
        (f = e.flow) != null && f.length && r.value !== -1 && (r.value += 1, t("flow-step", r.value), d()), ((p = e.flow) == null ? void 0 : p.length) === r.value && Ot().then(() => l())
      },
      l = () => {
        r.value = -1
      },
      c = (f, p, ...h) => {
        var _, v;
        e.flow[r.value] === f && n.value && ((v = (_ = n.value)[p]) == null || v.call(_, ...h))
      },
      d = (f = 0) => {
        f && (r.value += f), c(Yn.month, "toggleMonthPicker", !0), c(Yn.year, "toggleYearPicker", !0), c(Yn.calendar, "toggleTimePicker", !1, !0), c(Yn.time, "toggleTimePicker", !0, !0);
        const p = e.flow[r.value];
        (p === Yn.hours || p === Yn.minutes || p === Yn.seconds) && c(p, "toggleTimePicker", !0, !0, p)
      };
    return {
      childMount: o,
      updateFlowStep: i,
      resetFlow: l,
      handleFlow: d,
      flowStep: r
    }
  },
  LJ = {
    key: 1,
    class: "dp__input_wrap"
  },
  RJ = ["id", "name", "inputmode", "placeholder", "disabled", "readonly", "required", "value", "autocomplete", "aria-label", "aria-disabled", "aria-invalid"],
  NJ = {
    key: 2,
    class: "dp--clear-btn"
  },
  FJ = ["aria-label"],
  BJ = te({
    compatConfig: {
      MODE: 3
    },
    __name: "DatepickerInput",
    props: {
      isMenuOpen: {
        type: Boolean,
        default: !1
      },
      inputValue: {
        type: String,
        default: ""
      },
      ...r1
    },
    emits: ["clear", "open", "update:input-value", "set-input-date", "close", "select-date", "set-empty-date", "toggle", "focus-prev", "focus", "blur", "real-blur", "text-input"],
    setup(e, {
      expose: t,
      emit: n
    }) {
      const r = n,
        s = e,
        {
          defaultedTextInput: a,
          defaultedAriaLabels: o,
          defaultedInline: i,
          defaultedConfig: l,
          defaultedRange: c,
          defaultedMultiDates: d,
          defaultedUI: f,
          getDefaultPattern: p,
          getDefaultStartTime: h
        } = tn(s),
        {
          checkMinMaxRange: _
        } = ti(s),
        v = U(),
        C = U(null),
        y = U(!1),
        b = U(!1),
        w = L(() => ({
          dp__pointer: !s.disabled && !s.readonly && !a.value.enabled,
          dp__disabled: s.disabled,
          dp__input_readonly: !a.value.enabled,
          dp__input: !0,
          dp__input_icon_pad: !s.hideInputIcon,
          dp__input_valid: typeof s.state == "boolean" ? s.state : !1,
          dp__input_invalid: typeof s.state == "boolean" ? !s.state : !1,
          dp__input_focus: y.value || s.isMenuOpen,
          dp__input_reg: !a.value.enabled,
          ...f.value.input ?? {}
        })),
        x = () => {
          r("set-input-date", null), s.clearable && s.autoApply && (r("set-empty-date"), v.value = null)
        },
        E = ae => {
          const ke = h();
          return eZ(ae, a.value.format ?? p(), ke ?? T7({}, s.enableSeconds), s.inputValue, b.value, s.formatLocale)
        },
        S = ae => {
          const {
            rangeSeparator: ke
          } = a.value, [be, ge] = ae.split(`${ke}`);
          if (be) {
            const H = E(be.trim()),
              oe = ge ? E(ge.trim()) : null;
            if (uu(H, oe)) return;
            const Ce = H && oe ? [H, oe] : [H];
            _(oe, Ce, 0) && (v.value = H ? Ce : null)
          }
        },
        T = () => {
          b.value = !0
        },
        j = ae => {
          if (c.value.enabled) S(ae);
          else if (d.value.enabled) {
            const ke = ae.split(";");
            v.value = ke.map(be => E(be.trim())).filter(be => be)
          } else v.value = E(ae)
        },
        P = ae => {
          var ke;
          const be = typeof ae == "string" ? ae : (ke = ae.target) == null ? void 0 : ke.value;
          be !== "" ? (a.value.openMenu && !s.isMenuOpen && r("open"), j(be), r("set-input-date", v.value)) : x(), b.value = !1, r("update:input-value", be), r("text-input", ae, v.value)
        },
        N = ae => {
          a.value.enabled ? (j(ae.target.value), a.value.enterSubmit && Zm(v.value) && s.inputValue !== "" ? (r("set-input-date", v.value, !0), v.value = null) : a.value.enterSubmit && s.inputValue === "" && (v.value = null, r("clear"))) : _e(ae)
        },
        ne = (ae, ke) => {
          a.value.enabled && a.value.tabSubmit && !ke && j(ae.target.value), a.value.tabSubmit && Zm(v.value) && s.inputValue !== "" ? (r("set-input-date", v.value, !0, !0), v.value = null) : a.value.tabSubmit && s.inputValue === "" && (v.value = null, r("clear", !0))
        },
        Y = () => {
          y.value = !0, r("focus"), Ot().then(() => {
            var ae;
            a.value.enabled && a.value.selectOnFocus && ((ae = C.value) == null || ae.select())
          })
        },
        _e = ae => {
          if ($o(ae, l.value, !0), a.value.enabled && a.value.openMenu && !i.value.input) {
            if (a.value.openMenu === "open" && !s.isMenuOpen) return r("open");
            if (a.value.openMenu === "toggle") return r("toggle")
          } else a.value.enabled || r("toggle")
        },
        Q = () => {
          r("real-blur"), y.value = !1, (!s.isMenuOpen || i.value.enabled && i.value.input) && r("blur"), s.autoApply && a.value.enabled && v.value && !s.isMenuOpen && (r("set-input-date", v.value), r("select-date"), v.value = null)
        },
        re = ae => {
          $o(ae, l.value, !0), r("clear")
        },
        J = ae => {
          if (ae.key === "Tab" && ne(ae), ae.key === "Enter" && N(ae), !a.value.enabled) {
            if (ae.code === "Tab") return;
            ae.preventDefault()
          }
        },
        ee = () => {
          var ae;
          (ae = C.value) == null || ae.focus({
            preventScroll: !0
          })
        },
        de = ae => {
          v.value = ae
        },
        se = ae => {
          ae.key === Gt.tab && ne(ae, !0)
        };
      return t({
        focusInput: ee,
        setParsedDate: de
      }), (ae, ke) => {
        var be, ge, H;
        return g(), k("div", {
          onClick: _e
        }, [ae.$slots.trigger && !ae.$slots["dp-input"] && !u(i).enabled ? ie(ae.$slots, "trigger", {
          key: 0
        }) : z("", !0), !ae.$slots.trigger && (!u(i).enabled || u(i).input) ? (g(), k("div", LJ, [ae.$slots["dp-input"] && !ae.$slots.trigger && (!u(i).enabled || u(i).enabled && u(i).input) ? ie(ae.$slots, "dp-input", {
          key: 0,
          value: e.inputValue,
          isMenuOpen: e.isMenuOpen,
          onInput: P,
          onEnter: N,
          onTab: ne,
          onClear: re,
          onBlur: Q,
          onKeypress: J,
          onPaste: T,
          onFocus: Y,
          openMenu: () => ae.$emit("open"),
          closeMenu: () => ae.$emit("close"),
          toggleMenu: () => ae.$emit("toggle")
        }) : z("", !0), ae.$slots["dp-input"] ? z("", !0) : (g(), k("input", {
          key: 1,
          id: ae.uid ? `dp-input-${ae.uid}` : void 0,
          ref_key: "inputRef",
          ref: C,
          "data-test-id": "dp-input",
          name: ae.name,
          class: we(w.value),
          inputmode: u(a).enabled ? "text" : "none",
          placeholder: ae.placeholder,
          disabled: ae.disabled,
          readonly: ae.readonly,
          required: ae.required,
          value: e.inputValue,
          autocomplete: ae.autocomplete,
          "aria-label": (be = u(o)) == null ? void 0 : be.input,
          "aria-disabled": ae.disabled || void 0,
          "aria-invalid": ae.state === !1 ? !0 : void 0,
          onInput: P,
          onBlur: Q,
          onFocus: Y,
          onKeypress: J,
          onKeydown: ke[0] || (ke[0] = oe => J(oe)),
          onPaste: T
        }, null, 42, RJ)), m("div", {
          onClick: ke[3] || (ke[3] = oe => r("toggle"))
        }, [ae.$slots["input-icon"] && !ae.hideInputIcon ? (g(), k("span", {
          key: 0,
          class: "dp__input_icon",
          onClick: ke[1] || (ke[1] = oe => r("toggle"))
        }, [ie(ae.$slots, "input-icon")])) : z("", !0), !ae.$slots["input-icon"] && !ae.hideInputIcon && !ae.$slots["dp-input"] ? (g(), G(u(Du), {
          key: 1,
          "aria-label": (ge = u(o)) == null ? void 0 : ge.calendarIcon,
          class: "dp__input_icon dp__input_icons",
          onClick: ke[2] || (ke[2] = oe => r("toggle"))
        }, null, 8, ["aria-label"])) : z("", !0)]), ae.$slots["clear-icon"] && e.inputValue && ae.clearable && !ae.disabled && !ae.readonly ? (g(), k("span", NJ, [ie(ae.$slots, "clear-icon", {
          clear: re
        })])) : z("", !0), ae.clearable && !ae.$slots["clear-icon"] && e.inputValue && !ae.disabled && !ae.readonly ? (g(), k("button", {
          key: 3,
          "aria-label": (H = u(o)) == null ? void 0 : H.clearInput,
          class: "dp--clear-btn",
          type: "button",
          onKeydown: ke[4] || (ke[4] = oe => u(ur)(oe, () => re(oe), !0, se)),
          onClick: ke[5] || (ke[5] = Er(oe => re(oe), ["prevent"]))
        }, [$(u(y7), {
          class: "dp__input_icons",
          "data-test-id": "clear-icon"
        })], 40, FJ)) : z("", !0)])) : z("", !0)])
      }
    }
  }),
  jJ = typeof window < "u" ? window : void 0,
  lh = () => {},
  HJ = e => Kc() ? (hu(e), !0) : !1,
  VJ = (e, t, n, r) => {
    if (!e) return lh;
    let s = lh;
    const a = Ne(() => u(e), i => {
        s(), i && (i.addEventListener(t, n, r), s = () => {
          i.removeEventListener(t, n, r), s = lh
        })
      }, {
        immediate: !0,
        flush: "post"
      }),
      o = () => {
        a(), s()
      };
    return HJ(o), o
  },
  UJ = (e, t, n, r = {}) => {
    const {
      window: s = jJ,
      event: a = "pointerdown"
    } = r;
    return s ? VJ(s, a, o => {
      const i = Sn(e),
        l = Sn(t);
      !i || !l || i === o.target || o.composedPath().includes(i) || o.composedPath().includes(l) || n(o)
    }, {
      passive: !0
    }) : void 0
  },
  zJ = ["data-dp-mobile"],
  YJ = te({
    compatConfig: {
      MODE: 3
    },
    __name: "VueDatePicker",
    props: {
      ...r1
    },
    emits: ["update:model-value", "update:model-timezone-value", "text-submit", "closed", "cleared", "open", "focus", "blur", "internal-model-change", "recalculate-position", "flow-step", "update-month-year", "invalid-select", "invalid-fixed-range", "tooltip-open", "tooltip-close", "time-picker-open", "time-picker-close", "am-pm-change", "range-start", "range-end", "date-update", "invalid-date", "overlay-toggle", "text-input"],
    setup(e, {
      expose: t,
      emit: n
    }) {
      const r = n,
        s = e,
        a = zo(),
        o = U(!1),
        i = zl(s, "modelValue"),
        l = zl(s, "timezone"),
        c = U(null),
        d = U(null),
        f = U(null),
        p = U(!1),
        h = U(null),
        _ = U(!1),
        v = U(!1),
        C = U(!1),
        y = U(!1),
        {
          setMenuFocused: b,
          setShiftKey: w
        } = M7(),
        {
          clearArrowNav: x
        } = ei(),
        {
          validateDate: E,
          isValidTime: S
        } = ti(s),
        {
          defaultedTransitions: T,
          defaultedTextInput: j,
          defaultedInline: P,
          defaultedConfig: N,
          defaultedRange: ne,
          defaultedMultiDates: Y
        } = tn(s),
        {
          menuTransition: _e,
          showTransition: Q
        } = xd(T),
        {
          isMobile: re
        } = B7(N);
      Ge(() => {
        Ce(s.modelValue), Ot().then(() => {
          if (!P.value.enabled) {
            const xe = be(h.value);
            xe == null || xe.addEventListener("scroll", q), window == null || window.addEventListener("resize", he)
          }
        }), P.value.enabled && (o.value = !0), window == null || window.addEventListener("keyup", A), window == null || window.addEventListener("keydown", F)
      }), en(() => {
        if (!P.value.enabled) {
          const xe = be(h.value);
          xe == null || xe.removeEventListener("scroll", q), window == null || window.removeEventListener("resize", he)
        }
        window == null || window.removeEventListener("keyup", A), window == null || window.removeEventListener("keydown", F)
      });
      const J = Fr(a, "all", s.presetDates),
        ee = Fr(a, "input");
      Ne([i, l], () => {
        Ce(i.value)
      }, {
        deep: !0
      });
      const {
        openOnTop: de,
        menuStyle: se,
        xCorrect: ae,
        setMenuPosition: ke,
        getScrollableParent: be,
        shadowRender: ge
      } = IJ({
        menuRef: c,
        menuRefInner: d,
        inputRef: f,
        pickerWrapperRef: h,
        inline: P,
        emit: r,
        props: s,
        slots: a
      }), {
        inputValue: H,
        internalModelValue: oe,
        parseExternalModelValue: Ce,
        emitModelValue: D,
        formatInputValue: pe,
        checkBeforeEmit: ye
      } = SZ(r, s, p), Ae = L(() => ({
        dp__main: !0,
        dp__theme_dark: s.dark,
        dp__theme_light: !s.dark,
        dp__flex_display: P.value.enabled,
        "dp--flex-display-collapsed": C.value,
        dp__flex_display_with_input: P.value.input
      })), fe = L(() => s.dark ? "dp__theme_dark" : "dp__theme_light"), I = L(() => s.teleport ? {
        to: typeof s.teleport == "boolean" ? "body" : s.teleport,
        disabled: !s.teleport || P.value.enabled
      } : {}), M = L(() => ({
        class: "dp__outer_menu_wrap"
      })), W = L(() => P.value.enabled && (s.timePicker || s.monthPicker || s.yearPicker || s.quarterPicker)), O = () => {
        var xe, $e;
        return (($e = (xe = f.value) == null ? void 0 : xe.$el) == null ? void 0 : $e.getBoundingClientRect()) ?? {
          width: 0,
          left: 0,
          right: 0
        }
      }, q = () => {
        o.value && (N.value.closeOnScroll ? Ve() : ke())
      }, he = () => {
        var xe;
        o.value && ke();
        const $e = ((xe = d.value) == null ? void 0 : xe.$el.getBoundingClientRect().width) ?? 0;
        C.value = document.body.offsetWidth <= $e
      }, A = xe => {
        xe.key === "Tab" && !P.value.enabled && !s.teleport && N.value.tabOutClosesMenu && (h.value.contains(document.activeElement) || Ve()), v.value = xe.shiftKey
      }, F = xe => {
        v.value = xe.shiftKey
      }, K = () => {
        !s.disabled && !s.readonly && (ge(m3, s), ke(!1), o.value = !0, o.value && r("open"), o.value || He(), Ce(s.modelValue))
      }, B = () => {
        var xe;
        H.value = "", He(), (xe = f.value) == null || xe.setParsedDate(null), r("update:model-value", null), r("update:model-timezone-value", null), r("cleared"), N.value.closeOnClearValue && Ve()
      }, ce = () => {
        const xe = oe.value;
        return !xe || !Array.isArray(xe) && E(xe) ? !0 : Array.isArray(xe) ? Y.value.enabled || xe.length === 2 && E(xe[0]) && E(xe[1]) ? !0 : ne.value.partialRange && !s.timePicker ? E(xe[0]) : !1 : !1
      }, le = () => {
        ye() && ce() ? (D(), Ve()) : r("invalid-select", oe.value)
      }, X = xe => {
        ve(), D(), N.value.closeOnAutoApply && !xe && Ve()
      }, ve = () => {
        f.value && j.value.enabled && f.value.setParsedDate(oe.value)
      }, Se = (xe = !1) => {
        s.autoApply && S(oe.value) && ce() && (ne.value.enabled && Array.isArray(oe.value) ? (ne.value.partialRange || oe.value.length === 2) && X(xe) : X(xe))
      }, He = () => {
        j.value.enabled || (oe.value = null)
      }, Ve = (xe = !1) => {
        xe && oe.value && N.value.setDateOnMenuClose && le(), P.value.enabled || (o.value && (o.value = !1, ae.value = !1, b(!1), w(!1), x(), r("closed"), H.value && Ce(i.value)), He(), r("blur"))
      }, sn = (xe, $e, Ue = !1) => {
        if (!xe) {
          oe.value = null;
          return
        }
        const $s = Array.isArray(xe) ? !xe.some(tl => !E(tl)) : E(xe),
          ss = S(xe);
        $s && ss ? (y.value = !0, oe.value = xe, $e && (_.value = Ue, le(), r("text-submit")), Ot().then(() => {
          y.value = !1
        })) : r("invalid-date", xe)
      }, Ut = () => {
        s.autoApply && S(oe.value) && D(), ve()
      }, On = () => o.value ? Ve() : K(), Xn = xe => {
        oe.value = xe
      }, oa = () => {
        j.value.enabled && (p.value = !0, pe()), r("focus")
      }, el = () => {
        if (j.value.enabled && (p.value = !1, Ce(s.modelValue), _.value)) {
          const xe = JK(h.value, v.value);
          xe == null || xe.focus()
        }
        r("blur")
      }, Dn = xe => {
        d.value && d.value.updateMonthYear(0, {
          month: i3(xe.month),
          year: i3(xe.year)
        })
      }, vr = xe => {
        Ce(xe ?? s.modelValue)
      }, me = (xe, $e) => {
        var Ue;
        (Ue = d.value) == null || Ue.switchView(xe, $e)
      }, Ie = xe => N.value.onClickOutside ? N.value.onClickOutside(xe) : Ve(!0), qe = (xe = 0) => {
        var $e;
        ($e = d.value) == null || $e.handleFlow(xe)
      };
      return UJ(c, f, () => Ie(ce)), t({
        closeMenu: Ve,
        selectDate: le,
        clearValue: B,
        openMenu: K,
        onScroll: q,
        formatInputValue: pe,
        updateInternalModelValue: Xn,
        setMonthYear: Dn,
        parseModel: vr,
        switchView: me,
        toggleMenu: On,
        handleFlow: qe,
        dpWrapMenuRef: c
      }), (xe, $e) => (g(), k("div", {
        ref_key: "pickerWrapperRef",
        ref: h,
        class: we(Ae.value),
        "data-datepicker-instance": "",
        "data-dp-mobile": u(re)
      }, [$(BJ, Le({
        ref_key: "inputRef",
        ref: f,
        "input-value": u(H),
        "onUpdate:inputValue": $e[0] || ($e[0] = Ue => Ht(H) ? H.value = Ue : null),
        "is-menu-open": o.value
      }, xe.$props, {
        onClear: B,
        onOpen: K,
        onSetInputDate: sn,
        onSetEmptyDate: u(D),
        onSelectDate: le,
        onToggle: On,
        onClose: Ve,
        onFocus: oa,
        onBlur: el,
        onRealBlur: $e[1] || ($e[1] = Ue => p.value = !1),
        onTextInput: $e[2] || ($e[2] = Ue => xe.$emit("text-input", Ue))
      }), Qn({
        _: 2
      }, [Je(u(ee), (Ue, $s) => ({
        name: Ue,
        fn: V(ss => [ie(xe.$slots, Ue, Nt(Qt(ss)))])
      }))]), 1040, ["input-value", "is-menu-open", "onSetEmptyDate"]), (g(), G(Kr(xe.teleport ? Jc : "div"), Nt(Qt(I.value)), {
        default: V(() => [$(zi, {
          name: u(_e)(u(de)),
          css: u(Q) && !u(P).enabled
        }, {
          default: V(() => [o.value ? (g(), k("div", Le({
            key: 0,
            ref_key: "dpWrapMenuRef",
            ref: c
          }, M.value, {
            class: {
              "dp--menu-wrapper": !u(P).enabled
            },
            style: u(P).enabled ? void 0 : u(se)
          }), [$(m3, Le({
            ref_key: "dpMenuRef",
            ref: d
          }, xe.$props, {
            "internal-model-value": u(oe),
            "onUpdate:internalModelValue": $e[3] || ($e[3] = Ue => Ht(oe) ? oe.value = Ue : null),
            class: {
              [fe.value]: !0,
              "dp--menu-wrapper": xe.teleport
            },
            "open-on-top": u(de),
            "no-overlay-focus": W.value,
            collapse: C.value,
            "get-input-rect": O,
            "is-text-input-date": y.value,
            onClosePicker: Ve,
            onSelectDate: le,
            onAutoApply: Se,
            onTimeUpdate: Ut,
            onFlowStep: $e[4] || ($e[4] = Ue => xe.$emit("flow-step", Ue)),
            onUpdateMonthYear: $e[5] || ($e[5] = Ue => xe.$emit("update-month-year", Ue)),
            onInvalidSelect: $e[6] || ($e[6] = Ue => xe.$emit("invalid-select", u(oe))),
            onAutoApplyInvalid: $e[7] || ($e[7] = Ue => xe.$emit("invalid-select", Ue)),
            onInvalidFixedRange: $e[8] || ($e[8] = Ue => xe.$emit("invalid-fixed-range", Ue)),
            onRecalculatePosition: u(ke),
            onTooltipOpen: $e[9] || ($e[9] = Ue => xe.$emit("tooltip-open", Ue)),
            onTooltipClose: $e[10] || ($e[10] = Ue => xe.$emit("tooltip-close", Ue)),
            onTimePickerOpen: $e[11] || ($e[11] = Ue => xe.$emit("time-picker-open", Ue)),
            onTimePickerClose: $e[12] || ($e[12] = Ue => xe.$emit("time-picker-close", Ue)),
            onAmPmChange: $e[13] || ($e[13] = Ue => xe.$emit("am-pm-change", Ue)),
            onRangeStart: $e[14] || ($e[14] = Ue => xe.$emit("range-start", Ue)),
            onRangeEnd: $e[15] || ($e[15] = Ue => xe.$emit("range-end", Ue)),
            onDateUpdate: $e[16] || ($e[16] = Ue => xe.$emit("date-update", Ue)),
            onInvalidDate: $e[17] || ($e[17] = Ue => xe.$emit("invalid-date", Ue)),
            onOverlayToggle: $e[18] || ($e[18] = Ue => xe.$emit("overlay-toggle", Ue)),
            onMenuBlur: $e[19] || ($e[19] = Ue => xe.$emit("blur"))
          }), Qn({
            _: 2
          }, [Je(u(J), (Ue, $s) => ({
            name: Ue,
            fn: V(ss => [ie(xe.$slots, Ue, Nt(Qt({
              ...ss
            })))])
          }))]), 1040, ["internal-model-value", "class", "open-on-top", "no-overlay-focus", "collapse", "is-text-input-date", "onRecalculatePosition"])], 16)) : z("", !0)]),
          _: 3
        }, 8, ["name", "css"])]),
        _: 3
      }, 16))], 10, zJ))
    }
  }),
  Xg = (() => {
    const e = YJ;
    return e.install = t => {
      t.component("Vue3DatePicker", e)
    }, e
  })(),
  WJ = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: Xg
  }, Symbol.toStringTag, {
    value: "Module"
  }));
Object.entries(WJ).forEach(([e, t]) => {
  e !== "default" && (Xg[e] = t)
});

function GJ(e, t = 83) {
  let n = null;
  return function() {
    n && (clearTimeout(n), n = null);
    const r = this,
      s = arguments;
    n = setTimeout(() => e.apply(r, s), t)
  }
}

function QJ(e) {
  const {
    top: t,
    bottom: n
  } = e.getBoundingClientRect();
  return (t + n) / 2
}

function g3(e) {
  return e.map(t => {
    switch (typeof t) {
      case "string":
        return {
          value: t, name: t
        };
      case "number":
      case "boolean":
        return {
          value: t, name: `${t}`
        }
    }
    return t
  })
}

function j7(e) {
  return e.changedTouches || e.touches
}

function uh(e) {
  return j7(e) ? e.changedTouches[0] || e.touches[0] : e
}
const Jm = te({
  props: {
    modelValue: null,
    options: {
      type: Array,
      default: () => []
    },
    dragSensitivity: {
      type: Number,
      default: 1.7
    },
    touchSensitivity: {
      type: Number,
      default: 1.7
    },
    scrollSensitivity: {
      type: Number,
      default: 1
    },
    empty: {
      type: String,
      default: "No Items"
    },
    placeholder: {
      type: String,
      default: null
    }
  },
  emits: {
    "update:modelValue": e => !0,
    start: () => !0,
    move: e => !0,
    end: e => !0,
    cancel: () => !0,
    wheel: e => !0,
    click: (e, t) => !0
  },
  data() {
    var e;
    const t = g3(this.options);
    let n = t.findIndex(s => s.value == this.modelValue);
    n === -1 && !this.placeholder && !this.$slots.placeholder && this.options.length > 0 && (n = 0);
    const r = ((e = t[n]) == null ? void 0 : e.value) ?? null;
    return {
      resizeObserver: null,
      refItems: [],
      internalOptions: t,
      internalIndex: n,
      internalValue: r,
      bounds: [],
      boundMin: 0,
      boundMax: 0,
      scroll: null,
      scrollOffsetTop: 0,
      scrollMin: 0,
      scrollMax: 0,
      transitionTimeout: null,
      start: null,
      isDragging: !1
    }
  },
  computed: {
    hasPlaceholder() {
      return !!(this.placeholder || this.$slots.placeholder)
    }
  },
  watch: {
    modelValue(e) {
      if (e == null && this.hasPlaceholder) {
        this.scrollTo(this.findScrollByIndex(-1));
        return
      }
      const t = this.internalOptions.findIndex(n => n.value == e);
      if (t === -1) {
        this.$emit("update:modelValue", this.internalValue);
        return
      }
      this.internalIndex !== t && (this.internalIndex = t, this.scrollTo(this.findScrollByIndex(t)))
    },
    options: {
      handler(e) {
        var t;
        const n = this.internalOptions = g3(e);
        let r = n.findIndex(a => a.value == this.modelValue);
        r === -1 && !this.hasPlaceholder && this.options.length > 0 && (r = 0);
        const s = ((t = n[r]) == null ? void 0 : t.value) ?? null;
        this.$nextTick(() => {
          this.calculateBounds(), this.scroll = this.findScrollByIndex(r), this.internalIndex = r, this.internalValue !== s && this.$emit("update:modelValue", this.internalValue = s)
        })
      },
      deep: !0
    }
  },
  beforeUpdate() {
    this.refItems = []
  },
  mounted() {
    this.calculateBounds(), this.scroll = this.findScrollByIndex(this.internalIndex), this.internalValue !== this.modelValue && this.$emit("update:modelValue", this.internalValue);
    const e = this.$el;
    e.addEventListener("touchstart", this.onStart), e.addEventListener("touchmove", this.onMove), e.addEventListener("touchend", this.onEnd), e.addEventListener("touchcancel", this.onCancel), "onwheel" in e ? e.addEventListener("wheel", this.onWheel) : "onmousewheel" in e ? e.addEventListener("mousewheel", this.onWheel) : "onDOMMouseScroll" in e && e.addEventListener("DOMMouseScroll", this.onWheel), e.addEventListener("mousedown", this.onStart), document.addEventListener("mousemove", this.onMove), document.addEventListener("mouseup", this.onEnd), document.addEventListener("mouseout", this.onDocumentMouseOut), typeof window.ResizeObserver < "u" && (this.resizeObserver = new window.ResizeObserver(() => this.resize())).observe(e)
  },
  beforeUnmount() {
    var e;
    const t = this.$el;
    t.removeEventListener("touchstart", this.onStart), t.removeEventListener("touchmove", this.onMove), t.removeEventListener("touchend", this.onEnd), t.removeEventListener("touchcancel", this.onCancel), "onwheel" in t ? t.removeEventListener("wheel", this.onWheel) : "onmousewheel" in t ? t.removeEventListener("mousewheel", this.onWheel) : "onDOMMouseScroll" in t && t.removeEventListener("DOMMouseScroll", this.onWheel), t.removeEventListener("mousedown", this.onStart), document.removeEventListener("mousemove", this.onMove), document.removeEventListener("mouseup", this.onEnd), document.removeEventListener("mouseout", this.onDocumentMouseOut), (e = this.resizeObserver) == null || e.disconnect()
  },
  methods: {
    setRefItem(e) {
      this.refItems.push(e)
    },
    resize() {
      this.$nextTick(() => {
        this.calculateBounds(), this.scroll = this.findScrollByIndex(this.internalIndex)
      })
    },
    calculateBounds() {
      const e = this.$refs.rotator,
        t = this.$refs.layerSelection,
        n = e.getBoundingClientRect().top,
        r = this.bounds = this.refItems.map(i => QJ(i) - n).sort((i, l) => i - l),
        s = this.boundMin = Math.min(...r),
        a = this.boundMax = Math.max(...r),
        o = this.scrollOffsetTop = t.offsetTop + t.offsetHeight / 2;
      this.scrollMin = o - s, this.scrollMax = o - a
    },
    sanitizeInternalIndex(e) {
      return Math.min(Math.max(e, this.hasPlaceholder ? -1 : 0), this.internalOptions.length - 1)
    },
    findIndexFromScroll(e) {
      let t = null,
        n = 0;
      return this.bounds.forEach((r, s) => {
        const a = r + e - this.scrollOffsetTop;
        (t === null || Math.abs(t) > Math.abs(a)) && (n = s, t = a)
      }), this.hasPlaceholder || this.options.length === 0 ? n - 1 : n
    },
    findScrollByIndex(e) {
      let t = e;
      return (this.hasPlaceholder || this.options.length === 0) && t++, e > -1 && t in this.bounds ? this.scrollOffsetTop - this.bounds[t] : e >= this.bounds.length ? this.scrollOffsetTop - this.boundMax : this.scrollOffsetTop - this.boundMin
    },
    onWheel(e) {
      if (this.scroll >= this.scrollMin && e.deltaY < 0 || this.scroll <= this.scrollMax && e.deltaY > 0 || this.bounds.length === 1) return;
      e.preventDefault();
      const t = this.sanitizeInternalIndex(this.internalIndex + (e.deltaY > 0 ? 1 : -1)),
        n = e.deltaY > 0 ? this.findScrollByIndex(t - 1) - this.findScrollByIndex(t) : this.findScrollByIndex(t) - this.findScrollByIndex(t + 1),
        r = Math.max(Math.min(e.deltaY, n), n * -1);
      this.scroll = Math.min(Math.max(this.scroll - r * this.scrollSensitivity, this.scrollMax), this.scrollMin);
      const s = this.sanitizeInternalIndex(this.findIndexFromScroll(this.scroll)),
        a = this.internalOptions[s],
        o = (a == null ? void 0 : a.value) ?? null;
      this.internalIndex = s, this.$emit("wheel", o), this.internalValue !== o && !(a != null && a.disabled) && this.$emit("update:modelValue", this.internalValue = o), this.onAfterWheel(() => {
        this.correction(this.scroll)
      })
    },
    onAfterWheel: GJ(e => {
      e()
    }, 200),
    onStart(e) {
      e.cancelable && e.preventDefault();
      const {
        clientY: t
      } = uh(e);
      this.start = [this.scroll, t], this.isDragging = !1, this.$emit("start")
    },
    onMove(e) {
      var t;
      if (!this.start) return;
      e.cancelable && e.preventDefault();
      const {
        clientY: n
      } = uh(e), r = n - this.start[1];
      Math.abs(r) > 1.5 && (this.isDragging = !0), this.scroll = this.start[0] + r * (j7(e) ? this.touchSensitivity : this.dragSensitivity);
      const s = this.sanitizeInternalIndex(this.findIndexFromScroll(this.scroll)),
        a = ((t = this.internalOptions[s]) == null ? void 0 : t.value) ?? null;
      this.$emit("move", a)
    },
    onEnd(e) {
      this.start && (e.cancelable && e.preventDefault(), this.isDragging ? this.correction(this.scroll) : this.onClick(e), this.start = null, this.isDragging = !1, this.$emit("end", this.internalValue))
    },
    onDocumentMouseOut(e) {
      var t;
      (e.relatedTarget === null || ((t = e.relatedTarget) == null ? void 0 : t.nodeName) === "HTML") && this.onCancel(e)
    },
    onCancel(e) {
      e.cancelable && e.preventDefault(), this.scrollTo(this.findScrollByIndex(this.internalIndex)), this.start = null, this.isDragging = !1, this.$emit("cancel")
    },
    onClick(e) {
      const t = this.$refs.layerTop,
        n = this.$refs.layerBottom,
        {
          clientX: r,
          clientY: s
        } = uh(e),
        a = t.getBoundingClientRect(),
        o = n.getBoundingClientRect();
      let i = this.internalIndex;
      if (a.left <= r && r <= a.right && a.top <= s && s <= a.bottom) {
        if (this.internalIndex === (this.hasPlaceholder ? -1 : 0)) return;
        for (i--; this.internalOptions[i] && this.internalOptions[i].disabled;) i--
      } else if (o.left <= r && r <= o.right && o.top <= s && s <= o.bottom) {
        if (this.internalIndex === this.internalOptions.length - 1) return;
        for (i++; this.internalOptions[i] && this.internalOptions[i].disabled;) i++
      }
      if (this.internalIndex !== i && this.internalOptions[i]) {
        const l = this.internalValue,
          c = this.internalOptions[i].value;
        this.scrollTo(this.findScrollByIndex(i), () => {
          this.internalIndex = i, this.emitModalValue(c)
        }), this.$emit("click", c, l)
      }
    },
    correction(e) {
      var t;
      const n = this.hasPlaceholder || this.options.length === 0 ? 1 : 0,
        r = this.bounds.map((a, o) => [o - n, a + e - this.scrollOffsetTop]).sort((a, o) => Math.abs(a[1]) - Math.abs(o[1])).map(([a]) => a);
      let s = 0;
      for (; r[s] != null && this.internalOptions[r[s]] && this.internalOptions[r[s]].disabled;) s++;
      if (r[s] === -1 || r[s] != null && this.internalOptions[r[s]]) {
        const a = r[s],
          o = ((t = this.internalOptions[a]) == null ? void 0 : t.value) ?? null;
        this.scrollTo(this.findScrollByIndex(a), () => {
          this.internalIndex = a, this.emitModalValue(o)
        })
      } else this.scrollTo(this.findScrollByIndex(this.internalIndex))
    },
    scrollTo(e, t) {
      this.scroll = e, this.transitionTimeout && clearTimeout(this.transitionTimeout), this.transitionTimeout = setTimeout(() => {
        this.transitionTimeout = null, t == null || t()
      }, 100)
    },
    emitModalValue(e) {
      this.internalValue !== e && this.$emit("update:modelValue", this.internalValue = e)
    }
  },
  render() {
    let e = [];
    return this.hasPlaceholder ? e.push(yn("div", {
      class: ["vue-scroll-picker-item", "vue-scroll-picker-item-placeholder", {
        "vue-scroll-picker-item-selected": this.internalIndex === -1
      }],
      ref: t => t && this.setRefItem(t)
    }, ie(this.$slots, "placeholder", {
      text: this.placeholder
    }, () => [this.placeholder]))) : this.internalOptions.length === 0 && e.push(yn("div", {
      class: ["vue-scroll-picker-item", "vue-scroll-picker-item-empty", "vue-scroll-picker-item-selected"],
      ref: t => t && this.setRefItem(t)
    }, ie(this.$slots, "empty", {
      text: this.empty
    }, () => [this.empty]))), e = e.concat(this.internalOptions.map((t, n) => yn("div", {
      class: ["vue-scroll-picker-item", {
        "vue-scroll-picker-item-selected": this.internalIndex === n,
        "vue-scroll-picker-item-disabled": t.disabled
      }],
      key: t.value,
      ref: r => r && this.setRefItem(r)
    }, ie(this.$slots, "default", {
      option: t
    }, () => [t.name])))), yn("div", {
      class: ["vue-scroll-picker"]
    }, [yn("div", {
      ref: "rotator",
      class: ["vue-scroll-picker-rotator", {
        "vue-scroll-picker-rotator-transition": this.transitionTimeout
      }],
      style: typeof this.scroll == "number" ? {
        top: `${this.scroll}px`
      } : {}
    }, e), yn("div", {
      class: ["vue-scroll-picker-layer"]
    }, [yn("div", {
      class: ["vue-scroll-picker-layer-top"],
      ref: "layerTop"
    }), yn("div", {
      class: ["vue-scroll-picker-layer-selection"],
      ref: "layerSelection"
    }), yn("div", {
      class: ["vue-scroll-picker-layer-bottom"],
      ref: "layerBottom"
    })])])
  }
});

function qJ(e) {
  e.component("VueScrollPicker", Jm)
}
typeof window < "u" && window.Vue && qJ(window.Vue);
const KJ = {
    class: "mx-2 flex w-full items-center justify-between border-b border-white-10 py-2 text-lg text-white"
  },
  ZJ = ["onClick"],
  JJ = {
    class: "flex items-center space-x-2"
  },
  XJ = ["onClick"],
  eX = {
    class: "mx-4 flex items-center justify-center gap-8 border-t border-white-10 py-2 text-white"
  },
  tX = {
    class: "flex flex-col items-center"
  },
  nX = ["onClick"],
  rX = ["onClick"],
  sX = {
    class: "flex flex-col items-center"
  },
  aX = ["onClick"],
  oX = ["onClick"],
  iX = te({
    __name: "DateTimePicker",
    props: {
      selectDate: {
        type: Function
      },
      defaultDate: {},
      minDate: {},
      maxDate: {}
    },
    setup(e) {
      const t = e,
        {
          t: n,
          locale: r
        } = Fe(),
        s = U(t.defaultDate),
        a = () => {
          t.selectDate(s.value)
        },
        o = U(0),
        i = U(0);
      o.value = +s.value.getMinutes(), i.value = +s.value.getHours();
      const l = f => Array.from({
          length: f
        }, (p, h) => h.toString().padStart(2, "0")).reverse(),
        c = l(60),
        d = l(24);
      return (f, p) => (g(), G(u(Xg), {
        "prevent-min-max-navigation": "",
        locale: u(r),
        modelValue: s.value,
        "onUpdate:modelValue": p[2] || (p[2] = h => s.value = h),
        "outline-none": "",
        inline: "",
        "auto-apply": "",
        "month-name-format": "long",
        "min-date": f.minDate,
        "max-date": f.maxDate,
        "six-weeks": "",
        "no-minutes-overlay": "",
        "no-hours-overlay": "",
        "time-picker-inline": "",
        dark: "",
        "aria-labels": {}
      }, {
        "month-year": V(({
          month: h,
          year: _,
          months: v,
          handleMonthYearChange: C
        }) => {
          var y;
          return [m("div", KJ, [m("button", {
            class: "flex h-8 w-8 items-center justify-center rounded-full transition hover:bg-gray-600",
            onClick: b => C == null ? void 0 : C(!1)
          }, p[3] || (p[3] = [m("span", {
            class: "h-2 w-2 rotate-[-45deg] border-l-2 border-t-2"
          }, null, -1)]), 8, ZJ), m("div", JJ, [m("span", null, R(h !== void 0 && ((y = v == null ? void 0 : v[h]) == null ? void 0 : y.text)), 1), m("span", null, R(_), 1)]), m("button", {
            class: "flex h-8 w-8 items-center justify-center rounded-full transition hover:bg-gray-600",
            onClick: b => C == null ? void 0 : C(!0)
          }, p[4] || (p[4] = [m("span", {
            class: "h-2 w-2 rotate-[135deg] border-l-2 border-t-2"
          }, null, -1)]), 8, XJ)])]
        }),
        "time-picker": V(({
          time: h,
          updateTime: _
        }) => [m("div", eX, [m("div", tX, [m("button", {
          onClick: v => {
            +h.hours + 1 < 24 && _(+h.hours + 1, !0), i.value = +h.hours
          },
          class: "flex h-8 w-8 items-center justify-center rounded-full transition hover:bg-gray-600"
        }, p[5] || (p[5] = [m("div", {
          class: "h-2 w-2 rotate-45 border-l-2 border-t-2"
        }, null, -1)]), 8, nX), $(u(Jm), {
          class: "text-xl",
          "onUpdate:modelValue": [v => _(Number(v), !0), p[0] || (p[0] = v => i.value = v)],
          modelValue: i.value,
          options: u(d)
        }, null, 8, ["onUpdate:modelValue", "modelValue", "options"]), m("button", {
          onClick: v => {
            +h.hours - 1 > -1 && _(+h.hours - 1, !0), i.value = +h.hours
          },
          class: "flex h-8 w-8 items-center justify-center rounded-full transition hover:bg-gray-600"
        }, p[6] || (p[6] = [m("div", {
          class: "h-2 w-2 rotate-45 border-b-2 border-r-2"
        }, null, -1)]), 8, rX)]), m("div", sX, [m("button", {
          onClick: v => (+h.minutes + 1 <= 59 && _(+h.minutes + 1, !1), o.value = +h.minutes),
          class: "flex h-8 w-8 items-center justify-center rounded-full transition hover:bg-gray-600"
        }, p[7] || (p[7] = [m("div", {
          class: "h-2 w-2 rotate-45 border-l-2 border-t-2"
        }, null, -1)]), 8, aX), $(u(Jm), {
          class: "text-xl",
          "onUpdate:modelValue": [v => _(Number(v), !1), p[1] || (p[1] = v => o.value = v)],
          modelValue: o.value,
          options: u(c)
        }, null, 8, ["onUpdate:modelValue", "modelValue", "options"]), m("button", {
          onClick: v => (+h.minutes - 1 >= 0 && _(+h.minutes - 1, !1), o.value = +h.minutes),
          class: "flex h-8 w-8 items-center justify-center rounded-full transition hover:bg-gray-600"
        }, p[8] || (p[8] = [m("div", {
          class: "h-2 w-2 rotate-45 border-b-2 border-r-2"
        }, null, -1)]), 8, oX)])]), $(qt, {
          variant: "primary",
          onClick: a
        }, {
          default: V(() => [Ye(R(u(n)("challenge.p2p.set")), 1)]),
          _: 1
        })]),
        _: 1
      }, 8, ["locale", "modelValue", "min-date", "max-date"]))
    }
  }),
  lX = {
    class: "flex flex-col gap-y-5"
  },
  uX = {
    class: "flex gap-5"
  },
  cX = {
    key: 0,
    class: "text-13 text-red-alert"
  },
  dX = {
    class: "flex w-44 justify-between"
  },
  fX = {
    class: "text-13"
  },
  pX = {
    class: "flex gap-5"
  },
  hX = {
    key: 0,
    class: "text-13 text-red-alert"
  },
  mX = {
    class: "flex w-44 justify-between"
  },
  gX = {
    class: "text-13"
  },
  vX = {
    key: 0,
    class: "flex items-center justify-center"
  },
  _X = {
    class: "absolute right-0 top-0 z-[57] flex h-full w-full justify-center bg-gray"
  },
  yX = {
    class: "relative"
  },
  bX = {
    class: "m-auto w-full sm:w-4/5 md:w-3/5"
  },
  wX = {
    class: "my-2 flex w-full justify-center"
  },
  CX = {
    class: "text-center font-accent text-24 font-bold text-white"
  },
  xX = {
    class: "mb-1"
  },
  kX = te({
    __name: "ChallengeDateField",
    setup(e) {
      const {
        t,
        locale: n
      } = Fe(), r = U(), s = U(), a = U(!1), o = () => {
        a.value = !a.value
      }, i = (b, w) => new Intl.DateTimeFormat(w, {
        month: "short"
      }).format(b), l = b => {
        const w = b.getDate().toString().padStart(2, "0"),
          x = i(b, n.value),
          E = b.getFullYear().toString().slice(-2),
          S = b.getHours().toString().padStart(2, "0"),
          T = b.getMinutes().toString().padStart(2, "0");
        return `${w}/${x}/${E}, ${S}:${T}`
      }, c = U(), d = U(new Date), f = U(new Date), p = U(new Date), h = b => {
        r.value = l(b), ue.start_at = b, o()
      }, _ = b => {
        s.value = l(b), ue.finish_at = b, o()
      }, v = () => {
        const b = new Date,
          w = new Date;
        f.value = new Date(b.getTime() + fl.START_MIN_MINUTES * 60 * 1e3), d.value = new Date(b.getTime() + fl.START_DEFAULT_MINUTES * 60 * 1e3), p.value.setMonth(w.getMonth() + fl.START_OFFSET_MONTHS), y.value = h, c.value = t("challenge.p2p.select_start_date"), o()
      }, C = () => {
        f.value = new Date, p.value = new Date;
        const b = ue.start_at;
        if (!b) return;
        const w = new Date(b);
        w.setHours(w.getHours() + fl.END_MIN_LIMIT_HOURS), f.value = w, d.value = w;
        const x = new Date(b);
        x.setMonth(x.getMonth() + fl.END_MAX_LIMIT_MONTHS), p.value = x, y.value = _, c.value = t("challenge.p2p.select_end_date"), o()
      }, y = U(h);
      return (b, w) => (g(), k("div", lX, [m("div", uX, [m("div", {
        class: "flex grow flex-col items-start justify-center",
        ref: x => u(na).start_at = x
      }, [$(hr, {
        title: u(t)("challenge.p2p.start"),
        substring: u(t)("challenge.p2p.tooltip.start")
      }, null, 8, ["title", "substring"]), u(vt).start_at ? (g(), k("div", cX, R(u(Va)(u(vt).start_at)), 1)) : z("", !0)], 512), m("div", {
        class: we(["flex h-12 w-44 max-w-md cursor-pointer items-center justify-between rounded-xl bg-black-30 px-4 shadow-inset-white", {
          "ring-1 ring-red-alert": u(vt).start_at
        }]),
        onClick: v
      }, [m("div", dX, [$(u(gy), {
        class: "text-white-30"
      }), m("div", fX, R(r.value), 1)])], 2)]), m("div", pX, [m("div", {
        class: "flex grow flex-col items-start justify-center",
        ref: x => u(na).finish_at = x
      }, [$(hr, {
        title: u(t)("challenge.p2p.end"),
        substring: u(t)("challenge.p2p.tooltip.end")
      }, null, 8, ["title", "substring"]), u(vt).finish_at ? (g(), k("div", hX, R(u(Va)(u(vt).finish_at)), 1)) : z("", !0)], 512), m("div", {
        class: we(["flex h-12 w-44 max-w-md cursor-pointer items-center justify-between rounded-xl bg-black-30 px-4 shadow-inset-white", {
          "ring-1 ring-red-alert": u(vt).finish_at,
          "bg-white-10": !u(ue).start_at
        }]),
        onClick: C
      }, [m("div", mX, [$(u(gy), {
        class: "text-white-30"
      }), m("div", gX, R(s.value), 1)])], 2)]), a.value ? (g(), k("div", vX, [m("div", _X, [$(u(Jn), {
        class: "h-full w-full px-4 pb-20 pt-2 sm:pb-2"
      }, {
        default: V(() => [m("div", yX, [$(u(pr), {
          class: "absolute -top-1 right-0 cursor-pointer",
          onClick: o
        })]), m("div", bX, [m("div", wX, [m("h1", CX, R(c.value), 1)]), m("div", xX, [$(iX, {
          "default-date": d.value,
          "select-date": y.value,
          "min-date": f.value,
          "max-date": p.value
        }, null, 8, ["default-date", "select-date", "min-date", "max-date"])])])]),
        _: 1
      })])])) : z("", !0)]))
    }
  }),
  SX = {
    class: "py-2"
  },
  EX = {
    class: "flex cursor-pointer items-center justify-between gap-2"
  },
  TX = {
    class: "flex items-center justify-start gap-2"
  },
  AX = {
    class: "w-4"
  },
  PX = te({
    __name: "ChallengeSelectGame",
    props: {
      selected: {
        type: Boolean
      },
      name: {},
      multiplier: {}
    },
    setup(e) {
      return (t, n) => (g(), k("div", SX, [m("div", EX, [m("div", TX, [m("div", AX, [t.selected ? (g(), G(u(b9), {
        key: 0
      })) : z("", !0)]), m("div", {
        class: we(["break-words text-16 text-white", {
          "font-bold text-yellow": t.selected
        }])
      }, R(t.name), 3)]), m("div", {
        class: we(["break-words text-13 font-normal text-white opacity-30", {
          "text-yellow": t.selected
        }])
      }, " x" + R(t.multiplier), 3)])]))
    }
  }),
  IX = {
    class: "absolute right-0 top-0 z-[57] box-border h-full w-full bg-gray pb-2 pt-2"
  },
  $X = {
    class: "text-center font-accent text-24 font-bold text-white"
  },
  MX = {
    key: 0,
    class: "flex h-full w-full items-center justify-center"
  },
  OX = {
    key: 1
  },
  DX = {
    class: "border-b border-white-10 px-4 pb-3"
  },
  LX = {
    class: "relative mt-3"
  },
  RX = {
    class: "px-4 pt-2"
  },
  NX = {
    class: "w-4"
  },
  FX = {
    class: "border-t border-white-10 px-4 pt-3"
  },
  BX = te({
    __name: "ChallengeSelectGames",
    props: {
      closeSelectGames: {
        type: Function
      },
      selectedGames: {},
      games: {},
      isGameLoading: {
        type: Boolean
      }
    },
    emits: ["emitSetGames"],
    setup(e, {
      emit: t
    }) {
      const n = e,
        r = U(null),
        {
          t: s
        } = Fe(),
        a = t,
        o = U([...n.selectedGames]),
        i = U(""),
        l = p => {
          const h = o.value.findIndex(_ => _.identifier === p.identifier);
          h === -1 ? o.value.push(p) : o.value.splice(h, 1)
        },
        c = () => {
          a("emitSetGames", o.value), n.closeSelectGames()
        },
        d = () => {
          const p = o.value.length === n.games.length;
          o.value = p ? [] : [...n.games]
        },
        f = L(() => n.games.filter(p => p.title.toLowerCase().startsWith(i.value.toLowerCase())));
      return Ge(() => {
        var p;
        (p = r == null ? void 0 : r.value) == null || p.focus()
      }), (p, h) => (g(), k("div", IX, [$(u(pr), {
        class: "absolute right-1 top-2 cursor-pointer",
        onClick: p.closeSelectGames
      }, null, 8, ["onClick"]), m("h1", $X, R(u(s)("challenge.p2p.select_games")), 1), p.isGameLoading ? (g(), k("div", MX, [$(u(Ka))])) : (g(), k("div", OX, [m("div", DX, [m("div", LX, [Tn(m("input", {
        ref_key: "selectInput",
        ref: r,
        "onUpdate:modelValue": h[0] || (h[0] = _ => i.value = _),
        type: "text",
        class: "shadow-inner inline-flex h-full w-full items-center justify-start gap-2 rounded-xl bg-[#171922] py-3 pl-8 pr-3 text-13 shadow-[0px_2px_0px_rgba(0,0,0,0.25)] focus:outline-none"
      }, null, 512), [
        [Mi, i.value]
      ]), $(u(Al), {
        class: "absolute left-2 top-3 text-15 leading-4 text-white-30"
      })])]), m("div", RX, [m("div", {
        onClick: d,
        class: we(["flex cursor-pointer gap-2 py-4 text-16 text-white", {
          "font-bold text-yellow": o.value.length === n.games.length
        }])
      }, [m("div", NX, [o.value.length === n.games.length ? (g(), G(u(b9), {
        key: 0
      })) : z("", !0)]), m("div", null, R(u(s)("challenge.p2p.select_all")), 1)], 2), $(u(Jn), {
        class: "h-[calc(100vh-260px)] border-t border-white-10 pr-4 sm:h-[calc(100vh-310px)]"
      }, {
        default: V(() => [(g(!0), k(Ee, null, Je(f.value, _ => (g(), G(PX, {
          key: _.identifier,
          selected: o.value.some(v => v.identifier === _.identifier),
          name: _.title,
          multiplier: _.max_multiplier,
          onClick: v => l(_)
        }, null, 8, ["selected", "name", "multiplier", "onClick"]))), 128))]),
        _: 1
      })]), m("div", FX, [$(qt, {
        variant: "primary",
        onClick: c
      }, {
        default: V(() => [Ye(R(u(s)("challenge.p2p.set")), 1)]),
        _: 1
      })])]))]))
    }
  }),
  jX = {
    class: "text-13 font-normal text-yellow"
  },
  HX = {
    class: "text-white-30"
  },
  VX = te({
    __name: "ChallengeSelectedOption",
    props: {
      id: {},
      name: {},
      multiplier: {}
    },
    emits: ["removeGame"],
    setup(e, {
      emit: t
    }) {
      const n = e,
        r = t,
        s = o => {
          o.stopPropagation(), r("removeGame", n.id)
        },
        a = o => {
          o.stopPropagation()
        };
      return (o, i) => (g(), k("div", {
        onClick: a,
        class: "inline-flex items-center justify-start gap-1 rounded-2xl border border-white-10 bg-gray-lighter py-1.5 pl-3 pr-2"
      }, [m("span", jX, R(o.name), 1), m("span", HX, "x" + R(o.multiplier), 1), m("span", {
        class: "flex cursor-pointer items-center justify-center",
        onClick: s
      }, [$(u(lB))])]))
    }
  }),
  UX = {
    class: "inline-flex h-full max-h-[108px] min-h-10 w-full flex-wrap items-center justify-start gap-2 text-13 focus:outline-none"
  },
  zX = {
    key: 1,
    class: "text-13 text-red-alert"
  },
  YX = te({
    __name: "ChallengeSelectGamesField",
    setup(e) {
      const {
        t
      } = Fe(), n = U(!1), {
        data: r,
        isLoading: s
      } = Ig(), a = L(() => {
        if (r.value) {
          const d = new Set;
          return r.value.filter(f => d.has(f.identifier) ? !1 : (d.add(f.identifier), !0))
        } else return []
      }), o = () => {
        n.value = !1
      }, i = d => {
        ue.game_identifiers = d
      }, l = d => {
        ue.game_identifiers = ue.game_identifiers.filter(f => f.identifier !== d)
      }, c = () => {
        var f;
        const d = (f = r == null ? void 0 : r.value) == null ? void 0 : f.find(p => p.identifier === Kn.identifier);
        d && i([d])
      };
      return Ge(() => {
        c()
      }), (d, f) => (g(), k("div", null, [$(hr, {
        title: u(t)("challenge.p2p.games"),
        substring: u(t)("challenge.p2p.tooltip.games")
      }, null, 8, ["title", "substring"]), m("div", {
        class: "relative mt-2",
        ref: p => u(na).game_identifiers = p
      }, [$(u(Jn), {
        onClick: f[0] || (f[0] = p => n.value = !0),
        class: "shadow-inner h-full w-full rounded-xl bg-[#171922] py-3 pl-3 pr-6"
      }, {
        default: V(() => [m("div", UX, [(g(!0), k(Ee, null, Je(u(ue).game_identifiers, p => (g(), G(VX, {
          id: p.identifier,
          key: p.identifier,
          name: p.title,
          multiplier: p.max_multiplier,
          onRemoveGame: l
        }, null, 8, ["id", "name", "multiplier"]))), 128))])]),
        _: 1
      }), $(u(y9), {
        class: "absolute right-2 top-2 cursor-pointer text-15 leading-4 text-white-30",
        onClick: f[1] || (f[1] = p => n.value = !0)
      })], 512), n.value ? (g(), G(BX, {
        key: 0,
        "close-select-games": o,
        selectedGames: u(ue).game_identifiers,
        games: a.value,
        "is-game-loading": u(s),
        onEmitSetGames: i
      }, null, 8, ["selectedGames", "games", "is-game-loading"])) : z("", !0), u(vt).game_identifiers ? (g(), k("div", zX, R(u(Va)(u(vt).game_identifiers)), 1)) : z("", !0)]))
    }
  }),
  WX = {
    key: 1,
    class: "flex h-full w-full items-center justify-center"
  },
  GX = ["max", "value"],
  Sd = te({
    __name: "ChallengeNumericInput",
    props: {
      max: {},
      modelValue: {
        default: "0"
      },
      formatInput: {},
      isNeedIncrementDecrement: {
        type: Boolean,
        default: !0
      },
      isFieldEnabled: {
        type: Boolean,
        default: !0
      },
      isFloat: {
        type: Boolean,
        default: !1
      }
    },
    emits: ["update:modelValue"],
    setup(e, {
      emit: t
    }) {
      const n = e,
        r = t,
        s = o => {
          const i = o.target;
          let l = n.formatInput(i.value);
          i.value = l;
          const c = n.isFloat ? l : l === "" ? 0 : Number(l);
          r("update:modelValue", c)
        },
        a = o => {
          if (!n.isFieldEnabled) return;
          const i = Number(n.modelValue),
            l = 1;
          let c = o === "increment" ? Math.min(n.max, i + l) : Math.max(0, i - l);
          n.isFloat && (c = Math.round(c * 1e6) / 1e6);
          const d = n.isFloat ? `${c}` : Math.round(c);
          r("update:modelValue", d)
        };
      return (o, i) => (g(), k("div", {
        class: we(["flex h-12 w-full cursor-pointer items-center justify-between rounded-xl bg-black-30 px-4 text-13 text-white shadow-inset-white", {
          "bg-white-10": !o.isFieldEnabled
        }])
      }, [o.isNeedIncrementDecrement ? (g(), k("div", {
        key: 0,
        onClick: i[0] || (i[0] = l => a("decrement"))
      }, [$(u(gB))])) : z("", !0), o.isFieldEnabled ? (g(), k("div", WX, [m("input", {
        max: n.max,
        value: n.modelValue,
        onInput: s,
        type: "text",
        class: "h-full w-full bg-transparent px-1 text-center placeholder-white outline-none ring-0 focus:ring-0"
      }, null, 40, GX)])) : z("", !0), o.isNeedIncrementDecrement ? (g(), k("div", {
        key: 2,
        onClick: i[1] || (i[1] = l => a("increment"))
      }, [$(u(y9))])) : z("", !0)], 2))
    }
  }),
  QX = {
    key: 0,
    class: "flex gap-5"
  },
  qX = {
    key: 0,
    class: "text-13 text-red-alert"
  },
  KX = {
    class: "flex w-44 justify-between"
  },
  ZX = te({
    __name: "ChallengeFeeField",
    setup(e) {
      const {
        t
      } = Fe(), n = s => gg(s, 2), r = L(() => ue.category === ln.P2P);
      return Ne(() => ue.category, () => {
        r.value || (ue.fee = null)
      }), (s, a) => r.value ? (g(), k("div", QX, [m("div", {
        class: "flex grow flex-col items-start justify-center",
        ref: o => u(na).fee = o
      }, [$(hr, {
        title: u(t)("challenge.p2p.entry_fee") + ", EUR",
        substring: u(t)("challenge.p2p.tooltip.fee")
      }, null, 8, ["title", "substring"]), u(vt).fee ? (g(), k("div", qX, R(u(Va)(u(vt).fee)), 1)) : z("", !0)], 512), m("div", {
        class: we(["flex h-12 items-center justify-center rounded-xl text-13 text-white", {
          "ring-1 ring-red-alert": u(vt).fee
        }])
      }, [m("div", KX, [$(Sd, {
        modelValue: u(ue).fee,
        "onUpdate:modelValue": a[0] || (a[0] = o => u(ue).fee = o),
        max: 1 / 0,
        "format-input": n,
        "is-need-increment-decrement": !1,
        "is-float": !0
      }, null, 8, ["modelValue"])])], 2)])) : z("", !0)
    }
  }),
  JX = {
    class: "flex gap-5"
  },
  XX = {
    class: "flex grow flex-col items-start justify-center"
  },
  eee = {
    class: "flex h-full w-44 justify-between"
  },
  tee = te({
    __name: "ChallengePrivacyField",
    setup(e) {
      const {
        t
      } = Fe(), n = () => {
        ue.privacy === bn.Public ? ue.privacy = bn.Private : (ue.join_code = null, ue.privacy = bn.Public)
      };
      return (r, s) => (g(), k("div", JX, [m("div", XX, [$(hr, {
        title: u(t)("challenge.p2p.privacy"),
        substring: u(t)("challenge.p2p.tooltip.privacy")
      }, null, 8, ["title", "substring"])]), m("div", {
        class: "flex h-12 items-center justify-center rounded-xl bg-black-30 text-13 text-white shadow-inset-white",
        onClick: n
      }, [m("div", eee, [m("div", {
        class: we(["my-1 ml-0.5 flex w-1/2 items-center justify-center", {
          "rounded-xl bg-gradient-to-b from-button-secondary-from to-button-secondary-to text-white  shadow-[inset_0_-2px_0_0_#212330,inset_0_1px_1px_0_rgba(255,255,255,0.35)]": u(ue).privacy === u(bn).Private,
          "text-white-30": u(ue).privacy === u(bn).Public
        }])
      }, [m("span", null, R(u(t)("challenge.p2p.private")), 1)], 2), m("div", {
        class: we(["my-1 ml-0.5 flex w-1/2 items-center justify-center", {
          "rounded-xl bg-gradient-to-b from-button-secondary-from to-button-secondary-to text-white  shadow-[inset_0_-2px_0_0_#212330,inset_0_1px_1px_0_rgba(255,255,255,0.35)]": u(ue).privacy === u(bn).Public,
          "text-white-30": u(ue).privacy === u(bn).Private
        }])
      }, [m("span", null, R(u(t)("challenge.p2p.public")), 1)], 2)])])]))
    }
  }),
  nee = {
    key: 0,
    class: "flex gap-5"
  },
  ree = {
    key: 0,
    class: "text-13 text-red-alert"
  },
  see = {
    class: "flex w-44 justify-between"
  },
  aee = te({
    __name: "ChallengeJoinCodeField",
    setup(e) {
      const {
        t
      } = Fe(), n = U(!1), r = () => {
        const s = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        let a = "";
        for (let o = 0; o < 5; o++) {
          const i = Math.floor(Math.random() * s.length);
          a += s.charAt(i)
        }
        ue.join_code = a
      };
      return Ne(() => ue.join_code, () => {
        ue.join_code && (ue.join_code = ue.join_code.toUpperCase())
      }), (s, a) => u(ue).privacy === u(bn).Private ? (g(), k("div", nee, [m("div", {
        class: "flex grow flex-col items-start justify-center",
        ref: o => u(na).join_code = o
      }, [$(hr, {
        title: u(t)("challenge.p2p.joining_code"),
        substring: u(t)("challenge.p2p.tooltip.joining_code")
      }, null, 8, ["title", "substring"]), u(vt).join_code ? (g(), k("div", ree, R(u(Va)(u(vt).join_code)), 1)) : z("", !0)], 512), m("div", {
        class: we(["flex h-12 items-center justify-center rounded-xl bg-black-30 text-13 text-white shadow-inset-white", {
          "ring-1 ring-red-alert": u(vt).join_code
        }])
      }, [m("div", see, [Tn(m("input", {
        "onUpdate:modelValue": a[0] || (a[0] = o => u(ue).join_code = o),
        maxlength: "5",
        onInput: a[1] || (a[1] = o => n.value = !0),
        class: "w-full bg-transparent text-center indent-10 uppercase placeholder-white outline-none ring-0 focus:ring-0"
      }, null, 544), [
        [Mi, u(ue).join_code]
      ]), m("div", {
        onClick: r,
        class: "mr-3 flex h-12 w-12 cursor-pointer items-center justify-center"
      }, [$(u(fB))])])], 2)])) : z("", !0)
    }
  }),
  oee = {
    class: "flex grow flex-col items-start"
  },
  iee = {
    class: "flex h-full items-center gap-x-2"
  },
  lee = {
    key: 0,
    class: "my-1 text-13 text-red-alert"
  },
  uee = {
    class: "flex w-44 justify-between"
  },
  cee = te({
    __name: "ChallengeSpinLimitField",
    setup(e) {
      const {
        t
      } = Fe(), n = U(!1);
      Ne(n, s => {
        ue.spin_limit = s ? 0 : null
      });
      const r = () => n.value = !n.value;
      return (s, a) => (g(), k("div", {
        class: "flex gap-5",
        ref: o => u(na).spin_limit = o
      }, [m("div", oee, [m("div", iee, [m("div", {
        class: we(["flex min-h-6 min-w-6 cursor-pointer items-center justify-center rounded-md bg-black-30 shadow-inset-white", {
          "bg-white-10": n.value
        }]),
        onClick: r
      }, [n.value ? (g(), G(u(w9), {
        key: 0
      })) : z("", !0)], 2), $(hr, {
        title: u(t)("challenge.p2p.spin_limit"),
        substring: u(t)("challenge.p2p.tooltip.spin_limit"),
        offset: -33
      }, null, 8, ["title", "substring"])]), u(vt).spin_limit ? (g(), k("div", lee, R(u(Va)(u(vt).spin_limit)), 1)) : z("", !0)]), m("div", {
        class: we(["flex h-12 items-center justify-center rounded-xl text-13 text-white shadow-inset-white", {
          "ring-1 ring-red-alert": u(vt).spin_limit
        }])
      }, [m("div", uee, [$(Sd, {
        modelValue: u(ue).spin_limit,
        "onUpdate:modelValue": a[0] || (a[0] = o => u(ue).spin_limit = o),
        max: 1 / 0,
        "format-input": u(v9),
        "is-field-enabled": n.value
      }, null, 8, ["modelValue", "format-input", "is-field-enabled"])])], 2)], 512))
    }
  }),
  dee = {
    class: "flex grow flex-col items-start"
  },
  fee = {
    class: "flex h-full items-center gap-x-2"
  },
  pee = {
    key: 0,
    class: "my-1 text-13 text-red-alert"
  },
  hee = {
    class: "flex w-44 justify-between"
  },
  mee = te({
    __name: "ChallengeMinBetField",
    setup(e) {
      const {
        t
      } = Fe(), n = U(!1);
      Ne(n, a => {
        ue.min_bet = a ? "0" : null
      });
      const r = () => {
          n.value = !n.value
        },
        s = a => gg(a, 2);
      return (a, o) => (g(), k("div", {
        class: "flex gap-5",
        ref: i => u(na).min_bet = i
      }, [m("div", dee, [m("div", fee, [m("div", {
        class: we(["flex min-h-6 min-w-6 cursor-pointer items-center justify-center rounded-md bg-black-30 shadow-inset-white", {
          "bg-white-10": n.value
        }]),
        onClick: r
      }, [n.value ? (g(), G(u(w9), {
        key: 0
      })) : z("", !0)], 2), $(hr, {
        title: u(t)("challenge.p2p.min_bet") + ", EUR",
        substring: u(t)("challenge.p2p.tooltip.min_bet"),
        offset: -33
      }, null, 8, ["title", "substring"])]), u(vt).min_bet ? (g(), k("div", pee, R(u(Va)(u(vt).min_bet)), 1)) : z("", !0)]), m("div", {
        class: we(["flex h-12 items-center justify-center rounded-xl text-13 text-white", {
          "ring-1 ring-red-alert": u(vt).min_bet
        }])
      }, [m("div", hee, [$(Sd, {
        modelValue: u(ue).min_bet,
        "onUpdate:modelValue": o[0] || (o[0] = i => u(ue).min_bet = i),
        "is-field-enabled": n.value,
        max: 1 / 0,
        "format-input": s,
        "is-need-increment-decrement": !1,
        "is-float": !0
      }, null, 8, ["modelValue", "is-field-enabled"])])], 2)], 512))
    }
  }),
  gee = {
    class: "text-13"
  },
  vee = {
    class: "mb-4 text-16 font-bold"
  },
  _ee = {
    class: "list-disc space-y-2 pl-4"
  },
  yee = {
    class: "font-bold"
  },
  bee = {
    class: "ml-1"
  },
  wee = {
    class: "font-bold"
  },
  Cee = {
    class: "ml-1"
  },
  xee = {
    class: "font-bold"
  },
  kee = {
    class: "ml-1"
  },
  See = {
    class: "mt-2 box-border rounded-xl border border-white-10 bg-gray-lighter py-3 pl-4 pr-4"
  },
  Eee = te({
    __name: "ChallengeFeaturesConditionField",
    setup(e) {
      const {
        t
      } = Fe();
      return (n, r) => (g(), k("div", null, [$(hr, {
        title: u(t)("challenge.p2p.buy_features_condition")
      }, {
        default: V(() => [m("div", gee, [m("p", vee, R(u(t)("challenge.p2p.tooltip.feature_conditions.header")), 1), m("ul", _ee, [m("li", null, [m("span", yee, R(u(t)("challenge.p2p.tooltip.feature_conditions.allowed_title")), 1), m("span", bee, R(u(t)("challenge.p2p.tooltip.feature_conditions.allowed_description")), 1)]), m("li", null, [m("span", wee, R(u(t)("challenge.p2p.tooltip.feature_conditions.bought_title")), 1), m("span", Cee, R(u(t)("challenge.p2p.tooltip.feature_conditions.bought_description")), 1)]), m("li", null, [m("span", xee, R(u(t)("challenge.p2p.tooltip.feature_conditions.bought_excluded_title")), 1), m("span", kee, R(u(t)("challenge.p2p.tooltip.feature_conditions.bought_excluded_description")), 1)])])])]),
        _: 1
      }, 8, ["title"]), m("div", See, [$(ys, {
        class: "mb-2 pt-2",
        id: "option_any_spin",
        modelValue: u(ue).feature_condition,
        "onUpdate:modelValue": r[0] || (r[0] = s => u(ue).feature_condition = s),
        description: u(t)("challenge.p2p.any_spin_allowed"),
        value: u(Pr).Allowed
      }, null, 8, ["modelValue", "description", "value"]), $(ys, {
        class: "mb-2 pt-2",
        id: "option_only_bought",
        modelValue: u(ue).feature_condition,
        "onUpdate:modelValue": r[1] || (r[1] = s => u(ue).feature_condition = s),
        description: u(t)("challenge.p2p.only_buy_features"),
        value: u(Pr).OnlyFeature
      }, null, 8, ["modelValue", "description", "value"]), $(ys, {
        class: "mb-2 pt-2 text-13",
        id: "option_exclude_bought",
        modelValue: u(ue).feature_condition,
        "onUpdate:modelValue": r[2] || (r[2] = s => u(ue).feature_condition = s),
        description: u(t)("challenge.p2p.buy_features_excluded"),
        value: u(Pr).DeniedBuy
      }, null, 8, ["modelValue", "description", "value"])])]))
    }
  }),
  Tee = {
    class: "mt-2 box-border rounded-xl border border-white-10 py-3 pl-4 pr-4"
  },
  Aee = {
    class: "w-8 font-bold"
  },
  Pee = ["onClick"],
  Iee = {
    key: 1,
    class: "w-8 opacity-0"
  },
  $ee = {
    key: 1,
    class: "flex h-full items-center justify-center pt-2 text-center text-13 text-red-alert"
  },
  Mee = {
    key: 0,
    class: "mt-6 font-bold"
  },
  Oee = {
    key: 1,
    class: "mt-6"
  },
  Dee = {
    class: "absolute left-0"
  },
  Lee = {
    class: "text-left text-16 font-bold"
  },
  Ree = {
    class: "mt-1 text-left text-13 font-normal text-white-30"
  },
  Nee = te({
    __name: "ChallengePrizeDistributionField",
    setup(e) {
      const {
        t
      } = Fe(), n = U(100), r = L(() => ue.prize_places.reduce((d, f) => Math.round(d * 100 + Number(f.prize) * 100) / 100, 0)), s = () => {
        ue.prize_places.length < 20 && ue.prize_places.push({
          place: ue.prize_places.length + 1,
          prize: "0"
        })
      }, a = L(() => ue.category === ln.P2P), o = d => {
        ue.prize_places.length <= 2 || (ue.prize_places.splice(d, 1), ue.prize_places.forEach((f, p) => {
          f.place = p + 1
        }))
      }, i = d => {
        let f = +d.replace(/[^\d]/g, "");
        return (isNaN(f) ? 0 : Math.floor(Math.max(Math.min(f, 99), 0))) + ""
      }, l = d => gg(d, 2), c = L(() => {
        const d = a.value ? ", %" : ", EUR";
        return t("challenge.p2p.prizes_distribution") + d
      });
      return Ne(() => ue.category, (d, f) => {
        d !== f && (ue.prize_places = [{
          place: 1,
          prize: "0"
        }, {
          place: 2,
          prize: "0"
        }])
      }), Ne(() => ue.prize_places, () => {
        ue.category === ln.Influencer && (ue.fee = ue.prize_places.reduce((d, f) => (d += Number(f.prize), d), 0).toString())
      }, {
        deep: !0
      }), (d, f) => (g(), k("div", null, [$(hr, {
        title: c.value,
        substring: a.value ? u(t)("challenge.p2p.tooltip.prizes_distribution") : u(t)("challenge.p2p.tooltip.prizes_distribution_money")
      }, null, 8, ["title", "substring"]), m("div", Tee, [m("div", {
        class: "my-2 flex w-full flex-col justify-between gap-y-2",
        ref: p => u(na).prize_places = p
      }, [(g(!0), k(Ee, null, Je(u(ue).prize_places, (p, h) => (g(), k("div", {
        key: h,
        class: "flex w-full items-center justify-between gap-x-4"
      }, [m("div", Aee, [m("h1", null, R(p.place), 1)]), $(Sd, {
        "format-input": a.value ? i : l,
        modelValue: p.prize,
        "onUpdate:modelValue": _ => p.prize = _,
        max: n.value - 1,
        "is-float": !0
      }, null, 8, ["format-input", "modelValue", "onUpdate:modelValue", "max"]), p.place > 1 && u(ue).prize_places.length > 2 ? (g(), k("div", {
        key: 0,
        class: "w-8 cursor-pointer",
        onClick: _ => o(h)
      }, [$(u(vy))], 8, Pee)) : (g(), k("div", Iee, [$(u(vy))]))]))), 128))], 512), u(ue).prize_places.length < 20 ? (g(), G(qt, {
        key: 0,
        onClick: s
      }, {
        default: V(() => [Ye(R(u(t)("challenge.p2p.add")), 1)]),
        _: 1
      })) : z("", !0), u(vt).prize_places ? (g(), k("div", $ee, [m("p", null, R(u(Va)(u(vt).prize_places)), 1)])) : z("", !0), m("div", {
        class: we(["w-full border border-white-10", [u(vt).prize_places ? "mt-2" : "mt-6"]])
      }, null, 2), m("div", {
        class: we(["relative", [a.value ? "mb-8" : "mb-4"]])
      }, [a.value ? z("", !0) : (g(), k("div", Mee, R(u(t)("challenge.p2p.total")) + ": " + R(r.value) + " EUR", 1)), a.value ? (g(), k("div", Oee, [m("div", Dee, [m("div", Lee, R(u(t)("challenge.p2p.total")), 1), m("div", Ree, R(u(t)("challenge.p2p.should_be")), 1)]), m("div", {
        class: we(["flex flex-col text-center", r.value === 100 ? "text-green" : "text-red-alert"])
      }, [m("p", null, R(r.value) + "%", 1)], 2)])) : z("", !0)], 2)])]))
    }
  }),
  Fee = {
    class: "mt-2 box-border rounded-xl border border-white-10 bg-gray-lighter py-3 pl-4 pr-4"
  },
  Bee = te({
    __name: "ChallengeJoinRulesField",
    setup(e) {
      const {
        t
      } = Fe();
      return (n, r) => (g(), k("div", null, [$(hr, {
        title: u(t)("challenge.p2p.joining_rules"),
        substring: u(t)("challenge.p2p.tooltip.joining_rules")
      }, null, 8, ["title", "substring"]), m("div", Fee, [$(ys, {
        class: "mb-2 pt-2",
        id: "can_join",
        modelValue: u(ue).joining_rule,
        "onUpdate:modelValue": r[0] || (r[0] = s => u(ue).joining_rule = s),
        description: u(t)("challenge.p2p.can_join"),
        value: u(As).AllowAfterStart
      }, null, 8, ["modelValue", "description", "value"]), $(ys, {
        class: "mb-2 pt-2",
        id: "not_join",
        modelValue: u(ue).joining_rule,
        "onUpdate:modelValue": r[1] || (r[1] = s => u(ue).joining_rule = s),
        description: u(t)("challenge.p2p.not_join"),
        value: u(As).DenyAfterStart
      }, null, 8, ["modelValue", "description", "value"])])]))
    }
  }),
  jee = {
    class: "box-border flex items-center justify-center rounded-xl border border-white-10 bg-gray-lighter py-5 text-16 font-bold"
  },
  Hee = te({
    __name: "ChallengeFeeInformField",
    setup(e) {
      const {
        t
      } = Fe(), n = L(() => {
        const r = {
            value: Gn(ue.fee ? Number(ue.fee) * 100 : 0)
          },
          s = `challenge.p2p.${ue.category===ln.P2P?"fee_is":"pool_is"}`;
        return t(s, r)
      });
      return (r, s) => (g(), k("div", jee, [m("h1", null, R(n.value), 1)]))
    }
  }),
  Vee = {
    class: "box-border flex flex-col rounded-xl border border-white-10 bg-gray-lighter px-4 py-4 text-16 font-bold"
  },
  Uee = {
    class: "my-2"
  },
  zee = {
    class: "flex cursor-pointer",
    for: "confirm_fee"
  },
  Yee = {
    class: "ml-2.5"
  },
  Wee = {
    class: "text-13 font-normal leading-5"
  },
  Gee = {
    class: "my-2"
  },
  Qee = {
    class: "flex cursor-pointer",
    for: "confirm_creation"
  },
  qee = {
    class: "ml-2.5"
  },
  Kee = {
    class: "text-13 font-normal leading-5"
  },
  Zee = te({
    __name: "ChallengeConfirmField",
    setup(e) {
      const {
        t
      } = Fe(), n = L(() => {
        const r = `challenge.p2p.agreements_debited${ue.category===ln.P2P?"":"_pool"}`;
        return t(r, {
          value: Gn(ue.fee ? Number(ue.fee) * 100 : 0)
        })
      });
      return (r, s) => (g(), k("div", Vee, [m("div", Uee, [Tn(m("input", {
        class: "hidden",
        type: "checkbox",
        id: "confirm_fee",
        "onUpdate:modelValue": s[0] || (s[0] = a => u(ue).confirm_fee = a)
      }, null, 512), [
        [B2, u(ue).confirm_fee]
      ]), m("label", zee, [m("div", {
        class: we([{
          "bg-yellow": u(ue).confirm_fee,
          "flex h-4 w-4 items-center justify-center rounded bg-black-30 shadow-inset-white": !u(ue).confirm_fee
        }, "flex h-4 w-4 items-center justify-start gap-2 rounded p-1"])
      }, [m("div", {
        class: we(["mb-0.5 h-1.5 w-3 rotate-[-45deg] border-b-2 border-l-2 border-black", u(ue).confirm_fee ? "opacity-100" : "opacity-0"])
      }, null, 2)], 2), m("div", Yee, [m("p", Wee, R(n.value), 1)])])]), m("div", Gee, [Tn(m("input", {
        class: "hidden",
        type: "checkbox",
        id: "confirm_creation",
        "onUpdate:modelValue": s[1] || (s[1] = a => u(ue).confirm_creation = a)
      }, null, 512), [
        [B2, u(ue).confirm_creation]
      ]), m("label", Qee, [m("div", {
        class: we([{
          "bg-yellow": u(ue).confirm_creation,
          "flex h-4 w-4 items-center justify-center rounded bg-black-30 shadow-inset-white": !u(ue).confirm_creation
        }, "flex h-4 w-4 items-center justify-start gap-2 rounded p-1"])
      }, [m("div", {
        class: we(["mb-0.5 h-1.5 w-3 rotate-[-45deg] border-b-2 border-l-2 border-black", u(ue).confirm_creation ? "opacity-100" : "opacity-0"])
      }, null, 2)], 2), m("div", qee, [m("p", Kee, R(u(t)("challenge.p2p.agreements_cant_edit")), 1)])])])]))
    }
  }),
  Jee = {
    key: 0,
    class: "w-full border border-white-10"
  },
  Xee = {
    class: "flex grow flex-col items-start justify-center"
  },
  ete = {
    key: 0,
    class: "text-13 text-red-alert"
  },
  tte = {
    class: "flex w-44 justify-between"
  },
  nte = te({
    __name: "ChallengeMultiplierField",
    setup(e) {
      const {
        t
      } = Fe();
      return Ne(() => ue.challenge_type, () => {
        ue.challenge_type !== ht.TopMultiplierSum && (ue.top_multiplier_count = null)
      }), (n, r) => (g(), k(Ee, null, [u(ue).challenge_type === u(ht).TopMultiplierSum ? (g(), k("div", Jee)) : z("", !0), u(ue).challenge_type === u(ht).TopMultiplierSum ? (g(), k("div", {
        key: 1,
        class: "flex gap-5",
        ref: s => u(na).top_multiplier_count = s
      }, [m("div", Xee, [$(hr, {
        title: u(t)("challenge.p2p.multiplier_count"),
        substring: u(t)("challenge.p2p.tooltip.multiplier")
      }, null, 8, ["title", "substring"]), u(vt).top_multiplier_count ? (g(), k("div", ete, R(u(Va)(u(vt).top_multiplier_count)), 1)) : z("", !0)]), m("div", {
        class: we(["flex h-12 items-center justify-center rounded-xl text-13 text-white shadow-inset-white", {
          "ring-1 ring-red-alert": u(vt).top_multiplier_count
        }])
      }, [m("div", tte, [$(Sd, {
        modelValue: u(ue).top_multiplier_count,
        "onUpdate:modelValue": r[0] || (r[0] = s => u(ue).top_multiplier_count = s),
        max: 1 / 0,
        "format-input": u(v9)
      }, null, 8, ["modelValue", "format-input"])])], 2)], 512)) : z("", !0)], 64))
    }
  }),
  rte = te({
    __name: "ChallengeRules",
    setup(e) {
      const {
        t
      } = Fe(), n = (s, a = {}) => t(`challenge.rules.${s}`, a), r = L(() => {
        const s = [];
        return [{
          text: n("fee", {
            value: Gn(ue.fee ? Number(ue.fee) * 100 : 0)
          }),
          iconType: "IconBet",
          isEnabled: !!ue.fee && ue.category === ln.P2P
        }, {
          text: n("goal"),
          iconType: "IconGoal",
          isEnabled: ue.challenge_type === ht.MaxMultiplier
        }, {
          text: n("goal_bets", {
            value: "1 EUR"
          }),
          iconType: "IconGoal",
          isEnabled: ue.challenge_type === ht.BetsSum
        }, {
          text: n("goal_mult", {
            value: ue.top_multiplier_count || 0
          }),
          iconType: "IconGoal",
          isEnabled: ue.challenge_type === ht.TopMultiplierSum
        }, {
          text: n("goal_sum"),
          iconType: "IconGoal",
          isEnabled: ue.challenge_type === ht.MultipliersSum
        }, {
          text: n("winner"),
          iconType: "IconWinner",
          isEnabled: ue.challenge_type === ht.MaxMultiplier
        }, {
          text: n("winner_bets"),
          iconType: "IconWinner",
          isEnabled: ue.challenge_type === ht.BetsSum
        }, {
          text: n("winner_mult"),
          iconType: "IconWinner",
          isEnabled: ue.challenge_type === ht.TopMultiplierSum
        }, {
          text: n("winner_sum"),
          iconType: "IconWinner",
          isEnabled: ue.challenge_type === ht.MultipliersSum
        }, {
          text: n("id"),
          iconType: "IconId",
          isEnabled: !0
        }, {
          text: n("bet"),
          iconType: "IconBet",
          isEnabled: !ue.min_bet
        }, {
          text: n("bet_eur", {
            value: Gn(ue.min_bet ? Number(ue.min_bet) * 100 : 0)
          }),
          iconType: "IconBet",
          isEnabled: !!ue.min_bet
        }, {
          text: n("spin"),
          iconType: "IconSpin",
          isEnabled: ue.feature_condition === Pr.Allowed
        }, {
          text: n("spin_feature"),
          iconType: "IconSpin",
          isEnabled: ue.feature_condition === Pr.OnlyFeature
        }, {
          text: n("spin_denied"),
          iconType: "IconSpin",
          isEnabled: ue.feature_condition === Pr.DeniedBuy
        }, {
          text: n("limit"),
          iconType: "IconSpinCount",
          isEnabled: !ue.spin_limit
        }, {
          text: n("limit_on", {
            value: ue.spin_limit
          }),
          iconType: "IconSpinCount",
          isEnabled: !!ue.spin_limit
        }, {
          text: n("one_participant"),
          iconType: "IconUser",
          isEnabled: !0
        }, {
          text: n("fewer_participant"),
          iconType: "IconUser",
          isEnabled: !0
        }, {
          text: n("prizes_distribution"),
          iconType: "IconWinner",
          isEnabled: !0
        }, {
          text: n("opened_after_start"),
          iconType: "IconTimer",
          isEnabled: ue.joining_rule === As.AllowAfterStart
        }, {
          text: n("closed_after_start"),
          iconType: "IconTimer",
          isEnabled: ue.joining_rule === As.DenyAfterStart
        }].forEach(({
          text: o,
          iconType: i,
          isEnabled: l
        }) => {
          l && s.push({
            iconType: i,
            text: o
          })
        }), s
      });
      return (s, a) => (g(), G(u(H9), {
        class: "m-0 sm:mb-0",
        rulesList: r.value,
        id: "challengeRules"
      }, null, 8, ["rulesList"]))
    }
  }),
  ste = () => E0({
    mutationKey: ["createChallenge"],
    mutationFn: e => dk(e),
    onMutate: () => {
      bt.loading = !0
    },
    onSuccess: e => {
      $t.invalidateQueries({
        queryKey: ["challenges"]
      }), $t.invalidateQueries({
        queryKey: ["challengeSearchPagination"]
      }), $t.invalidateQueries({
        queryKey: ["challengeFinishedSearchPagination"]
      });
      const t = e == null ? void 0 : e.id;
      gs.id = (e == null ? void 0 : e.id) || null, gs.name = (e == null ? void 0 : e.name) || null, gs.join_code = (e == null ? void 0 : e.join_code) || null, gs.privacy = (e == null ? void 0 : e.privacy) || null, t && (gd.value = !0, Cn.push({
        name: "challenge",
        params: {
          id: t
        }
      }))
    },
    onError: e => {
      rH(e)
    },
    onSettled: () => {
      bt.loading = !1
    }
  }),
  ate = () => {
    var t, n;
    const e = {
      category: ue.category,
      challenge_type: ue.challenge_type,
      image_url: ue.image_url,
      game_identifiers: ue.game_identifiers.map(r => r.identifier),
      privacy: ue.privacy,
      start_at: ((t = ue.start_at) == null ? void 0 : t.toISOString()) || "",
      finish_at: ((n = ue.finish_at) == null ? void 0 : n.toISOString()) || "",
      feature_condition: ue.feature_condition,
      prize_places: ue.prize_places.map(r => ({
        place: r.place,
        prize: Number(r.prize)
      })),
      joining_rule: ue.joining_rule
    };
    return ue.spin_limit && ue.spin_limit > 0 && (e.spin_limit = ue.spin_limit), ue.min_bet && Number(ue.min_bet) > 0 && (e.min_bet = Number(ue.min_bet)), ue.challenge_type === ht.TopMultiplierSum && (e.top_multiplier_count = ue.top_multiplier_count), ue.category === ln.P2P && (e.fee = ue.fee ? Number(ue.fee) : 0), ue.privacy === bn.Private && (e.join_code = ue.join_code), e
  },
  ote = te({
    __name: "ChallengeCreateButton",
    setup(e) {
      const {
        t
      } = Fe(), {
        mutate: n,
        isPending: r
      } = ste(), s = L(() => ue.category === ln.P2P), a = L(() => rp.value && jy.value ? !0 : !ue.confirm_fee || !ue.confirm_creation), o = () => {
        if (rp.value = !0, Tg(), !jy.value) {
          const i = ate();
          n(i)
        }
      };
      return (i, l) => (g(), G(qt, {
        variant: u(r) ? "processing" : "primary",
        disabled: a.value,
        onClick: l[0] || (l[0] = c => o())
      }, {
        default: V(() => [Ye(R(s.value ? u(t)("challenge.p2p.challenge_pay_fee_create") : u(t)("challenge.p2p.challenge_deposit_prize_create")), 1)]),
        _: 1
      }, 8, ["variant", "disabled"]))
    }
  }),
  ite = {
    key: 0,
    class: "absolute bottom-0 left-0 right-0 top-0 z-[57] flex w-full items-center justify-center bg-[rgba(33,35,48,0.90)] sm:items-center"
  },
  lte = {
    class: "flex w-full items-center justify-center"
  },
  ute = {
    class: "mt-4 font-accent text-24 font-bold text-white"
  },
  cte = te({
    __name: "ChallengeLoadingModal",
    setup(e) {
      const {
        t
      } = Fe();
      return (n, r) => u(bt).loading ? (g(), k("div", ite, [m("div", null, [m("div", lte, [$(u(Ka))]), m("div", ute, R(u(t)("challenge.p2p.challenge_creating")), 1)])])) : z("", !0)
    }
  }),
  dte = {
    key: 0,
    class: "absolute bottom-0 left-0 right-0 top-0 z-[57] flex w-full items-center justify-center bg-[rgba(33,35,48,0.90)] sm:items-center"
  },
  fte = {
    class: "relative my-5 mt-2 box-border w-full max-w-[400px] rounded-xl border border-white-10 bg-gray-lighter p-4 sm:mt-5 sm:h-auto sm:p-4 md:mt-5 md:p-10 lg:mt-2"
  },
  pte = {
    class: "mt-7 text-center font-accent text-24 font-bold leading-[120%] sm:mt-4 sm:text-16 md:mt-7 md:text-24"
  },
  hte = {
    class: "mt-32 flex w-full items-center justify-center gap-2 sm:mt-8 sm:gap-5 md:mt-20"
  },
  mte = te({
    __name: "ChallengeLeaveModal",
    setup(e) {
      const {
        t
      } = Fe();
      Cn.beforeEach((s, a) => (s.fullPath === "/lobby/create/challenge" && R9(), a.fullPath === "/lobby/create/challenge" && !bt.leavePath && !gd.value ? (Object.assign(bt, {
        leave: !0,
        leavePath: s.fullPath
      }), !1) : !0));
      const n = () => {
          Object.assign(bt, {
            leavePath: "",
            leave: !1
          })
        },
        r = () => {
          O9(), bt.leave = !1, bt.leavePath ? Cn.push(bt.leavePath) : bt.closeLobby && (bt.leavePath = "", ps()), bt.closeLobby = !1
        };
      return (s, a) => u(bt).leave ? (g(), k("div", dte, [m("div", fte, [$(u(qa), {
        class: "absolute right-3 top-3 cursor-pointer",
        onClick: n
      }), a[0] || (a[0] = m("div", {
        class: "mt-28 flex items-center justify-center sm:mt-4 md:mt-11"
      }, [m("img", {
        class: "h-auto w-[120px] sm:w-[60px] md:w-[120px]",
        src: Dg,
        alt: "Info Img"
      })], -1)), m("div", pte, R(u(t)("challenge.p2p.form_leave_warning")), 1), m("div", hte, [$(qt, {
        variant: "secondary",
        class: "px-1 py-2 sm:text-12 lg:text-15",
        onClick: r
      }, {
        default: V(() => [Ye(R(u(t)("challenge.p2p.form_discard")), 1)]),
        _: 1
      }), $(qt, {
        variant: "primary",
        class: "px-1 py-2 sm:text-12 lg:text-15",
        onClick: n
      }, {
        default: V(() => [Ye(R(u(t)("challenge.p2p.form_keep_editing")), 1)]),
        _: 1
      })])])])) : z("", !0)
    }
  }),
  gte = "./assets/wallet.png",
  vte = {
    key: 0,
    class: "absolute bottom-0 left-0 right-0 top-0 z-[57] flex w-full items-center justify-center bg-[rgba(33,35,48,0.90)] sm:items-center"
  },
  _te = {
    class: "relative my-5 mt-2 box-border w-full max-w-[400px] rounded-xl border border-white-10 bg-gray-lighter p-4 sm:mt-5 sm:h-auto sm:p-4 md:mt-5 md:p-10 lg:mt-2"
  },
  yte = {
    class: "mt-28 flex items-center justify-center sm:mt-4 md:mt-11"
  },
  bte = {
    key: 0,
    class: "h-auto w-[120px] sm:w-[60px] md:w-[120px]",
    src: gte,
    alt: "Info Img"
  },
  wte = {
    key: 1,
    class: "h-auto w-[120px] sm:w-[60px] md:w-[120px]",
    src: Dg,
    alt: "Info Img"
  },
  Cte = {
    class: "mt-4 text-center font-accent text-24 font-bold leading-[120%] sm:mt-4 sm:text-16 md:mt-7 md:text-24"
  },
  xte = {
    class: "mt-2 text-center text-16 font-normal"
  },
  kte = {
    class: "mt-32 flex w-full items-center justify-center gap-2 sm:mt-8 sm:gap-5 md:mt-20"
  },
  Ste = te({
    __name: "ChallengeErrorFormModal",
    setup(e) {
      const {
        t
      } = Fe(), n = () => {
        bt.error = !1, Um.value = null
      }, r = L(() => {
        const s = Um.value;
        return s !== null && By[s] ? By[s] : Xj
      });
      return (s, a) => u(bt).error ? (g(), k("div", vte, [m("div", _te, [$(u(qa), {
        class: "absolute right-3 top-3 cursor-pointer",
        onClick: n
      }), m("div", yte, [r.value.icon === "wallet" ? (g(), k("img", bte)) : (g(), k("img", wte))]), m("div", Cte, R(u(t)(r.value.title)), 1), m("div", xte, R(u(t)(r.value.subtitle)), 1), m("div", kte, [$(qt, {
        variant: "primary",
        class: "px-1 py-2 sm:text-12 lg:text-15",
        onClick: n
      }, {
        default: V(() => [Ye(R(u(t)("challenge.p2p.got_it")), 1)]),
        _: 1
      })])])])) : z("", !0)
    }
  }),
  Ete = "./assets/cup.png",
  Tte = {
    key: 0,
    class: "absolute bottom-0 left-0 right-0 top-0 z-[57] flex w-full items-center justify-center bg-[rgba(33,35,48,0.90)] sm:items-center"
  },
  Ate = {
    class: "relative my-5 mt-2 box-border w-full max-w-[400px] rounded-xl border border-white-10 bg-yellow p-4 sm:mt-5 sm:h-auto sm:p-4 md:mt-5 md:p-10 lg:mt-2"
  },
  Pte = {
    class: "mt-7 text-center font-accent text-24 font-bold leading-[120%] text-black sm:mt-4 sm:text-16 md:mt-7 md:text-24"
  },
  Ite = {
    class: "mt-4 text-center text-16 font-normal text-black"
  },
  $te = {
    class: "mt-1 text-center text-16 font-bold text-black"
  },
  Mte = {
    class: "mt-1 text-center text-16 font-normal text-black"
  },
  Ote = {
    key: 0
  },
  Dte = {
    class: "font-bold"
  },
  Lte = {
    key: 1
  },
  Rte = {
    class: "mt-32 flex w-full flex-col items-center gap-1 sm:mt-8 sm:gap-5 md:mt-20"
  },
  Nte = te({
    __name: "ChallengeSuccessfulModal",
    setup(e) {
      const {
        t
      } = Fe();
      Cn.beforeEach((s, a) => (s.fullPath === "/lobby/create/challenge" && R9(), a.fullPath === "/lobby/create/challenge" && !bt.success && gd.value ? (bt.success = !0, bt.leavePath = s.fullPath, !1) : !0));
      const n = () => {
          var a;
          const s = document.createElement("textarea");
          s.value = ((a = gs.join_code) == null ? void 0 : a.toString()) || "", document.body.appendChild(s), s.select();
          try {
            document.execCommand("copy")
          } catch (o) {
            console.warn("error copy code: ", o)
          } finally {
            document.body.removeChild(s), s.remove()
          }
        },
        r = () => {
          bt.closeLobby ? (bt.leavePath = "", ps()) : Cn.push(bt.leavePath), bt.success = !1, bt.closeLobby = !1, O9()
        };
      return (s, a) => {
        var o;
        return u(bt).success ? (g(), k("div", Tte, [m("div", Ate, [$(u(qa), {
          class: "absolute right-3 top-3 cursor-pointer text-black",
          onClick: r
        }), a[0] || (a[0] = m("div", {
          class: "mt-28 flex items-center justify-center sm:mt-4 md:mt-11"
        }, [m("img", {
          class: "h-auto w-[120px] sm:w-[60px] md:w-[120px]",
          src: Ete,
          alt: "Info Img"
        })], -1)), m("div", Pte, R(u(t)("challenge.p2p.congratulations")), 1), m("div", Ite, R(u(t)("challenge.p2p.you_created")), 1), m("div", $te, R(u(t)("challenge.p2p.challenge", {
          value: (o = u(gs).name) == null ? void 0 : o.replace(/\D/g, "")
        })), 1), m("div", Mte, [u(gs).privacy === u(bn).Private ? (g(), k("p", Ote, [Ye(R(u(t)("challenge.p2p.invite_code_first_part")) + " ", 1), m("span", Dte, R(u(gs).join_code), 1), Ye(" " + R(u(t)("challenge.p2p.invite_code_second_part")), 1)])) : (g(), k("p", Lte, R(u(t)("challenge.p2p.invite_more")), 1))]), m("div", Rte, [u(gs).privacy === u(bn).Private ? (g(), k(Ee, {
          key: 0
        }, [$(qt, {
          variant: "ghost",
          class: "px-1 py-2 sm:text-12 lg:text-15",
          onClick: n
        }, {
          default: V(() => [Ye(R(u(t)("challenge.playerCode.button")), 1)]),
          _: 1
        }), m("button", {
          class: "h-12 w-full font-bold uppercase text-black sm:text-12 lg:text-15",
          onClick: r
        }, R(u(t)("challenge.p2p.got_it")), 1)], 64)) : (g(), G(qt, {
          key: 1,
          variant: "ghost",
          class: "px-1 py-2 sm:text-12 lg:text-15",
          onClick: r
        }, {
          default: V(() => [Ye(R(u(t)("challenge.p2p.got_it")), 1)]),
          _: 1
        }))])])])) : z("", !0)
      }
    }
  }),
  Fte = {
    class: "mx-4 my-4 flex flex-col gap-5 sm:mb-4 sm:mt-0"
  },
  Bte = !1,
  jte = te({
    __name: "ChallengeCreate",
    setup(e) {
      return (t, n) => (g(), G(u(Jn), {
        class: "h-full"
      }, {
        default: V(() => [$(Nte), $(mte), $(Ste), $(cte), $(wQ), m("div", Fte, [$(DQ), $(RQ), n[0] || (n[0] = m("div", {
          class: "w-full border border-white-10"
        }, null, -1)), $(mQ), $(YX), $(ZX), Bte ? (g(), G(tee, {
          key: 0
        })) : z("", !0), $(aee), $(kX), $(nte), n[1] || (n[1] = m("div", {
          class: "w-full border border-white-10"
        }, null, -1)), $(cee), $(mee), n[2] || (n[2] = m("div", {
          class: "w-full border border-white-10"
        }, null, -1)), $(Eee), $(Nee), $(Bee), $(rte), $(Zee), $(Hee), $(ote)])]),
        _: 1
      }))
    }
  }),
  Hte = {
    class: "relative w-full sm:w-4/6 sm:border-l sm:border-white-10 sm:pr-0"
  },
  Vte = te({
    __name: "CreateChallengePage",
    setup(e) {
      const t = Tr("(min-width: 568px)"),
        n = L(() => !t.value);
      return (r, s) => (g(), G(vd, {
        id: "create",
        isActivePath: "/lobby/challenge"
      }, {
        default: V(() => [$(G9, {
          id: "create",
          class: we(["relative w-full rounded-bl-xl sm:w-2/6", {
            hidden: n.value
          }])
        }, null, 8, ["class"]), m("div", Hte, [$(jte)])]),
        _: 1
      }))
    }
  }),
  Ute = {
    class: "mt-2"
  },
  zte = {
    class: "mb-3 flex items-center justify-between"
  },
  Yte = {
    class: "text-15 font-bold text-yellow sm:text-16"
  },
  Wte = {
    class: "text-10 font-normal text-white-50 sm:text-14"
  },
  Gte = {
    class: "h-1.5 w-full rounded-xl bg-black-30"
  },
  Qte = te({
    __name: "ProfileProgressBar",
    props: {
      level: {},
      value: {},
      max: {},
      progress: {}
    },
    setup(e) {
      const {
        t
      } = Fe();
      return (n, r) => (g(), k("div", Ute, [m("div", zte, [m("div", Yte, R(u(t)("profile.level")) + " " + R(n.level), 1), m("div", Wte, R(Math.floor(n.value)) + "/" + R(n.max) + R(u(t)("profile.xp")), 1)]), m("div", Gte, [m("div", {
        class: "h-1.5 rounded-xl bg-yellow duration-300 ease-linear",
        style: Mt({
          width: n.progress + "%"
        })
      }, null, 4)])]))
    }
  });
var li = (e => (e.BigWins = "big_wins", e.P2PChallenges = "p2p_challenges", e.MysteryBox = "mystery_box", e))(li || {}),
  Xm = (e => (e.LevelUpPoints = "level_up_points", e))(Xm || {});
const qte = {
    class: "flex rounded-xl border border-white-10 bg-gray-lighter p-4"
  },
  Kte = {
    class: "flex items-start gap-2"
  },
  Zte = {
    class: "relative z-0 mx-1 min-w-6 text-yellow"
  },
  Jte = {
    class: "absolute -inset-x-3 -inset-y-3 flex h-11 w-11 items-center justify-center"
  },
  Xte = {
    class: "flex flex-col gap-y-1"
  },
  ene = {
    class: "mt-0 pt-0 text-16 font-bold text-white"
  },
  tne = {
    key: 0,
    class: "text-13"
  },
  ch = te({
    __name: "ProfilePrivilegeCard",
    props: {
      points: {},
      level: {},
      privilege_type: {}
    },
    setup(e) {
      const {
        t
      } = Fe(), n = e, r = {
        [Xm.LevelUpPoints]: yF,
        [li.BigWins]: iF,
        [li.P2PChallenges]: dF,
        [li.MysteryBox]: mF,
        undefined: xF
      }, s = {
        [Xm.LevelUpPoints]: t("profile.privileges.type_title.extra_points", {
          value: n.points || 0
        }),
        [li.BigWins]: t("profile.privileges.type_title.big_wins"),
        [li.P2PChallenges]: t("profile.privileges.type_title.p2p_challenges"),
        [li.MysteryBox]: t("profile.privileges.type_title.mystery_box"),
        undefined: t("profile.privileges.next_empty")
      }, a = r[n.privilege_type ?? "undefined"], o = s[n.privilege_type ?? "undefined"];
      return (i, l) => (g(), k("div", null, [m("div", qte, [m("div", Kte, [m("div", Zte, [m("div", Jte, [$(u(a))])]), m("div", Xte, [m("div", ene, R(u(o)), 1), i.level ? (g(), k("div", tne, R(u(t)("profile.level")) + " " + R(i.level), 1)) : z("", !0)])])])]))
    }
  }),
  nne = {
    key: 0,
    class: "mx-4 mb-4 flex flex-col gap-x-1 gap-y-2"
  },
  rne = {
    class: "mb-2 mt-6 flex justify-center text-16 font-bold uppercase text-yellow"
  },
  sne = {
    class: "mb-2 mt-6 flex justify-center text-16 font-bold uppercase text-yellow"
  },
  ane = te({
    __name: "ProfilePrivilegeList",
    setup(e) {
      const {
        t
      } = Fe(), {
        data: n
      } = Kp();
      return (r, s) => u(n) ? (g(), k("div", nne, [m("div", rne, R(u(t)("profile.privileges.next_title")), 1), u(n).next_privileges.length ? (g(!0), k(Ee, {
        key: 0
      }, Je(u(n).next_privileges, ({
        points: a,
        level: o,
        privilege_type: i,
        reward_type: l
      }) => (g(), k("div", {
        key: o
      }, [$(ch, {
        privilege_type: i || l,
        points: a,
        level: o
      }, null, 8, ["privilege_type", "points", "level"])]))), 128)) : (g(), G(ch, {
        key: 1
      })), u(n).current_privileges.length ? (g(), k(Ee, {
        key: 2
      }, [m("div", sne, R(u(t)("profile.privileges.current_title")), 1), (g(!0), k(Ee, null, Je(u(n).current_privileges, ({
        points: a,
        level: o,
        privilege_type: i,
        reward_type: l
      }) => (g(), k("div", {
        key: o
      }, [$(ch, {
        privilege_type: i || l,
        points: a,
        level: o
      }, null, 8, ["privilege_type", "points", "level"])]))), 128))], 64)) : z("", !0)])) : z("", !0)
    }
  }),
  one = {
    key: 0,
    class: "flex flex-1 flex-col items-center justify-center"
  },
  ine = {
    class: "flex h-fit w-full flex-col pb-16 sm:pb-0"
  },
  lne = {
    key: 0,
    class: "sticky top-0 z-[56] flex h-12 w-full items-center justify-center rounded-t-xl border-b border-white-10 bg-gray-lighter"
  },
  une = {
    class: "flex items-center justify-between gap-2"
  },
  cne = {
    class: "text-center font-accent text-24 font-bold text-white"
  },
  dne = {
    key: 1,
    class: "m-4 flex h-fit flex-1 flex-col items-center gap-2 rounded-xl border border-white-10 bg-gray-lighter p-4 sm:flex-row sm:items-start sm:gap-5"
  },
  fne = {
    class: "flex flex-col items-center gap-1 sm:items-start"
  },
  pne = {
    class: "text-10 uppercase text-white-50"
  },
  hne = {
    class: "font-accent text-16 font-bold"
  },
  mne = {
    class: "text-13 text-white-30"
  },
  gne = {
    class: "m-4 rounded-xl border border-white-10 bg-gray-lighter p-4"
  },
  vne = {
    class: "flex flex-col items-center gap-2 sm:flex-row sm:items-start sm:gap-5"
  },
  _ne = {
    class: "flex flex-col gap-1 sm:gap-0"
  },
  yne = {
    class: "text-center text-10 font-normal uppercase text-white-50 sm:text-start sm:text-14"
  },
  bne = {
    class: "mb-1 text-center text-15 font-bold text-white sm:mb-2 sm:text-start sm:text-24"
  },
  wne = te({
    __name: "Profile",
    setup(e) {
      const {
        t
      } = Fe(), n = Tr("(min-width: 568px)"), r = U(!1), {
        data: s,
        isLoading: a,
        error: o
      } = Kp(), i = l => {
        l.currentTarget.scrollTop > 48 ? r.value = !0 : r.value = !1
      };
      return Ge(() => {
        var l;
        Jt({
          payload: {
            eventName: "lobby_loyalty_open",
            eventData: {
              loyalty_level: (l = s == null ? void 0 : s.value) == null ? void 0 : l.current_level
            }
          }
        })
      }), (l, c) => u(a) ? (g(), k("div", one, [$(u(Ka))])) : (g(), G(u(Jn), {
        key: 1,
        class: "h-full w-full p-0",
        handleScroll: i
      }, {
        default: V(() => [m("div", ine, [u(n) ? z("", !0) : (g(), k("div", lne, [m("div", une, [m("h1", cne, R(u(t)("profile.title")), 1)]), $(u(pr), {
          class: "absolute right-1 top-1 cursor-pointer hover:scale-95 sm:hidden",
          onClick: u(ps)
        }, null, 8, ["onClick"])])), u(o) || !u(s) ? (g(), k("div", dne, [$(u(Dm), {
          class: "h-8 w-8 text-gray-light sm:h-10 sm:w-10"
        }), m("div", fne, [m("div", pne, R(u(t)("profile.id_title")), 1), m("div", hne, R(u(t)("profile.error.title")), 1), m("div", mne, R(u(t)("profile.error.sub_title")), 1)])])) : (g(), k(Ee, {
          key: 2
        }, [m("div", gne, [m("div", vne, [$(u(Dm), {
          class: "h-8 w-8 rounded-full text-yellow shadow-[0_0_0_#D07E04,0_0_12px_#FF7A00] sm:h-10 sm:w-10"
        }), m("div", _ne, [m("div", yne, R(u(t)("profile.id_title")), 1), m("div", bne, R(u(s).id), 1)])]), $(Qte, {
          level: u(s).current_level,
          value: u(s).current_points - u(s).initial_level_points,
          max: u(s).points_for_next_level,
          progress: u(s).progress
        }, null, 8, ["level", "value", "max", "progress"])]), $(ane)], 64))])]),
        _: 1
      }))
    }
  }),
  Cne = te({
    __name: "ProfilePage",
    setup(e) {
      return (t, n) => (g(), G(vd, {
        isActivePath: "/lobby/profile"
      }, {
        default: V(() => [$(wne)]),
        _: 1
      }))
    }
  }),
  xne = () => ns({
    queryKey: ["challenges"],
    queryFn: () => ik(),
    select: e => (e.active = e.active.map(t => (t.image_url = t.custom_header_url || t.image_url, t)), e.planned = e.planned.map(t => (t.image_url = t.custom_header_url || t.image_url, t)), e.finished = e.finished.map(t => (t.image_url = t.custom_header_url || t.image_url, t)), e),
    refetchInterval: 60 * 1e3,
    placeholderData: ts,
    staleTime: 60 * 1e3
  });

function kne() {
  const {
    isLoading: e,
    data: t
  } = xne(), {
    isLoading: n,
    data: r
  } = Mg(), s = L(() => e.value || n.value);
  return {
    events: L(() => {
      var d, f, p, h, _, v, C;
      const o = ((f = (d = t.value) == null ? void 0 : d.planned) == null ? void 0 : f.map(y => ({
          id: String(y.id),
          name: y.name,
          games: y.game_identifiers
        }))) || [],
        i = ((h = (p = t.value) == null ? void 0 : p.active) == null ? void 0 : h.map(y => ({
          id: String(y.id),
          name: y.name,
          games: y.game_identifiers
        }))) || [],
        l = ((v = (_ = t.value) == null ? void 0 : _.finished) == null ? void 0 : v.map(y => ({
          id: String(y.id),
          name: y.name,
          games: y.game_identifiers
        }))) || [];
      return [...((C = r.value) == null ? void 0 : C.map(y => ({
        id: String(y.id),
        name: y.public_name,
        games: y.game_identifiers
      }))) || [], ...o, ...i, ...l]
    }),
    isLoading: s
  }
}
const Sne = te({
    __name: "Select",
    props: {
      open: {
        type: Boolean
      },
      defaultOpen: {
        type: Boolean
      },
      defaultValue: {},
      modelValue: {},
      dir: {},
      name: {},
      autocomplete: {},
      disabled: {
        type: Boolean
      },
      required: {
        type: Boolean
      }
    },
    emits: ["update:modelValue", "update:open"],
    setup(e, {
      emit: t
    }) {
      const s = Ga(e, t);
      return (a, o) => (g(), G(u(tP), Nt(Qt(u(s))), {
        default: V(() => [ie(a.$slots, "default")]),
        _: 3
      }, 16))
    }
  }),
  Ene = te({
    inheritAttrs: !1,
    __name: "SelectContent",
    props: {
      forceMount: {
        type: Boolean
      },
      position: {
        default: "popper"
      },
      bodyLock: {
        type: Boolean
      },
      side: {},
      sideOffset: {},
      align: {},
      alignOffset: {},
      avoidCollisions: {
        type: Boolean
      },
      collisionBoundary: {},
      collisionPadding: {},
      arrowPadding: {},
      sticky: {},
      hideWhenDetached: {
        type: Boolean
      },
      updatePositionStrategy: {},
      prioritizePosition: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {},
      class: {}
    },
    emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
    setup(e, {
      emit: t
    }) {
      const n = e,
        r = t,
        s = L(() => {
          const {
            class: o,
            ...i
          } = n;
          return i
        }),
        a = Ga(s, r);
      return (o, i) => (g(), G(u(aP), null, {
        default: V(() => [$(u(pP), Le({
          ...u(a),
          ...o.$attrs
        }, {
          class: u(rn)("relative z-50 max-h-96 min-w-32 max-w-min overflow-hidden rounded-md border data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2", o.position === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1", n.class)
        }), {
          default: V(() => [$(u(Pne)), $(u(_P), {
            class: we(u(rn)("p-1", o.position === "popper" && "h-[--radix-select-trigger-height] w-full min-w-[--radix-select-trigger-width]"))
          }, {
            default: V(() => [ie(o.$slots, "default")]),
            _: 3
          }, 8, ["class"]), $(u(Ane))]),
          _: 3
        }, 16, ["class"])]),
        _: 3
      }))
    }
  }),
  Tne = {
    class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center"
  },
  v3 = te({
    __name: "SelectItem",
    props: {
      value: {},
      disabled: {
        type: Boolean
      },
      textValue: {},
      asChild: {
        type: Boolean
      },
      as: {
        type: [String, Object, Function]
      },
      class: {}
    },
    setup(e) {
      const t = e,
        n = L(() => {
          const {
            class: s,
            ...a
          } = t;
          return a
        }),
        r = Ko(n);
      return (s, a) => (g(), G(u(mP), Le(u(r), {
        class: u(rn)("relative flex w-full cursor-pointer select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none hover:bg-black-10 data-[disabled]:pointer-events-none data-[disabled]:opacity-50", t.class)
      }), {
        default: V(() => [m("span", Tne, [$(u(gP), null, {
          default: V(() => [$(u(_9), {
            class: "h-3.5 w-3.5"
          })]),
          _: 1
        })]), $(u(vP), null, {
          default: V(() => [ie(s.$slots, "default")]),
          _: 3
        })]),
        _: 3
      }, 16, ["class"]))
    }
  }),
  Ane = te({
    __name: "SelectScrollDownButton",
    props: {
      asChild: {
        type: Boolean
      },
      as: {
        type: [String, Object, Function]
      },
      class: {}
    },
    setup(e) {
      const t = e,
        n = L(() => {
          const {
            class: s,
            ...a
          } = t;
          return a
        }),
        r = Ko(n);
      return (s, a) => (g(), G(u(bP), Le(u(r), {
        class: u(rn)("flex cursor-default items-center justify-center py-1", t.class)
      }), {
        default: V(() => [ie(s.$slots, "default", {}, () => [$(u(yg), {
          class: "h-3.5 w-3.5"
        })])]),
        _: 3
      }, 16, ["class"]))
    }
  }),
  Pne = te({
    __name: "SelectScrollUpButton",
    props: {
      asChild: {
        type: Boolean
      },
      as: {
        type: [String, Object, Function]
      },
      class: {}
    },
    setup(e) {
      const t = e,
        n = L(() => {
          const {
            class: s,
            ...a
          } = t;
          return a
        }),
        r = Ko(n);
      return (s, a) => (g(), G(u(yP), Le(u(r), {
        class: u(rn)("flex cursor-default items-center justify-center py-1", t.class)
      }), {
        default: V(() => [ie(s.$slots, "default", {}, () => [$(u(yg), {
          class: "h-3.5 w-3.5 rotate-180"
        })])]),
        _: 3
      }, 16, ["class"]))
    }
  }),
  Ine = te({
    __name: "SelectTrigger",
    props: {
      disabled: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {
        type: [String, Object, Function]
      },
      class: {}
    },
    setup(e) {
      const t = e,
        n = L(() => {
          const {
            class: s,
            ...a
          } = t;
          return a
        }),
        r = Ko(n);
      return (s, a) => (g(), G(u(sP), Le(u(r), {
        class: u(rn)("flex h-10 w-full items-center justify-between rounded-md border px-3 py-2 text-start text-14 focus:outline-none focus:ring-1 focus:ring-gray-700 focus:ring-offset-1 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:truncate", t.class)
      }), {
        default: V(() => [ie(s.$slots, "default"), $(u(CP), {
          "as-child": ""
        }, {
          default: V(() => [$(u(yg), {
            class: "h-3.5 w-3.5 opacity-50"
          })]),
          _: 1
        })]),
        _: 3
      }, 16, ["class"]))
    }
  }),
  $ne = te({
    __name: "SelectValue",
    props: {
      placeholder: {},
      asChild: {
        type: Boolean
      },
      as: {
        type: [String, Object, Function]
      }
    },
    setup(e) {
      const t = e;
      return (n, r) => (g(), G(u(wP), Nt(Qt(t)), {
        default: V(() => [ie(n.$slots, "default")]),
        _: 3
      }, 16))
    }
  }),
  Mne = {
    class: "flex h-fit min-h-full w-full flex-col items-center"
  },
  One = {
    class: "relative z-[56] flex h-12 min-h-12 w-full items-center justify-center rounded-t-xl border-b border-white-10 bg-gray-lighter sm:rounded-none sm:border-0 sm:bg-transparent"
  },
  Dne = {
    class: "flex items-center justify-between gap-2"
  },
  Lne = {
    class: "text-center font-accent text-24 font-bold text-white"
  },
  Rne = {
    class: "z-[57] flex h-full w-full max-w-md flex-col gap-6 bg-gray p-4 sm:pt-2"
  },
  Nne = {
    class: "mb-3 font-bold text-white"
  },
  Fne = {
    class: "flex w-fit gap-2 rounded-xl bg-black-40 p-1"
  },
  Bne = ["onClick"],
  jne = {
    class: "mb-3 font-bold text-white"
  },
  Hne = {
    class: "mt-auto flex gap-3 pt-4"
  },
  Vne = te({
    __name: "GameFilterPanel",
    props: {
      initialFilter: {}
    },
    emits: ["handleFilterChange", "handleFilterClose"],
    setup(e, {
      emit: t
    }) {
      const n = e,
        r = t,
        {
          t: s
        } = Fe(),
        a = Mr(),
        {
          events: o
        } = kne(),
        i = [{
          value: "all",
          label: s("games.filter.volatility.all")
        }, {
          value: "low",
          label: s("games.filter.volatility.low")
        }, {
          value: "medium",
          label: s("games.filter.volatility.medium")
        }, {
          value: "high",
          label: s("games.filter.volatility.high")
        }],
        l = U("all"),
        c = U(null),
        d = U("all"),
        f = U([]),
        p = v => {
          l.value = v
        },
        h = () => {
          l.value = "all", d.value = "all", f.value = []
        },
        _ = () => {
          var C, y;
          const v = a.query.eventId ? a.query.eventId : "";
          Jt({
            payload: {
              eventName: "lobby_games_filter",
              eventData: {
                type: v,
                filter_type: l.value
              }
            }
          }), r("handleFilterChange", {
            volatility: l.value,
            eventId: ((C = c.value) == null ? void 0 : C.id) || "",
            games: ((y = c.value) == null ? void 0 : y.games) || []
          })
        };
      return Ge(() => {
        var v, C;
        if ((v = n.initialFilter) != null && v.volatility && (l.value = n.initialFilter.volatility), (C = n.initialFilter) != null && C.eventId) {
          const y = o.value.find(b => b.id === n.initialFilter.eventId);
          y && (c.value = y, d.value = y.id)
        }
      }), Ne(() => d.value, () => {
        var v;
        if (d.value === "all" && c.value) c.value = null;
        else {
          const C = o.value.find(y => y.id === d.value);
          C && ((v = c.value) == null ? void 0 : v.id) !== C.id && (c.value = C)
        }
      }), (v, C) => (g(), G(u(Jn), {
        class: "z-[57] flex w-full flex-1 flex-col items-center bg-gray sm:w-[314px] sm:rounded-l-xl md:mr-0"
      }, {
        default: V(() => [m("div", Mne, [m("div", One, [m("div", Dne, [m("h1", Lne, R(u(s)("games.filter.title")), 1)]), $(u(pr), {
          class: "absolute right-1 top-1 cursor-pointer hover:scale-95",
          onClick: C[0] || (C[0] = y => v.$emit("handleFilterClose"))
        })]), m("div", Rne, [m("div", null, [m("h3", Nne, R(u(s)("games.filter.label.volatility")), 1), m("div", Fne, [(g(), k(Ee, null, Je(i, y => m("button", {
          key: y.value,
          onClick: b => p(y.value),
          class: we(["rounded-xl px-4 py-1.5 text-sm transition-colors", l.value === y.value ? "bg-white/10 text-white" : "text-white/60 hover:text-white"])
        }, R(y.label), 11, Bne)), 64))])]), m("div", null, [m("h3", jne, R(u(s)("games.filter.label.events")), 1), $(u(Sne), {
          modelValue: d.value,
          "onUpdate:modelValue": C[1] || (C[1] = y => d.value = y)
        }, {
          default: V(() => [$(u(Ine), {
            class: "w-full border border-gray-700 bg-black-40"
          }, {
            default: V(() => [$(u($ne), {
              placeholder: u(s)("games.filter.event.select")
            }, null, 8, ["placeholder"])]),
            _: 1
          }), $(u(Ene), {
            class: "border border-gray-700 bg-gray"
          }, {
            default: V(() => [$(u(v3), {
              key: "all",
              value: "all"
            }, {
              default: V(() => [Ye(R(u(s)("games.filter.event.all")), 1)]),
              _: 1
            }), (g(!0), k(Ee, null, Je(u(o), y => (g(), G(u(v3), {
              key: y.id,
              value: y.id
            }, {
              default: V(() => [Ye(R(y.name), 1)]),
              _: 2
            }, 1032, ["value"]))), 128))]),
            _: 1
          })]),
          _: 1
        }, 8, ["modelValue"])]), m("div", Hne, [$(u(qt), {
          onClick: h,
          class: "flex-1"
        }, {
          default: V(() => [Ye(R(u(s)("games.filter.button.clear")), 1)]),
          _: 1
        }), $(u(qt), {
          onClick: _,
          variant: "link",
          class: "flex-1"
        }, {
          default: V(() => [Ye(R(u(s)("games.filter.button.filter")), 1)]),
          _: 1
        })])])])]),
        _: 1
      }))
    }
  });
var go = (e => (e.POPULAR = "popular", e.NEWEST = "newest", e.OLDEST = "oldest", e.HOT = "hot", e.COLD = "cold", e))(go || {});
const Une = {
    class: "flex h-fit min-h-full w-full flex-col items-center"
  },
  zne = {
    class: "relative z-[56] flex h-12 min-h-12 w-full items-center justify-center rounded-t-xl border-b border-white-10 bg-gray-lighter sm:rounded-none sm:border-0 sm:bg-transparent"
  },
  Yne = {
    class: "flex items-center justify-between gap-2"
  },
  Wne = {
    class: "text-center font-accent text-24 font-bold text-white"
  },
  Gne = {
    class: "z-[57] flex h-full w-full max-w-md flex-col bg-gray p-4 sm:pt-2"
  },
  Qne = {
    class: "w-6"
  },
  qne = ["onClick"],
  Kne = te({
    __name: "GameSortPanel",
    props: {
      sortType: {}
    },
    emits: ["handleSortChange", "handleSortClose"],
    setup(e, {
      emit: t
    }) {
      const n = t,
        {
          t: r
        } = Fe(),
        s = o => {
          Jt({
            payload: {
              eventName: "lobby_games_sort",
              eventData: {
                sort_type: o
              }
            }
          }), n("handleSortChange", o)
        },
        a = () => {
          n("handleSortClose")
        };
      return (o, i) => (g(), G(u(Jn), {
        class: "z-[57] flex w-full flex-1 flex-col items-center bg-gray sm:w-[314px] sm:rounded-l-xl md:mr-0"
      }, {
        default: V(() => [m("div", Une, [m("div", zne, [m("div", Yne, [m("h1", Wne, R(u(r)("games.sort.title")), 1)]), $(u(pr), {
          class: "absolute right-1 top-1 cursor-pointer hover:scale-95",
          onClick: a
        })]), m("div", Gne, [(g(!0), k(Ee, null, Je(Object.values(u(go)), l => (g(), k("div", {
          key: l,
          class: "flex w-full items-center"
        }, [m("div", Qne, [o.sortType === l ? (g(), G(u(_9), {
          key: 0,
          class: "text-yellow"
        })) : z("", !0)]), m("div", {
          onClick: c => s(l),
          class: we(["w-full cursor-pointer rounded-lg p-3 text-left hover:bg-black-10", {
            "text-yellow": o.sortType === l
          }])
        }, R(u(r)(`games.sort.sort_types.${l}`)), 11, qne)]))), 128))])])]),
        _: 1
      }))
    }
  }),
  Zne = {
    key: 0,
    class: "flex flex-1 flex-col items-center justify-center"
  },
  Jne = {
    key: 1,
    class: "flex flex-1 flex-col items-center justify-center"
  },
  Xne = {
    class: "pb-2 pt-5 font-accent text-18 font-bold"
  },
  ere = {
    class: "text-13 text-white-50"
  },
  tre = {
    key: 2,
    class: "flex flex-1 flex-col items-center justify-center"
  },
  nre = {
    class: "pb-2 pt-5 font-accent text-18 font-bold"
  },
  rre = {
    class: "text-13 text-white-50"
  },
  sre = {
    class: "flex h-fit min-h-full w-full flex-col items-center pb-16 sm:pb-0"
  },
  are = {
    key: 0,
    class: "sticky top-0 z-[56] flex h-12 w-full items-center justify-center rounded-t-xl border-b border-white-10 bg-gray-lighter"
  },
  ore = {
    class: "flex items-center justify-between gap-2"
  },
  ire = {
    class: "text-center font-accent text-24 font-bold text-white"
  },
  lre = {
    class: "flex h-full w-full flex-col gap-4 p-4"
  },
  ure = {
    class: "flex h-12 w-full items-center justify-between gap-2"
  },
  cre = {
    class: "relative h-full w-full"
  },
  dre = ["placeholder"],
  fre = {
    class: "flex gap-2"
  },
  pre = {
    key: 0,
    class: "absolute -right-1 -top-1 size-3 rounded-full bg-yellow"
  },
  hre = {
    key: 0,
    class: "flex flex-1 flex-col items-center justify-center"
  },
  mre = {
    class: "pb-2 pt-5 font-accent text-18 font-bold"
  },
  gre = {
    class: "text-13 text-white-50"
  },
  vre = {
    key: 1,
    class: "grid-rows-* grid w-full cursor-pointer gap-3 pb-16 xs:grid-cols-3 sm:grid-cols-4 sm:pb-0 md:grid-cols-5"
  },
  _re = ["onClick"],
  yre = ["src", "data-src", "onError"],
  bre = {
    key: 1,
    class: "order-999 absolute bottom-0 left-0 right-0 top-0 order-last flex flex-1 flex-col items-center justify-end bg-black-80 sm:items-end"
  },
  wre = {
    key: 2,
    class: "order-999 absolute bottom-0 left-0 right-0 top-0 order-last flex flex-1 flex-col items-center justify-end bg-black-80 sm:items-end"
  },
  Cre = te({
    __name: "Games",
    setup(e) {
      const {
        t
      } = Fe(), n = Mr(), r = Tr("(min-width: 568px)"), {
        isLoading: s,
        error: a,
        data: o
      } = Ig(), i = U(""), l = U(!1), c = U(!1), d = U(!1), f = U([]), p = U(null), h = U(1), {
        addIntersectionObserver: _,
        setRoot: v
      } = U9({
        startAfterRootAdding: !0
      }), C = xn({
        volatility: "all",
        eventId: "",
        games: ""
      }), y = U(go.POPULAR), b = L(() => {
        var de;
        if (!((de = o.value) != null && de.length)) return o.value || [];
        let ee = o.value;
        return i.value && (ee = ee.filter(se => se.title.toLocaleLowerCase().includes(i.value.toLocaleLowerCase()))), d.value && (C.volatility && C.volatility !== "all" && (ee = ee.filter(se => se.volatility && se.volatility.includes(C.volatility))), C.games && C.games.length > 0 && (ee = ee.filter(se => C.games.includes(se.identifier)))), ee
      }), w = L(() => {
        let ee = [...b.value];
        switch (y.value) {
          case go.POPULAR:
            ee.sort((de, se) => se.bet_sum_eur - de.bet_sum_eur);
            break;
          case go.NEWEST:
            ee.sort((de, se) => se.released_at.getTime() - de.released_at.getTime());
            break;
          case go.OLDEST:
            ee.sort((de, se) => de.released_at.getTime() - se.released_at.getTime());
            break;
          case go.HOT:
            ee.sort((de, se) => (se.effective_rtp || 0) - (de.effective_rtp || 0));
            break;
          case go.COLD:
            ee.sort((de, se) => (de.effective_rtp || 0) - (se.effective_rtp || 0));
            break
        }
        return ee
      }), x = () => {
        i.value = ""
      }, E = (ee, de) => {
        Jt({
          payload: {
            eventName: "lobby_games_game_click",
            eventData: {
              recipient_game_identifier: de
            }
          }
        }), js(), Mb(ee)
      }, S = () => new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAXwAAAF8CAYAAADM5wDKAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAxnSURBVHgB7d2/j1VlGsDxV3GFVWYZVLKBkAUSMsYKDH+AYw8CJTaODZZgtJ+hlwRKaYBipQSFnqGXiO2ELLBrUBcVyKCLMS47z03YWIhw7zn3vOfyfD4J8UdlMXx5fc57nvPMg89fe1AAeOo9WwBIQfABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCQEHyAJwQdIQvABkhB8gCSeK9Ci/R9+Va4s3S+TauvGPw3+Oj21avD3Wzf9qeyYWTP4550zqwtMMsGnVXeW/1uu3/ylTKo/+m+fnnp2JfprBr/e2PVimd31wuDfwaR45sHnrz0o0JI33/tnWbz8Y8kior9vdqrsXfn18P8OoK8cT6CBxcs/lcNHvy3b9lxd+cPuRjl94W6BvhJ8aEnEf27hZtn21tXy7pGb5frXkzva4ukk+NCyeA5w6vzdwan//aPfCD+9IfgwRsfO3DbqoTcEH8YsTvwPRz1O+9Qk+NCRCH+MeY6cuFWgBsGHji2c+G4w5nHap2uCDxXEjR7Rp2uCD5XEiOf1t6+VK0s/F+iC4ENFd5Z/HZz0RZ8uCD5U9jD6xjuMm+BDDzyMfiyfg3ERfOiJmOnHSgYYF8GHHjm3uFyOn/mhwDgIPvRM3NM32mEcBB96Jub5R078u0DbBB96KJauubVD2wQfesrOHdom+NBT5xbvmeXTKh8xZyJdO7+98TdkY2QSVyGvLN0vly7/NPgWb58CG7P842e+L/MHNxRogxM+acUfGPER8sMHXipnP9pcbl98tZxc2FS2burPx8jjmia0RfDhN+Z2ryvXPtvem/DHjp3YrAltEHz4HRH+ix9v6UX0L62MmqANgg+PECOfL/6+reycWVNqcsKnLYIPf2B6atXKSf9vVaMfYx23dWiD4MNjRPTPHt288tc6v13itk7cJIKmBB+eQIx3Dh94udTypeDTAsGHJ3TowPpqp/x4XwCaEnx4QjHaqXXKt1eHNgg+DOGd3etKDWb4tEHwYQhxL7/G3Xy3dGiD4MOQZne9WLoWN3WgKcGHIe2cWV1qMMenKcGHITXd0gm1CD4Macum5wtMIsGHIU2v9duGyeQnFyAJwYcJMb12VYEmBB8mRK21Djw9/ATBkO7c6/4lqD59dpHJJfgwpBovQbkKShsEH4ZU4wWoWNwGTQk+DOlGhVXFs7teKNCU4MOQanxjdkfl7+rydBB8GNKVpf+Urjnh0wbBhyHE6b7rVcViT1sEH4Zw+sKd0rV39kwXaIPgwxOK2zmnzt8tXXPCpy2CD0/odKXYu4NPWwQfnkCc7hdO3CpdM86hTYIPjxGxf/O9G6VrsU5hrtJH03k6CT78gbiRs/+Dr8r1Ci9bzR/cUKBNgg+P8PBkf2Xpfuma0z3jIPjwO+K+fa3Yh4sfbynQtucK8H8R+iMrD2drrE94aP7gK27mMBaCT3pXln4uly7/WM4tLlcNfZjd9WJZMLtnTASfifTuws3SVMzoY7d916sSHiXm9icXNhYYF8FnItU+ibctYh9ze6McxslDW6hM7OmK4ENFO2fWiD2dEXyo5NCBl8oXn2wTezpjhg8dGzycnd9kCyadE3zoyPTUsyun+pfL4ZWTffw9dE3wYcyEnr7w0wdjNj21qny5dL98eml5cPcfanHChzGLTZvxK97kDTG7n9szXd6xHI2OOeFDx+KlsbmFm2XbW1fL6Qvdf0WLvAQfKolTf4T/9bf/YdRDJwQfKovlbdv2XC3Hz/xQYJwEH3ri8NFvy/tHvykwLoIPPXLszO2y/8OverPBk6eL4EPPxG2e/R/+q0DbBB96KG7yGO/QNsGHnorxjge5tEnwoccWTnznyiat8aYtE+na+e1jWSscD0uvLN0f/Lq0MlZZvPxj1Qeo8QnG+Jxj7MyHppzw4TdiuVmsPohFZ2c/2lxuX3y1nFzYNFhpXEvM872RSxsEHx5jbve6cu2z7WX+4IZSy8KJW65q0pjgwxNaOPjK4NRfY8VxrGE4fub7Ak0IPgxh3+zU4GtVNcStHad8mhB8GFJEP2b8XYsHuLFTH0Yl+DCC+ZXxTo3RzqnzdwqMSvBhBPEVq8MHXi5dixs77uUzKsGHER06sL7KKf+0Uz4jEnwYUZzy53ZPl67FKR9GIfjQwN6VB7hdi+C7rcMoBB8a2DmzuspYJ1Y+wLAEHxqIsc7OmT+Xrl0y1mEEgg8NxSm/a27qMArBh4ZqLFaLbZ4wLMGHhsaxpvlxYrcODEvwoaEtm54vNbipw7AEHxqaXlvnt9Gde78WGIbgw4RywmdYgg8N1biHH2J7JgxD8KGhuIsPk0DwoSEnbSaF4ENDZulMCsGHhu7cqxN8oySGJfjQUK2RTq2HxUwuPzHQ0JeV1hzUeMOXySb40FCNNQfGOYxC8KGhK0s/l65t3fhcgWEJPjQQ8/saHyNxwmcUgg8N1PoQyc6ZNQWGJfjQwKkLd0sNNXbwM/kEH0YUX506t7hcatjhhM8IBB9GdOTErVLL7K4XCgxL8GEEiyuz+1Pn64xzxJ5RCT4MKUY57x65WWqZ3fVigVEIPgwhYv/mezeqflN27+xUgVEIPjyhGOPUjn3cztk5s7rAKLyuB48R64/jAe2xMz+U2oxzaELw4XdE5M9dWi6nz98ZnOz7Yv7gKwVGJfhMpE8Xl8u6FtcL3F3+dTCqid32sSqh5tjmUeJ2jg2ZNCH4TKTDR78t2Rw68FKBJjy0hQkQD2v3uZ1DQ4IPE+Dk/KYCTQk+9Nzcnmlv19IKwYcei1GOmzm0RfChx+YPbnAzh9YIPvRU3MqZ272uQFsEH3oovmh17IO/FmiT4EPPxNz+7NHNBdom+NAjEfuLH28xt2csvGkLPRFjnIj99JRzGOPhJwt6IB7QfvHJNrFnrJzwoaIIfFy9PGxPDh0QfKgkdtufXNhoXk9nBB865lRPLYIPHYq9OLEqwameGgQfOhDjmwi9JWjUJPgwJjG6mdu9vhx6e70TPb0g+NCyOM3vnV27Evtp1yzpFcGHhiLq+2b/Ut5YGdfse2NK5OktwYchxOqDeCN268bny45XV/uwOBPlmQefv/agQEsWL/9Urn/9S3laRMzjxD49tUrYmXiCD5CEYSNAEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyQh+ABJCD5AEoIPkITgAyTxP61ZuRoVO2pjAAAAAElFTkSuQmCC", import.meta.url).href, T = (ee, de) => {
        const se = ee.target;
        se.src = S(), f.value.includes(de) || f.value.push(de)
      }, j = () => {
        l.value = !0
      }, P = () => {
        l.value = !1
      }, N = ee => {
        Object.assign(C, ee), ee.volatility && ee.volatility !== "all" || ee.games && ee.games.length > 0 ? d.value = !0 : d.value = !1, l.value = !1
      }, ne = () => {
        c.value = !0
      }, Y = () => {
        c.value = !1
      }, _e = ee => {
        y.value = ee, Y()
      }, Q = () => {
        n.query.eventId && n.query.games && n.query.games.length > 0 && (C.games = n.query.games, C.eventId = n.query.eventId, d.value = !0)
      };
      Ne(() => n.query, () => Q(), {
        immediate: !0
      });
      const re = () => {
          p.value && (h.value = p.value.offsetWidth / 170)
        },
        J = L(() => {
          let ee = 0;
          return ee = Math.round(16 * h.value), ee < 10 ? ee = 10 : ee > 24 && (ee = 24), `text-${ee}`
        });
      return Ne(() => [p.value], () => {
        re()
      }, {
        immediate: !0
      }), Ge(() => {
        window.addEventListener("resize", re), setTimeout(() => v(null));
        const ee = n.query.source ? n.query.source : "",
          de = n.query.eventId ? n.query.eventId : "";
        Jt({
          payload: {
            eventName: "lobby_games_open",
            eventData: {
              source: ee,
              type: de
            }
          }
        })
      }), en(() => {
        f.value = [], window.removeEventListener("resize", re)
      }), (ee, de) => u(s) ? (g(), k("div", Zne, [$(u(Ka))])) : u(a) ? (g(), k("div", Jne, [$(u(_f), {
        class: "h-32 w-32 text-gray-light"
      }), m("div", Xne, R(u(t)("common.error.games_title")), 1), m("div", ere, R(u(t)("common.error.sub_title")), 1)])) : u(o) ? (g(), G(u(Jn), {
        key: 3,
        class: "h-full w-full p-0"
      }, {
        default: V(() => [m("div", sre, [u(r) ? z("", !0) : (g(), k("div", are, [m("div", ore, [m("h1", ire, R(u(t)("games.title")), 1)]), $(u(pr), {
          class: "absolute right-1 top-1 cursor-pointer hover:scale-95 sm:hidden",
          onClick: u(js)
        }, null, 8, ["onClick"])])), m("div", lre, [m("div", ure, [m("div", cre, [$(u(Al), {
          class: "absolute left-5 top-1/2 h-5 w-5 -translate-y-1/2 transform text-white"
        }), Tn(m("input", {
          "onUpdate:modelValue": de[0] || (de[0] = se => i.value = se),
          placeholder: u(t)("games.search_placeholder"),
          class: "h-full w-full rounded-lg bg-gray-lighter py-4 pl-14 pr-10 text-white placeholder-white-30 outline-none ring-1 ring-white-10"
        }, null, 8, dre), [
          [Mi, i.value]
        ]), i.value ? (g(), G(u(qa), {
          key: 0,
          onClick: x,
          class: "absolute right-5 top-1/2 size-3 -translate-y-1/2 transform cursor-pointer text-white-30"
        })) : z("", !0)]), m("div", fre, [m("div", {
          class: "relative flex size-12 min-w-12 cursor-pointer items-center justify-center rounded-lg border-white-10 bg-gray-lighter ring-1 ring-white-10",
          onClick: ne
        }, [$(u(YR), {
          class: "size-6"
        })]), m("div", {
          class: "relative flex size-12 min-w-12 cursor-pointer items-center justify-center rounded-lg border-white-10 bg-gray-lighter ring-1 ring-white-10",
          onClick: j
        }, [$(u(aN), {
          class: "size-6"
        }), d.value ? (g(), k("div", pre)) : z("", !0)])])]), !u(s) && !w.value.length ? (g(), k("div", hre, [$(u(_f), {
          class: "h-32 w-32 text-gray-light"
        }), m("div", mre, R(u(t)("games.empty_title")), 1), m("div", gre, R(u(t)("games.empty_subtitle")), 1)])) : (g(), k("div", vre, [(g(!0), k(Ee, null, Je(w.value, (se, ae) => (g(), k("div", {
          key: se.identifier,
          onClick: ke => E(se.url, se.identifier),
          ref_for: !0,
          ref: ke => ae === 0 ? p.value = ke : null,
          class: "relative"
        }, [m("img", {
          ref_for: !0,
          ref: ke => u(_)(ke),
          src: S(),
          "data-src": se.img,
          onError: ke => T(ke, se.identifier),
          class: "text-theme-black-white h-auto w-full cursor-pointer rounded-lg object-contain",
          draggable: "false"
        }, null, 40, yre), f.value.includes(se.identifier) ? (g(), k("div", {
          key: 0,
          class: we(["text-theme-black-white absolute top-[65%] flex w-full flex-wrap justify-center px-3 font-accent font-bold uppercase", J.value])
        }, R(se.title), 3)) : z("", !0)], 8, _re))), 128))]))]), l.value ? (g(), k("div", bre, [$(Vne, {
          initialFilter: C,
          onHandleFilterClose: P,
          onHandleFilterChange: N
        }, null, 8, ["initialFilter"])])) : z("", !0), c.value ? (g(), k("div", wre, [$(Kne, {
          sortType: y.value,
          onHandleSortClose: Y,
          onHandleSortChange: _e
        }, null, 8, ["sortType"])])) : z("", !0)])]),
        _: 1
      })) : (g(), k("div", tre, [$(u(_f), {
        class: "h-32 w-32 text-gray-light"
      }), m("div", nre, R(u(t)("games.empty_title")), 1), m("div", rre, R(u(t)("games.empty_subtitle")), 1)]))
    }
  }),
  xre = te({
    __name: "GamesPage",
    setup(e) {
      return (t, n) => (g(), G(vd, {
        isActivePath: "/lobby/games"
      }, {
        default: V(() => [$(Cre)]),
        _: 1
      }))
    }
  }),
  kre = [{
    path: "/lobby/root",
    component: yk,
    name: "root",
    props: !0
  }, {
    path: "/lobby/drop/:id?",
    component: iY,
    name: "drop",
    props: !0
  }, {
    path: "/lobby/challenge/:id?",
    component: nQ,
    name: "challenge",
    props: !0
  }, {
    path: "/lobby/create/challenge",
    component: Vte,
    name: "create_challenge",
    props: !0
  }, {
    path: "/lobby/games",
    component: xre,
    name: "games",
    props: !0
  }, {
    path: "/lobby/profile",
    component: Cne,
    name: "profile",
    props: !0
  }],
  Cn = vx({
    history: WC(),
    routes: kre
  }),
  Sre = () => {
    $t.invalidateQueries({
      queryKey: ["profile"]
    })
  },
  Ere = (e, t) => {
    if (e == null) throw new Error("MessageBroker: iframe is null");
    const n = e;
    window.addEventListener("message", s => {
      t(s.data)
    });

    function r(s) {
      try {
        n == null || n.postMessage(s, "*")
      } catch {
        console.error("MessageBroker can't send command")
      }
    }
    return {
      sendCommand: r
    }
  },
  Tre = () => {
    const e = Ere(window.parent, t);
    kV((s, a) => e.sendCommand({
      name: s,
      sender: "lobby",
      params: a
    })), e.sendCommand({
      name: "ready",
      sender: "lobby"
    });

    function t(s) {
      var a, o, i, l;
      s.name !== "balance_update" && uc.updateBreadcrumbs({
        eventName: s.name,
        eventSender: s.sender,
        ...s.params && {
          eventParams: JSON.stringify(s.params)
        }
      }), s.name === "setup" && n(((a = s.params) == null ? void 0 : a.options) || ""), s.name === "open" && (_k(), ok(), Sre(), pv((o = s.params) == null ? void 0 : o.balance), Hh.value = !0, (i = s.params) != null && i.eventType && Cn.push({
        name: s.params.eventType,
        ...s.params.eventType !== "root" && {
          params: {
            id: s.params.id
          }
        }
      })), s.name === "close" && (Hh.value = !1), s.name === "balance_update" && pv((l = s.params) == null ? void 0 : l.balance)
    }

    function n(s) {
      var a, o, i, l, c, d, f, p, h;
      uc.init(s), Yx({
        isMobile: s.isMobile || !1,
        locale: s.locale || "",
        identifier: s.identifier || "",
        currency: s.currency || "",
        lobby_launch_url: s.lobby_launch_url || ""
      }), Wx(s.lobby_v2_options || {}), Gx({
        code: ((o = (a = s.rules) == null ? void 0 : a.currency) == null ? void 0 : o.code) || "",
        symbol: ((l = (i = s.rules) == null ? void 0 : i.currency) == null ? void 0 : l.symbol) || "",
        subunits: ((d = (c = s.rules) == null ? void 0 : c.currency) == null ? void 0 : d.subunits) || 0,
        exponent: ((p = (f = s.rules) == null ? void 0 : f.currency) == null ? void 0 : p.exponent) || 0
      }), wR(s == null ? void 0 : s.locale, ((h = s == null ? void 0 : s.lobby_v2_options) == null ? void 0 : h.lobby_fe_script_url) || ""), gk(r), rk(r)
    }

    function r(s, a) {
      uc.updateBreadcrumbs({
        eventName: s,
        eventSender: "lobby",
        ...a && {
          eventParams: JSON.stringify(a)
        }
      }), s === "inited" ? Yh.value && Uh.value && e.sendCommand({
        name: s,
        sender: "lobby",
        params: a
      }) : e.sendCommand({
        name: s,
        sender: "lobby",
        params: a
      })
    }
    window.onerror = function(s) {
      console.error("lobby handler: " + s), r("close_lobby")
    }
  },
  Are = {
    install: () => {
      Tre()
    }
  };
var Pre = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

function Ire(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
var H7 = {
  exports: {}
};
(function(e, t) {
  (function(n, r) {
    e.exports = r()
  })(Pre, function() {
    return function(n) {
      var r = {};

      function s(a) {
        if (r[a]) return r[a].exports;
        var o = r[a] = {
          i: a,
          l: !1,
          exports: {}
        };
        return n[a].call(o.exports, o, o.exports, s), o.l = !0, o.exports
      }
      return s.m = n, s.c = r, s.d = function(a, o, i) {
        s.o(a, o) || Object.defineProperty(a, o, {
          enumerable: !0,
          get: i
        })
      }, s.r = function(a) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(a, Symbol.toStringTag, {
          value: "Module"
        }), Object.defineProperty(a, "__esModule", {
          value: !0
        })
      }, s.t = function(a, o) {
        if (1 & o && (a = s(a)), 8 & o || 4 & o && typeof a == "object" && a && a.__esModule) return a;
        var i = Object.create(null);
        if (s.r(i), Object.defineProperty(i, "default", {
            enumerable: !0,
            value: a
          }), 2 & o && typeof a != "string")
          for (var l in a) s.d(i, l, (function(c) {
            return a[c]
          }).bind(null, l));
        return i
      }, s.n = function(a) {
        var o = a && a.__esModule ? function() {
          return a.default
        } : function() {
          return a
        };
        return s.d(o, "a", o), o
      }, s.o = function(a, o) {
        return Object.prototype.hasOwnProperty.call(a, o)
      }, s.p = "", s(s.s = 0)
    }([function(n, r, s) {
      function a(h, _, v) {
        return _ in h ? Object.defineProperty(h, _, {
          value: v,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }) : h[_] = v, h
      }

      function o(h) {
        return (o = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(_) {
          return typeof _
        } : function(_) {
          return _ && typeof Symbol == "function" && _.constructor === Symbol && _ !== Symbol.prototype ? "symbol" : typeof _
        })(h)
      }
      var i;
      s.r(r);
      var l = function(h) {
          return h < .5 ? 4 * h * h * h : (h - 1) * (2 * h - 2) * (2 * h - 2) + 1
        },
        c = function() {
          return {
            duration: 500,
            offset: 0,
            container: window,
            updateHistory: !0,
            easingFunction: null
          }
        },
        d = Symbol("smoothScrollCtx"),
        f = function(h) {
          var _ = h.scrollTo,
            v = h.offset,
            C = h.duration,
            y = h.container,
            b = h.updateHistory,
            w = h.hash,
            x = h.easingFunction;
          i || (i = window.requestAnimationFrame || function(Y) {
            return window.setTimeout(Y, 16)
          }), b && window.history.pushState && location.hash !== w && window.history.pushState("", "", w);
          var E, S, T = typeof _ == "number",
            j = y.scrollTop || window.pageYOffset,
            P = (T ? _ : (S = j, (E = _).nodeName === "HTML" ? -S : E.getBoundingClientRect().top + S)) + v,
            N = typeof x == "function" ? x : l,
            ne = Date.now();
          (function Y() {
            var _e = Date.now() - ne,
              Q = _e < C,
              re = Q ? j + (P - j) * N(_e / C) : P;
            Q ? i(Y) : b && !T && location.replace("#" + _.id), y === window ? y.scrollTo(0, re) : y.scrollTop = re
          })()
        },
        p = {
          install: function(h, _) {
            var v, C = !h.version.startsWith("3"),
              y = function() {
                return _ ? Object.assign(c(), _) : c()
              };
            h.directive("smooth-scroll", (a(v = {}, C ? "inserted" : "mounted", function(w, x, E) {
              if ((typeof window > "u" ? "undefined" : o(window)) === "object" && window.pageYOffset !== void 0) {
                var S = Object.assign(y(), x.value);
                typeof S.container == "string" && (S.container = document.querySelector(S.container));
                var T = function(j) {
                  j.preventDefault();
                  var P = C ? E.data.attrs.href : E.props.href,
                    N = document.getElementById(P.substring(1));
                  N && f(Object.assign(S, {
                    scrollTo: N,
                    hash: P
                  }))
                };
                w.addEventListener("click", T), w[d] = {
                  clickHandler: T
                }
              }
            }), a(v, C ? "unbind" : "unmounted", function(w) {
              w.removeEventListener("click", w[d].clickHandler), w[d] = null
            }), v));
            var b = function(w) {
              var x = Object.assign(y(), w);
              return f(x)
            };
            (C ? h.prototype : h.config.globalProperties).$smoothScroll = b, C || h.provide("smoothScroll", b)
          }
        };
      r.default = p
    }]).default
  })
})(H7);
var $re = H7.exports;
const Mre = Ire($re),
  Ore = te({
    __name: "Toast",
    props: {
      class: {},
      variant: {},
      onOpenChange: {
        type: Function
      },
      defaultOpen: {
        type: Boolean
      },
      forceMount: {
        type: Boolean
      },
      type: {},
      open: {
        type: Boolean
      },
      duration: {},
      asChild: {
        type: Boolean
      },
      as: {
        type: [String, Object, Function]
      }
    },
    emits: ["escapeKeyDown", "pause", "resume", "swipeStart", "swipeMove", "swipeCancel", "swipeEnd", "update:open"],
    setup(e, {
      emit: t
    }) {
      const n = e,
        r = t,
        s = L(() => {
          const {
            class: o,
            ...i
          } = n;
          return i
        }),
        a = Ga(s, r);
      return (o, i) => (g(), G(u(LP), Le(u(a), {
        class: u(rn)(u(Fre)({
          variant: o.variant
        }), n.class),
        "onUpdate:open": o.onOpenChange
      }), {
        default: V(() => [ie(o.$slots, "default")]),
        _: 3
      }, 16, ["class", "onUpdate:open"]))
    }
  }),
  Dre = te({
    __name: "ToastViewport",
    props: {
      hotkey: {},
      label: {
        type: [String, Function]
      },
      asChild: {
        type: Boolean
      },
      as: {
        type: [String, Object, Function]
      },
      class: {}
    },
    setup(e) {
      const t = e,
        n = L(() => {
          const {
            class: r,
            ...s
          } = t;
          return s
        });
      return (r, s) => (g(), G(u(FP), Le(n.value, {
        class: u(rn)("fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]", t.class)
      }), null, 16, ["class"]))
    }
  }),
  Lre = te({
    __name: "ToastClose",
    props: {
      asChild: {
        type: Boolean
      },
      as: {
        type: [String, Object, Function]
      },
      class: {}
    },
    setup(e) {
      const t = e,
        n = L(() => {
          const {
            class: r,
            ...s
          } = t;
          return s
        });
      return (r, s) => (g(), G(u(NP), Le(n.value, {
        class: u(rn)("absolute right-2 top-2.5 rounded-md p-1 focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100", t.class)
      }), {
        default: V(() => [$(u(qa), {
          class: "h-3 w-3 text-white"
        })]),
        _: 1
      }, 16, ["class"]))
    }
  }),
  Rre = te({
    __name: "ToastTitle",
    props: {
      asChild: {
        type: Boolean
      },
      as: {
        type: [String, Object, Function]
      },
      class: {}
    },
    setup(e) {
      const t = e,
        n = L(() => {
          const {
            class: r,
            ...s
          } = t;
          return s
        });
      return (r, s) => (g(), G(u(BP), Le(n.value, {
        class: u(rn)("text-sm font-semibold", t.class)
      }), {
        default: V(() => [ie(r.$slots, "default")]),
        _: 3
      }, 16, ["class"]))
    }
  }),
  _3 = te({
    __name: "ToastDescription",
    props: {
      asChild: {
        type: Boolean
      },
      as: {
        type: [String, Object, Function]
      },
      class: {}
    },
    setup(e) {
      const t = e,
        n = L(() => {
          const {
            class: r,
            ...s
          } = t;
          return s
        });
      return (r, s) => (g(), G(u(jP), Le({
        class: u(rn)("text-12", t.class)
      }, n.value), {
        default: V(() => [ie(r.$slots, "default")]),
        _: 3
      }, 16, ["class"]))
    }
  }),
  Nre = te({
    __name: "ToastProvider",
    props: {
      label: {},
      duration: {},
      swipeDirection: {},
      swipeThreshold: {}
    },
    setup(e) {
      const t = e;
      return (n, r) => (g(), G(u(SP), Nt(Qt(t)), {
        default: V(() => [ie(n.$slots, "default")]),
        _: 3
      }, 16))
    }
  }),
  Fre = _u("group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[--radix-toast-swipe-end-x] data-[swipe=move]:translate-x-[--radix-toast-swipe-move-x] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-top-full data-[state=closed]:sm:slide-out-to-bottom-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full", {
    variants: {
      variant: {
        default: "toast-theme-secondary"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }),
  Bre = {
    class: "grid gap-1"
  },
  jre = te({
    __name: "Toaster",
    setup(e) {
      const {
        toasts: t
      } = K9();
      return (n, r) => (g(), G(u(Nre), null, {
        default: V(() => [(g(!0), k(Ee, null, Je(u(t), s => (g(), G(u(Ore), Le({
          key: s.id
        }, {
          ref_for: !0
        }, s, {
          class: "rounded-2xl border-none bg-gradient-to-b from-button-secondary-from to-button-secondary-to p-3 shadow-[0_0_15px_0_rgba(0,0,0,0.90),inset_0_1px_0_0_rgba(255,255,255,0.25)]"
        }), {
          default: V(() => [m("div", Bre, [s.title ? (g(), G(u(Rre), {
            key: 0
          }, {
            default: V(() => [Ye(R(s.title), 1)]),
            _: 2
          }, 1024)) : z("", !0), s.description ? (g(), k(Ee, {
            key: 1
          }, [Yl(s.description) ? (g(), G(u(_3), {
            key: 0
          }, {
            default: V(() => [(g(), G(Kr(s.description)))]),
            _: 2
          }, 1024)) : (g(), G(u(_3), {
            key: 1
          }, {
            default: V(() => [Ye(R(s.description), 1)]),
            _: 2
          }, 1024))], 64)) : z("", !0), $(u(Lre))]), (g(), G(Kr(s.action)))]),
          _: 2
        }, 1040))), 128)), $(u(Dre))]),
        _: 1
      }))
    }
  });

function Hre() {
  const e = Mr();
  Ne(() => e.path, (t, n) => uc.updateBreadcrumbs({
    routes: `FROM: ${n} TO: ${t}`
  }))
}
const Vre = () => {
    const e = navigator.userAgent,
      n = "ontouchstart" in window && /iPad|Macintosh/.test(e),
      r = e.includes("Safari") && !e.includes("Chrome") && !e.includes("Android");
    return n && r
  },
  V7 = () => {
    const e = document.getElementById("lobby-app"),
      t = Kn.isMobile,
      n = window.innerHeight > window.innerWidth;
    e && (Vre() ? (e.style.width = "calc(100% - 8px)", e.style.height = "calc(100% - 76px)", e.style.marginTop = "72px", e.style.marginBottom = "4px") : t && n && window.innerHeight > window.innerWidth * 2 ? (e.style.width = "calc(100% - 8px)", e.style.height = "calc(100% - 94px)", e.style.marginTop = "60px", e.style.marginBottom = "34px") : t && !n && window.innerWidth > window.innerHeight * 2 ? (e.style.width = "calc(100% - 120px)", e.style.height = "calc(100% - 24px)", e.style.marginTop = "4px", e.style.marginBottom = "20px") : (e.style.width = "calc(100% - 8px)", e.style.height = "calc(100% - 8px)", e.style.marginTop = "4px", e.style.marginBottom = "4px"))
  },
  y3 = p9(V7, 300),
  Ure = () => {
    Ge(() => {
      V7(), window.addEventListener("resize", y3)
    }), en(() => {
      window.removeEventListener("resize", y3)
    })
  },
  zre = {
    key: 0
  },
  Yre = te({
    __name: "App",
    setup(e) {
      return Hre(), Ure(), (t, n) => {
        const r = w5("RouterView");
        return u(Hh) ? (g(), k("main", zre, [$(r), $(jre)])) : z("", !0)
      }
    }
  }),
  Wre = {
    install() {
      try {
        "light" === "dark" || (document.documentElement.classList.remove("dark"), Do.value = "")
      } catch (e) {
        console.error("[ThemePlugin] initTheme failed:", e)
      }
    }
  },
  Xi = mC(Yre);
Xi.use(Are);
Xi.use(Wre);
Xi.use(Ux, {
  queryClient: $t
});
Xi.use(Cn);
Xi.use(Rc);
Xi.use(Mre);
Xi.mount("#lobby-app");
console.log("%cGrowth Lobby > App Version: 2.4.19", "border: 1px solid #CFE221; padding: 4px 8px; font-weight: 600");
console.log("%cGrowth Lobby > Git Branch/Git Commit: HEAD b75e59e v2.4.19", "border: 1px solid #CFE221; padding: 4px 8px; font-weight: 600");
console.log("%cGrowth Lobby > Build mode: production", "border: 1px solid #CFE221; padding: 4px 8px; font-weight: 600");
//# sourceMappingURL=lobby.js.map

//# debugId=74ebc269-8aaf-5abf-b0a9-c59e8e8c8e35