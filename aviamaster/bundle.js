(function() {
  "use strict";
  var Zl = document.createElement("style");
  Zl.textContent = '#coin-app *,#coin-app :before,#coin-app :after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }#coin-app ::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }#coin-app *,#coin-app :before,#coin-app :after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}#coin-app :before,#coin-app :after{--tw-content: ""}#coin-app,#coin-app :host{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}#coin-app{margin:0;line-height:inherit}#coin-app hr{height:0;color:inherit;border-top-width:1px}#coin-app abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}#coin-app h1,#coin-app h2,#coin-app h3,#coin-app h4,#coin-app h5,#coin-app h6{font-size:inherit;font-weight:inherit}#coin-app a{color:inherit;text-decoration:inherit}#coin-app b,#coin-app strong{font-weight:bolder}#coin-app code,#coin-app kbd,#coin-app samp,#coin-app pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}#coin-app small{font-size:80%}#coin-app sub,#coin-app sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}#coin-app sub{bottom:-.25em}#coin-app sup{top:-.5em}#coin-app table{text-indent:0;border-color:inherit;border-collapse:collapse}#coin-app button,#coin-app input,#coin-app optgroup,#coin-app select,#coin-app textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}#coin-app button,#coin-app select{text-transform:none}#coin-app button,#coin-app input:where([type=button]),#coin-app input:where([type=reset]),#coin-app input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}#coin-app :-moz-focusring{outline:auto}#coin-app :-moz-ui-invalid{box-shadow:none}#coin-app progress{vertical-align:baseline}#coin-app ::-webkit-inner-spin-button,#coin-app ::-webkit-outer-spin-button{height:auto}#coin-app [type=search]{-webkit-appearance:textfield;outline-offset:-2px}#coin-app ::-webkit-search-decoration{-webkit-appearance:none}#coin-app ::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}#coin-app summary{display:list-item}#coin-app blockquote,#coin-app dl,#coin-app dd,#coin-app h1,#coin-app h2,#coin-app h3,#coin-app h4,#coin-app h5,#coin-app h6,#coin-app hr,#coin-app figure,#coin-app p,#coin-app pre{margin:0}#coin-app fieldset{margin:0;padding:0}#coin-app legend{padding:0}#coin-app ol,#coin-app ul,#coin-app menu{list-style:none;margin:0;padding:0}#coin-app dialog{padding:0}#coin-app textarea{resize:vertical}#coin-app input::-moz-placeholder,#coin-app textarea::-moz-placeholder{opacity:1;color:#9ca3af}#coin-app input::placeholder,#coin-app textarea::placeholder{opacity:1;color:#9ca3af}#coin-app button,#coin-app [role=button]{cursor:pointer}#coin-app :disabled{cursor:default}#coin-app img,#coin-app svg,#coin-app video,#coin-app canvas,#coin-app audio,#coin-app iframe,#coin-app embed,#coin-app object{display:block;vertical-align:middle}#coin-app img,#coin-app video{max-width:100%;height:auto}#coin-app [hidden]:where(:not([hidden=until-found])){display:none}#coin-app .container{width:100%;margin-right:auto;margin-left:auto;padding-right:2rem;padding-left:2rem}@media (min-width: 1400px){#coin-app .container{max-width:1400px}}#coin-app .visible{visibility:visible}#coin-app .static{position:static}#coin-app .fixed{position:fixed}#coin-app .absolute{position:absolute}#coin-app .relative{position:relative}#coin-app .inset-0{top:0;right:0;bottom:0;left:0}#coin-app .right-4{right:1rem}#coin-app .top-4{top:1rem}#coin-app .z-\\[998\\]{z-index:998}#coin-app .mx-auto{margin-left:auto;margin-right:auto}#coin-app .mt-2{margin-top:.5rem}#coin-app .flex{display:flex}#coin-app .hidden{display:none}#coin-app .h-6{height:1.5rem}#coin-app .h-full{height:100%}#coin-app .min-h-full{min-height:100%}#coin-app .w-full{width:100%}#coin-app .transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}#coin-app .cursor-pointer{cursor:pointer}#coin-app .touch-manipulation{touch-action:manipulation}#coin-app .resize{resize:both}#coin-app .flex-col{flex-direction:column}#coin-app .items-center{align-items:center}#coin-app .items-baseline{align-items:baseline}#coin-app .justify-center{justify-content:center}#coin-app .gap-1{gap:.25rem}#coin-app .overflow-auto{overflow:auto}#coin-app .overflow-hidden{overflow:hidden}#coin-app .truncate{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}#coin-app .rounded-3xl{border-radius:1.5rem}#coin-app .border{border-width:1px}#coin-app .bg-black{--tw-bg-opacity: 1;background-color:rgb(0 0 0 / var(--tw-bg-opacity, 1))}#coin-app .bg-opacity-80{--tw-bg-opacity: .8}#coin-app .bg-cover{background-size:cover}#coin-app .bg-center{background-position:center}#coin-app .bg-no-repeat{background-repeat:no-repeat}#coin-app .p-6{padding:1.5rem}#coin-app .py-4{padding-top:1rem;padding-bottom:1rem}#coin-app .text-center{text-align:center}#coin-app .font-sans{font-family:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji"}#coin-app .text-4xl{font-size:2.25rem;line-height:2.5rem}#coin-app .uppercase{text-transform:uppercase}#coin-app .capitalize{text-transform:capitalize}#coin-app .text-white{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity, 1))}#coin-app .text-opacity-80{--tw-text-opacity: .8}#coin-app .shadow{--tw-shadow: 0 1px 3px 0 rgb(0 0 0 / .1), 0 1px 2px -1px rgb(0 0 0 / .1);--tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}#coin-app .filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}#coin-app .transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,-webkit-backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter,-webkit-backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}#coin-app .ease-in-out{transition-timing-function:cubic-bezier(.4,0,.2,1)}#coin-app #coin-theme{--font-primary: "IBM Plex Sans", sans-serif;--font-secondary: "Cairo", sans-serif;--base_font: "IBM Plex Sans", sans-serif;--secondary_font: "Cairo", sans-serif;--base_font_color: #4C3D11}#coin-app #coin-theme.dark{--font-primary: "Poppins", sans-serif;--font-secondary: "Poppins", sans-serif;--base_font: "Poppins", sans-serif;--secondary_font: "Poppins", sans-serif;--base_font_color: #2F3741}#coin-app #coin-app{position:fixed;z-index:1000;font-family:var(--font-primary)}#coin-app #coin-app img{-webkit-user-select:none;-moz-user-select:none;user-select:none;touch-action:manipulation;-webkit-user-drag:none}@font-face{font-family:IBM Plex Sans;src:url(' + new URL("assets/IBMPlexSans.Cpx0gSar.eot", document.currentScript && document.currentScript.tagName.toUpperCase() === "SCRIPT" && document.currentScript.src || document.baseURI).href + ");src:url(" + new URL("assets/IBMPlexSans.Cpx0gSar.eot?#iefix", document.currentScript && document.currentScript.tagName.toUpperCase() === "SCRIPT" && document.currentScript.src || document.baseURI).href + ') format("embedded-opentype"),url(data:font/woff;base64,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) format("woff"),url(' + new URL("assets/IBMPlexSans.D3FTc7Pl.ttf", document.currentScript && document.currentScript.tagName.toUpperCase() === "SCRIPT" && document.currentScript.src || document.baseURI).href + ') format("truetype");font-weight:400;font-style:normal}@font-face{font-family:IBM Plex Sans;src:url(' + new URL("assets/IBMPlexSans-Medium.Ba7fOBgo.eot", document.currentScript && document.currentScript.tagName.toUpperCase() === "SCRIPT" && document.currentScript.src || document.baseURI).href + ");src:url(" + new URL("assets/IBMPlexSans-Medium.Ba7fOBgo.eot?#iefix", document.currentScript && document.currentScript.tagName.toUpperCase() === "SCRIPT" && document.currentScript.src || document.baseURI).href + ') format("embedded-opentype"),url(data:font/woff;base64,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) format("woff"),url(' + new URL("assets/IBMPlexSans-Medium.C-SrZCuI.ttf", document.currentScript && document.currentScript.tagName.toUpperCase() === "SCRIPT" && document.currentScript.src || document.baseURI).href + ') format("truetype");font-weight:500;font-style:normal}@font-face{font-family:IBM Plex Sans;src:url(' + new URL("assets/IBMPlexSans-Bold.BohPzoGF.eot", document.currentScript && document.currentScript.tagName.toUpperCase() === "SCRIPT" && document.currentScript.src || document.baseURI).href + ");src:url(" + new URL("assets/IBMPlexSans-Bold.BohPzoGF.eot?#iefix", document.currentScript && document.currentScript.tagName.toUpperCase() === "SCRIPT" && document.currentScript.src || document.baseURI).href + ') format("embedded-opentype"),url(data:font/woff;base64,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) format("woff"),url(' + new URL("assets/IBMPlexSans-Bold.ExXQi6rr.ttf", document.currentScript && document.currentScript.tagName.toUpperCase() === "SCRIPT" && document.currentScript.src || document.baseURI).href + ') format("truetype");font-weight:700;font-style:normal}@font-face{font-family:Cairo;src:url(' + new URL("assets/Cairo-Black.CrUZRok1.eot", document.currentScript && document.currentScript.tagName.toUpperCase() === "SCRIPT" && document.currentScript.src || document.baseURI).href + ");src:url(" + new URL("assets/Cairo-Black.CrUZRok1.eot?#iefix", document.currentScript && document.currentScript.tagName.toUpperCase() === "SCRIPT" && document.currentScript.src || document.baseURI).href + ') format("embedded-opentype"),url(data:font/woff;base64,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) format("woff"),url(' + new URL("assets/Cairo-Black.zRLbEn7t.ttf", document.currentScript && document.currentScript.tagName.toUpperCase() === "SCRIPT" && document.currentScript.src || document.baseURI).href + `) format("truetype");font-weight:900;font-style:normal}#coin-app .tooltip-container[data-v-65f5ce74]{position:absolute!important;transform:translateY(-50%) scale(var(--scale));transform-origin:center;display:flex;align-items:center;background:#ffcc29cc;color:var(--base_font_color);white-space:nowrap;cursor:pointer;gap:12px;z-index:-1;box-shadow:0 4px 8px #0003;border:none;pointer-events:auto}#coin-app .tooltip-left[data-v-65f5ce74]{right:50%;padding:calc(var(--base-size) * .5) calc(50% + var(--base-size)) calc(var(--base-size) * .5) calc(var(--base-size) * 1.5)!important;border-radius:999px 0 0 999px}#coin-app .tooltip-right[data-v-65f5ce74]{left:50%;padding:calc(var(--base-size) * .5) calc(var(--base-size) * 1.5) calc(var(--base-size) * .5) calc(50% + var(--base-size))!important;border-radius:0 999px 999px 0}#coin-app .slide-left-enter-active[data-v-65f5ce74],#coin-app .slide-left-leave-active[data-v-65f5ce74]{transition:all .5s cubic-bezier(.34,1.56,.64,1)}#coin-app .slide-left-enter-from[data-v-65f5ce74],#coin-app .slide-left-leave-to[data-v-65f5ce74]{opacity:0;transform:translate(-40px,-45%) scale(var(--scale))}#coin-app .slide-right-enter-active[data-v-65f5ce74],#coin-app .slide-right-leave-active[data-v-65f5ce74]{transition:all .5s cubic-bezier(.34,1.56,.64,1)}#coin-app .slide-right-enter-from[data-v-65f5ce74],#coin-app .slide-right-leave-to[data-v-65f5ce74]{opacity:0;transform:translate(40px,-45%) scale(var(--scale))}#coin-app .tooltip-left .tooltip-text[data-v-65f5ce74]{text-align:right}#coin-app .tooltip-right .tooltip-text[data-v-65f5ce74]{text-align:left}#coin-app .tooltip-text[data-v-65f5ce74]{font-family:var(--font-primary);display:flex;flex-direction:column;gap:2px;font-weight:700;line-height:1.2;text-transform:capitalize}#coin-app .tooltip-arrow[data-v-65f5ce74]{display:flex;align-items:center;height:100%}#coin-app .tooltip-arrow svg[data-v-65f5ce74]{height:60%;width:auto;color:#fff}#coin-app .tooltip-left .tooltip-arrow[data-v-65f5ce74]{transform:rotate(180deg)}#coin-app .coin-sprite[data-v-894a8d02]{overflow:hidden;background-repeat:no-repeat;background-position:0 0;transition:transform .3s ease;position:absolute;left:50%;top:50%;transform-origin:center}#coin-app .coin-animate[data-v-894a8d02]{animation:coin-spin-894a8d02 .6s steps(6) forwards}@keyframes coin-spin-894a8d02{0%{background-position:0 0}to{background-position:-1116px 0}}#coin-app .container[data-v-f2b66c65]{z-index:997;--background-color: yellow;position:fixed;pointer-events:none}#coin-app .coin-content[data-v-f2b66c65]{flex:1;justify-content:center;align-items:center;display:flex;pointer-events:none}#coin-app .box[data-v-f2b66c65]{border-radius:5px;max-width:100vw;max-height:100dvh;text-align:center;justify-content:center;align-items:center;display:flex;pointer-events:auto}#coin-app .disabled[data-v-f2b66c65]{background-color:gray}#coin-app .fade-enter-active,#coin-app .fade-leave-active{transition:opacity .3s ease-in-out}#coin-app .fade-enter-from,#coin-app .fade-leave-to{opacity:0}#coin-app .viewport{width:340px;max-height:100vh;display:flex;align-items:flex-start;justify-content:center;overflow-y:auto;scrollbar-width:thin;scrollbar-color:rgba(255,255,255,.5) rgba(0,0,0,.2)}#coin-app .viewport::-webkit-scrollbar{width:10px}#coin-app .viewport::-webkit-scrollbar-track{background:#000;border-radius:10px}#coin-app .viewport::-webkit-scrollbar-thumb{background:#ffffff80;border-radius:8px;-webkit-transition:background .3s ease;transition:background .3s ease}#coin-app .viewport::-webkit-scrollbar-thumb:hover{background:#ffffffb3;width:8px}#coin-app .popup-container{width:324px;height:504px;max-height:90vh;margin-top:auto;margin-bottom:auto;min-width:324px;min-height:504px;position:relative}#coin-app .won-text{position:absolute;top:149px;left:0;right:0;text-align:center;color:#fff;font-family:var(--font-primary);font-size:16px;font-style:normal;font-weight:700;line-height:120%;text-transform:uppercase}#coin-app .prize-text{position:absolute;top:165px;left:0;right:0;text-align:center}#coin-app .eur-value{color:#fff;font-family:var(--font-secondary);font-size:42px;font-style:normal;font-weight:900;line-height:100%;letter-spacing:-.47px;--letter-spacing: -1.47px}#coin-app .eur-eur{color:#fff;font-family:var(--font-secondary);font-size:16px;font-style:normal;font-weight:900;line-height:100%;text-transform:uppercase}#coin-app .local-currency{color:#fff;text-align:center;font-family:var(--font-secondary);font-size:16px;font-style:normal;font-weight:900;line-height:100%;text-transform:uppercase}#coin-app .local-currency-tip{color:#fff;text-align:center;font-family:var(--font-primary);font-size:12px;font-style:normal;font-weight:600;line-height:120%}#coin-app .prize-tip-text{position:absolute;top:253px;left:0;right:0;text-align:center;color:#fff;font-family:var(--font-primary);font-size:10px;font-style:normal;font-weight:600;line-height:120%}#coin-app .conf-btn{position:absolute;top:316px;left:0;right:0;margin:0 auto;border-radius:10px;background:linear-gradient(180deg,#feeb33,#fea904);box-shadow:0 2px #df6309,0 4px #bd4c00,0 10px 25px #30246099;color:#000;text-align:center;font-family:var(--font-primary);font-size:16px;font-style:normal;font-weight:700;line-height:120%;text-transform:uppercase;padding:.75rem 1.5rem;width:80%;max-width:250px;height:3rem;cursor:pointer;transition:all .3s ease;display:flex;align-items:center;justify-content:center;white-space:normal;word-wrap:break-word}#coin-app .conf-btn:hover{transform:translateY(-2px);box-shadow:0 4px #df6309,0 6px #bd4c00,0 12px 28px #302460b3}#coin-app .conf-btn:active{transform:translateY(2px);box-shadow:0 1px #df6309,0 2px #bd4c00,0 6px 15px #30246080}#coin-app .campaign-title{position:absolute;top:383px;left:0;right:0;text-align:center;color:#fff;font-family:var(--font-primary);font-size:16px;font-style:normal;font-weight:600;line-height:120%;text-transform:uppercase}#coin-app .logo{position:absolute;top:404px;left:0;right:0;text-align:center;display:flex;justify-content:center;width:100%}#coin-app #coin-theme.dark .conf-btn{border-radius:138px;border:2.149px solid rgba(255,255,255,.15);background:radial-gradient(59.85% 59.85% at 22.81% 5.7%,#ffff4f,#ffff4f00),radial-gradient(39.7% 39.7% at 76.75% 6.58%,#ffff4f,#ffff4f00),radial-gradient(35.98% 35.98% at 37.28% 100%,#ffff4f,#ffff4f00),linear-gradient(180deg,#fc0,#ff8d00);box-shadow:0 -4px #bf360c80 inset}@media (min-width: 1920px) and (max-width: 2309px){#coin-app .viewport{width:502px}#coin-app .popup-container{min-width:486px;min-height:756px;max-height:90vh}#coin-app .won-text{top:223.5px;font-size:24px}#coin-app .eur-value{font-size:63px;letter-spacing:-.705px}#coin-app .eur-eur{font-size:24px}#coin-app .prize-text{top:247.5px}#coin-app .prize-tip-text{top:379.5px;font-size:15px}#coin-app .conf-btn{top:474px;height:4.5rem;max-width:375px;font-size:1.875rem}#coin-app .logo{top:606px;height:2.25rem}#coin-app .campaign-title{top:574.5px;font-size:21px}#coin-app .local-currency{font-size:24px}#coin-app .local-currency-tip{font-size:18px;line-height:120%}}@media (min-width: 2400px){#coin-app .viewport{width:988px}#coin-app .popup-container{min-width:972px;min-height:1512px;max-height:90vh}#coin-app .won-text{top:447px;font-size:48px}#coin-app .eur-value{font-size:126px;letter-spacing:-1.41px}#coin-app .eur-eur{font-size:48px}#coin-app .prize-text{top:495px}#coin-app .prize-tip-text{top:759px;font-size:30px}#coin-app .conf-btn{top:948px;height:9rem;max-width:750px;font-size:3.75rem}#coin-app .logo{top:1212px;height:4.5rem}#coin-app .campaign-title{top:1149px;font-size:42px}#coin-app .local-currency{font-size:48px}#coin-app .local-currency-tip{font-size:36px;line-height:120%}}#coin-app .fade-delayed-enter-active{transition:all 1s ease;transition-delay:.8s;animation:glow 1s ease-in-out .8s}#coin-app .fade-delayed-leave-active{transition:opacity .5s ease}#coin-app .fade-delayed-enter-from,#coin-app .fade-delayed-leave-to{opacity:0}#coin-app .slide-down-enter-active{transition:all 1.2s cubic-bezier(.175,.885,.32,1.275);transition-delay:.4s;animation:glow 1.2s ease-in-out .4s}#coin-app .slide-down-leave-active{transition:all .7s ease}#coin-app .slide-down-enter-from,#coin-app .slide-down-leave-to{opacity:.1;transform:translateY(-60px)}#coin-app .slide-up-enter-active{transition:all 1.2s cubic-bezier(.175,.885,.32,1.275);transition-delay:1.2s;animation:glow 1.2s ease-in-out 1.2s}#coin-app .slide-up-leave-active{transition:all .7s ease}#coin-app .slide-up-enter-from,#coin-app .slide-up-leave-to{opacity:.1;transform:translateY(60px)}#coin-app .scale-up-enter-active{transition:all 1.2s cubic-bezier(.175,.885,.32,1.275);transition-delay:2s;animation:buttonGlow 1.2s ease-in-out 2s}#coin-app .scale-up-leave-active{transition:all .7s ease}#coin-app .scale-up-enter-from,#coin-app .scale-up-leave-to{opacity:.1;transform:scale(.7)}#coin-app .pulse-shadow{animation:pulseShadow 2.5s infinite;animation-delay:3s}@keyframes pulseShadow{0%,to{box-shadow:0 0 #3b82f680,inset 0 -4px #0000004d,inset 0 1px 1px #ffffff59;transform:scale(1)}50%{box-shadow:0 0 25px #3b82f6,inset 0 -4px #0000004d,inset 0 1px 1px #ffffff59;transform:scale(1.07)}}@keyframes glow{0%{text-shadow:0 0 0 rgba(255,255,255,0)}50%{text-shadow:0 0 15px rgba(255,255,255,.8)}to{text-shadow:0 0 5px rgba(255,255,255,.3)}}@keyframes buttonGlow{0%{box-shadow:0 0 #3b82f600}50%{box-shadow:0 0 30px #3b82f6}to{box-shadow:0 0 10px #3b82f680}}#coin-app .modal[data-v-707316fb]{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:flex;justify-content:center;align-items:center}#coin-app .modal-content[data-v-707316fb]{background-color:#fff;padding:20px;border-radius:8px;box-shadow:0 2px 10px #0000001a}#coin-app .coin-widget-container[data-v-b904ef38]{display:flex;flex-direction:column;align-items:center;justify-content:center;pointer-events:none;gap:0;width:100%;z-index:1000}#coin-app .content-icon[data-v-b904ef38]{-o-object-fit:contain;object-fit:contain;pointer-events:none;touch-action:none}#coin-app .coin-widget-container[data-v-7b6b89ec]{display:flex;flex-direction:column;align-items:center;justify-content:center;pointer-events:none;width:100%;height:100%;z-index:1000;transform:translateY(-4px)}#coin-app .content-wrapper[data-v-7b6b89ec]{display:flex;flex-direction:column;align-items:center;justify-content:center;width:120%;gap:4px}#coin-app .coin-icon[data-v-4fe84296]{-o-object-fit:contain;object-fit:contain;pointer-events:none;margin-bottom:4px}#coin-app .middle[data-v-0a90cefe]{--value-outline-color: #ffcc29;--value-outline-width: 1px;text-transform:uppercase;font-family:var(--secondary_font);font-size:44px;font-weight:900;color:var(--base_font_color);text-shadow:1px 1px 2px #d3d0c7;white-space:nowrap;pointer-events:none;text-align:center;margin:0;padding:0;line-height:1;max-width:100%;display:flex;justify-content:center;align-items:center;text-shadow:-2px -2px 0 var(--value-outline-color),2px -2px 0 var(--value-outline-color),-2px 2px 0 var(--value-outline-color),2px 2px 0 var(--value-outline-color)}#coin-app .down[data-v-0a90cefe]{--label-outline-color: #ffcc29;--label-outline-width: 1px;max-width:250px;font-family:var(--primary_font);font-size:28px;font-weight:500;color:var(--base_font_color);text-shadow:1px 1px 2px #d3d0c7;white-space:nowrap;pointer-events:none;text-align:center;margin:0;padding:0;line-height:1;display:flex;justify-content:center;align-items:center;text-shadow:-2px -2px 0 var(--label-outline-color),2px -2px 0 var(--label-outline-color),-2px 2px 0 var(--label-outline-color),2px 2px 0 var(--label-outline-color)}#coin-app .middle[data-v-64634c19]{--value-outline-color: #ffcc29;--value-outline-width: 1px;text-transform:uppercase;font-family:var(--secondary_font);font-size:44px;font-weight:900;color:var(--base_font_color);text-shadow:1px 1px 2px #d3d0c7;white-space:nowrap;pointer-events:none;text-align:center;margin:0;padding:0;line-height:1;max-width:100%;display:flex;justify-content:center;align-items:center;text-shadow:-2px -2px 0 var(--value-outline-color),2px -2px 0 var(--value-outline-color),-2px 2px 0 var(--value-outline-color),2px 2px 0 var(--value-outline-color)}#coin-app .down[data-v-64634c19]{--label-outline-color: #ffcc29;--label-outline-width: 1px;max-width:250px;font-family:var(--primary_font);font-size:28px;font-weight:500;color:var(--base_font_color);text-shadow:1px 1px 2px #d3d0c7;white-space:nowrap;pointer-events:none;text-align:center;margin:0;padding:0;line-height:1;display:flex;justify-content:center;align-items:center;text-shadow:-2px -2px 0 var(--label-outline-color),2px -2px 0 var(--label-outline-color),-2px 2px 0 var(--label-outline-color),2px 2px 0 var(--label-outline-color)}#coin-app .timer-container[data-v-25525c3f]{display:flex;align-items:center;justify-content:center;min-height:2rem}#coin-app .timer-display[data-v-25525c3f]{display:flex;align-items:center;justify-content:center}#coin-app .timer-text[data-v-25525c3f]{--label-outline-color: #ffcc29;--label-outline-width: 1px;max-width:180px;font-family:var(--base_font);font-size:28px;font-weight:500;color:var(--base_font_color);text-shadow:1px 1px 2px #d3d0c7;white-space:normal;pointer-events:none;text-align:center;margin:0;padding:0;line-height:1;display:flex;justify-content:center;align-items:center;text-shadow:-2px -2px 0 var(--label-outline-color),2px -2px 0 var(--label-outline-color),-2px 2px 0 var(--label-outline-color),2px 2px 0 var(--label-outline-color)}#coin-app .timer-text-old[data-v-25525c3f]{--value-outline-color: #ffcc29;--value-outline-width: 1px;font-family:var(--secondary_font);font-size:32px;font-weight:900;color:var(--base_font_color);text-shadow:1px 1px 2px #d3d0c7;white-space:nowrap;pointer-events:none;text-align:center;margin:0;padding:0;line-height:1.1;max-width:100%;display:flex;justify-content:center;align-items:center;text-shadow:-2px -2px 0 var(--value-outline-color),2px -2px 0 var(--value-outline-color),-2px 2px 0 var(--value-outline-color),2px 2px 0 var(--value-outline-color)}#coin-app .timer-loader[data-v-25525c3f]{display:flex;align-items:center;justify-content:center}#coin-app .loader-spinner[data-v-25525c3f]{width:1.5rem;height:1.5rem;border:2px solid currentColor;border-top:2px solid transparent;border-radius:50%;animation:spin-25525c3f 1s linear infinite;opacity:.6}@keyframes spin-25525c3f{0%{transform:rotate(0)}to{transform:rotate(360deg)}}#coin-app #coin-theme.dark .timer-text[data-v-25525c3f]{font-family:var(--base_font)}#coin-app .middle[data-v-433004a4]{--value-outline-color: #ffcc29;--value-outline-width: 1px;text-transform:uppercase;font-family:var(--secondary_font);font-size:32px;font-weight:900;color:var(--base_font_color);text-shadow:1px 1px 2px #d3d0c7;white-space:nowrap;pointer-events:none;text-align:center;margin:0;padding:0;line-height:1.1;max-width:100%;display:flex;justify-content:center;align-items:center;text-shadow:-2px -2px 0 var(--value-outline-color),2px -2px 0 var(--value-outline-color),-2px 2px 0 var(--value-outline-color),2px 2px 0 var(--value-outline-color)}#coin-app .middle[data-v-9b317e0a]{--value-outline-color: #ffcc29;--value-outline-width: 1px;text-transform:uppercase;font-family:var(--secondary_font);font-size:44px;font-weight:900;color:var(--base_font_color);text-shadow:1px 1px 2px #d3d0c7;white-space:nowrap;pointer-events:none;text-align:center;margin:0;padding:0;line-height:1;max-width:100%;display:flex;justify-content:center;align-items:center;text-shadow:-2px -2px 0 var(--value-outline-color),2px -2px 0 var(--value-outline-color),-2px 2px 0 var(--value-outline-color),2px 2px 0 var(--value-outline-color)}#coin-app .down[data-v-9b317e0a]{--label-outline-color: #ffcc29;--label-outline-width: 1px;max-width:250px;font-family:var(--primary_font);font-size:28px;font-weight:500;color:var(--base_font_color);text-shadow:1px 1px 2px #d3d0c7;white-space:nowrap;pointer-events:none;text-align:center;margin:0;padding:0;line-height:1;display:flex;justify-content:center;align-items:center;text-shadow:-2px -2px 0 var(--label-outline-color),2px -2px 0 var(--label-outline-color),-2px 2px 0 var(--label-outline-color),2px 2px 0 var(--label-outline-color)}#coin-app #coin-theme.dark .coin-label[data-v-9b317e0a]{font-family:var(--base_font)}
/*$vite$:1*/`, document.head.appendChild(Zl);
  var Ke = typeof document < "u" ? document.currentScript : null;
  /**
   * @vue/shared v3.5.16
   * (c) 2018-present Yuxi (Evan) You and Vue contributors
   * @license MIT
   **/
  /*! #__NO_SIDE_EFFECTS__ */
  function ao(e) {
    const t = Object.create(null);
    for (const n of e.split(",")) t[n] = 1;
    return n => n in t
  }
  const ue = {},
    gi = [],
    Et = () => {},
    Qm = () => !1,
    Ur = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97),
    lo = e => e.startsWith("onUpdate:"),
    Ne = Object.assign,
    co = (e, t) => {
      const n = e.indexOf(t);
      n > -1 && e.splice(n, 1)
    },
    _m = Object.prototype.hasOwnProperty,
    oe = (e, t) => _m.call(e, t),
    G = Array.isArray,
    yi = e => Br(e) === "[object Map]",
    Ul = e => Br(e) === "[object Set]",
    J = e => typeof e == "function",
    Pe = e => typeof e == "string",
    on = e => typeof e == "symbol",
    ye = e => e !== null && typeof e == "object",
    Bl = e => (ye(e) || J(e)) && J(e.then) && J(e.catch),
    Gl = Object.prototype.toString,
    Br = e => Gl.call(e),
    $m = e => Br(e).slice(8, -1),
    Kl = e => Br(e) === "[object Object]",
    uo = e => Pe(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e,
    qi = ao(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
    Gr = e => {
      const t = Object.create(null);
      return n => t[n] || (t[n] = e(n))
    },
    ev = /-(\w)/g,
    yt = Gr(e => e.replace(ev, (t, n) => n ? n.toUpperCase() : "")),
    tv = /\B([A-Z])/g,
    Kn = Gr(e => e.replace(tv, "-$1").toLowerCase()),
    Kr = Gr(e => e.charAt(0).toUpperCase() + e.slice(1)),
    fo = Gr(e => e ? `on${Kr(e)}` : ""),
    Dn = (e, t) => !Object.is(e, t),
    po = (e, ...t) => {
      for (let n = 0; n < e.length; n++) e[n](...t)
    },
    Jl = (e, t, n, i = !1) => {
      Object.defineProperty(e, t, {
        configurable: !0,
        enumerable: !1,
        writable: i,
        value: n
      })
    },
    nv = e => {
      const t = parseFloat(e);
      return isNaN(t) ? e : t
    },
    iv = e => {
      const t = Pe(e) ? Number(e) : NaN;
      return isNaN(t) ? e : t
    };
  let Yl;
  const Jr = () => Yl || (Yl = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});

  function bt(e) {
    if (G(e)) {
      const t = {};
      for (let n = 0; n < e.length; n++) {
        const i = e[n],
          r = Pe(i) ? av(i) : bt(i);
        if (r)
          for (const s in r) t[s] = r[s]
      }
      return t
    } else if (Pe(e) || ye(e)) return e
  }
  const rv = /;(?![^(]*\))/g,
    sv = /:([^]+)/,
    ov = /\/\*[^]*?\*\//g;

  function av(e) {
    const t = {};
    return e.replace(ov, "").split(rv).forEach(n => {
      if (n) {
        const i = n.split(sv);
        i.length > 1 && (t[i[0].trim()] = i[1].trim())
      }
    }), t
  }

  function Zi(e) {
    let t = "";
    if (Pe(e)) t = e;
    else if (G(e))
      for (let n = 0; n < e.length; n++) {
        const i = Zi(e[n]);
        i && (t += i + " ")
      } else if (ye(e))
        for (const n in e) e[n] && (t += n + " ");
    return t.trim()
  }
  const lv = ao("itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly");

  function Ql(e) {
    return !!e || e === ""
  }
  const _l = e => !!(e && e.__v_isRef === !0),
    je = e => Pe(e) ? e : e == null ? "" : G(e) || ye(e) && (e.toString === Gl || !J(e.toString)) ? _l(e) ? je(e.value) : JSON.stringify(e, $l, 2) : String(e),
    $l = (e, t) => _l(t) ? $l(e, t.value) : yi(t) ? {
      [`Map(${t.size})`]: [...t.entries()].reduce((n, [i, r], s) => (n[ho(i, s) + " =>"] = r, n), {})
    } : Ul(t) ? {
      [`Set(${t.size})`]: [...t.values()].map(n => ho(n))
    } : on(t) ? ho(t) : ye(t) && !G(t) && !Kl(t) ? String(t) : t,
    ho = (e, t = "") => {
      var n;
      return on(e) ? `Symbol(${(n=e.description)!=null?n:t})` : e
    };
  /**
   * @vue/reactivity v3.5.16
   * (c) 2018-present Yuxi (Evan) You and Vue contributors
   * @license MIT
   **/
  let it;
  class ec {
    constructor(t = !1) {
      this.detached = t, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = it, !t && it && (this.index = (it.scopes || (it.scopes = [])).push(this) - 1)
    }
    get active() {
      return this._active
    }
    pause() {
      if (this._active) {
        this._isPaused = !0;
        let t, n;
        if (this.scopes)
          for (t = 0, n = this.scopes.length; t < n; t++) this.scopes[t].pause();
        for (t = 0, n = this.effects.length; t < n; t++) this.effects[t].pause()
      }
    }
    resume() {
      if (this._active && this._isPaused) {
        this._isPaused = !1;
        let t, n;
        if (this.scopes)
          for (t = 0, n = this.scopes.length; t < n; t++) this.scopes[t].resume();
        for (t = 0, n = this.effects.length; t < n; t++) this.effects[t].resume()
      }
    }
    run(t) {
      if (this._active) {
        const n = it;
        try {
          return it = this, t()
        } finally {
          it = n
        }
      }
    }
    on() {
      ++this._on === 1 && (this.prevScope = it, it = this)
    }
    off() {
      this._on > 0 && --this._on === 0 && (it = this.prevScope, this.prevScope = void 0)
    }
    stop(t) {
      if (this._active) {
        this._active = !1;
        let n, i;
        for (n = 0, i = this.effects.length; n < i; n++) this.effects[n].stop();
        for (this.effects.length = 0, n = 0, i = this.cleanups.length; n < i; n++) this.cleanups[n]();
        if (this.cleanups.length = 0, this.scopes) {
          for (n = 0, i = this.scopes.length; n < i; n++) this.scopes[n].stop(!0);
          this.scopes.length = 0
        }
        if (!this.detached && this.parent && !t) {
          const r = this.parent.scopes.pop();
          r && r !== this && (this.parent.scopes[this.index] = r, r.index = this.index)
        }
        this.parent = void 0
      }
    }
  }

  function cv(e) {
    return new ec(e)
  }

  function uv() {
    return it
  }
  let he;
  const mo = new WeakSet;
  class tc {
    constructor(t) {
      this.fn = t, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, it && it.active && it.effects.push(this)
    }
    pause() {
      this.flags |= 64
    }
    resume() {
      this.flags & 64 && (this.flags &= -65, mo.has(this) && (mo.delete(this), this.trigger()))
    }
    notify() {
      this.flags & 2 && !(this.flags & 32) || this.flags & 8 || ic(this)
    }
    run() {
      if (!(this.flags & 1)) return this.fn();
      this.flags |= 2, lc(this), rc(this);
      const t = he,
        n = Vt;
      he = this, Vt = !0;
      try {
        return this.fn()
      } finally {
        sc(this), he = t, Vt = n, this.flags &= -3
      }
    }
    stop() {
      if (this.flags & 1) {
        for (let t = this.deps; t; t = t.nextDep) bo(t);
        this.deps = this.depsTail = void 0, lc(this), this.onStop && this.onStop(), this.flags &= -2
      }
    }
    trigger() {
      this.flags & 64 ? mo.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty()
    }
    runIfDirty() {
      yo(this) && this.run()
    }
    get dirty() {
      return yo(this)
    }
  }
  let nc = 0,
    Ui, Bi;

  function ic(e, t = !1) {
    if (e.flags |= 8, t) {
      e.next = Bi, Bi = e;
      return
    }
    e.next = Ui, Ui = e
  }

  function vo() {
    nc++
  }

  function go() {
    if (--nc > 0) return;
    if (Bi) {
      let t = Bi;
      for (Bi = void 0; t;) {
        const n = t.next;
        t.next = void 0, t.flags &= -9, t = n
      }
    }
    let e;
    for (; Ui;) {
      let t = Ui;
      for (Ui = void 0; t;) {
        const n = t.next;
        if (t.next = void 0, t.flags &= -9, t.flags & 1) try {
          t.trigger()
        } catch (i) {
          e || (e = i)
        }
        t = n
      }
    }
    if (e) throw e
  }

  function rc(e) {
    for (let t = e.deps; t; t = t.nextDep) t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t
  }

  function sc(e) {
    let t, n = e.depsTail,
      i = n;
    for (; i;) {
      const r = i.prevDep;
      i.version === -1 ? (i === n && (n = r), bo(i), fv(i)) : t = i, i.dep.activeLink = i.prevActiveLink, i.prevActiveLink = void 0, i = r
    }
    e.deps = t, e.depsTail = n
  }

  function yo(e) {
    for (let t = e.deps; t; t = t.nextDep)
      if (t.dep.version !== t.version || t.dep.computed && (oc(t.dep.computed) || t.dep.version !== t.version)) return !0;
    return !!e._dirty
  }

  function oc(e) {
    if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === Gi) || (e.globalVersion = Gi, !e.isSSR && e.flags & 128 && (!e.deps && !e._dirty || !yo(e)))) return;
    e.flags |= 2;
    const t = e.dep,
      n = he,
      i = Vt;
    he = e, Vt = !0;
    try {
      rc(e);
      const r = e.fn(e._value);
      (t.version === 0 || Dn(r, e._value)) && (e.flags |= 128, e._value = r, t.version++)
    } catch (r) {
      throw t.version++, r
    } finally {
      he = n, Vt = i, sc(e), e.flags &= -3
    }
  }

  function bo(e, t = !1) {
    const {
      dep: n,
      prevSub: i,
      nextSub: r
    } = e;
    if (i && (i.nextSub = r, e.prevSub = void 0), r && (r.prevSub = i, e.nextSub = void 0), n.subs === e && (n.subs = i, !i && n.computed)) {
      n.computed.flags &= -5;
      for (let s = n.computed.deps; s; s = s.nextDep) bo(s, !0)
    }!t && !--n.sc && n.map && n.map.delete(n.key)
  }

  function fv(e) {
    const {
      prevDep: t,
      nextDep: n
    } = e;
    t && (t.nextDep = n, e.prevDep = void 0), n && (n.prevDep = t, e.nextDep = void 0)
  }
  let Vt = !0;
  const ac = [];

  function Mt() {
    ac.push(Vt), Vt = !1
  }

  function It() {
    const e = ac.pop();
    Vt = e === void 0 ? !0 : e
  }

  function lc(e) {
    const {
      cleanup: t
    } = e;
    if (e.cleanup = void 0, t) {
      const n = he;
      he = void 0;
      try {
        t()
      } finally {
        he = n
      }
    }
  }
  let Gi = 0;
  class dv {
    constructor(t, n) {
      this.sub = t, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0
    }
  }
  class Ao {
    constructor(t) {
      this.computed = t, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0
    }
    track(t) {
      if (!he || !Vt || he === this.computed) return;
      let n = this.activeLink;
      if (n === void 0 || n.sub !== he) n = this.activeLink = new dv(he, this), he.deps ? (n.prevDep = he.depsTail, he.depsTail.nextDep = n, he.depsTail = n) : he.deps = he.depsTail = n, cc(n);
      else if (n.version === -1 && (n.version = this.version, n.nextDep)) {
        const i = n.nextDep;
        i.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = i), n.prevDep = he.depsTail, n.nextDep = void 0, he.depsTail.nextDep = n, he.depsTail = n, he.deps === n && (he.deps = i)
      }
      return n
    }
    trigger(t) {
      this.version++, Gi++, this.notify(t)
    }
    notify(t) {
      vo();
      try {
        for (let n = this.subs; n; n = n.prevSub) n.sub.notify() && n.sub.dep.notify()
      } finally {
        go()
      }
    }
  }

  function cc(e) {
    if (e.dep.sc++, e.sub.flags & 4) {
      const t = e.dep.computed;
      if (t && !e.dep.subs) {
        t.flags |= 20;
        for (let i = t.deps; i; i = i.nextDep) cc(i)
      }
      const n = e.dep.subs;
      n !== e && (e.prevSub = n, n && (n.nextSub = e)), e.dep.subs = e
    }
  }
  const Po = new WeakMap,
    Jn = Symbol(""),
    wo = Symbol(""),
    Ki = Symbol("");

  function Ze(e, t, n) {
    if (Vt && he) {
      let i = Po.get(e);
      i || Po.set(e, i = new Map);
      let r = i.get(n);
      r || (i.set(n, r = new Ao), r.map = i, r.key = n), r.track()
    }
  }

  function an(e, t, n, i, r, s) {
    const o = Po.get(e);
    if (!o) {
      Gi++;
      return
    }
    const a = l => {
      l && l.trigger()
    };
    if (vo(), t === "clear") o.forEach(a);
    else {
      const l = G(e),
        u = l && uo(n);
      if (l && n === "length") {
        const c = Number(i);
        o.forEach((f, d) => {
          (d === "length" || d === Ki || !on(d) && d >= c) && a(f)
        })
      } else switch ((n !== void 0 || o.has(void 0)) && a(o.get(n)), u && a(o.get(Ki)), t) {
        case "add":
          l ? u && a(o.get("length")) : (a(o.get(Jn)), yi(e) && a(o.get(wo)));
          break;
        case "delete":
          l || (a(o.get(Jn)), yi(e) && a(o.get(wo)));
          break;
        case "set":
          yi(e) && a(o.get(Jn));
          break
      }
    }
    go()
  }

  function bi(e) {
    const t = ie(e);
    return t === e ? t : (Ze(t, "iterate", Ki), Nt(e) ? t : t.map(Je))
  }

  function xo(e) {
    return Ze(e = ie(e), "iterate", Ki), e
  }
  const pv = {
    __proto__: null,
    [Symbol.iterator]() {
      return To(this, Symbol.iterator, Je)
    },
    concat(...e) {
      return bi(this).concat(...e.map(t => G(t) ? bi(t) : t))
    },
    entries() {
      return To(this, "entries", e => (e[1] = Je(e[1]), e))
    },
    every(e, t) {
      return ln(this, "every", e, t, void 0, arguments)
    },
    filter(e, t) {
      return ln(this, "filter", e, t, n => n.map(Je), arguments)
    },
    find(e, t) {
      return ln(this, "find", e, t, Je, arguments)
    },
    findIndex(e, t) {
      return ln(this, "findIndex", e, t, void 0, arguments)
    },
    findLast(e, t) {
      return ln(this, "findLast", e, t, Je, arguments)
    },
    findLastIndex(e, t) {
      return ln(this, "findLastIndex", e, t, void 0, arguments)
    },
    forEach(e, t) {
      return ln(this, "forEach", e, t, void 0, arguments)
    },
    includes(...e) {
      return Lo(this, "includes", e)
    },
    indexOf(...e) {
      return Lo(this, "indexOf", e)
    },
    join(e) {
      return bi(this).join(e)
    },
    lastIndexOf(...e) {
      return Lo(this, "lastIndexOf", e)
    },
    map(e, t) {
      return ln(this, "map", e, t, void 0, arguments)
    },
    pop() {
      return Ji(this, "pop")
    },
    push(...e) {
      return Ji(this, "push", e)
    },
    reduce(e, ...t) {
      return uc(this, "reduce", e, t)
    },
    reduceRight(e, ...t) {
      return uc(this, "reduceRight", e, t)
    },
    shift() {
      return Ji(this, "shift")
    },
    some(e, t) {
      return ln(this, "some", e, t, void 0, arguments)
    },
    splice(...e) {
      return Ji(this, "splice", e)
    },
    toReversed() {
      return bi(this).toReversed()
    },
    toSorted(e) {
      return bi(this).toSorted(e)
    },
    toSpliced(...e) {
      return bi(this).toSpliced(...e)
    },
    unshift(...e) {
      return Ji(this, "unshift", e)
    },
    values() {
      return To(this, "values", Je)
    }
  };

  function To(e, t, n) {
    const i = xo(e),
      r = i[t]();
    return i !== e && !Nt(e) && (r._next = r.next, r.next = () => {
      const s = r._next();
      return s.value && (s.value = n(s.value)), s
    }), r
  }
  const hv = Array.prototype;

  function ln(e, t, n, i, r, s) {
    const o = xo(e),
      a = o !== e && !Nt(e),
      l = o[t];
    if (l !== hv[t]) {
      const f = l.apply(e, s);
      return a ? Je(f) : f
    }
    let u = n;
    o !== e && (a ? u = function(f, d) {
      return n.call(this, Je(f), d, e)
    } : n.length > 2 && (u = function(f, d) {
      return n.call(this, f, d, e)
    }));
    const c = l.call(o, u, i);
    return a && r ? r(c) : c
  }

  function uc(e, t, n, i) {
    const r = xo(e);
    let s = n;
    return r !== e && (Nt(e) ? n.length > 3 && (s = function(o, a, l) {
      return n.call(this, o, a, l, e)
    }) : s = function(o, a, l) {
      return n.call(this, o, Je(a), l, e)
    }), r[t](s, ...i)
  }

  function Lo(e, t, n) {
    const i = ie(e);
    Ze(i, "iterate", Ki);
    const r = i[t](...n);
    return (r === -1 || r === !1) && zo(n[0]) ? (n[0] = ie(n[0]), i[t](...n)) : r
  }

  function Ji(e, t, n = []) {
    Mt(), vo();
    const i = ie(e)[t].apply(e, n);
    return go(), It(), i
  }
  const mv = ao("__proto__,__v_isRef,__isVue"),
    fc = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(on));

  function vv(e) {
    on(e) || (e = String(e));
    const t = ie(this);
    return Ze(t, "has", e), t.hasOwnProperty(e)
  }
  class dc {
    constructor(t = !1, n = !1) {
      this._isReadonly = t, this._isShallow = n
    }
    get(t, n, i) {
      if (n === "__v_skip") return t.__v_skip;
      const r = this._isReadonly,
        s = this._isShallow;
      if (n === "__v_isReactive") return !r;
      if (n === "__v_isReadonly") return r;
      if (n === "__v_isShallow") return s;
      if (n === "__v_raw") return i === (r ? s ? yc : gc : s ? vc : mc).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(i) ? t : void 0;
      const o = G(t);
      if (!r) {
        let l;
        if (o && (l = pv[n])) return l;
        if (n === "hasOwnProperty") return vv
      }
      const a = Reflect.get(t, n, Re(t) ? t : i);
      return (on(n) ? fc.has(n) : mv(n)) || (r || Ze(t, "get", n), s) ? a : Re(a) ? o && uo(n) ? a : a.value : ye(a) ? r ? cn(a) : Oo(a) : a
    }
  }
  class pc extends dc {
    constructor(t = !1) {
      super(!1, t)
    }
    set(t, n, i, r) {
      let s = t[n];
      if (!this._isShallow) {
        const l = Yn(s);
        if (!Nt(i) && !Yn(i) && (s = ie(s), i = ie(i)), !G(t) && Re(s) && !Re(i)) return l ? !1 : (s.value = i, !0)
      }
      const o = G(t) && uo(n) ? Number(n) < t.length : oe(t, n),
        a = Reflect.set(t, n, i, Re(t) ? t : r);
      return t === ie(r) && (o ? Dn(i, s) && an(t, "set", n, i) : an(t, "add", n, i)), a
    }
    deleteProperty(t, n) {
      const i = oe(t, n);
      t[n];
      const r = Reflect.deleteProperty(t, n);
      return r && i && an(t, "delete", n, void 0), r
    }
    has(t, n) {
      const i = Reflect.has(t, n);
      return (!on(n) || !fc.has(n)) && Ze(t, "has", n), i
    }
    ownKeys(t) {
      return Ze(t, "iterate", G(t) ? "length" : Jn), Reflect.ownKeys(t)
    }
  }
  class hc extends dc {
    constructor(t = !1) {
      super(!0, t)
    }
    set(t, n) {
      return !0
    }
    deleteProperty(t, n) {
      return !0
    }
  }
  const gv = new pc,
    yv = new hc,
    bv = new pc(!0),
    Av = new hc(!0),
    So = e => e,
    Yr = e => Reflect.getPrototypeOf(e);

  function Pv(e, t, n) {
    return function(...i) {
      const r = this.__v_raw,
        s = ie(r),
        o = yi(s),
        a = e === "entries" || e === Symbol.iterator && o,
        l = e === "keys" && o,
        u = r[e](...i),
        c = n ? So : t ? Xo : Je;
      return !t && Ze(s, "iterate", l ? wo : Jn), {
        next() {
          const {
            value: f,
            done: d
          } = u.next();
          return d ? {
            value: f,
            done: d
          } : {
            value: a ? [c(f[0]), c(f[1])] : c(f),
            done: d
          }
        },
        [Symbol.iterator]() {
          return this
        }
      }
    }
  }

  function Qr(e) {
    return function(...t) {
      return e === "delete" ? !1 : e === "clear" ? void 0 : this
    }
  }

  function wv(e, t) {
    const n = {
      get(r) {
        const s = this.__v_raw,
          o = ie(s),
          a = ie(r);
        e || (Dn(r, a) && Ze(o, "get", r), Ze(o, "get", a));
        const {
          has: l
        } = Yr(o), u = t ? So : e ? Xo : Je;
        if (l.call(o, r)) return u(s.get(r));
        if (l.call(o, a)) return u(s.get(a));
        s !== o && s.get(r)
      },
      get size() {
        const r = this.__v_raw;
        return !e && Ze(ie(r), "iterate", Jn), Reflect.get(r, "size", r)
      },
      has(r) {
        const s = this.__v_raw,
          o = ie(s),
          a = ie(r);
        return e || (Dn(r, a) && Ze(o, "has", r), Ze(o, "has", a)), r === a ? s.has(r) : s.has(r) || s.has(a)
      },
      forEach(r, s) {
        const o = this,
          a = o.__v_raw,
          l = ie(a),
          u = t ? So : e ? Xo : Je;
        return !e && Ze(l, "iterate", Jn), a.forEach((c, f) => r.call(s, u(c), u(f), o))
      }
    };
    return Ne(n, e ? {
      add: Qr("add"),
      set: Qr("set"),
      delete: Qr("delete"),
      clear: Qr("clear")
    } : {
      add(r) {
        !t && !Nt(r) && !Yn(r) && (r = ie(r));
        const s = ie(this);
        return Yr(s).has.call(s, r) || (s.add(r), an(s, "add", r, r)), this
      },
      set(r, s) {
        !t && !Nt(s) && !Yn(s) && (s = ie(s));
        const o = ie(this),
          {
            has: a,
            get: l
          } = Yr(o);
        let u = a.call(o, r);
        u || (r = ie(r), u = a.call(o, r));
        const c = l.call(o, r);
        return o.set(r, s), u ? Dn(s, c) && an(o, "set", r, s) : an(o, "add", r, s), this
      },
      delete(r) {
        const s = ie(this),
          {
            has: o,
            get: a
          } = Yr(s);
        let l = o.call(s, r);
        l || (r = ie(r), l = o.call(s, r)), a && a.call(s, r);
        const u = s.delete(r);
        return l && an(s, "delete", r, void 0), u
      },
      clear() {
        const r = ie(this),
          s = r.size !== 0,
          o = r.clear();
        return s && an(r, "clear", void 0, void 0), o
      }
    }), ["keys", "values", "entries", Symbol.iterator].forEach(r => {
      n[r] = Pv(r, e, t)
    }), n
  }

  function _r(e, t) {
    const n = wv(e, t);
    return (i, r, s) => r === "__v_isReactive" ? !e : r === "__v_isReadonly" ? e : r === "__v_raw" ? i : Reflect.get(oe(n, r) && r in i ? n : i, r, s)
  }
  const xv = {
      get: _r(!1, !1)
    },
    Tv = {
      get: _r(!1, !0)
    },
    Lv = {
      get: _r(!0, !1)
    },
    Sv = {
      get: _r(!0, !0)
    },
    mc = new WeakMap,
    vc = new WeakMap,
    gc = new WeakMap,
    yc = new WeakMap;

  function Ov(e) {
    switch (e) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0
    }
  }

  function zv(e) {
    return e.__v_skip || !Object.isExtensible(e) ? 0 : Ov($m(e))
  }

  function Oo(e) {
    return Yn(e) ? e : $r(e, !1, gv, xv, mc)
  }

  function Xv(e) {
    return $r(e, !1, bv, Tv, vc)
  }

  function cn(e) {
    return $r(e, !0, yv, Lv, gc)
  }

  function BL(e) {
    return $r(e, !0, Av, Sv, yc)
  }

  function $r(e, t, n, i, r) {
    if (!ye(e) || e.__v_raw && !(t && e.__v_isReactive)) return e;
    const s = zv(e);
    if (s === 0) return e;
    const o = r.get(e);
    if (o) return o;
    const a = new Proxy(e, s === 2 ? i : n);
    return r.set(e, a), a
  }

  function Yi(e) {
    return Yn(e) ? Yi(e.__v_raw) : !!(e && e.__v_isReactive)
  }

  function Yn(e) {
    return !!(e && e.__v_isReadonly)
  }

  function Nt(e) {
    return !!(e && e.__v_isShallow)
  }

  function zo(e) {
    return e ? !!e.__v_raw : !1
  }

  function ie(e) {
    const t = e && e.__v_raw;
    return t ? ie(t) : e
  }

  function Dv(e) {
    return !oe(e, "__v_skip") && Object.isExtensible(e) && Jl(e, "__v_skip", !0), e
  }
  const Je = e => ye(e) ? Oo(e) : e,
    Xo = e => ye(e) ? cn(e) : e;

  function Re(e) {
    return e ? e.__v_isRef === !0 : !1
  }

  function te(e) {
    return Ac(e, !1)
  }

  function bc(e) {
    return Ac(e, !0)
  }

  function Ac(e, t) {
    return Re(e) ? e : new Vv(e, t)
  }
  class Vv {
    constructor(t, n) {
      this.dep = new Ao, this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = n ? t : ie(t), this._value = n ? t : Je(t), this.__v_isShallow = n
    }
    get value() {
      return this.dep.track(), this._value
    }
    set value(t) {
      const n = this._rawValue,
        i = this.__v_isShallow || Nt(t) || Yn(t);
      t = i ? t : ie(t), Dn(t, n) && (this._rawValue = t, this._value = i ? t : Je(t), this.dep.trigger())
    }
  }

  function fe(e) {
    return Re(e) ? e.value : e
  }
  const Nv = {
    get: (e, t, n) => t === "__v_raw" ? e : fe(Reflect.get(e, t, n)),
    set: (e, t, n, i) => {
      const r = e[t];
      return Re(r) && !Re(n) ? (r.value = n, !0) : Reflect.set(e, t, n, i)
    }
  };

  function Pc(e) {
    return Yi(e) ? e : new Proxy(e, Nv)
  }
  class jv {
    constructor(t, n, i) {
      this.fn = t, this.setter = n, this._value = void 0, this.dep = new Ao(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = Gi - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = i
    }
    notify() {
      if (this.flags |= 16, !(this.flags & 8) && he !== this) return ic(this, !0), !0
    }
    get value() {
      const t = this.dep.track();
      return oc(this), t && (t.version = this.dep.version), this._value
    }
    set value(t) {
      this.setter && this.setter(t)
    }
  }

  function Rv(e, t, n = !1) {
    let i, r;
    return J(e) ? i = e : (i = e.get, r = e.set), new jv(i, r, n)
  }
  const es = {},
    ts = new WeakMap;
  let Qn;

  function Fv(e, t = !1, n = Qn) {
    if (n) {
      let i = ts.get(n);
      i || ts.set(n, i = []), i.push(e)
    }
  }

  function Cv(e, t, n = ue) {
    const {
      immediate: i,
      deep: r,
      once: s,
      scheduler: o,
      augmentJob: a,
      call: l
    } = n, u = P => r ? P : Nt(P) || r === !1 || r === 0 ? un(P, 1) : un(P);
    let c, f, d, p, h = !1,
      g = !1;
    if (Re(e) ? (f = () => e.value, h = Nt(e)) : Yi(e) ? (f = () => u(e), h = !0) : G(e) ? (g = !0, h = e.some(P => Yi(P) || Nt(P)), f = () => e.map(P => {
        if (Re(P)) return P.value;
        if (Yi(P)) return u(P);
        if (J(P)) return l ? l(P, 2) : P()
      })) : J(e) ? t ? f = l ? () => l(e, 2) : e : f = () => {
        if (d) {
          Mt();
          try {
            d()
          } finally {
            It()
          }
        }
        const P = Qn;
        Qn = c;
        try {
          return l ? l(e, 3, [p]) : e(p)
        } finally {
          Qn = P
        }
      } : f = Et, t && r) {
      const P = f,
        O = r === !0 ? 1 / 0 : r;
      f = () => un(P(), O)
    }
    const A = uv(),
      m = () => {
        c.stop(), A && A.active && co(A.effects, c)
      };
    if (s && t) {
      const P = t;
      t = (...O) => {
        P(...O), m()
      }
    }
    let x = g ? new Array(e.length).fill(es) : es;
    const T = P => {
      if (!(!(c.flags & 1) || !c.dirty && !P))
        if (t) {
          const O = c.run();
          if (r || h || (g ? O.some((N, V) => Dn(N, x[V])) : Dn(O, x))) {
            d && d();
            const N = Qn;
            Qn = c;
            try {
              const V = [O, x === es ? void 0 : g && x[0] === es ? [] : x, p];
              x = O, l ? l(t, 3, V) : t(...V)
            } finally {
              Qn = N
            }
          }
        } else c.run()
    };
    return a && a(T), c = new tc(f), c.scheduler = o ? () => o(T, !1) : T, p = P => Fv(P, !1, c), d = c.onStop = () => {
      const P = ts.get(c);
      if (P) {
        if (l) l(P, 4);
        else
          for (const O of P) O();
        ts.delete(c)
      }
    }, t ? i ? T(!0) : x = c.run() : o ? o(T.bind(null, !0), !0) : c.run(), m.pause = c.pause.bind(c), m.resume = c.resume.bind(c), m.stop = m, m
  }

  function un(e, t = 1 / 0, n) {
    if (t <= 0 || !ye(e) || e.__v_skip || (n = n || new Set, n.has(e))) return e;
    if (n.add(e), t--, Re(e)) un(e.value, t, n);
    else if (G(e))
      for (let i = 0; i < e.length; i++) un(e[i], t, n);
    else if (Ul(e) || yi(e)) e.forEach(i => {
      un(i, t, n)
    });
    else if (Kl(e)) {
      for (const i in e) un(e[i], t, n);
      for (const i of Object.getOwnPropertySymbols(e)) Object.prototype.propertyIsEnumerable.call(e, i) && un(e[i], t, n)
    }
    return e
  }
  /**
   * @vue/runtime-core v3.5.16
   * (c) 2018-present Yuxi (Evan) You and Vue contributors
   * @license MIT
   **/
  const Qi = [];
  let Do = !1;

  function GL(e, ...t) {
    if (Do) return;
    Do = !0, Mt();
    const n = Qi.length ? Qi[Qi.length - 1].component : null,
      i = n && n.appContext.config.warnHandler,
      r = Wv();
    if (i) Ai(i, n, 11, [e + t.map(s => {
      var o, a;
      return (a = (o = s.toString) == null ? void 0 : o.call(s)) != null ? a : JSON.stringify(s)
    }).join(""), n && n.proxy, r.map(({
      vnode: s
    }) => `at <${Ou(n,s.type)}>`).join(`
`), r]);
    else {
      const s = [`[Vue warn]: ${e}`, ...t];
      r.length && s.push(`
`, ...Hv(r)), console.warn(...s)
    }
    It(), Do = !1
  }

  function Wv() {
    let e = Qi[Qi.length - 1];
    if (!e) return [];
    const t = [];
    for (; e;) {
      const n = t[0];
      n && n.vnode === e ? n.recurseCount++ : t.push({
        vnode: e,
        recurseCount: 0
      });
      const i = e.component && e.component.parent;
      e = i && i.vnode
    }
    return t
  }

  function Hv(e) {
    const t = [];
    return e.forEach((n, i) => {
      t.push(...i === 0 ? [] : [`
`], ...kv(n))
    }), t
  }

  function kv({
    vnode: e,
    recurseCount: t
  }) {
    const n = t > 0 ? `... (${t} recursive calls)` : "",
      i = e.component ? e.component.parent == null : !1,
      r = ` at <${Ou(e.component,e.type,i)}`,
      s = ">" + n;
    return e.props ? [r, ...Ev(e.props), s] : [r + s]
  }

  function Ev(e) {
    const t = [],
      n = Object.keys(e);
    return n.slice(0, 3).forEach(i => {
      t.push(...wc(i, e[i]))
    }), n.length > 3 && t.push(" ..."), t
  }

  function wc(e, t, n) {
    return Pe(t) ? (t = JSON.stringify(t), n ? t : [`${e}=${t}`]) : typeof t == "number" || typeof t == "boolean" || t == null ? n ? t : [`${e}=${t}`] : Re(t) ? (t = wc(e, ie(t.value), !0), n ? t : [`${e}=Ref<`, t, ">"]) : J(t) ? [`${e}=fn${t.name?`<${t.name}>`:""}`] : (t = ie(t), n ? t : [`${e}=`, t])
  }

  function Ai(e, t, n, i) {
    try {
      return i ? e(...i) : e()
    } catch (r) {
      _i(r, t, n)
    }
  }

  function jt(e, t, n, i) {
    if (J(e)) {
      const r = Ai(e, t, n, i);
      return r && Bl(r) && r.catch(s => {
        _i(s, t, n)
      }), r
    }
    if (G(e)) {
      const r = [];
      for (let s = 0; s < e.length; s++) r.push(jt(e[s], t, n, i));
      return r
    }
  }

  function _i(e, t, n, i = !0) {
    const r = t ? t.vnode : null,
      {
        errorHandler: s,
        throwUnhandledErrorInProduction: o
      } = t && t.appContext.config || ue;
    if (t) {
      let a = t.parent;
      const l = t.proxy,
        u = `https://vuejs.org/error-reference/#runtime-${n}`;
      for (; a;) {
        const c = a.ec;
        if (c) {
          for (let f = 0; f < c.length; f++)
            if (c[f](e, l, u) === !1) return
        }
        a = a.parent
      }
      if (s) {
        Mt(), Ai(s, null, 10, [e, l, u]), It();
        return
      }
    }
    Mv(e, n, r, i, o)
  }

  function Mv(e, t, n, i = !0, r = !1) {
    if (r) throw e;
    console.error(e)
  }
  const Ye = [];
  let qt = -1;
  const Pi = [];
  let Vn = null,
    wi = 0;
  const xc = Promise.resolve();
  let ns = null;

  function Vo(e) {
    const t = ns || xc;
    return e ? t.then(this ? e.bind(this) : e) : t
  }

  function Iv(e) {
    let t = qt + 1,
      n = Ye.length;
    for (; t < n;) {
      const i = t + n >>> 1,
        r = Ye[i],
        s = $i(r);
      s < e || s === e && r.flags & 2 ? t = i + 1 : n = i
    }
    return t
  }

  function No(e) {
    if (!(e.flags & 1)) {
      const t = $i(e),
        n = Ye[Ye.length - 1];
      !n || !(e.flags & 2) && t >= $i(n) ? Ye.push(e) : Ye.splice(Iv(t), 0, e), e.flags |= 1, Tc()
    }
  }

  function Tc() {
    ns || (ns = xc.then(Oc))
  }

  function qv(e) {
    G(e) ? Pi.push(...e) : Vn && e.id === -1 ? Vn.splice(wi + 1, 0, e) : e.flags & 1 || (Pi.push(e), e.flags |= 1), Tc()
  }

  function Lc(e, t, n = qt + 1) {
    for (; n < Ye.length; n++) {
      const i = Ye[n];
      if (i && i.flags & 2) {
        if (e && i.id !== e.uid) continue;
        Ye.splice(n, 1), n--, i.flags & 4 && (i.flags &= -2), i(), i.flags & 4 || (i.flags &= -2)
      }
    }
  }

  function Sc(e) {
    if (Pi.length) {
      const t = [...new Set(Pi)].sort((n, i) => $i(n) - $i(i));
      if (Pi.length = 0, Vn) {
        Vn.push(...t);
        return
      }
      for (Vn = t, wi = 0; wi < Vn.length; wi++) {
        const n = Vn[wi];
        n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2
      }
      Vn = null, wi = 0
    }
  }
  const $i = e => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id;

  function Oc(e) {
    try {
      for (qt = 0; qt < Ye.length; qt++) {
        const t = Ye[qt];
        t && !(t.flags & 8) && (t.flags & 4 && (t.flags &= -2), Ai(t, t.i, t.i ? 15 : 14), t.flags & 4 || (t.flags &= -2))
      }
    } finally {
      for (; qt < Ye.length; qt++) {
        const t = Ye[qt];
        t && (t.flags &= -2)
      }
      qt = -1, Ye.length = 0, Sc(), ns = null, (Ye.length || Pi.length) && Oc()
    }
  }
  let Fe = null,
    zc = null;

  function is(e) {
    const t = Fe;
    return Fe = e, zc = e && e.type.__scopeId || null, t
  }

  function ve(e, t = Fe, n) {
    if (!t || e._n) return e;
    const i = (...r) => {
      i._d && gu(-1);
      const s = is(t);
      let o;
      try {
        o = e(...r)
      } finally {
        is(s), i._d && gu(1)
      }
      return o
    };
    return i._n = !0, i._c = !0, i._d = !0, i
  }

  function Zv(e, t) {
    if (Fe === null) return e;
    const n = ps(Fe),
      i = e.dirs || (e.dirs = []);
    for (let r = 0; r < t.length; r++) {
      let [s, o, a, l = ue] = t[r];
      s && (J(s) && (s = {
        mounted: s,
        updated: s
      }), s.deep && un(o), i.push({
        dir: s,
        instance: n,
        value: o,
        oldValue: void 0,
        arg: a,
        modifiers: l
      }))
    }
    return e
  }

  function _n(e, t, n, i) {
    const r = e.dirs,
      s = t && t.dirs;
    for (let o = 0; o < r.length; o++) {
      const a = r[o];
      s && (a.oldValue = s[o].value);
      let l = a.dir[i];
      l && (Mt(), jt(l, n, 8, [e.el, a, e, t]), It())
    }
  }
  const Uv = Symbol("_vte"),
    Xc = e => e.__isTeleport,
    Nn = Symbol("_leaveCb"),
    rs = Symbol("_enterCb");

  function Bv() {
    const e = {
      isMounted: !1,
      isLeaving: !1,
      isUnmounting: !1,
      leavingVNodes: new Map
    };
    return Zt(() => {
      e.isMounted = !0
    }), as(() => {
      e.isUnmounting = !0
    }), e
  }
  const At = [Function, Array],
    Dc = {
      mode: String,
      appear: Boolean,
      persisted: Boolean,
      onBeforeEnter: At,
      onEnter: At,
      onAfterEnter: At,
      onEnterCancelled: At,
      onBeforeLeave: At,
      onLeave: At,
      onAfterLeave: At,
      onLeaveCancelled: At,
      onBeforeAppear: At,
      onAppear: At,
      onAfterAppear: At,
      onAppearCancelled: At
    },
    Vc = e => {
      const t = e.subTree;
      return t.component ? Vc(t.component) : t
    },
    Gv = {
      name: "BaseTransition",
      props: Dc,
      setup(e, {
        slots: t
      }) {
        const n = ni(),
          i = Bv();
        return () => {
          const r = t.default && Fc(t.default(), !0);
          if (!r || !r.length) return;
          const s = Nc(r),
            o = ie(e),
            {
              mode: a
            } = o;
          if (i.isLeaving) return Ro(s);
          const l = Rc(s);
          if (!l) return Ro(s);
          let u = jo(l, o, i, n, f => u = f);
          l.type !== Ee && er(l, u);
          let c = n.subTree && Rc(n.subTree);
          if (c && c.type !== Ee && !ti(l, c) && Vc(n).type !== Ee) {
            let f = jo(c, o, i, n);
            if (er(c, f), a === "out-in" && l.type !== Ee) return i.isLeaving = !0, f.afterLeave = () => {
              i.isLeaving = !1, n.job.flags & 8 || n.update(), delete f.afterLeave, c = void 0
            }, Ro(s);
            a === "in-out" && l.type !== Ee ? f.delayLeave = (d, p, h) => {
              const g = jc(i, c);
              g[String(c.key)] = c, d[Nn] = () => {
                p(), d[Nn] = void 0, delete u.delayedLeave, c = void 0
              }, u.delayedLeave = () => {
                h(), delete u.delayedLeave, c = void 0
              }
            } : c = void 0
          } else c && (c = void 0);
          return s
        }
      }
    };

  function Nc(e) {
    let t = e[0];
    if (e.length > 1) {
      for (const n of e)
        if (n.type !== Ee) {
          t = n;
          break
        }
    }
    return t
  }
  const Kv = Gv;

  function jc(e, t) {
    const {
      leavingVNodes: n
    } = e;
    let i = n.get(t.type);
    return i || (i = Object.create(null), n.set(t.type, i)), i
  }

  function jo(e, t, n, i, r) {
    const {
      appear: s,
      mode: o,
      persisted: a = !1,
      onBeforeEnter: l,
      onEnter: u,
      onAfterEnter: c,
      onEnterCancelled: f,
      onBeforeLeave: d,
      onLeave: p,
      onAfterLeave: h,
      onLeaveCancelled: g,
      onBeforeAppear: A,
      onAppear: m,
      onAfterAppear: x,
      onAppearCancelled: T
    } = t, P = String(e.key), O = jc(n, e), N = (C, I) => {
      C && jt(C, i, 9, I)
    }, V = (C, I) => {
      const U = I[1];
      N(C, I), G(C) ? C.every(j => j.length <= 1) && U() : C.length <= 1 && U()
    }, R = {
      mode: o,
      persisted: a,
      beforeEnter(C) {
        let I = l;
        if (!n.isMounted)
          if (s) I = A || l;
          else return;
        C[Nn] && C[Nn](!0);
        const U = O[P];
        U && ti(e, U) && U.el[Nn] && U.el[Nn](), N(I, [C])
      },
      enter(C) {
        let I = u,
          U = c,
          j = f;
        if (!n.isMounted)
          if (s) I = m || u, U = x || c, j = T || f;
          else return;
        let Z = !1;
        const se = C[rs] = Ve => {
          Z || (Z = !0, Ve ? N(j, [C]) : N(U, [C]), R.delayedLeave && R.delayedLeave(), C[rs] = void 0)
        };
        I ? V(I, [C, se]) : se()
      },
      leave(C, I) {
        const U = String(e.key);
        if (C[rs] && C[rs](!0), n.isUnmounting) return I();
        N(d, [C]);
        let j = !1;
        const Z = C[Nn] = se => {
          j || (j = !0, I(), se ? N(g, [C]) : N(h, [C]), C[Nn] = void 0, O[U] === e && delete O[U])
        };
        O[U] = e, p ? V(p, [C, Z]) : Z()
      },
      clone(C) {
        const I = jo(C, t, n, i, r);
        return r && r(I), I
      }
    };
    return R
  }

  function Ro(e) {
    if (nr(e)) return e = pn(e), e.children = null, e
  }

  function Rc(e) {
    if (!nr(e)) return Xc(e.type) && e.children ? Nc(e.children) : e;
    if (e.component) return e.component.subTree;
    const {
      shapeFlag: t,
      children: n
    } = e;
    if (n) {
      if (t & 16) return n[0];
      if (t & 32 && J(n.default)) return n.default()
    }
  }

  function er(e, t) {
    e.shapeFlag & 6 && e.component ? (e.transition = t, er(e.component.subTree, t)) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t
  }

  function Fc(e, t = !1, n) {
    let i = [],
      r = 0;
    for (let s = 0; s < e.length; s++) {
      let o = e[s];
      const a = n == null ? o.key : String(n) + String(o.key != null ? o.key : s);
      o.type === We ? (o.patchFlag & 128 && r++, i = i.concat(Fc(o.children, t, a))) : (t || o.type !== Ee) && i.push(a != null ? pn(o, {
        key: a
      }) : o)
    }
    if (r > 1)
      for (let s = 0; s < i.length; s++) i[s].patchFlag = -2;
    return i
  } /*! #__NO_SIDE_EFFECTS__ */
  function Ce(e, t) {
    return J(e) ? Ne({
      name: e.name
    }, t, {
      setup: e
    }) : e
  }

  function Fo(e) {
    e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0]
  }

  function Jv(e) {
    const t = ni(),
      n = bc(null);
    if (t) {
      const r = t.refs === ue ? t.refs = {} : t.refs;
      Object.defineProperty(r, e, {
        enumerable: !0,
        get: () => n.value,
        set: s => n.value = s
      })
    }
    return n
  }

  function ss(e, t, n, i, r = !1) {
    if (G(e)) {
      e.forEach((h, g) => ss(h, t && (G(t) ? t[g] : t), n, i, r));
      return
    }
    if (xi(i) && !r) {
      i.shapeFlag & 512 && i.type.__asyncResolved && i.component.subTree.component && ss(e, t, n, i.component.subTree);
      return
    }
    const s = i.shapeFlag & 4 ? ps(i.component) : i.el,
      o = r ? null : s,
      {
        i: a,
        r: l
      } = e,
      u = t && t.r,
      c = a.refs === ue ? a.refs = {} : a.refs,
      f = a.setupState,
      d = ie(f),
      p = f === ue ? () => !1 : h => oe(d, h);
    if (u != null && u !== l && (Pe(u) ? (c[u] = null, p(u) && (f[u] = null)) : Re(u) && (u.value = null)), J(l)) Ai(l, a, 12, [o, c]);
    else {
      const h = Pe(l),
        g = Re(l);
      if (h || g) {
        const A = () => {
          if (e.f) {
            const m = h ? p(l) ? f[l] : c[l] : l.value;
            r ? G(m) && co(m, s) : G(m) ? m.includes(s) || m.push(s) : h ? (c[l] = [s], p(l) && (f[l] = c[l])) : (l.value = [s], e.k && (c[e.k] = l.value))
          } else h ? (c[l] = o, p(l) && (f[l] = o)) : g && (l.value = o, e.k && (c[e.k] = o))
        };
        o ? (A.id = -1, ht(A, n)) : A()
      }
    }
  }
  const Cc = e => e.nodeType === 8;
  Jr().requestIdleCallback, Jr().cancelIdleCallback;

  function Yv(e, t) {
    if (Cc(e) && e.data === "[") {
      let n = 1,
        i = e.nextSibling;
      for (; i;) {
        if (i.nodeType === 1) {
          if (t(i) === !1) break
        } else if (Cc(i))
          if (i.data === "]") {
            if (--n === 0) break
          } else i.data === "[" && n++;
        i = i.nextSibling
      }
    } else t(e)
  }
  const xi = e => !!e.type.__asyncLoader; /*! #__NO_SIDE_EFFECTS__ */
  function tr(e) {
    J(e) && (e = {
      loader: e
    });
    const {
      loader: t,
      loadingComponent: n,
      errorComponent: i,
      delay: r = 200,
      hydrate: s,
      timeout: o,
      suspensible: a = !0,
      onError: l
    } = e;
    let u = null,
      c, f = 0;
    const d = () => (f++, u = null, p()),
      p = () => {
        let h;
        return u || (h = u = t().catch(g => {
          if (g = g instanceof Error ? g : new Error(String(g)), l) return new Promise((A, m) => {
            l(g, () => A(d()), () => m(g), f + 1)
          });
          throw g
        }).then(g => h !== u && u ? u : (g && (g.__esModule || g[Symbol.toStringTag] === "Module") && (g = g.default), c = g, g)))
      };
    return Ce({
      name: "AsyncComponentWrapper",
      __asyncLoader: p,
      __asyncHydrate(h, g, A) {
        const m = s ? () => {
          const T = s(() => {
            A()
          }, P => Yv(h, P));
          T && (g.bum || (g.bum = [])).push(T), (g.u || (g.u = [])).push(() => !0)
        } : A;
        c ? m() : p().then(() => !g.isUnmounted && m())
      },
      get __asyncResolved() {
        return c
      },
      setup() {
        const h = He;
        if (Fo(h), c) return () => Co(c, h);
        const g = T => {
          u = null, _i(T, h, 13, !i)
        };
        if (a && h.suspense || Li) return p().then(T => () => Co(T, h)).catch(T => (g(T), () => i ? ne(i, {
          error: T
        }) : null));
        const A = te(!1),
          m = te(),
          x = te(!!r);
        return r && setTimeout(() => {
          x.value = !1
        }, r), o != null && setTimeout(() => {
          if (!A.value && !m.value) {
            const T = new Error(`Async component timed out after ${o}ms.`);
            g(T), m.value = T
          }
        }, o), p().then(() => {
          A.value = !0, h.parent && nr(h.parent.vnode) && h.parent.update()
        }).catch(T => {
          g(T), m.value = T
        }), () => {
          if (A.value && c) return Co(c, h);
          if (m.value && i) return ne(i, {
            error: m.value
          });
          if (n && !x.value) return ne(n)
        }
      }
    })
  }

  function Co(e, t) {
    const {
      ref: n,
      props: i,
      children: r,
      ce: s
    } = t.vnode, o = ne(e, i, r);
    return o.ref = n, o.ce = s, delete t.vnode.ce, o
  }
  const nr = e => e.type.__isKeepAlive;

  function Qv(e, t) {
    Wc(e, "a", t)
  }

  function _v(e, t) {
    Wc(e, "da", t)
  }

  function Wc(e, t, n = He) {
    const i = e.__wdc || (e.__wdc = () => {
      let r = n;
      for (; r;) {
        if (r.isDeactivated) return;
        r = r.parent
      }
      return e()
    });
    if (os(t, i, n), n) {
      let r = n.parent;
      for (; r && r.parent;) nr(r.parent.vnode) && $v(i, t, n, r), r = r.parent
    }
  }

  function $v(e, t, n, i) {
    const r = os(t, e, i, !0);
    $n(() => {
      co(i[t], r)
    }, n)
  }

  function os(e, t, n = He, i = !1) {
    if (n) {
      const r = n[e] || (n[e] = []),
        s = t.__weh || (t.__weh = (...o) => {
          Mt();
          const a = cr(n),
            l = jt(t, n, e, o);
          return a(), It(), l
        });
      return i ? r.unshift(s) : r.push(s), s
    }
  }
  const fn = e => (t, n = He) => {
      (!Li || e === "sp") && os(e, (...i) => t(...i), n)
    },
    Hc = fn("bm"),
    Zt = fn("m"),
    kc = fn("bu"),
    Ec = fn("u"),
    as = fn("bum"),
    $n = fn("um"),
    eg = fn("sp"),
    tg = fn("rtg"),
    ng = fn("rtc");

  function ig(e, t = He) {
    os("ec", e, t)
  }
  const rg = "components",
    Mc = Symbol.for("v-ndc");

  function sg(e) {
    return Pe(e) ? og(rg, e, !1) || e : e || Mc
  }

  function og(e, t, n = !0, i = !1) {
    const r = Fe || He;
    if (r) {
      const s = r.type;
      {
        const a = Su(s, !1);
        if (a && (a === t || a === yt(t) || a === Kr(yt(t)))) return s
      }
      const o = Ic(r[e] || s[e], t) || Ic(r.appContext[e], t);
      return !o && i ? s : o
    }
  }

  function Ic(e, t) {
    return e && (e[t] || e[yt(t)] || e[Kr(yt(t))])
  }

  function ls(e, t) {
    for (let n = 0; n < t.length; n++) {
      const i = t[n];
      if (G(i))
        for (let r = 0; r < i.length; r++) e[i[r].name] = i[r].fn;
      else i && (e[i.name] = i.key ? (...r) => {
        const s = i.fn(...r);
        return s && (s.key = i.key), s
      } : i.fn)
    }
    return e
  }

  function Wo(e, t, n = {}, i, r) {
    if (Fe.ce || Fe.parent && xi(Fe.parent) && Fe.parent.ce) return t !== "default" && (n.name = t), ae(), rt(We, null, [ne("slot", n, i)], 64);
    let s = e[t];
    s && s._c && (s._d = !1), ae();
    const o = s && qc(s(n)),
      a = n.key || o && o.key,
      l = rt(We, {
        key: (a && !on(a) ? a : `_${t}`) + ""
      }, o || [], o && e._ === 1 ? 64 : -2);
    return s && s._c && (s._d = !0), l
  }

  function qc(e) {
    return e.some(t => lr(t) ? !(t.type === Ee || t.type === We && !qc(t.children)) : !0) ? e : null
  }
  const Ho = e => e ? wu(e) ? ps(e) : Ho(e.parent) : null,
    ir = Ne(Object.create(null), {
      $: e => e,
      $el: e => e.vnode.el,
      $data: e => e.data,
      $props: e => e.props,
      $attrs: e => e.attrs,
      $slots: e => e.slots,
      $refs: e => e.refs,
      $parent: e => Ho(e.parent),
      $root: e => Ho(e.root),
      $host: e => e.ce,
      $emit: e => e.emit,
      $options: e => Kc(e),
      $forceUpdate: e => e.f || (e.f = () => {
        No(e.update)
      }),
      $nextTick: e => e.n || (e.n = Vo.bind(e.proxy)),
      $watch: e => Xg.bind(e)
    }),
    ko = (e, t) => e !== ue && !e.__isScriptSetup && oe(e, t),
    ag = {
      get({
        _: e
      }, t) {
        if (t === "__v_skip") return !0;
        const {
          ctx: n,
          setupState: i,
          data: r,
          props: s,
          accessCache: o,
          type: a,
          appContext: l
        } = e;
        let u;
        if (t[0] !== "$") {
          const p = o[t];
          if (p !== void 0) switch (p) {
            case 1:
              return i[t];
            case 2:
              return r[t];
            case 4:
              return n[t];
            case 3:
              return s[t]
          } else {
            if (ko(i, t)) return o[t] = 1, i[t];
            if (r !== ue && oe(r, t)) return o[t] = 2, r[t];
            if ((u = e.propsOptions[0]) && oe(u, t)) return o[t] = 3, s[t];
            if (n !== ue && oe(n, t)) return o[t] = 4, n[t];
            Eo && (o[t] = 0)
          }
        }
        const c = ir[t];
        let f, d;
        if (c) return t === "$attrs" && Ze(e.attrs, "get", ""), c(e);
        if ((f = a.__cssModules) && (f = f[t])) return f;
        if (n !== ue && oe(n, t)) return o[t] = 4, n[t];
        if (d = l.config.globalProperties, oe(d, t)) return d[t]
      },
      set({
        _: e
      }, t, n) {
        const {
          data: i,
          setupState: r,
          ctx: s
        } = e;
        return ko(r, t) ? (r[t] = n, !0) : i !== ue && oe(i, t) ? (i[t] = n, !0) : oe(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (s[t] = n, !0)
      },
      has({
        _: {
          data: e,
          setupState: t,
          accessCache: n,
          ctx: i,
          appContext: r,
          propsOptions: s
        }
      }, o) {
        let a;
        return !!n[o] || e !== ue && oe(e, o) || ko(t, o) || (a = s[0]) && oe(a, o) || oe(i, o) || oe(ir, o) || oe(r.config.globalProperties, o)
      },
      defineProperty(e, t, n) {
        return n.get != null ? e._.accessCache[t] = 0 : oe(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n)
      }
    };

  function lg() {
    return Zc().slots
  }

  function cg() {
    return Zc().attrs
  }

  function Zc() {
    const e = ni();
    return e.setupContext || (e.setupContext = Lu(e))
  }

  function Uc(e) {
    return G(e) ? e.reduce((t, n) => (t[n] = null, t), {}) : e
  }
  let Eo = !0;

  function ug(e) {
    const t = Kc(e),
      n = e.proxy,
      i = e.ctx;
    Eo = !1, t.beforeCreate && Bc(t.beforeCreate, e, "bc");
    const {
      data: r,
      computed: s,
      methods: o,
      watch: a,
      provide: l,
      inject: u,
      created: c,
      beforeMount: f,
      mounted: d,
      beforeUpdate: p,
      updated: h,
      activated: g,
      deactivated: A,
      beforeDestroy: m,
      beforeUnmount: x,
      destroyed: T,
      unmounted: P,
      render: O,
      renderTracked: N,
      renderTriggered: V,
      errorCaptured: R,
      serverPrefetch: C,
      expose: I,
      inheritAttrs: U,
      components: j,
      directives: Z,
      filters: se
    } = t;
    if (u && fg(u, i, null), o)
      for (const _ in o) {
        const Q = o[_];
        J(Q) && (i[_] = Q.bind(n))
      }
    if (r) {
      const _ = r.call(n, n);
      ye(_) && (e.data = Oo(_))
    }
    if (Eo = !0, s)
      for (const _ in s) {
        const Q = s[_],
          ze = J(Q) ? Q.bind(n, n) : J(Q.get) ? Q.get.bind(n, n) : Et,
          zt = !J(Q) && J(Q.set) ? Q.set.bind(n) : Et,
          nt = le({
            get: ze,
            set: zt
          });
        Object.defineProperty(i, _, {
          enumerable: !0,
          configurable: !0,
          get: () => nt.value,
          set: qe => nt.value = qe
        })
      }
    if (a)
      for (const _ in a) Gc(a[_], i, n, _);
    if (l) {
      const _ = J(l) ? l.call(n) : l;
      Reflect.ownKeys(_).forEach(Q => {
        _c(Q, _[Q])
      })
    }
    c && Bc(c, e, "c");

    function pe(_, Q) {
      G(Q) ? Q.forEach(ze => _(ze.bind(n))) : Q && _(Q.bind(n))
    }
    if (pe(Hc, f), pe(Zt, d), pe(kc, p), pe(Ec, h), pe(Qv, g), pe(_v, A), pe(ig, R), pe(ng, N), pe(tg, V), pe(as, x), pe($n, P), pe(eg, C), G(I))
      if (I.length) {
        const _ = e.exposed || (e.exposed = {});
        I.forEach(Q => {
          Object.defineProperty(_, Q, {
            get: () => n[Q],
            set: ze => n[Q] = ze
          })
        })
      } else e.exposed || (e.exposed = {});
    O && e.render === Et && (e.render = O), U != null && (e.inheritAttrs = U), j && (e.components = j), Z && (e.directives = Z), C && Fo(e)
  }

  function fg(e, t, n = Et) {
    G(e) && (e = Mo(e));
    for (const i in e) {
      const r = e[i];
      let s;
      ye(r) ? "default" in r ? s = jn(r.from || i, r.default, !0) : s = jn(r.from || i) : s = jn(r), Re(s) ? Object.defineProperty(t, i, {
        enumerable: !0,
        configurable: !0,
        get: () => s.value,
        set: o => s.value = o
      }) : t[i] = s
    }
  }

  function Bc(e, t, n) {
    jt(G(e) ? e.map(i => i.bind(t.proxy)) : e.bind(t.proxy), t, n)
  }

  function Gc(e, t, n, i) {
    let r = i.includes(".") ? du(n, i) : () => n[i];
    if (Pe(e)) {
      const s = t[e];
      J(s) && dn(r, s)
    } else if (J(e)) dn(r, e.bind(n));
    else if (ye(e))
      if (G(e)) e.forEach(s => Gc(s, t, n, i));
      else {
        const s = J(e.handler) ? e.handler.bind(n) : t[e.handler];
        J(s) && dn(r, s, e)
      }
  }

  function Kc(e) {
    const t = e.type,
      {
        mixins: n,
        extends: i
      } = t,
      {
        mixins: r,
        optionsCache: s,
        config: {
          optionMergeStrategies: o
        }
      } = e.appContext,
      a = s.get(t);
    let l;
    return a ? l = a : !r.length && !n && !i ? l = t : (l = {}, r.length && r.forEach(u => cs(l, u, o, !0)), cs(l, t, o)), ye(t) && s.set(t, l), l
  }

  function cs(e, t, n, i = !1) {
    const {
      mixins: r,
      extends: s
    } = t;
    s && cs(e, s, n, !0), r && r.forEach(o => cs(e, o, n, !0));
    for (const o in t)
      if (!(i && o === "expose")) {
        const a = dg[o] || n && n[o];
        e[o] = a ? a(e[o], t[o]) : t[o]
      } return e
  }
  const dg = {
    data: Jc,
    props: Yc,
    emits: Yc,
    methods: rr,
    computed: rr,
    beforeCreate: Qe,
    created: Qe,
    beforeMount: Qe,
    mounted: Qe,
    beforeUpdate: Qe,
    updated: Qe,
    beforeDestroy: Qe,
    beforeUnmount: Qe,
    destroyed: Qe,
    unmounted: Qe,
    activated: Qe,
    deactivated: Qe,
    errorCaptured: Qe,
    serverPrefetch: Qe,
    components: rr,
    directives: rr,
    watch: hg,
    provide: Jc,
    inject: pg
  };

  function Jc(e, t) {
    return t ? e ? function() {
      return Ne(J(e) ? e.call(this, this) : e, J(t) ? t.call(this, this) : t)
    } : t : e
  }

  function pg(e, t) {
    return rr(Mo(e), Mo(t))
  }

  function Mo(e) {
    if (G(e)) {
      const t = {};
      for (let n = 0; n < e.length; n++) t[e[n]] = e[n];
      return t
    }
    return e
  }

  function Qe(e, t) {
    return e ? [...new Set([].concat(e, t))] : t
  }

  function rr(e, t) {
    return e ? Ne(Object.create(null), e, t) : t
  }

  function Yc(e, t) {
    return e ? G(e) && G(t) ? [...new Set([...e, ...t])] : Ne(Object.create(null), Uc(e), Uc(t ?? {})) : t
  }

  function hg(e, t) {
    if (!e) return t;
    if (!t) return e;
    const n = Ne(Object.create(null), e);
    for (const i in t) n[i] = Qe(e[i], t[i]);
    return n
  }

  function Qc() {
    return {
      app: null,
      config: {
        isNativeTag: Qm,
        performance: !1,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: Object.create(null),
      optionsCache: new WeakMap,
      propsCache: new WeakMap,
      emitsCache: new WeakMap
    }
  }
  let mg = 0;

  function vg(e, t) {
    return function(i, r = null) {
      J(i) || (i = Ne({}, i)), r != null && !ye(r) && (r = null);
      const s = Qc(),
        o = new WeakSet,
        a = [];
      let l = !1;
      const u = s.app = {
        _uid: mg++,
        _component: i,
        _props: r,
        _container: null,
        _context: s,
        _instance: null,
        version: Yg,
        get config() {
          return s.config
        },
        set config(c) {},
        use(c, ...f) {
          return o.has(c) || (c && J(c.install) ? (o.add(c), c.install(u, ...f)) : J(c) && (o.add(c), c(u, ...f))), u
        },
        mixin(c) {
          return s.mixins.includes(c) || s.mixins.push(c), u
        },
        component(c, f) {
          return f ? (s.components[c] = f, u) : s.components[c]
        },
        directive(c, f) {
          return f ? (s.directives[c] = f, u) : s.directives[c]
        },
        mount(c, f, d) {
          if (!l) {
            const p = u._ceVNode || ne(i, r);
            return p.appContext = s, d === !0 ? d = "svg" : d === !1 && (d = void 0), e(p, c, d), l = !0, u._container = c, c.__vue_app__ = u, ps(p.component)
          }
        },
        onUnmount(c) {
          a.push(c)
        },
        unmount() {
          l && (jt(a, u._instance, 16), e(null, u._container), delete u._container.__vue_app__)
        },
        provide(c, f) {
          return s.provides[c] = f, u
        },
        runWithContext(c) {
          const f = Ti;
          Ti = u;
          try {
            return c()
          } finally {
            Ti = f
          }
        }
      };
      return u
    }
  }
  let Ti = null;

  function _c(e, t) {
    if (He) {
      let n = He.provides;
      const i = He.parent && He.parent.provides;
      i === n && (n = He.provides = Object.create(i)), n[e] = t
    }
  }

  function jn(e, t, n = !1) {
    const i = He || Fe;
    if (i || Ti) {
      let r = Ti ? Ti._context.provides : i ? i.parent == null || i.ce ? i.vnode.appContext && i.vnode.appContext.provides : i.parent.provides : void 0;
      if (r && e in r) return r[e];
      if (arguments.length > 1) return n && J(t) ? t.call(i && i.proxy) : t
    }
  }
  const $c = {},
    eu = () => Object.create($c),
    tu = e => Object.getPrototypeOf(e) === $c;

  function gg(e, t, n, i = !1) {
    const r = {},
      s = eu();
    e.propsDefaults = Object.create(null), nu(e, t, r, s);
    for (const o in e.propsOptions[0]) o in r || (r[o] = void 0);
    n ? e.props = i ? r : Xv(r) : e.type.props ? e.props = r : e.props = s, e.attrs = s
  }

  function yg(e, t, n, i) {
    const {
      props: r,
      attrs: s,
      vnode: {
        patchFlag: o
      }
    } = e, a = ie(r), [l] = e.propsOptions;
    let u = !1;
    if ((i || o > 0) && !(o & 16)) {
      if (o & 8) {
        const c = e.vnode.dynamicProps;
        for (let f = 0; f < c.length; f++) {
          let d = c[f];
          if (us(e.emitsOptions, d)) continue;
          const p = t[d];
          if (l)
            if (oe(s, d)) p !== s[d] && (s[d] = p, u = !0);
            else {
              const h = yt(d);
              r[h] = Io(l, a, h, p, e, !1)
            }
          else p !== s[d] && (s[d] = p, u = !0)
        }
      }
    } else {
      nu(e, t, r, s) && (u = !0);
      let c;
      for (const f in a)(!t || !oe(t, f) && ((c = Kn(f)) === f || !oe(t, c))) && (l ? n && (n[f] !== void 0 || n[c] !== void 0) && (r[f] = Io(l, a, f, void 0, e, !0)) : delete r[f]);
      if (s !== a)
        for (const f in s)(!t || !oe(t, f)) && (delete s[f], u = !0)
    }
    u && an(e.attrs, "set", "")
  }

  function nu(e, t, n, i) {
    const [r, s] = e.propsOptions;
    let o = !1,
      a;
    if (t)
      for (let l in t) {
        if (qi(l)) continue;
        const u = t[l];
        let c;
        r && oe(r, c = yt(l)) ? !s || !s.includes(c) ? n[c] = u : (a || (a = {}))[c] = u : us(e.emitsOptions, l) || (!(l in i) || u !== i[l]) && (i[l] = u, o = !0)
      }
    if (s) {
      const l = ie(n),
        u = a || ue;
      for (let c = 0; c < s.length; c++) {
        const f = s[c];
        n[f] = Io(r, l, f, u[f], e, !oe(u, f))
      }
    }
    return o
  }

  function Io(e, t, n, i, r, s) {
    const o = e[n];
    if (o != null) {
      const a = oe(o, "default");
      if (a && i === void 0) {
        const l = o.default;
        if (o.type !== Function && !o.skipFactory && J(l)) {
          const {
            propsDefaults: u
          } = r;
          if (n in u) i = u[n];
          else {
            const c = cr(r);
            i = u[n] = l.call(null, t), c()
          }
        } else i = l;
        r.ce && r.ce._setProp(n, i)
      }
      o[0] && (s && !a ? i = !1 : o[1] && (i === "" || i === Kn(n)) && (i = !0))
    }
    return i
  }
  const bg = new WeakMap;

  function iu(e, t, n = !1) {
    const i = n ? bg : t.propsCache,
      r = i.get(e);
    if (r) return r;
    const s = e.props,
      o = {},
      a = [];
    let l = !1;
    if (!J(e)) {
      const c = f => {
        l = !0;
        const [d, p] = iu(f, t, !0);
        Ne(o, d), p && a.push(...p)
      };
      !n && t.mixins.length && t.mixins.forEach(c), e.extends && c(e.extends), e.mixins && e.mixins.forEach(c)
    }
    if (!s && !l) return ye(e) && i.set(e, gi), gi;
    if (G(s))
      for (let c = 0; c < s.length; c++) {
        const f = yt(s[c]);
        ru(f) && (o[f] = ue)
      } else if (s)
        for (const c in s) {
          const f = yt(c);
          if (ru(f)) {
            const d = s[c],
              p = o[f] = G(d) || J(d) ? {
                type: d
              } : Ne({}, d),
              h = p.type;
            let g = !1,
              A = !0;
            if (G(h))
              for (let m = 0; m < h.length; ++m) {
                const x = h[m],
                  T = J(x) && x.name;
                if (T === "Boolean") {
                  g = !0;
                  break
                } else T === "String" && (A = !1)
              } else g = J(h) && h.name === "Boolean";
            p[0] = g, p[1] = A, (g || oe(p, "default")) && a.push(f)
          }
        }
    const u = [o, a];
    return ye(e) && i.set(e, u), u
  }

  function ru(e) {
    return e[0] !== "$" && !qi(e)
  }
  const qo = e => e[0] === "_" || e === "$stable",
    Zo = e => G(e) ? e.map(Ut) : [Ut(e)],
    Ag = (e, t, n) => {
      if (t._n) return t;
      const i = ve((...r) => Zo(t(...r)), n);
      return i._c = !1, i
    },
    su = (e, t, n) => {
      const i = e._ctx;
      for (const r in e) {
        if (qo(r)) continue;
        const s = e[r];
        if (J(s)) t[r] = Ag(r, s, i);
        else if (s != null) {
          const o = Zo(s);
          t[r] = () => o
        }
      }
    },
    ou = (e, t) => {
      const n = Zo(t);
      e.slots.default = () => n
    },
    au = (e, t, n) => {
      for (const i in t)(n || !qo(i)) && (e[i] = t[i])
    },
    Pg = (e, t, n) => {
      const i = e.slots = eu();
      if (e.vnode.shapeFlag & 32) {
        const r = t._;
        r ? (au(i, t, n), n && Jl(i, "_", r, !0)) : su(t, i)
      } else t && ou(e, t)
    },
    wg = (e, t, n) => {
      const {
        vnode: i,
        slots: r
      } = e;
      let s = !0,
        o = ue;
      if (i.shapeFlag & 32) {
        const a = t._;
        a ? n && a === 1 ? s = !1 : au(r, t, n) : (s = !t.$stable, su(t, r)), o = t
      } else t && (ou(e, t), o = {
        default: 1
      });
      if (s)
        for (const a in r) !qo(a) && o[a] == null && delete r[a]
    },
    ht = Cg;

  function xg(e) {
    return Tg(e)
  }

  function Tg(e, t) {
    const n = Jr();
    n.__VUE__ = !0;
    const {
      insert: i,
      remove: r,
      patchProp: s,
      createElement: o,
      createText: a,
      createComment: l,
      setText: u,
      setElementText: c,
      parentNode: f,
      nextSibling: d,
      setScopeId: p = Et,
      insertStaticContent: h
    } = e, g = (b, w, D, H = null, W = null, k = null, v = void 0, y = null, S = !!w.dynamicChildren) => {
      if (b === w) return;
      b && !ti(b, w) && (H = vt(b), qe(b, W, k, !0), b = null), w.patchFlag === -2 && (S = !1, w.dynamicChildren = null);
      const {
        type: z,
        ref: M,
        shapeFlag: F
      } = w;
      switch (z) {
        case sr:
          A(b, w, D, H);
          break;
        case Ee:
          m(b, w, D, H);
          break;
        case Bo:
          b == null && x(w, D, H, v);
          break;
        case We:
          j(b, w, D, H, W, k, v, y, S);
          break;
        default:
          F & 1 ? O(b, w, D, H, W, k, v, y, S) : F & 6 ? Z(b, w, D, H, W, k, v, y, S) : (F & 64 || F & 128) && z.process(b, w, D, H, W, k, v, y, S, Xn)
      }
      M != null && W && ss(M, b && b.ref, k, w || b, !w)
    }, A = (b, w, D, H) => {
      if (b == null) i(w.el = a(w.children), D, H);
      else {
        const W = w.el = b.el;
        w.children !== b.children && u(W, w.children)
      }
    }, m = (b, w, D, H) => {
      b == null ? i(w.el = l(w.children || ""), D, H) : w.el = b.el
    }, x = (b, w, D, H) => {
      [b.el, b.anchor] = h(b.children, w, D, H, b.el, b.anchor)
    }, T = ({
      el: b,
      anchor: w
    }, D, H) => {
      let W;
      for (; b && b !== w;) W = d(b), i(b, D, H), b = W;
      i(w, D, H)
    }, P = ({
      el: b,
      anchor: w
    }) => {
      let D;
      for (; b && b !== w;) D = d(b), r(b), b = D;
      r(w)
    }, O = (b, w, D, H, W, k, v, y, S) => {
      w.type === "svg" ? v = "svg" : w.type === "math" && (v = "mathml"), b == null ? N(w, D, H, W, k, v, y, S) : C(b, w, W, k, v, y, S)
    }, N = (b, w, D, H, W, k, v, y) => {
      let S, z;
      const {
        props: M,
        shapeFlag: F,
        transition: L,
        dirs: X
      } = b;
      if (S = b.el = o(b.type, k, M && M.is, M), F & 8 ? c(S, b.children) : F & 16 && R(b.children, S, null, H, W, Uo(b, k), v, y), X && _n(b, null, H, "created"), V(S, b, b.scopeId, v, H), M) {
        for (const K in M) K !== "value" && !qi(K) && s(S, K, null, M[K], k, H);
        "value" in M && s(S, "value", null, M.value, k), (z = M.onVnodeBeforeMount) && Bt(z, H, b)
      }
      X && _n(b, null, H, "beforeMount");
      const q = Lg(W, L);
      q && L.beforeEnter(S), i(S, w, D), ((z = M && M.onVnodeMounted) || q || X) && ht(() => {
        z && Bt(z, H, b), q && L.enter(S), X && _n(b, null, H, "mounted")
      }, W)
    }, V = (b, w, D, H, W) => {
      if (D && p(b, D), H)
        for (let k = 0; k < H.length; k++) p(b, H[k]);
      if (W) {
        let k = W.subTree;
        if (w === k || vu(k.type) && (k.ssContent === w || k.ssFallback === w)) {
          const v = W.vnode;
          V(b, v, v.scopeId, v.slotScopeIds, W.parent)
        }
      }
    }, R = (b, w, D, H, W, k, v, y, S = 0) => {
      for (let z = S; z < b.length; z++) {
        const M = b[z] = y ? Rn(b[z]) : Ut(b[z]);
        g(null, M, w, D, H, W, k, v, y)
      }
    }, C = (b, w, D, H, W, k, v) => {
      const y = w.el = b.el;
      let {
        patchFlag: S,
        dynamicChildren: z,
        dirs: M
      } = w;
      S |= b.patchFlag & 16;
      const F = b.props || ue,
        L = w.props || ue;
      let X;
      if (D && ei(D, !1), (X = L.onVnodeBeforeUpdate) && Bt(X, D, w, b), M && _n(w, b, D, "beforeUpdate"), D && ei(D, !0), (F.innerHTML && L.innerHTML == null || F.textContent && L.textContent == null) && c(y, ""), z ? I(b.dynamicChildren, z, y, D, H, Uo(w, W), k) : v || Q(b, w, y, null, D, H, Uo(w, W), k, !1), S > 0) {
        if (S & 16) U(y, F, L, D, W);
        else if (S & 2 && F.class !== L.class && s(y, "class", null, L.class, W), S & 4 && s(y, "style", F.style, L.style, W), S & 8) {
          const q = w.dynamicProps;
          for (let K = 0; K < q.length; K++) {
            const $ = q[K],
              ke = F[$],
              Te = L[$];
            (Te !== ke || $ === "value") && s(y, $, ke, Te, W, D)
          }
        }
        S & 1 && b.children !== w.children && c(y, w.children)
      } else !v && z == null && U(y, F, L, D, W);
      ((X = L.onVnodeUpdated) || M) && ht(() => {
        X && Bt(X, D, w, b), M && _n(w, b, D, "updated")
      }, H)
    }, I = (b, w, D, H, W, k, v) => {
      for (let y = 0; y < w.length; y++) {
        const S = b[y],
          z = w[y],
          M = S.el && (S.type === We || !ti(S, z) || S.shapeFlag & 198) ? f(S.el) : D;
        g(S, z, M, null, H, W, k, v, !0)
      }
    }, U = (b, w, D, H, W) => {
      if (w !== D) {
        if (w !== ue)
          for (const k in w) !qi(k) && !(k in D) && s(b, k, w[k], null, W, H);
        for (const k in D) {
          if (qi(k)) continue;
          const v = D[k],
            y = w[k];
          v !== y && k !== "value" && s(b, k, y, v, W, H)
        }
        "value" in D && s(b, "value", w.value, D.value, W)
      }
    }, j = (b, w, D, H, W, k, v, y, S) => {
      const z = w.el = b ? b.el : a(""),
        M = w.anchor = b ? b.anchor : a("");
      let {
        patchFlag: F,
        dynamicChildren: L,
        slotScopeIds: X
      } = w;
      X && (y = y ? y.concat(X) : X), b == null ? (i(z, D, H), i(M, D, H), R(w.children || [], D, M, W, k, v, y, S)) : F > 0 && F & 64 && L && b.dynamicChildren ? (I(b.dynamicChildren, L, D, W, k, v, y), (w.key != null || W && w === W.subTree) && lu(b, w, !0)) : Q(b, w, D, M, W, k, v, y, S)
    }, Z = (b, w, D, H, W, k, v, y, S) => {
      w.slotScopeIds = y, b == null ? w.shapeFlag & 512 ? W.ctx.activate(w, D, H, v, S) : se(w, D, H, W, k, v, S) : Ve(b, w, S)
    }, se = (b, w, D, H, W, k, v) => {
      const y = b.component = qg(b, H, W);
      if (nr(b) && (y.ctx.renderer = Xn), Zg(y, !1, v), y.asyncDep) {
        if (W && W.registerDep(y, pe, v), !b.el) {
          const S = y.subTree = ne(Ee);
          m(null, S, w, D)
        }
      } else pe(y, b, w, D, W, k, v)
    }, Ve = (b, w, D) => {
      const H = w.component = b.component;
      if (Rg(b, w, D))
        if (H.asyncDep && !H.asyncResolved) {
          _(H, w, D);
          return
        } else H.next = w, H.update();
      else w.el = b.el, H.vnode = w
    }, pe = (b, w, D, H, W, k, v) => {
      const y = () => {
        if (b.isMounted) {
          let {
            next: F,
            bu: L,
            u: X,
            parent: q,
            vnode: K
          } = b;
          {
            const kt = cu(b);
            if (kt) {
              F && (F.el = K.el, _(b, F, v)), kt.asyncDep.then(() => {
                b.isUnmounted || y()
              });
              return
            }
          }
          let $ = F,
            ke;
          ei(b, !1), F ? (F.el = K.el, _(b, F, v)) : F = K, L && po(L), (ke = F.props && F.props.onVnodeBeforeUpdate) && Bt(ke, q, F, K), ei(b, !0);
          const Te = hu(b),
            Dt = b.subTree;
          b.subTree = Te, g(Dt, Te, f(Dt.el), vt(Dt), b, W, k), F.el = Te.el, $ === null && Fg(b, Te.el), X && ht(X, W), (ke = F.props && F.props.onVnodeUpdated) && ht(() => Bt(ke, q, F, K), W)
        } else {
          let F;
          const {
            el: L,
            props: X
          } = w, {
            bm: q,
            m: K,
            parent: $,
            root: ke,
            type: Te
          } = b, Dt = xi(w);
          ei(b, !1), q && po(q), !Dt && (F = X && X.onVnodeBeforeMount) && Bt(F, $, w), ei(b, !0);
          {
            ke.ce && ke.ce._injectChildStyle(Te);
            const kt = b.subTree = hu(b);
            g(null, kt, D, H, b, W, k), w.el = kt.el
          }
          if (K && ht(K, W), !Dt && (F = X && X.onVnodeMounted)) {
            const kt = w;
            ht(() => Bt(F, $, kt), W)
          }(w.shapeFlag & 256 || $ && xi($.vnode) && $.vnode.shapeFlag & 256) && b.a && ht(b.a, W), b.isMounted = !0, w = D = H = null
        }
      };
      b.scope.on();
      const S = b.effect = new tc(y);
      b.scope.off();
      const z = b.update = S.run.bind(S),
        M = b.job = S.runIfDirty.bind(S);
      M.i = b, M.id = b.uid, S.scheduler = () => No(M), ei(b, !0), z()
    }, _ = (b, w, D) => {
      w.component = b;
      const H = b.vnode.props;
      b.vnode = w, b.next = null, yg(b, w.props, H, D), wg(b, w.children, D), Mt(), Lc(b), It()
    }, Q = (b, w, D, H, W, k, v, y, S = !1) => {
      const z = b && b.children,
        M = b ? b.shapeFlag : 0,
        F = w.children,
        {
          patchFlag: L,
          shapeFlag: X
        } = w;
      if (L > 0) {
        if (L & 128) {
          zt(z, F, D, H, W, k, v, y, S);
          return
        } else if (L & 256) {
          ze(z, F, D, H, W, k, v, y, S);
          return
        }
      }
      X & 8 ? (M & 16 && dt(z, W, k), F !== z && c(D, F)) : M & 16 ? X & 16 ? zt(z, F, D, H, W, k, v, y, S) : dt(z, W, k, !0) : (M & 8 && c(D, ""), X & 16 && R(F, D, H, W, k, v, y, S))
    }, ze = (b, w, D, H, W, k, v, y, S) => {
      b = b || gi, w = w || gi;
      const z = b.length,
        M = w.length,
        F = Math.min(z, M);
      let L;
      for (L = 0; L < F; L++) {
        const X = w[L] = S ? Rn(w[L]) : Ut(w[L]);
        g(b[L], X, D, null, W, k, v, y, S)
      }
      z > M ? dt(b, W, k, !0, !1, F) : R(w, D, H, W, k, v, y, S, F)
    }, zt = (b, w, D, H, W, k, v, y, S) => {
      let z = 0;
      const M = w.length;
      let F = b.length - 1,
        L = M - 1;
      for (; z <= F && z <= L;) {
        const X = b[z],
          q = w[z] = S ? Rn(w[z]) : Ut(w[z]);
        if (ti(X, q)) g(X, q, D, null, W, k, v, y, S);
        else break;
        z++
      }
      for (; z <= F && z <= L;) {
        const X = b[F],
          q = w[L] = S ? Rn(w[L]) : Ut(w[L]);
        if (ti(X, q)) g(X, q, D, null, W, k, v, y, S);
        else break;
        F--, L--
      }
      if (z > F) {
        if (z <= L) {
          const X = L + 1,
            q = X < M ? w[X].el : H;
          for (; z <= L;) g(null, w[z] = S ? Rn(w[z]) : Ut(w[z]), D, q, W, k, v, y, S), z++
        }
      } else if (z > L)
        for (; z <= F;) qe(b[z], W, k, !0), z++;
      else {
        const X = z,
          q = z,
          K = new Map;
        for (z = q; z <= L; z++) {
          const gt = w[z] = S ? Rn(w[z]) : Ut(w[z]);
          gt.key != null && K.set(gt.key, z)
        }
        let $, ke = 0;
        const Te = L - q + 1;
        let Dt = !1,
          kt = 0;
        const Zr = new Array(Te);
        for (z = 0; z < Te; z++) Zr[z] = 0;
        for (z = X; z <= F; z++) {
          const gt = b[z];
          if (ke >= Te) {
            qe(gt, W, k, !0);
            continue
          }
          let sn;
          if (gt.key != null) sn = K.get(gt.key);
          else
            for ($ = q; $ <= L; $++)
              if (Zr[$ - q] === 0 && ti(gt, w[$])) {
                sn = $;
                break
              } sn === void 0 ? qe(gt, W, k, !0) : (Zr[sn - q] = z + 1, sn >= kt ? kt = sn : Dt = !0, g(gt, w[sn], D, null, W, k, v, y, S), ke++)
        }
        const Jm = Dt ? Sg(Zr) : gi;
        for ($ = Jm.length - 1, z = Te - 1; z >= 0; z--) {
          const gt = q + z,
            sn = w[gt],
            Ym = gt + 1 < M ? w[gt + 1].el : H;
          Zr[z] === 0 ? g(null, sn, D, Ym, W, k, v, y, S) : Dt && ($ < 0 || z !== Jm[$] ? nt(sn, D, Ym, 2) : $--)
        }
      }
    }, nt = (b, w, D, H, W = null) => {
      const {
        el: k,
        type: v,
        transition: y,
        children: S,
        shapeFlag: z
      } = b;
      if (z & 6) {
        nt(b.component.subTree, w, D, H);
        return
      }
      if (z & 128) {
        b.suspense.move(w, D, H);
        return
      }
      if (z & 64) {
        v.move(b, w, D, Xn);
        return
      }
      if (v === We) {
        i(k, w, D);
        for (let F = 0; F < S.length; F++) nt(S[F], w, D, H);
        i(b.anchor, w, D);
        return
      }
      if (v === Bo) {
        T(b, w, D);
        return
      }
      if (H !== 2 && z & 1 && y)
        if (H === 0) y.beforeEnter(k), i(k, w, D), ht(() => y.enter(k), W);
        else {
          const {
            leave: F,
            delayLeave: L,
            afterLeave: X
          } = y, q = () => {
            b.ctx.isUnmounted ? r(k) : i(k, w, D)
          }, K = () => {
            F(k, () => {
              q(), X && X()
            })
          };
          L ? L(k, q, K) : K()
        }
      else i(k, w, D)
    }, qe = (b, w, D, H = !1, W = !1) => {
      const {
        type: k,
        props: v,
        ref: y,
        children: S,
        dynamicChildren: z,
        shapeFlag: M,
        patchFlag: F,
        dirs: L,
        cacheIndex: X
      } = b;
      if (F === -2 && (W = !1), y != null && (Mt(), ss(y, null, D, b, !0), It()), X != null && (w.renderCache[X] = void 0), M & 256) {
        w.ctx.deactivate(b);
        return
      }
      const q = M & 1 && L,
        K = !xi(b);
      let $;
      if (K && ($ = v && v.onVnodeBeforeUnmount) && Bt($, w, b), M & 6) rn(b.component, D, H);
      else {
        if (M & 128) {
          b.suspense.unmount(D, H);
          return
        }
        q && _n(b, null, w, "beforeUnmount"), M & 64 ? b.type.remove(b, w, D, Xn, H) : z && !z.hasOnce && (k !== We || F > 0 && F & 64) ? dt(z, w, D, !1, !0) : (k === We && F & 384 || !W && M & 16) && dt(S, w, D), H && zn(b)
      }(K && ($ = v && v.onVnodeUnmounted) || q) && ht(() => {
        $ && Bt($, w, b), q && _n(b, null, w, "unmounted")
      }, D)
    }, zn = b => {
      const {
        type: w,
        el: D,
        anchor: H,
        transition: W
      } = b;
      if (w === We) {
        Gn(D, H);
        return
      }
      if (w === Bo) {
        P(b);
        return
      }
      const k = () => {
        r(D), W && !W.persisted && W.afterLeave && W.afterLeave()
      };
      if (b.shapeFlag & 1 && W && !W.persisted) {
        const {
          leave: v,
          delayLeave: y
        } = W, S = () => v(D, k);
        y ? y(b.el, k, S) : S()
      } else k()
    }, Gn = (b, w) => {
      let D;
      for (; b !== w;) D = d(b), r(b), b = D;
      r(w)
    }, rn = (b, w, D) => {
      const {
        bum: H,
        scope: W,
        job: k,
        subTree: v,
        um: y,
        m: S,
        a: z,
        parent: M,
        slots: {
          __: F
        }
      } = b;
      uu(S), uu(z), H && po(H), M && G(F) && F.forEach(L => {
        M.renderCache[L] = void 0
      }), W.stop(), k && (k.flags |= 8, qe(v, b, w, D)), y && ht(y, w), ht(() => {
        b.isUnmounted = !0
      }, w), w && w.pendingBranch && !w.isUnmounted && b.asyncDep && !b.asyncResolved && b.suspenseId === w.pendingId && (w.deps--, w.deps === 0 && w.resolve())
    }, dt = (b, w, D, H = !1, W = !1, k = 0) => {
      for (let v = k; v < b.length; v++) qe(b[v], w, D, H, W)
    }, vt = b => {
      if (b.shapeFlag & 6) return vt(b.component.subTree);
      if (b.shapeFlag & 128) return b.suspense.next();
      const w = d(b.anchor || b.el),
        D = w && w[Uv];
      return D ? d(D) : w
    };
    let pt = !1;
    const Xt = (b, w, D) => {
        b == null ? w._vnode && qe(w._vnode, null, null, !0) : g(w._vnode || null, b, w, null, null, null, D), w._vnode = b, pt || (pt = !0, Lc(), Sc(), pt = !1)
      },
      Xn = {
        p: g,
        um: qe,
        m: nt,
        r: zn,
        mt: se,
        mc: R,
        pc: Q,
        pbc: I,
        n: vt,
        o: e
      };
    return {
      render: Xt,
      hydrate: void 0,
      createApp: vg(Xt)
    }
  }

  function Uo({
    type: e,
    props: t
  }, n) {
    return n === "svg" && e === "foreignObject" || n === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : n
  }

  function ei({
    effect: e,
    job: t
  }, n) {
    n ? (e.flags |= 32, t.flags |= 4) : (e.flags &= -33, t.flags &= -5)
  }

  function Lg(e, t) {
    return (!e || e && !e.pendingBranch) && t && !t.persisted
  }

  function lu(e, t, n = !1) {
    const i = e.children,
      r = t.children;
    if (G(i) && G(r))
      for (let s = 0; s < i.length; s++) {
        const o = i[s];
        let a = r[s];
        a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = r[s] = Rn(r[s]), a.el = o.el), !n && a.patchFlag !== -2 && lu(o, a)), a.type === sr && (a.el = o.el), a.type === Ee && !a.el && (a.el = o.el)
      }
  }

  function Sg(e) {
    const t = e.slice(),
      n = [0];
    let i, r, s, o, a;
    const l = e.length;
    for (i = 0; i < l; i++) {
      const u = e[i];
      if (u !== 0) {
        if (r = n[n.length - 1], e[r] < u) {
          t[i] = r, n.push(i);
          continue
        }
        for (s = 0, o = n.length - 1; s < o;) a = s + o >> 1, e[n[a]] < u ? s = a + 1 : o = a;
        u < e[n[s]] && (s > 0 && (t[i] = n[s - 1]), n[s] = i)
      }
    }
    for (s = n.length, o = n[s - 1]; s-- > 0;) n[s] = o, o = t[o];
    return n
  }

  function cu(e) {
    const t = e.subTree.component;
    if (t) return t.asyncDep && !t.asyncResolved ? t : cu(t)
  }

  function uu(e) {
    if (e)
      for (let t = 0; t < e.length; t++) e[t].flags |= 8
  }
  const Og = Symbol.for("v-scx"),
    zg = () => jn(Og);

  function dn(e, t, n) {
    return fu(e, t, n)
  }

  function fu(e, t, n = ue) {
    const {
      immediate: i,
      deep: r,
      flush: s,
      once: o
    } = n, a = Ne({}, n), l = t && i || !t && s !== "post";
    let u;
    if (Li) {
      if (s === "sync") {
        const p = zg();
        u = p.__watcherHandles || (p.__watcherHandles = [])
      } else if (!l) {
        const p = () => {};
        return p.stop = Et, p.resume = Et, p.pause = Et, p
      }
    }
    const c = He;
    a.call = (p, h, g) => jt(p, c, h, g);
    let f = !1;
    s === "post" ? a.scheduler = p => {
      ht(p, c && c.suspense)
    } : s !== "sync" && (f = !0, a.scheduler = (p, h) => {
      h ? p() : No(p)
    }), a.augmentJob = p => {
      t && (p.flags |= 4), f && (p.flags |= 2, c && (p.id = c.uid, p.i = c))
    };
    const d = Cv(e, t, a);
    return Li && (u ? u.push(d) : l && d()), d
  }

  function Xg(e, t, n) {
    const i = this.proxy,
      r = Pe(e) ? e.includes(".") ? du(i, e) : () => i[e] : e.bind(i, i);
    let s;
    J(t) ? s = t : (s = t.handler, n = t);
    const o = cr(this),
      a = fu(r, s.bind(i), n);
    return o(), a
  }

  function du(e, t) {
    const n = t.split(".");
    return () => {
      let i = e;
      for (let r = 0; r < n.length && i; r++) i = i[n[r]];
      return i
    }
  }
  const Dg = (e, t) => t === "modelValue" || t === "model-value" ? e.modelModifiers : e[`${t}Modifiers`] || e[`${yt(t)}Modifiers`] || e[`${Kn(t)}Modifiers`];

  function Vg(e, t, ...n) {
    if (e.isUnmounted) return;
    const i = e.vnode.props || ue;
    let r = n;
    const s = t.startsWith("update:"),
      o = s && Dg(i, t.slice(7));
    o && (o.trim && (r = n.map(c => Pe(c) ? c.trim() : c)), o.number && (r = n.map(nv)));
    let a, l = i[a = fo(t)] || i[a = fo(yt(t))];
    !l && s && (l = i[a = fo(Kn(t))]), l && jt(l, e, 6, r);
    const u = i[a + "Once"];
    if (u) {
      if (!e.emitted) e.emitted = {};
      else if (e.emitted[a]) return;
      e.emitted[a] = !0, jt(u, e, 6, r)
    }
  }

  function pu(e, t, n = !1) {
    const i = t.emitsCache,
      r = i.get(e);
    if (r !== void 0) return r;
    const s = e.emits;
    let o = {},
      a = !1;
    if (!J(e)) {
      const l = u => {
        const c = pu(u, t, !0);
        c && (a = !0, Ne(o, c))
      };
      !n && t.mixins.length && t.mixins.forEach(l), e.extends && l(e.extends), e.mixins && e.mixins.forEach(l)
    }
    return !s && !a ? (ye(e) && i.set(e, null), null) : (G(s) ? s.forEach(l => o[l] = null) : Ne(o, s), ye(e) && i.set(e, o), o)
  }

  function us(e, t) {
    return !e || !Ur(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), oe(e, t[0].toLowerCase() + t.slice(1)) || oe(e, Kn(t)) || oe(e, t))
  }

  function KL() {}

  function hu(e) {
    const {
      type: t,
      vnode: n,
      proxy: i,
      withProxy: r,
      propsOptions: [s],
      slots: o,
      attrs: a,
      emit: l,
      render: u,
      renderCache: c,
      props: f,
      data: d,
      setupState: p,
      ctx: h,
      inheritAttrs: g
    } = e, A = is(e);
    let m, x;
    try {
      if (n.shapeFlag & 4) {
        const P = r || i,
          O = P;
        m = Ut(u.call(O, P, c, f, p, d, h)), x = a
      } else {
        const P = t;
        m = Ut(P.length > 1 ? P(f, {
          attrs: a,
          slots: o,
          emit: l
        }) : P(f, null)), x = t.props ? a : Ng(a)
      }
    } catch (P) {
      or.length = 0, _i(P, e, 1), m = ne(Ee)
    }
    let T = m;
    if (x && g !== !1) {
      const P = Object.keys(x),
        {
          shapeFlag: O
        } = T;
      P.length && O & 7 && (s && P.some(lo) && (x = jg(x, s)), T = pn(T, x, !1, !0))
    }
    return n.dirs && (T = pn(T, null, !1, !0), T.dirs = T.dirs ? T.dirs.concat(n.dirs) : n.dirs), n.transition && er(T, n.transition), m = T, is(A), m
  }
  const Ng = e => {
      let t;
      for (const n in e)(n === "class" || n === "style" || Ur(n)) && ((t || (t = {}))[n] = e[n]);
      return t
    },
    jg = (e, t) => {
      const n = {};
      for (const i in e)(!lo(i) || !(i.slice(9) in t)) && (n[i] = e[i]);
      return n
    };

  function Rg(e, t, n) {
    const {
      props: i,
      children: r,
      component: s
    } = e, {
      props: o,
      children: a,
      patchFlag: l
    } = t, u = s.emitsOptions;
    if (t.dirs || t.transition) return !0;
    if (n && l >= 0) {
      if (l & 1024) return !0;
      if (l & 16) return i ? mu(i, o, u) : !!o;
      if (l & 8) {
        const c = t.dynamicProps;
        for (let f = 0; f < c.length; f++) {
          const d = c[f];
          if (o[d] !== i[d] && !us(u, d)) return !0
        }
      }
    } else return (r || a) && (!a || !a.$stable) ? !0 : i === o ? !1 : i ? o ? mu(i, o, u) : !0 : !!o;
    return !1
  }

  function mu(e, t, n) {
    const i = Object.keys(t);
    if (i.length !== Object.keys(e).length) return !0;
    for (let r = 0; r < i.length; r++) {
      const s = i[r];
      if (t[s] !== e[s] && !us(n, s)) return !0
    }
    return !1
  }

  function Fg({
    vnode: e,
    parent: t
  }, n) {
    for (; t;) {
      const i = t.subTree;
      if (i.suspense && i.suspense.activeBranch === e && (i.el = e.el), i === e)(e = t.vnode).el = n, t = t.parent;
      else break
    }
  }
  const vu = e => e.__isSuspense;

  function Cg(e, t) {
    t && t.pendingBranch ? G(e) ? t.effects.push(...e) : t.effects.push(e) : qv(e)
  }
  const We = Symbol.for("v-fgt"),
    sr = Symbol.for("v-txt"),
    Ee = Symbol.for("v-cmt"),
    Bo = Symbol.for("v-stc"),
    or = [];
  let mt = null;

  function ae(e = !1) {
    or.push(mt = e ? null : [])
  }

  function Wg() {
    or.pop(), mt = or[or.length - 1] || null
  }
  let ar = 1;

  function gu(e, t = !1) {
    ar += e, e < 0 && mt && t && (mt.hasOnce = !0)
  }

  function yu(e) {
    return e.dynamicChildren = ar > 0 ? mt || gi : null, Wg(), ar > 0 && mt && mt.push(e), e
  }

  function Ue(e, t, n, i, r, s) {
    return yu(ee(e, t, n, i, r, s, !0))
  }

  function rt(e, t, n, i, r) {
    return yu(ne(e, t, n, i, r, !0))
  }

  function lr(e) {
    return e ? e.__v_isVNode === !0 : !1
  }

  function ti(e, t) {
    return e.type === t.type && e.key === t.key
  }
  const bu = ({
      key: e
    }) => e ?? null,
    fs = ({
      ref: e,
      ref_key: t,
      ref_for: n
    }) => (typeof e == "number" && (e = "" + e), e != null ? Pe(e) || Re(e) || J(e) ? {
      i: Fe,
      r: e,
      k: t,
      f: !!n
    } : e : null);

  function ee(e, t = null, n = null, i = 0, r = null, s = e === We ? 0 : 1, o = !1, a = !1) {
    const l = {
      __v_isVNode: !0,
      __v_skip: !0,
      type: e,
      props: t,
      key: t && bu(t),
      ref: t && fs(t),
      scopeId: zc,
      slotScopeIds: null,
      children: n,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetStart: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag: s,
      patchFlag: i,
      dynamicProps: r,
      dynamicChildren: null,
      appContext: null,
      ctx: Fe
    };
    return a ? (Go(l, n), s & 128 && e.normalize(l)) : n && (l.shapeFlag |= Pe(n) ? 8 : 16), ar > 0 && !o && mt && (l.patchFlag > 0 || s & 6) && l.patchFlag !== 32 && mt.push(l), l
  }
  const ne = Hg;

  function Hg(e, t = null, n = null, i = 0, r = null, s = !1) {
    if ((!e || e === Mc) && (e = Ee), lr(e)) {
      const a = pn(e, t, !0);
      return n && Go(a, n), ar > 0 && !s && mt && (a.shapeFlag & 6 ? mt[mt.indexOf(e)] = a : mt.push(a)), a.patchFlag = -2, a
    }
    if (Jg(e) && (e = e.__vccOpts), t) {
      t = kg(t);
      let {
        class: a,
        style: l
      } = t;
      a && !Pe(a) && (t.class = Zi(a)), ye(l) && (zo(l) && !G(l) && (l = Ne({}, l)), t.style = bt(l))
    }
    const o = Pe(e) ? 1 : vu(e) ? 128 : Xc(e) ? 64 : ye(e) ? 4 : J(e) ? 2 : 0;
    return ee(e, t, n, i, r, o, s, !0)
  }

  function kg(e) {
    return e ? zo(e) || tu(e) ? Ne({}, e) : e : null
  }

  function pn(e, t, n = !1, i = !1) {
    const {
      props: r,
      ref: s,
      patchFlag: o,
      children: a,
      transition: l
    } = e, u = t ? Au(r || {}, t) : r, c = {
      __v_isVNode: !0,
      __v_skip: !0,
      type: e.type,
      props: u,
      key: u && bu(u),
      ref: t && t.ref ? n && s ? G(s) ? s.concat(fs(t)) : [s, fs(t)] : fs(t) : s,
      scopeId: e.scopeId,
      slotScopeIds: e.slotScopeIds,
      children: a,
      target: e.target,
      targetStart: e.targetStart,
      targetAnchor: e.targetAnchor,
      staticCount: e.staticCount,
      shapeFlag: e.shapeFlag,
      patchFlag: t && e.type !== We ? o === -1 ? 16 : o | 16 : o,
      dynamicProps: e.dynamicProps,
      dynamicChildren: e.dynamicChildren,
      appContext: e.appContext,
      dirs: e.dirs,
      transition: l,
      component: e.component,
      suspense: e.suspense,
      ssContent: e.ssContent && pn(e.ssContent),
      ssFallback: e.ssFallback && pn(e.ssFallback),
      el: e.el,
      anchor: e.anchor,
      ctx: e.ctx,
      ce: e.ce
    };
    return l && i && er(c, l.clone(c)), c
  }

  function Eg(e = " ", t = 0) {
    return ne(sr, null, e, t)
  }

  function Rt(e = "", t = !1) {
    return t ? (ae(), rt(Ee, null, e)) : ne(Ee, null, e)
  }

  function Ut(e) {
    return e == null || typeof e == "boolean" ? ne(Ee) : G(e) ? ne(We, null, e.slice()) : lr(e) ? Rn(e) : ne(sr, null, String(e))
  }

  function Rn(e) {
    return e.el === null && e.patchFlag !== -1 || e.memo ? e : pn(e)
  }

  function Go(e, t) {
    let n = 0;
    const {
      shapeFlag: i
    } = e;
    if (t == null) t = null;
    else if (G(t)) n = 16;
    else if (typeof t == "object")
      if (i & 65) {
        const r = t.default;
        r && (r._c && (r._d = !1), Go(e, r()), r._c && (r._d = !0));
        return
      } else {
        n = 32;
        const r = t._;
        !r && !tu(t) ? t._ctx = Fe : r === 3 && Fe && (Fe.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024))
      }
    else J(t) ? (t = {
      default: t,
      _ctx: Fe
    }, n = 32) : (t = String(t), i & 64 ? (n = 16, t = [Eg(t)]) : n = 8);
    e.children = t, e.shapeFlag |= n
  }

  function Au(...e) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
      const i = e[n];
      for (const r in i)
        if (r === "class") t.class !== i.class && (t.class = Zi([t.class, i.class]));
        else if (r === "style") t.style = bt([t.style, i.style]);
      else if (Ur(r)) {
        const s = t[r],
          o = i[r];
        o && s !== o && !(G(s) && s.includes(o)) && (t[r] = s ? [].concat(s, o) : o)
      } else r !== "" && (t[r] = i[r])
    }
    return t
  }

  function Bt(e, t, n, i = null) {
    jt(e, t, 7, [n, i])
  }
  const Mg = Qc();
  let Ig = 0;

  function qg(e, t, n) {
    const i = e.type,
      r = (t ? t.appContext : e.appContext) || Mg,
      s = {
        uid: Ig++,
        vnode: e,
        type: i,
        parent: t,
        appContext: r,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        job: null,
        scope: new ec(!0),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: t ? t.provides : Object.create(r.provides),
        ids: t ? t.ids : ["", 0, 0],
        accessCache: null,
        renderCache: [],
        components: null,
        directives: null,
        propsOptions: iu(i, r),
        emitsOptions: pu(i, r),
        emit: null,
        emitted: null,
        propsDefaults: ue,
        inheritAttrs: i.inheritAttrs,
        ctx: ue,
        data: ue,
        props: ue,
        attrs: ue,
        slots: ue,
        refs: ue,
        setupState: ue,
        setupContext: null,
        suspense: n,
        suspenseId: n ? n.pendingId : 0,
        asyncDep: null,
        asyncResolved: !1,
        isMounted: !1,
        isUnmounted: !1,
        isDeactivated: !1,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
      };
    return s.ctx = {
      _: s
    }, s.root = t ? t.root : s, s.emit = Vg.bind(null, s), e.ce && e.ce(s), s
  }
  let He = null;
  const ni = () => He || Fe;
  let ds, Ko;
  {
    const e = Jr(),
      t = (n, i) => {
        let r;
        return (r = e[n]) || (r = e[n] = []), r.push(i), s => {
          r.length > 1 ? r.forEach(o => o(s)) : r[0](s)
        }
      };
    ds = t("__VUE_INSTANCE_SETTERS__", n => He = n), Ko = t("__VUE_SSR_SETTERS__", n => Li = n)
  }
  const cr = e => {
      const t = He;
      return ds(e), e.scope.on(), () => {
        e.scope.off(), ds(t)
      }
    },
    Pu = () => {
      He && He.scope.off(), ds(null)
    };

  function wu(e) {
    return e.vnode.shapeFlag & 4
  }
  let Li = !1;

  function Zg(e, t = !1, n = !1) {
    t && Ko(t);
    const {
      props: i,
      children: r
    } = e.vnode, s = wu(e);
    gg(e, i, s, t), Pg(e, r, n || t);
    const o = s ? Ug(e, t) : void 0;
    return t && Ko(!1), o
  }

  function Ug(e, t) {
    const n = e.type;
    e.accessCache = Object.create(null), e.proxy = new Proxy(e.ctx, ag);
    const {
      setup: i
    } = n;
    if (i) {
      Mt();
      const r = e.setupContext = i.length > 1 ? Lu(e) : null,
        s = cr(e),
        o = Ai(i, e, 0, [e.props, r]),
        a = Bl(o);
      if (It(), s(), (a || e.sp) && !xi(e) && Fo(e), a) {
        if (o.then(Pu, Pu), t) return o.then(l => {
          xu(e, l)
        }).catch(l => {
          _i(l, e, 0)
        });
        e.asyncDep = o
      } else xu(e, o)
    } else Tu(e)
  }

  function xu(e, t, n) {
    J(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : ye(t) && (e.setupState = Pc(t)), Tu(e)
  }

  function Tu(e, t, n) {
    const i = e.type;
    e.render || (e.render = i.render || Et);
    {
      const r = cr(e);
      Mt();
      try {
        ug(e)
      } finally {
        It(), r()
      }
    }
  }
  const Bg = {
    get(e, t) {
      return Ze(e, "get", ""), e[t]
    }
  };

  function Lu(e) {
    const t = n => {
      e.exposed = n || {}
    };
    return {
      attrs: new Proxy(e.attrs, Bg),
      slots: e.slots,
      emit: e.emit,
      expose: t
    }
  }

  function ps(e) {
    return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(Pc(Dv(e.exposed)), {
      get(t, n) {
        if (n in t) return t[n];
        if (n in ir) return ir[n](e)
      },
      has(t, n) {
        return n in t || n in ir
      }
    })) : e.proxy
  }
  const Gg = /(?:^|[-_])(\w)/g,
    Kg = e => e.replace(Gg, t => t.toUpperCase()).replace(/[-_]/g, "");

  function Su(e, t = !0) {
    return J(e) ? e.displayName || e.name : e.name || t && e.__name
  }

  function Ou(e, t, n = !1) {
    let i = Su(t);
    if (!i && t.__file) {
      const r = t.__file.match(/([^/\\]+)\.\w+$/);
      r && (i = r[1])
    }
    if (!i && e && e.parent) {
      const r = s => {
        for (const o in s)
          if (s[o] === t) return o
      };
      i = r(e.components || e.parent.type.components) || r(e.appContext.components)
    }
    return i ? Kg(i) : n ? "App" : "Anonymous"
  }

  function Jg(e) {
    return J(e) && "__vccOpts" in e
  }
  const le = (e, t) => Rv(e, t, Li);

  function ur(e, t, n) {
    const i = arguments.length;
    return i === 2 ? ye(t) && !G(t) ? lr(t) ? ne(e, null, [t]) : ne(e, t) : ne(e, null, t) : (i > 3 ? n = Array.prototype.slice.call(arguments, 2) : i === 3 && lr(n) && (n = [n]), ne(e, t, n))
  }
  const Yg = "3.5.16";
  /**
   * @vue/runtime-dom v3.5.16
   * (c) 2018-present Yuxi (Evan) You and Vue contributors
   * @license MIT
   **/
  let Jo;
  const zu = typeof window < "u" && window.trustedTypes;
  if (zu) try {
    Jo = zu.createPolicy("vue", {
      createHTML: e => e
    })
  } catch {}
  const Xu = Jo ? e => Jo.createHTML(e) : e => e,
    Qg = "http://www.w3.org/2000/svg",
    _g = "http://www.w3.org/1998/Math/MathML",
    hn = typeof document < "u" ? document : null,
    Du = hn && hn.createElement("template"),
    $g = {
      insert: (e, t, n) => {
        t.insertBefore(e, n || null)
      },
      remove: e => {
        const t = e.parentNode;
        t && t.removeChild(e)
      },
      createElement: (e, t, n, i) => {
        const r = t === "svg" ? hn.createElementNS(Qg, e) : t === "mathml" ? hn.createElementNS(_g, e) : n ? hn.createElement(e, {
          is: n
        }) : hn.createElement(e);
        return e === "select" && i && i.multiple != null && r.setAttribute("multiple", i.multiple), r
      },
      createText: e => hn.createTextNode(e),
      createComment: e => hn.createComment(e),
      setText: (e, t) => {
        e.nodeValue = t
      },
      setElementText: (e, t) => {
        e.textContent = t
      },
      parentNode: e => e.parentNode,
      nextSibling: e => e.nextSibling,
      querySelector: e => hn.querySelector(e),
      setScopeId(e, t) {
        e.setAttribute(t, "")
      },
      insertStaticContent(e, t, n, i, r, s) {
        const o = n ? n.previousSibling : t.lastChild;
        if (r && (r === s || r.nextSibling))
          for (; t.insertBefore(r.cloneNode(!0), n), !(r === s || !(r = r.nextSibling)););
        else {
          Du.innerHTML = Xu(i === "svg" ? `<svg>${e}</svg>` : i === "mathml" ? `<math>${e}</math>` : e);
          const a = Du.content;
          if (i === "svg" || i === "mathml") {
            const l = a.firstChild;
            for (; l.firstChild;) a.appendChild(l.firstChild);
            a.removeChild(l)
          }
          t.insertBefore(a, n)
        }
        return [o ? o.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild]
      }
    },
    Fn = "transition",
    fr = "animation",
    dr = Symbol("_vtc"),
    Vu = {
      name: String,
      type: String,
      css: {
        type: Boolean,
        default: !0
      },
      duration: [String, Number, Object],
      enterFromClass: String,
      enterActiveClass: String,
      enterToClass: String,
      appearFromClass: String,
      appearActiveClass: String,
      appearToClass: String,
      leaveFromClass: String,
      leaveActiveClass: String,
      leaveToClass: String
    },
    ey = Ne({}, Dc, Vu),
    mn = (e => (e.displayName = "Transition", e.props = ey, e))((e, {
      slots: t
    }) => ur(Kv, ty(e), t)),
    ii = (e, t = []) => {
      G(e) ? e.forEach(n => n(...t)) : e && e(...t)
    },
    Nu = e => e ? G(e) ? e.some(t => t.length > 1) : e.length > 1 : !1;

  function ty(e) {
    const t = {};
    for (const j in e) j in Vu || (t[j] = e[j]);
    if (e.css === !1) return t;
    const {
      name: n = "v",
      type: i,
      duration: r,
      enterFromClass: s = `${n}-enter-from`,
      enterActiveClass: o = `${n}-enter-active`,
      enterToClass: a = `${n}-enter-to`,
      appearFromClass: l = s,
      appearActiveClass: u = o,
      appearToClass: c = a,
      leaveFromClass: f = `${n}-leave-from`,
      leaveActiveClass: d = `${n}-leave-active`,
      leaveToClass: p = `${n}-leave-to`
    } = e, h = ny(r), g = h && h[0], A = h && h[1], {
      onBeforeEnter: m,
      onEnter: x,
      onEnterCancelled: T,
      onLeave: P,
      onLeaveCancelled: O,
      onBeforeAppear: N = m,
      onAppear: V = x,
      onAppearCancelled: R = T
    } = t, C = (j, Z, se, Ve) => {
      j._enterCancelled = Ve, ri(j, Z ? c : a), ri(j, Z ? u : o), se && se()
    }, I = (j, Z) => {
      j._isLeaving = !1, ri(j, f), ri(j, p), ri(j, d), Z && Z()
    }, U = j => (Z, se) => {
      const Ve = j ? V : x,
        pe = () => C(Z, j, se);
      ii(Ve, [Z, pe]), ju(() => {
        ri(Z, j ? l : s), vn(Z, j ? c : a), Nu(Ve) || Ru(Z, i, g, pe)
      })
    };
    return Ne(t, {
      onBeforeEnter(j) {
        ii(m, [j]), vn(j, s), vn(j, o)
      },
      onBeforeAppear(j) {
        ii(N, [j]), vn(j, l), vn(j, u)
      },
      onEnter: U(!1),
      onAppear: U(!0),
      onLeave(j, Z) {
        j._isLeaving = !0;
        const se = () => I(j, Z);
        vn(j, f), j._enterCancelled ? (vn(j, d), Wu()) : (Wu(), vn(j, d)), ju(() => {
          j._isLeaving && (ri(j, f), vn(j, p), Nu(P) || Ru(j, i, A, se))
        }), ii(P, [j, se])
      },
      onEnterCancelled(j) {
        C(j, !1, void 0, !0), ii(T, [j])
      },
      onAppearCancelled(j) {
        C(j, !0, void 0, !0), ii(R, [j])
      },
      onLeaveCancelled(j) {
        I(j), ii(O, [j])
      }
    })
  }

  function ny(e) {
    if (e == null) return null;
    if (ye(e)) return [Yo(e.enter), Yo(e.leave)];
    {
      const t = Yo(e);
      return [t, t]
    }
  }

  function Yo(e) {
    return iv(e)
  }

  function vn(e, t) {
    t.split(/\s+/).forEach(n => n && e.classList.add(n)), (e[dr] || (e[dr] = new Set)).add(t)
  }

  function ri(e, t) {
    t.split(/\s+/).forEach(i => i && e.classList.remove(i));
    const n = e[dr];
    n && (n.delete(t), n.size || (e[dr] = void 0))
  }

  function ju(e) {
    requestAnimationFrame(() => {
      requestAnimationFrame(e)
    })
  }
  let iy = 0;

  function Ru(e, t, n, i) {
    const r = e._endId = ++iy,
      s = () => {
        r === e._endId && i()
      };
    if (n != null) return setTimeout(s, n);
    const {
      type: o,
      timeout: a,
      propCount: l
    } = ry(e, t);
    if (!o) return i();
    const u = o + "end";
    let c = 0;
    const f = () => {
        e.removeEventListener(u, d), s()
      },
      d = p => {
        p.target === e && ++c >= l && f()
      };
    setTimeout(() => {
      c < l && f()
    }, a + 1), e.addEventListener(u, d)
  }

  function ry(e, t) {
    const n = window.getComputedStyle(e),
      i = h => (n[h] || "").split(", "),
      r = i(`${Fn}Delay`),
      s = i(`${Fn}Duration`),
      o = Fu(r, s),
      a = i(`${fr}Delay`),
      l = i(`${fr}Duration`),
      u = Fu(a, l);
    let c = null,
      f = 0,
      d = 0;
    t === Fn ? o > 0 && (c = Fn, f = o, d = s.length) : t === fr ? u > 0 && (c = fr, f = u, d = l.length) : (f = Math.max(o, u), c = f > 0 ? o > u ? Fn : fr : null, d = c ? c === Fn ? s.length : l.length : 0);
    const p = c === Fn && /\b(transform|all)(,|$)/.test(i(`${Fn}Property`).toString());
    return {
      type: c,
      timeout: f,
      propCount: d,
      hasTransform: p
    }
  }

  function Fu(e, t) {
    for (; e.length < t.length;) e = e.concat(e);
    return Math.max(...t.map((n, i) => Cu(n) + Cu(e[i])))
  }

  function Cu(e) {
    return e === "auto" ? 0 : Number(e.slice(0, -1).replace(",", ".")) * 1e3
  }

  function Wu() {
    return document.body.offsetHeight
  }

  function sy(e, t, n) {
    const i = e[dr];
    i && (t = (t ? [t, ...i] : [...i]).join(" ")), t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t
  }
  const hs = Symbol("_vod"),
    Hu = Symbol("_vsh"),
    oy = {
      beforeMount(e, {
        value: t
      }, {
        transition: n
      }) {
        e[hs] = e.style.display === "none" ? "" : e.style.display, n && t ? n.beforeEnter(e) : pr(e, t)
      },
      mounted(e, {
        value: t
      }, {
        transition: n
      }) {
        n && t && n.enter(e)
      },
      updated(e, {
        value: t,
        oldValue: n
      }, {
        transition: i
      }) {
        !t != !n && (i ? t ? (i.beforeEnter(e), pr(e, !0), i.enter(e)) : i.leave(e, () => {
          pr(e, !1)
        }) : pr(e, t))
      },
      beforeUnmount(e, {
        value: t
      }) {
        pr(e, t)
      }
    };

  function pr(e, t) {
    e.style.display = t ? e[hs] : "none", e[Hu] = !t
  }
  const ay = Symbol(""),
    ly = /(^|;)\s*display\s*:/;

  function cy(e, t, n) {
    const i = e.style,
      r = Pe(n);
    let s = !1;
    if (n && !r) {
      if (t)
        if (Pe(t))
          for (const o of t.split(";")) {
            const a = o.slice(0, o.indexOf(":")).trim();
            n[a] == null && ms(i, a, "")
          } else
            for (const o in t) n[o] == null && ms(i, o, "");
      for (const o in n) o === "display" && (s = !0), ms(i, o, n[o])
    } else if (r) {
      if (t !== n) {
        const o = i[ay];
        o && (n += ";" + o), i.cssText = n, s = ly.test(n)
      }
    } else t && e.removeAttribute("style");
    hs in e && (e[hs] = s ? i.display : "", e[Hu] && (i.display = "none"))
  }
  const ku = /\s*!important$/;

  function ms(e, t, n) {
    if (G(n)) n.forEach(i => ms(e, t, i));
    else if (n == null && (n = ""), t.startsWith("--")) e.setProperty(t, n);
    else {
      const i = uy(e, t);
      ku.test(n) ? e.setProperty(Kn(i), n.replace(ku, ""), "important") : e[i] = n
    }
  }
  const Eu = ["Webkit", "Moz", "ms"],
    Qo = {};

  function uy(e, t) {
    const n = Qo[t];
    if (n) return n;
    let i = yt(t);
    if (i !== "filter" && i in e) return Qo[t] = i;
    i = Kr(i);
    for (let r = 0; r < Eu.length; r++) {
      const s = Eu[r] + i;
      if (s in e) return Qo[t] = s
    }
    return t
  }
  const Mu = "http://www.w3.org/1999/xlink";

  function Iu(e, t, n, i, r, s = lv(t)) {
    i && t.startsWith("xlink:") ? n == null ? e.removeAttributeNS(Mu, t.slice(6, t.length)) : e.setAttributeNS(Mu, t, n) : n == null || s && !Ql(n) ? e.removeAttribute(t) : e.setAttribute(t, s ? "" : on(n) ? String(n) : n)
  }

  function qu(e, t, n, i, r) {
    if (t === "innerHTML" || t === "textContent") {
      n != null && (e[t] = t === "innerHTML" ? Xu(n) : n);
      return
    }
    const s = e.tagName;
    if (t === "value" && s !== "PROGRESS" && !s.includes("-")) {
      const a = s === "OPTION" ? e.getAttribute("value") || "" : e.value,
        l = n == null ? e.type === "checkbox" ? "on" : "" : String(n);
      (a !== l || !("_value" in e)) && (e.value = l), n == null && e.removeAttribute(t), e._value = n;
      return
    }
    let o = !1;
    if (n === "" || n == null) {
      const a = typeof e[t];
      a === "boolean" ? n = Ql(n) : n == null && a === "string" ? (n = "", o = !0) : a === "number" && (n = 0, o = !0)
    }
    try {
      e[t] = n
    } catch {}
    o && e.removeAttribute(r || t)
  }

  function fy(e, t, n, i) {
    e.addEventListener(t, n, i)
  }

  function dy(e, t, n, i) {
    e.removeEventListener(t, n, i)
  }
  const Zu = Symbol("_vei");

  function py(e, t, n, i, r = null) {
    const s = e[Zu] || (e[Zu] = {}),
      o = s[t];
    if (i && o) o.value = i;
    else {
      const [a, l] = hy(t);
      if (i) {
        const u = s[t] = gy(i, r);
        fy(e, a, u, l)
      } else o && (dy(e, a, o, l), s[t] = void 0)
    }
  }
  const Uu = /(?:Once|Passive|Capture)$/;

  function hy(e) {
    let t;
    if (Uu.test(e)) {
      t = {};
      let i;
      for (; i = e.match(Uu);) e = e.slice(0, e.length - i[0].length), t[i[0].toLowerCase()] = !0
    }
    return [e[2] === ":" ? e.slice(3) : Kn(e.slice(2)), t]
  }
  let _o = 0;
  const my = Promise.resolve(),
    vy = () => _o || (my.then(() => _o = 0), _o = Date.now());

  function gy(e, t) {
    const n = i => {
      if (!i._vts) i._vts = Date.now();
      else if (i._vts <= n.attached) return;
      jt(yy(i, n.value), t, 5, [i])
    };
    return n.value = e, n.attached = vy(), n
  }

  function yy(e, t) {
    if (G(t)) {
      const n = e.stopImmediatePropagation;
      return e.stopImmediatePropagation = () => {
        n.call(e), e._stopped = !0
      }, t.map(i => r => !r._stopped && i && i(r))
    } else return t
  }
  const Bu = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123,
    by = (e, t, n, i, r, s) => {
      const o = r === "svg";
      t === "class" ? sy(e, i, o) : t === "style" ? cy(e, n, i) : Ur(t) ? lo(t) || py(e, t, n, i, s) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : Ay(e, t, i, o)) ? (qu(e, t, i), !e.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && Iu(e, t, i, o, s, t !== "value")) : e._isVueCE && (/[A-Z]/.test(t) || !Pe(i)) ? qu(e, yt(t), i, s, t) : (t === "true-value" ? e._trueValue = i : t === "false-value" && (e._falseValue = i), Iu(e, t, i, o))
    };

  function Ay(e, t, n, i) {
    if (i) return !!(t === "innerHTML" || t === "textContent" || t in e && Bu(t) && J(n));
    if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "autocorrect" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA") return !1;
    if (t === "width" || t === "height") {
      const r = e.tagName;
      if (r === "IMG" || r === "VIDEO" || r === "CANVAS" || r === "SOURCE") return !1
    }
    return Bu(t) && Pe(n) ? !1 : t in e
  }
  const Py = ["ctrl", "shift", "alt", "meta"],
    wy = {
      stop: e => e.stopPropagation(),
      prevent: e => e.preventDefault(),
      self: e => e.target !== e.currentTarget,
      ctrl: e => !e.ctrlKey,
      shift: e => !e.shiftKey,
      alt: e => !e.altKey,
      meta: e => !e.metaKey,
      left: e => "button" in e && e.button !== 0,
      middle: e => "button" in e && e.button !== 1,
      right: e => "button" in e && e.button !== 2,
      exact: (e, t) => Py.some(n => e[`${n}Key`] && !t.includes(n))
    },
    vs = (e, t) => {
      const n = e._withMods || (e._withMods = {}),
        i = t.join(".");
      return n[i] || (n[i] = (r, ...s) => {
        for (let o = 0; o < t.length; o++) {
          const a = wy[t[o]];
          if (a && a(r, t)) return
        }
        return e(r, ...s)
      })
    },
    xy = Ne({
      patchProp: by
    }, $g);
  let Gu;

  function Ty() {
    return Gu || (Gu = xg(xy))
  }
  const Ly = (...e) => {
    const t = Ty().createApp(...e),
      {
        mount: n
      } = t;
    return t.mount = i => {
      const r = Oy(i);
      if (!r) return;
      const s = t._component;
      !J(s) && !s.render && !s.template && (s.template = r.innerHTML), r.nodeType === 1 && (r.textContent = "");
      const o = n(r, !1, Sy(r));
      return r instanceof Element && (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")), o
    }, t
  };

  function Sy(e) {
    if (e instanceof SVGElement) return "svg";
    if (typeof MathMLElement == "function" && e instanceof MathMLElement) return "mathml"
  }

  function Oy(e) {
    return Pe(e) ? document.querySelector(e) : e
  }
  const Ku = e => t => typeof t == "string" && t.startsWith(e),
    $o = Ku("--"),
    zy = Ku("var(--"),
    ea = e => zy(e) ? Xy.test(e.split("/*")[0].trim()) : !1,
    Xy = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,
    hr = {};

  function Ju(e) {
    for (const t in e) hr[t] = e[t], $o(t) && (hr[t].isCSSVariable = !0)
  }

  function mr(e, t) {
    const n = typeof e == "string" && !t ? `${e}Context` : t,
      i = Symbol(n);
    return [o => {
      const a = jn(i, o);
      if (a === void 0) throw new Error(`Injection \`${i.toString()}\` not found. Component must be used within ${Array.isArray(e)?`one of the following components: ${e.join(", ")}`:`\`${e}\``}`);
      return a
    }, o => (_c(i, o), o)]
  }
  const [Dy, Vy] = mr("Motion"), [Ny, YL] = mr("LayoutGroup");

  function Yu(e) {
    return e !== null && typeof e == "object" && typeof e.start == "function"
  }
  class gn {
    constructor(t) {
      this.state = t
    }
    beforeMount() {}
    mount() {}
    unmount() {}
    update() {}
    beforeUpdate() {}
    beforeUnmount() {}
  }

  function vr(e, t, n) {
    if (Array.isArray(e)) return e.reduce((i, r) => {
      const s = vr(r, t, n);
      return s ? {
        ...i,
        ...s
      } : i
    }, {});
    if (typeof e == "object") return e;
    if (e && t) {
      const i = t[e];
      return typeof i == "function" ? i(n) : i
    }
  }

  function jy(e, t) {
    return typeof e != typeof t ? !0 : Array.isArray(e) && Array.isArray(t) ? !Ry(e, t) : e !== t
  }

  function Ry(e, t) {
    const n = t.length;
    if (n !== e.length) return !1;
    for (let i = 0; i < n; i++)
      if (t[i] !== e[i]) return !1;
    return !0
  }

  function Qu(e) {
    return e == null ? void 0 : e.startsWith("--")
  }
  const Fy = e => e;

  function Cy(e) {
    return typeof e == "number"
  }
  const Wy = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "svg", "switch", "symbol", "text", "tspan", "use", "view", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "linearGradient", "radialGradient", "textPath"],
    Hy = new Set(Wy);

  function _u(e) {
    return Hy.has(e)
  }
  class ky {
    constructor(t) {
      this.features = [];
      const {
        features: n = [],
        lazyMotionContext: i
      } = t.options, r = n.concat(i.features.value);
      this.features = r.map(o => new o(t));
      const s = this.features;
      dn(i.features, o => {
        o.forEach(a => {
          if (!r.includes(a)) {
            r.push(a);
            const l = new a(t);
            s.push(l), t.isMounted() && (l.beforeMount(), l.mount())
          }
        })
      }, {
        flush: "pre"
      })
    }
    mount() {
      this.features.forEach(t => t.mount())
    }
    beforeMount() {
      this.features.forEach(t => {
        var n;
        return (n = t.beforeMount) == null ? void 0 : n.call(t)
      })
    }
    unmount() {
      this.features.forEach(t => t.unmount())
    }
    update() {
      this.features.forEach(t => {
        var n;
        return (n = t.update) == null ? void 0 : n.call(t)
      })
    }
    beforeUpdate() {
      this.features.forEach(t => t.beforeUpdate())
    }
    beforeUnmount() {
      this.features.forEach(t => t.beforeUnmount())
    }
  }
  const ta = new WeakMap,
    [Ey, QL] = mr("AnimatePresenceContext");

  function My(e) {
    return typeof e == "string" || e === !1 || Array.isArray(e)
  }
  const st = e => e,
    gs = ["setup", "read", "resolveKeyframes", "preUpdate", "update", "preRender", "render", "postRender"];

  function Iy(e, t) {
    let n = new Set,
      i = new Set,
      r = !1,
      s = !1;
    const o = new WeakSet;
    let a = {
      delta: 0,
      timestamp: 0,
      isProcessing: !1
    };

    function l(c) {
      o.has(c) && (u.schedule(c), e()), c(a)
    }
    const u = {
      schedule: (c, f = !1, d = !1) => {
        const h = d && r ? n : i;
        return f && o.add(c), h.has(c) || h.add(c), c
      },
      cancel: c => {
        i.delete(c), o.delete(c)
      },
      process: c => {
        if (a = c, r) {
          s = !0;
          return
        }
        r = !0, [n, i] = [i, n], n.forEach(l), n.clear(), r = !1, s && (s = !1, u.process(c))
      }
    };
    return u
  }
  const yn = {},
    qy = 40;

  function $u(e, t) {
    let n = !1,
      i = !0;
    const r = {
        delta: 0,
        timestamp: 0,
        isProcessing: !1
      },
      s = () => n = !0,
      o = gs.reduce((T, P) => (T[P] = Iy(s), T), {}),
      {
        setup: a,
        read: l,
        resolveKeyframes: u,
        preUpdate: c,
        update: f,
        preRender: d,
        render: p,
        postRender: h
      } = o,
      g = () => {
        const T = yn.useManualTiming ? r.timestamp : performance.now();
        n = !1, yn.useManualTiming || (r.delta = i ? 1e3 / 60 : Math.max(Math.min(T - r.timestamp, qy), 1)), r.timestamp = T, r.isProcessing = !0, a.process(r), l.process(r), u.process(r), c.process(r), f.process(r), d.process(r), p.process(r), h.process(r), r.isProcessing = !1, n && t && (i = !1, e(g))
      },
      A = () => {
        n = !0, i = !0, r.isProcessing || e(g)
      };
    return {
      schedule: gs.reduce((T, P) => {
        const O = o[P];
        return T[P] = (N, V = !1, R = !1) => (n || A(), O.schedule(N, V, R)), T
      }, {}),
      cancel: T => {
        for (let P = 0; P < gs.length; P++) o[gs[P]].cancel(T)
      },
      state: r,
      steps: o
    }
  }
  const {
    schedule: ge,
    cancel: bn,
    state: Me,
    steps: na
  } = $u(typeof requestAnimationFrame < "u" ? requestAnimationFrame : st, !0), ef = new WeakMap;
  let Zy = 0;
  const ia = new Set;
  class Uy {
    constructor(t, n) {
      var i;
      this.element = null, this.isSafeToRemove = !1, this.isVShow = !1, this.children = new Set, this.activeStates = {
        initial: !0,
        animate: !0
      }, this.currentProcess = null, this._context = null, this.animateUpdates = st, this.id = `motion-state-${Zy++}`, this.options = t, this.parent = n, (i = n == null ? void 0 : n.children) == null || i.add(this), this.depth = (n == null ? void 0 : n.depth) + 1 || 0;
      const s = (t.initial === void 0 && t.variants ? this.context.initial : t.initial) === !1 ? ["initial", "animate"] : ["initial"];
      this.initTarget(s), this.featureManager = new ky(this), this.type = _u(this.options.as) ? "svg" : "html"
    }
    get context() {
      if (!this._context) {
        const t = {
          get: (n, i) => {
            var r;
            return My(this.options[i]) ? this.options[i] : (r = this.parent) == null ? void 0 : r.context[i]
          }
        };
        this._context = new Proxy({}, t)
      }
      return this._context
    }
    initTarget(t) {
      var n;
      const i = this.options.custom ?? ((n = this.options.animatePresenceContext) == null ? void 0 : n.custom);
      this.baseTarget = t.reduce((r, s) => ({
        ...r,
        ...vr(this.options[s] || this.context[s], this.options.variants, i)
      }), {}), this.target = {}
    }
    updateOptions(t) {
      var n;
      this.options = t, (n = this.visualElement) == null || n.update({
        ...this.options,
        whileTap: this.options.whilePress
      }, {
        isPresent: !ta.has(this.element)
      })
    }
    beforeMount() {
      this.featureManager.beforeMount()
    }
    mount(t, n, i = !1) {
      var r;
      this.element = t, this.updateOptions(n), this.featureManager.mount(), !i && this.options.animate && ((r = this.startAnimation) == null || r.call(this)), this.options.layoutId && (ia.add(this.options.layoutId), ge.render(() => {
        ia.clear()
      }))
    }
    clearAnimation() {
      var t, n;
      this.currentProcess && bn(this.currentProcess), this.currentProcess = null, (n = (t = this.visualElement) == null ? void 0 : t.variantChildren) == null || n.forEach(i => {
        i.state.clearAnimation()
      })
    }
    startAnimation() {
      this.clearAnimation(), this.currentProcess = ge.render(() => {
        this.currentProcess = null, this.animateUpdates()
      })
    }
    beforeUnmount() {
      this.featureManager.beforeUnmount()
    }
    unmount(t = !1) {
      const n = this.options.layoutId && !ia.has(this.options.layoutId);
      (() => {
        const r = () => {
          var s, o, a;
          t && Array.from(this.children).reverse().forEach(this.unmountChild), (o = (s = this.parent) == null ? void 0 : s.children) == null || o.delete(this), ef.delete(this.element), this.featureManager.unmount(), (a = this.visualElement) == null || a.unmount(), this.clearAnimation()
        };
        n ? Promise.resolve().then(r) : r()
      })()
    }
    unmountChild(t) {
      t.unmount(!0)
    }
    beforeUpdate() {
      this.featureManager.beforeUpdate()
    }
    update(t) {
      this.updateOptions(t), this.featureManager.update(), this.startAnimation()
    }
    setActive(t, n, i = !0) {
      var r;
      !this.element || this.activeStates[t] === n || (this.activeStates[t] = n, (r = this.visualElement.variantChildren) == null || r.forEach(s => {
        s.state.setActive(t, n, !1)
      }), i && this.animateUpdates({
        isFallback: !n && t !== "exit" && this.visualElement.isControllingVariants,
        isExit: t === "exit" && this.activeStates.exit
      }))
    }
    isMounted() {
      return !!this.element
    }
    willUpdate(t) {
      var n;
      (this.options.layout || this.options.layoutId) && ((n = this.visualElement.projection) == null || n.willUpdate())
    }
  }
  const si = new WeakMap;

  function tf(e, t, n) {
    return new CustomEvent(e, {
      detail: {
        target: t,
        isExit: n
      }
    })
  }
  const nf = {
      syntax: "<angle>",
      initialValue: "0deg",
      toDefaultUnit: e => `${e}deg`
    },
    By = {
      translate: {
        syntax: "<length-percentage>",
        initialValue: "0px",
        toDefaultUnit: e => `${e}px`
      },
      rotate: nf,
      scale: {
        syntax: "<number>",
        initialValue: 1,
        toDefaultUnit: Fy
      },
      skew: nf
    },
    Gy = ["translate", "scale", "rotate", "skew"],
    Ky = ["", "X", "Y", "Z"],
    ra = new Map,
    ys = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"];
  Gy.forEach(e => {
    Ky.forEach(t => {
      ys.push(e + t), ra.set(e + t, By[e])
    })
  });
  const Jy = new Set(ys),
    Yy = e => Jy.has(e),
    rf = {
      x: "translateX",
      y: "translateY",
      z: "translateZ"
    };

  function Qy([e], [t]) {
    return ys.indexOf(e) - ys.indexOf(t)
  }

  function _y(e, [t, n]) {
    return `${e} ${t}(${n})`
  }

  function $y(e) {
    return e.sort(Qy).reduce(_y, "").trim()
  }
  const sf = {
      translate: [0, 0],
      rotate: 0,
      scale: 1,
      skew: 0,
      x: 0,
      y: 0,
      z: 0
    },
    gr = e => ({
      test: t => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1,
      parse: parseFloat,
      transform: t => `${t}${e}`
    }),
    Cn = gr("deg"),
    Gt = gr("%"),
    B = gr("px"),
    eb = gr("vh"),
    tb = gr("vw"),
    of = {
      ...Gt,
      parse: e => Gt.parse(e) / 100,
      transform: e => Gt.transform(e * 100)
    },
    Le = e => !!(e && e.getVelocity),
    nb = {
      get: (e, t) => {
        let n = Qu(t) ? e.style.getPropertyValue(t) : getComputedStyle(e)[t];
        if (!n && n !== "0") {
          const i = ra.get(t);
          i && (n = i.initialValue)
        }
        return n
      },
      set: (e, t, n) => {
        Qu(t) ? e.style.setProperty(t, n) : e.style[t] = n
      }
    };

  function ib(e) {
    var t;
    const n = {},
      i = [];
    for (let r in e) {
      let s = e[r];
      s = Le(s) ? s.get() : s, Yy(r) && r in rf && (r = rf[r]);
      let o = Array.isArray(s) ? s[0] : s;
      const a = ra.get(r);
      a ? (o = Cy(s) ? (t = a.toDefaultUnit) == null ? void 0 : t.call(a, s) : s, i.push([r, o])) : n[r] = o
    }
    return i.length && (n.transform = $y(i)), Object.keys(n).length === 0 ? null : n
  }
  const rb = {
    fill: !0,
    stroke: !0,
    opacity: !0,
    "stroke-width": !0,
    "fill-opacity": !0,
    "stroke-opacity": !0,
    "stroke-linecap": !0,
    "stroke-linejoin": !0,
    "stroke-dasharray": !0,
    "stroke-dashoffset": !0,
    cx: !0,
    cy: !0,
    r: !0,
    d: !0,
    x1: !0,
    y1: !0,
    x2: !0,
    y2: !0,
    points: !0,
    "path-length": !0,
    viewBox: !0,
    width: !0,
    height: !0,
    "preserve-aspect-ratio": !0,
    "clip-path": !0,
    filter: !0,
    mask: !0,
    "stop-color": !0,
    "stop-opacity": !0,
    "gradient-transform": !0,
    "gradient-units": !0,
    "spread-method": !0,
    "marker-end": !0,
    "marker-mid": !0,
    "marker-start": !0,
    "text-anchor": !0,
    "dominant-baseline": !0,
    "font-family": !0,
    "font-size": !0,
    "font-weight": !0,
    "letter-spacing": !0,
    "vector-effect": !0
  };

  function sb(e) {
    return e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase()
  }

  function ob(e, t, n = 1, i = 0) {
    e.pathLength = 1, delete e["path-length"], e["stroke-dashoffset"] = B.transform(-i);
    const r = B.transform(t),
      s = B.transform(n);
    e["stroke-dasharray"] = `${r} ${s}`
  }

  function ab(e) {
    const t = {},
      n = {};
    for (const i in e) {
      const r = sb(i);
      if (r in rb) {
        const s = e[i];
        t[r] = Le(s) ? s.get() : s
      } else n[i] = e[i]
    }
    return t["path-length"] !== void 0 && ob(t, t["path-length"], t["path-spacing"], t["path-offset"]), {
      attrs: t,
      style: n
    }
  }
  typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
  const af = e => typeof e < "u";

  function lb({
    top: e,
    left: t,
    right: n,
    bottom: i
  }) {
    return {
      x: {
        min: t,
        max: n
      },
      y: {
        min: e,
        max: i
      }
    }
  }

  function cb(e, t) {
    if (!t) return e;
    const n = t({
        x: e.left,
        y: e.top
      }),
      i = t({
        x: e.right,
        y: e.bottom
      });
    return {
      top: n.y,
      left: n.x,
      bottom: i.y,
      right: i.x
    }
  }

  function ub(e, t) {
    return lb(cb(e.getBoundingClientRect(), t))
  }
  const lf = {
      animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
      exit: ["exit"],
      drag: ["drag", "dragControls"],
      focus: ["whileFocus"],
      hover: ["whileHover", "onHoverStart", "onHoverEnd"],
      tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
      pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
      inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
      layout: ["layout", "layoutId"]
    },
    sa = {};
  for (const e in lf) sa[e] = {
    isEnabled: t => lf[e].some(n => !!t[n])
  };
  const cf = () => ({
      translate: 0,
      scale: 1,
      origin: 0,
      originPoint: 0
    }),
    Si = () => ({
      x: cf(),
      y: cf()
    }),
    uf = () => ({
      min: 0,
      max: 0
    }),
    xe = () => ({
      x: uf(),
      y: uf()
    }),
    fb = typeof window < "u",
    bs = {
      current: null
    },
    ff = {
      current: !1
    };

  function db() {
    if (ff.current = !0, !!fb)
      if (window.matchMedia) {
        const e = window.matchMedia("(prefers-reduced-motion)"),
          t = () => bs.current = e.matches;
        e.addListener(t), t()
      } else bs.current = !1
  }

  function pb(e) {
    return e !== null && typeof e == "object" && typeof e.start == "function"
  }

  function hb(e) {
    return typeof e == "string" || Array.isArray(e)
  }
  const mb = ["initial", ...["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"]];

  function df(e) {
    return pb(e.animate) || mb.some(t => hb(e[t]))
  }

  function vb(e) {
    return !!(df(e) || e.variants)
  }
  let As;

  function gb() {
    As = void 0
  }
  const ot = {
    now: () => (As === void 0 && ot.set(Me.isProcessing || yn.useManualTiming ? Me.timestamp : performance.now()), As),
    set: e => {
      As = e, queueMicrotask(gb)
    }
  };

  function oa(e, t) {
    e.indexOf(t) === -1 && e.push(t)
  }

  function Ps(e, t) {
    const n = e.indexOf(t);
    n > -1 && e.splice(n, 1)
  }
  class aa {
    constructor() {
      this.subscriptions = []
    }
    add(t) {
      return oa(this.subscriptions, t), () => Ps(this.subscriptions, t)
    }
    notify(t, n, i) {
      const r = this.subscriptions.length;
      if (r)
        if (r === 1) this.subscriptions[0](t, n, i);
        else
          for (let s = 0; s < r; s++) {
            const o = this.subscriptions[s];
            o && o(t, n, i)
          }
    }
    getSize() {
      return this.subscriptions.length
    }
    clear() {
      this.subscriptions.length = 0
    }
  }

  function pf(e, t) {
    return t ? e * (1e3 / t) : 0
  }
  const hf = 30,
    yb = e => !isNaN(parseFloat(e));
  class bb {
    constructor(t, n = {}) {
      this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (i, r = !0) => {
        var s, o;
        const a = ot.now();
        if (this.updatedAt !== a && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(i), this.current !== this.prev && ((s = this.events.change) == null || s.notify(this.current), this.dependents))
          for (const l of this.dependents) l.dirty();
        r && ((o = this.events.renderRequest) == null || o.notify(this.current))
      }, this.hasAnimated = !1, this.setCurrent(t), this.owner = n.owner
    }
    setCurrent(t) {
      this.current = t, this.updatedAt = ot.now(), this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = yb(this.current))
    }
    setPrevFrameValue(t = this.current) {
      this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt
    }
    onChange(t) {
      return this.on("change", t)
    }
    on(t, n) {
      this.events[t] || (this.events[t] = new aa);
      const i = this.events[t].add(n);
      return t === "change" ? () => {
        i(), ge.read(() => {
          this.events.change.getSize() || this.stop()
        })
      } : i
    }
    clearListeners() {
      for (const t in this.events) this.events[t].clear()
    }
    attach(t, n) {
      this.passiveEffect = t, this.stopPassiveEffect = n
    }
    set(t, n = !0) {
      !n || !this.passiveEffect ? this.updateAndNotify(t, n) : this.passiveEffect(t, this.updateAndNotify)
    }
    setWithVelocity(t, n, i) {
      this.set(n), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - i
    }
    jump(t, n = !0) {
      this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
    }
    dirty() {
      var t;
      (t = this.events.change) == null || t.notify(this.current)
    }
    addDependent(t) {
      this.dependents || (this.dependents = new Set), this.dependents.add(t)
    }
    removeDependent(t) {
      this.dependents && this.dependents.delete(t)
    }
    get() {
      return this.current
    }
    getPrevious() {
      return this.prev
    }
    getVelocity() {
      const t = ot.now();
      if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > hf) return 0;
      const n = Math.min(this.updatedAt - this.prevUpdatedAt, hf);
      return pf(parseFloat(this.current) - parseFloat(this.prevFrameValue), n)
    }
    start(t) {
      return this.stop(), new Promise(n => {
        this.hasAnimated = !0, this.animation = t(n), this.events.animationStart && this.events.animationStart.notify()
      }).then(() => {
        this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation()
      })
    }
    stop() {
      this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation()
    }
    isAnimating() {
      return !!this.animation
    }
    clearAnimation() {
      delete this.animation
    }
    destroy() {
      var t, n;
      (t = this.dependents) == null || t.clear(), (n = this.events.destroy) == null || n.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
    }
  }

  function Oi(e, t) {
    return new bb(e, t)
  }

  function Ab(e, t, n) {
    for (const i in t) {
      const r = t[i],
        s = n[i];
      if (Le(r)) e.addValue(i, r);
      else if (Le(s)) e.addValue(i, Oi(r, {
        owner: e
      }));
      else if (s !== r)
        if (e.hasValue(i)) {
          const o = e.getValue(i);
          o.liveStyle === !0 ? o.jump(r) : o.hasAnimated || o.set(r)
        } else {
          const o = e.getStaticValue(i);
          e.addValue(i, Oi(o !== void 0 ? o : r, {
            owner: e
          }))
        }
    }
    for (const i in n) t[i] === void 0 && e.removeValue(i);
    return t
  }

  function mf(e) {
    const t = [{}, {}];
    return e == null || e.values.forEach((n, i) => {
      t[0][i] = n.get(), t[1][i] = n.getVelocity()
    }), t
  }

  function vf(e, t, n, i) {
    if (typeof t == "function") {
      const [r, s] = mf(i);
      t = t(n !== void 0 ? n : e.custom, r, s)
    }
    if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") {
      const [r, s] = mf(i);
      t = t(n !== void 0 ? n : e.custom, r, s)
    }
    return t
  }

  function Pb(e) {
    for (let t = 1; t < e.length; t++) e[t] ?? (e[t] = e[t - 1])
  }
  const oi = e => e * 180 / Math.PI,
    la = e => {
      const t = oi(Math.atan2(e[1], e[0]));
      return ca(t)
    },
    wb = {
      x: 4,
      y: 5,
      translateX: 4,
      translateY: 5,
      scaleX: 0,
      scaleY: 3,
      scale: e => (Math.abs(e[0]) + Math.abs(e[3])) / 2,
      rotate: la,
      rotateZ: la,
      skewX: e => oi(Math.atan(e[1])),
      skewY: e => oi(Math.atan(e[2])),
      skew: e => (Math.abs(e[1]) + Math.abs(e[2])) / 2
    },
    ca = e => (e = e % 360, e < 0 && (e += 360), e),
    gf = la,
    yf = e => Math.sqrt(e[0] * e[0] + e[1] * e[1]),
    bf = e => Math.sqrt(e[4] * e[4] + e[5] * e[5]),
    xb = {
      x: 12,
      y: 13,
      z: 14,
      translateX: 12,
      translateY: 13,
      translateZ: 14,
      scaleX: yf,
      scaleY: bf,
      scale: e => (yf(e) + bf(e)) / 2,
      rotateX: e => ca(oi(Math.atan2(e[6], e[5]))),
      rotateY: e => ca(oi(Math.atan2(-e[2], e[0]))),
      rotateZ: gf,
      rotate: gf,
      skewX: e => oi(Math.atan(e[4])),
      skewY: e => oi(Math.atan(e[1])),
      skew: e => (Math.abs(e[1]) + Math.abs(e[4])) / 2
    };

  function ua(e) {
    return e.includes("scale") ? 1 : 0
  }

  function fa(e, t) {
    if (!e || e === "none") return ua(t);
    const n = e.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
    let i, r;
    if (n) i = xb, r = n;
    else {
      const a = e.match(/^matrix\(([-\d.e\s,]+)\)$/u);
      i = wb, r = a
    }
    if (!r) return ua(t);
    const s = i[t],
      o = r[1].split(",").map(Lb);
    return typeof s == "function" ? s(o) : o[s]
  }
  const Tb = (e, t) => {
    const {
      transform: n = "none"
    } = getComputedStyle(e);
    return fa(n, t)
  };

  function Lb(e) {
    return parseFloat(e.trim())
  }
  const zi = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"],
    Xi = new Set(zi),
    An = (e, t, n) => n > t ? t : n < e ? e : n,
    Di = {
      test: e => typeof e == "number",
      parse: parseFloat,
      transform: e => e
    },
    yr = {
      ...Di,
      transform: e => An(0, 1, e)
    },
    ws = {
      ...Di,
      default: 1
    },
    Af = e => e === Di || e === B,
    Sb = new Set(["x", "y", "z"]),
    Ob = zi.filter(e => !Sb.has(e));

  function zb(e) {
    const t = [];
    return Ob.forEach(n => {
      const i = e.getValue(n);
      i !== void 0 && (t.push([n, i.get()]), i.set(n.startsWith("scale") ? 1 : 0))
    }), t
  }
  const ai = {
    width: ({
      x: e
    }, {
      paddingLeft: t = "0",
      paddingRight: n = "0"
    }) => e.max - e.min - parseFloat(t) - parseFloat(n),
    height: ({
      y: e
    }, {
      paddingTop: t = "0",
      paddingBottom: n = "0"
    }) => e.max - e.min - parseFloat(t) - parseFloat(n),
    top: (e, {
      top: t
    }) => parseFloat(t),
    left: (e, {
      left: t
    }) => parseFloat(t),
    bottom: ({
      y: e
    }, {
      top: t
    }) => parseFloat(t) + (e.max - e.min),
    right: ({
      x: e
    }, {
      left: t
    }) => parseFloat(t) + (e.max - e.min),
    x: (e, {
      transform: t
    }) => fa(t, "x"),
    y: (e, {
      transform: t
    }) => fa(t, "y")
  };
  ai.translateX = ai.x, ai.translateY = ai.y;
  const li = new Set;
  let da = !1,
    pa = !1,
    ha = !1;

  function Pf() {
    if (pa) {
      const e = Array.from(li).filter(i => i.needsMeasurement),
        t = new Set(e.map(i => i.element)),
        n = new Map;
      t.forEach(i => {
        const r = zb(i);
        r.length && (n.set(i, r), i.render())
      }), e.forEach(i => i.measureInitialState()), t.forEach(i => {
        i.render();
        const r = n.get(i);
        r && r.forEach(([s, o]) => {
          var a;
          (a = i.getValue(s)) == null || a.set(o)
        })
      }), e.forEach(i => i.measureEndState()), e.forEach(i => {
        i.suspendedScrollY !== void 0 && window.scrollTo(0, i.suspendedScrollY)
      })
    }
    pa = !1, da = !1, li.forEach(e => e.complete(ha)), li.clear()
  }

  function wf() {
    li.forEach(e => {
      e.readKeyframes(), e.needsMeasurement && (pa = !0)
    })
  }

  function Xb() {
    ha = !0, wf(), Pf(), ha = !1
  }
  class ma {
    constructor(t, n, i, r, s, o = !1) {
      this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...t], this.onComplete = n, this.name = i, this.motionValue = r, this.element = s, this.isAsync = o
    }
    scheduleResolve() {
      this.state = "scheduled", this.isAsync ? (li.add(this), da || (da = !0, ge.read(wf), ge.resolveKeyframes(Pf))) : (this.readKeyframes(), this.complete())
    }
    readKeyframes() {
      const {
        unresolvedKeyframes: t,
        name: n,
        element: i,
        motionValue: r
      } = this;
      if (t[0] === null) {
        const s = r == null ? void 0 : r.get(),
          o = t[t.length - 1];
        if (s !== void 0) t[0] = s;
        else if (i && n) {
          const a = i.readValue(n, o);
          a != null && (t[0] = a)
        }
        t[0] === void 0 && (t[0] = o), r && s === void 0 && r.set(t[0])
      }
      Pb(t)
    }
    setFinalKeyframe() {}
    measureInitialState() {}
    renderEndStyles() {}
    measureEndState() {}
    complete(t = !1) {
      this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, t), li.delete(this)
    }
    cancel() {
      this.state === "scheduled" && (li.delete(this), this.state = "pending")
    }
    resume() {
      this.state === "pending" && this.scheduleResolve()
    }
  }
  const xf = e => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e),
    Tf = e => /^0[^.\s]+$/u.test(e),
    br = e => Math.round(e * 1e5) / 1e5,
    va = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;

  function Db(e) {
    return e == null
  }
  const Vb = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,
    ga = (e, t) => n => !!(typeof n == "string" && Vb.test(n) && n.startsWith(e) || t && !Db(n) && Object.prototype.hasOwnProperty.call(n, t)),
    Lf = (e, t, n) => i => {
      if (typeof i != "string") return i;
      const [r, s, o, a] = i.match(va);
      return {
        [e]: parseFloat(r),
        [t]: parseFloat(s),
        [n]: parseFloat(o),
        alpha: a !== void 0 ? parseFloat(a) : 1
      }
    },
    Nb = e => An(0, 255, e),
    ya = {
      ...Di,
      transform: e => Math.round(Nb(e))
    },
    ci = {
      test: ga("rgb", "red"),
      parse: Lf("red", "green", "blue"),
      transform: ({
        red: e,
        green: t,
        blue: n,
        alpha: i = 1
      }) => "rgba(" + ya.transform(e) + ", " + ya.transform(t) + ", " + ya.transform(n) + ", " + br(yr.transform(i)) + ")"
    };

  function jb(e) {
    let t = "",
      n = "",
      i = "",
      r = "";
    return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), i = e.substring(5, 7), r = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), i = e.substring(3, 4), r = e.substring(4, 5), t += t, n += n, i += i, r += r), {
      red: parseInt(t, 16),
      green: parseInt(n, 16),
      blue: parseInt(i, 16),
      alpha: r ? parseInt(r, 16) / 255 : 1
    }
  }
  const ba = {
      test: ga("#"),
      parse: jb,
      transform: ci.transform
    },
    Vi = {
      test: ga("hsl", "hue"),
      parse: Lf("hue", "saturation", "lightness"),
      transform: ({
        hue: e,
        saturation: t,
        lightness: n,
        alpha: i = 1
      }) => "hsla(" + Math.round(e) + ", " + Gt.transform(br(t)) + ", " + Gt.transform(br(n)) + ", " + br(yr.transform(i)) + ")"
    },
    Se = {
      test: e => ci.test(e) || ba.test(e) || Vi.test(e),
      parse: e => ci.test(e) ? ci.parse(e) : Vi.test(e) ? Vi.parse(e) : ba.parse(e),
      transform: e => typeof e == "string" ? e : e.hasOwnProperty("red") ? ci.transform(e) : Vi.transform(e),
      getAnimatableNone: e => {
        const t = Se.parse(e);
        return t.alpha = 0, Se.transform(t)
      }
    },
    Rb = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;

  function Fb(e) {
    var t, n;
    return isNaN(e) && typeof e == "string" && (((t = e.match(va)) == null ? void 0 : t.length) || 0) + (((n = e.match(Rb)) == null ? void 0 : n.length) || 0) > 0
  }
  const Sf = "number",
    Of = "color",
    Cb = "var",
    Wb = "var(",
    zf = "${}",
    Hb = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;

  function Ar(e) {
    const t = e.toString(),
      n = [],
      i = {
        color: [],
        number: [],
        var: []
      },
      r = [];
    let s = 0;
    const a = t.replace(Hb, l => (Se.test(l) ? (i.color.push(s), r.push(Of), n.push(Se.parse(l))) : l.startsWith(Wb) ? (i.var.push(s), r.push(Cb), n.push(l)) : (i.number.push(s), r.push(Sf), n.push(parseFloat(l))), ++s, zf)).split(zf);
    return {
      values: n,
      split: a,
      indexes: i,
      types: r
    }
  }

  function Xf(e) {
    return Ar(e).values
  }

  function Df(e) {
    const {
      split: t,
      types: n
    } = Ar(e), i = t.length;
    return r => {
      let s = "";
      for (let o = 0; o < i; o++)
        if (s += t[o], r[o] !== void 0) {
          const a = n[o];
          a === Sf ? s += br(r[o]) : a === Of ? s += Se.transform(r[o]) : s += r[o]
        } return s
    }
  }
  const kb = e => typeof e == "number" ? 0 : Se.test(e) ? Se.getAnimatableNone(e) : e;

  function Eb(e) {
    const t = Xf(e);
    return Df(e)(t.map(kb))
  }
  const Wn = {
      test: Fb,
      parse: Xf,
      createTransformer: Df,
      getAnimatableNone: Eb
    },
    Mb = {
      test: e => e === "auto",
      parse: e => e
    },
    Vf = e => t => t.test(e),
    Nf = [Di, B, Gt, Cn, tb, eb, Mb],
    jf = e => Nf.find(Vf(e)),
    Ib = [...Nf, Se, Wn],
    qb = e => Ib.find(Vf(e)),
    Zb = new Set(["brightness", "contrast", "saturate", "opacity"]);

  function Ub(e) {
    const [t, n] = e.slice(0, -1).split("(");
    if (t === "drop-shadow") return e;
    const [i] = n.match(va) || [];
    if (!i) return e;
    const r = n.replace(i, "");
    let s = Zb.has(t) ? 1 : 0;
    return i !== n && (s *= 100), t + "(" + s + r + ")"
  }
  const Bb = /\b([a-z-]*)\(.*?\)/gu,
    Aa = {
      ...Wn,
      getAnimatableNone: e => {
        const t = e.match(Bb);
        return t ? t.map(Ub).join(" ") : e
      }
    },
    Rf = {
      ...Di,
      transform: Math.round
    },
    Pa = {
      borderWidth: B,
      borderTopWidth: B,
      borderRightWidth: B,
      borderBottomWidth: B,
      borderLeftWidth: B,
      borderRadius: B,
      radius: B,
      borderTopLeftRadius: B,
      borderTopRightRadius: B,
      borderBottomRightRadius: B,
      borderBottomLeftRadius: B,
      width: B,
      maxWidth: B,
      height: B,
      maxHeight: B,
      top: B,
      right: B,
      bottom: B,
      left: B,
      padding: B,
      paddingTop: B,
      paddingRight: B,
      paddingBottom: B,
      paddingLeft: B,
      margin: B,
      marginTop: B,
      marginRight: B,
      marginBottom: B,
      marginLeft: B,
      backgroundPositionX: B,
      backgroundPositionY: B,
      ...{
        rotate: Cn,
        rotateX: Cn,
        rotateY: Cn,
        rotateZ: Cn,
        scale: ws,
        scaleX: ws,
        scaleY: ws,
        scaleZ: ws,
        skew: Cn,
        skewX: Cn,
        skewY: Cn,
        distance: B,
        translateX: B,
        translateY: B,
        translateZ: B,
        x: B,
        y: B,
        z: B,
        perspective: B,
        transformPerspective: B,
        opacity: yr,
        originX: of,
        originY: of,
        originZ: B
      },
      zIndex: Rf,
      fillOpacity: yr,
      strokeOpacity: yr,
      numOctaves: Rf
    },
    Gb = {
      ...Pa,
      color: Se,
      backgroundColor: Se,
      outlineColor: Se,
      fill: Se,
      stroke: Se,
      borderColor: Se,
      borderTopColor: Se,
      borderRightColor: Se,
      borderBottomColor: Se,
      borderLeftColor: Se,
      filter: Aa,
      WebkitFilter: Aa
    },
    Ff = e => Gb[e];

  function Cf(e, t) {
    let n = Ff(e);
    return n !== Aa && (n = Wn), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0
  }
  const Wf = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"];
  class Hf {
    scrapeMotionValuesFromProps(t, n, i) {
      return {}
    }
    constructor({
      parent: t,
      props: n,
      presenceContext: i,
      reducedMotionConfig: r,
      blockInitialAnimation: s,
      visualState: o
    }, a = {}) {
      this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = ma, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
        this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
      }, this.renderScheduledAt = 0, this.scheduleRender = () => {
        const d = ot.now();
        this.renderScheduledAt < d && (this.renderScheduledAt = d, ge.render(this.render, !1, !0))
      };
      const {
        latestValues: l,
        renderState: u
      } = o;
      this.latestValues = l, this.baseTarget = {
        ...l
      }, this.initialValues = n.initial ? {
        ...l
      } : {}, this.renderState = u, this.parent = t, this.props = n, this.presenceContext = i, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = r, this.options = a, this.blockInitialAnimation = !!s, this.isControllingVariants = df(n), this.isVariantNode = vb(n), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(t && t.current);
      const {
        willChange: c,
        ...f
      } = this.scrapeMotionValuesFromProps(n, {}, this);
      for (const d in f) {
        const p = f[d];
        l[d] !== void 0 && Le(p) && p.set(l[d], !1)
      }
    }
    mount(t) {
      this.current = t, si.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, i) => this.bindToMotionValue(i, n)), ff.current || db(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : bs.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext)
    }
    unmount() {
      this.projection && this.projection.unmount(), bn(this.notifyUpdate), bn(this.render), this.valueSubscriptions.forEach(t => t()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
      for (const t in this.events) this.events[t].clear();
      for (const t in this.features) {
        const n = this.features[t];
        n && (n.unmount(), n.isMounted = !1)
      }
      this.current = null
    }
    bindToMotionValue(t, n) {
      this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)();
      const i = Xi.has(t);
      i && this.onBindTransform && this.onBindTransform();
      const r = n.on("change", a => {
          this.latestValues[t] = a, this.props.onUpdate && ge.preRender(this.notifyUpdate), i && this.projection && (this.projection.isTransformDirty = !0)
        }),
        s = n.on("renderRequest", this.scheduleRender);
      let o;
      window.MotionCheckAppearSync && (o = window.MotionCheckAppearSync(this, t, n)), this.valueSubscriptions.set(t, () => {
        r(), s(), o && o(), n.owner && n.stop()
      })
    }
    sortNodePosition(t) {
      return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current)
    }
    updateFeatures() {
      let t = "animation";
      for (t in sa) {
        const n = sa[t];
        if (!n) continue;
        const {
          isEnabled: i,
          Feature: r
        } = n;
        if (!this.features[t] && r && i(this.props) && (this.features[t] = new r(this)), this.features[t]) {
          const s = this.features[t];
          s.isMounted ? s.update() : (s.mount(), s.isMounted = !0)
        }
      }
    }
    triggerBuild() {
      this.build(this.renderState, this.latestValues, this.props)
    }
    measureViewportBox() {
      return this.current ? this.measureInstanceViewportBox(this.current, this.props) : xe()
    }
    getStaticValue(t) {
      return this.latestValues[t]
    }
    setStaticValue(t, n) {
      this.latestValues[t] = n
    }
    update(t, n) {
      (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
      for (let i = 0; i < Wf.length; i++) {
        const r = Wf[i];
        this.propEventSubscriptions[r] && (this.propEventSubscriptions[r](), delete this.propEventSubscriptions[r]);
        const s = "on" + r,
          o = t[s];
        o && (this.propEventSubscriptions[r] = this.on(r, o))
      }
      this.prevMotionValues = Ab(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue()
    }
    getProps() {
      return this.props
    }
    getVariant(t) {
      return this.props.variants ? this.props.variants[t] : void 0
    }
    getDefaultTransition() {
      return this.props.transition
    }
    getTransformPagePoint() {
      return this.props.transformPagePoint
    }
    getClosestVariantNode() {
      return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
    }
    addVariantChild(t) {
      const n = this.getClosestVariantNode();
      if (n) return n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t)
    }
    addValue(t, n) {
      const i = this.values.get(t);
      n !== i && (i && this.removeValue(t), this.bindToMotionValue(t, n), this.values.set(t, n), this.latestValues[t] = n.get())
    }
    removeValue(t) {
      this.values.delete(t);
      const n = this.valueSubscriptions.get(t);
      n && (n(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState)
    }
    hasValue(t) {
      return this.values.has(t)
    }
    getValue(t, n) {
      if (this.props.values && this.props.values[t]) return this.props.values[t];
      let i = this.values.get(t);
      return i === void 0 && n !== void 0 && (i = Oi(n === null ? void 0 : n, {
        owner: this
      }), this.addValue(t, i)), i
    }
    readValue(t, n) {
      let i = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : this.getBaseTargetFromProps(this.props, t) ?? this.readValueFromInstance(this.current, t, this.options);
      return i != null && (typeof i == "string" && (xf(i) || Tf(i)) ? i = parseFloat(i) : !qb(i) && Wn.test(n) && (i = Cf(t, n)), this.setBaseTarget(t, Le(i) ? i.get() : i)), Le(i) ? i.get() : i
    }
    setBaseTarget(t, n) {
      this.baseTarget[t] = n
    }
    getBaseTarget(t) {
      var n;
      const {
        initial: i
      } = this.props;
      let r;
      if (typeof i == "string" || typeof i == "object") {
        const o = vf(this.props, i, (n = this.presenceContext) == null ? void 0 : n.custom);
        o && (r = o[t])
      }
      if (i && r !== void 0) return r;
      const s = this.getBaseTargetFromProps(this.props, t);
      return s !== void 0 && !Le(s) ? s : this.initialValues[t] !== void 0 && r === void 0 ? void 0 : this.baseTarget[t]
    }
    on(t, n) {
      return this.events[t] || (this.events[t] = new aa), this.events[t].add(n)
    }
    notify(t, ...n) {
      this.events[t] && this.events[t].notify(...n)
    }
  }
  const kf = new Set(["width", "height", "top", "left", "right", "bottom", ...zi]);
  let wa = () => {};
  const Kb = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;

  function Jb(e) {
    const t = Kb.exec(e);
    if (!t) return [, ];
    const [, n, i, r] = t;
    return [`--${n??i}`, r]
  }

  function Ef(e, t, n = 1) {
    const [i, r] = Jb(e);
    if (!i) return;
    const s = window.getComputedStyle(t).getPropertyValue(i);
    if (s) {
      const o = s.trim();
      return xf(o) ? parseFloat(o) : o
    }
    return ea(r) ? Ef(r, t, n + 1) : r
  }

  function Yb(e) {
    return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || Tf(e) : !0
  }
  const Qb = new Set(["auto", "none", "0"]);

  function _b(e, t, n) {
    let i = 0,
      r;
    for (; i < e.length && !r;) {
      const s = e[i];
      typeof s == "string" && !Qb.has(s) && Ar(s).values.length && (r = e[i]), i++
    }
    if (r && n)
      for (const s of t) e[s] = Cf(n, r)
  }
  class $b extends ma {
    constructor(t, n, i, r, s) {
      super(t, n, i, r, s, !0)
    }
    readKeyframes() {
      const {
        unresolvedKeyframes: t,
        element: n,
        name: i
      } = this;
      if (!n || !n.current) return;
      super.readKeyframes();
      for (let l = 0; l < t.length; l++) {
        let u = t[l];
        if (typeof u == "string" && (u = u.trim(), ea(u))) {
          const c = Ef(u, n.current);
          c !== void 0 && (t[l] = c), l === t.length - 1 && (this.finalKeyframe = u)
        }
      }
      if (this.resolveNoneKeyframes(), !kf.has(i) || t.length !== 2) return;
      const [r, s] = t, o = jf(r), a = jf(s);
      if (o !== a)
        if (Af(o) && Af(a))
          for (let l = 0; l < t.length; l++) {
            const u = t[l];
            typeof u == "string" && (t[l] = parseFloat(u))
          } else ai[i] && (this.needsMeasurement = !0)
    }
    resolveNoneKeyframes() {
      const {
        unresolvedKeyframes: t,
        name: n
      } = this, i = [];
      for (let r = 0; r < t.length; r++)(t[r] === null || Yb(t[r])) && i.push(r);
      i.length && _b(t, i, n)
    }
    measureInitialState() {
      const {
        element: t,
        unresolvedKeyframes: n,
        name: i
      } = this;
      if (!t || !t.current) return;
      i === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = ai[i](t.measureViewportBox(), window.getComputedStyle(t.current)), n[0] = this.measuredOrigin;
      const r = n[n.length - 1];
      r !== void 0 && t.getValue(i, r).jump(r, !1)
    }
    measureEndState() {
      var t;
      const {
        element: n,
        name: i,
        unresolvedKeyframes: r
      } = this;
      if (!n || !n.current) return;
      const s = n.getValue(i);
      s && s.jump(this.measuredOrigin, !1);
      const o = r.length - 1,
        a = r[o];
      r[o] = ai[i](n.measureViewportBox(), window.getComputedStyle(n.current)), a !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = a), (t = this.removedTransforms) != null && t.length && this.removedTransforms.forEach(([l, u]) => {
        n.getValue(l).set(u)
      }), this.resolveNoneKeyframes()
    }
  }
  class Mf extends Hf {
    constructor() {
      super(...arguments), this.KeyframeResolver = $b
    }
    sortInstanceNodePosition(t, n) {
      return t.compareDocumentPosition(n) & 2 ? 1 : -1
    }
    getBaseTargetFromProps(t, n) {
      return t.style ? t.style[n] : void 0
    }
    removeValueFromRenderState(t, {
      vars: n,
      style: i
    }) {
      delete n[t], delete i[t]
    }
    handleChildMotionValue() {
      this.childSubscription && (this.childSubscription(), delete this.childSubscription);
      const {
        children: t
      } = this.props;
      Le(t) && (this.childSubscription = t.on("change", n => {
        this.current && (this.current.textContent = `${n}`)
      }))
    }
  }
  const If = (e, t) => t && typeof e == "number" ? t.transform(e) : e,
    eA = {
      x: "translateX",
      y: "translateY",
      z: "translateZ",
      transformPerspective: "perspective"
    },
    tA = zi.length;

  function nA(e, t, n) {
    let i = "",
      r = !0;
    for (let s = 0; s < tA; s++) {
      const o = zi[s],
        a = e[o];
      if (a === void 0) continue;
      let l = !0;
      if (typeof a == "number" ? l = a === (o.startsWith("scale") ? 1 : 0) : l = parseFloat(a) === 0, !l || n) {
        const u = If(a, Pa[o]);
        if (!l) {
          r = !1;
          const c = eA[o] || o;
          i += `${c}(${u}) `
        }
        n && (t[o] = u)
      }
    }
    return i = i.trim(), n ? i = n(t, r ? "" : i) : r && (i = "none"), i
  }

  function qf(e, t, n) {
    const {
      style: i,
      vars: r,
      transformOrigin: s
    } = e;
    let o = !1,
      a = !1;
    for (const l in t) {
      const u = t[l];
      if (Xi.has(l)) {
        o = !0;
        continue
      } else if ($o(l)) {
        r[l] = u;
        continue
      } else {
        const c = If(u, Pa[l]);
        l.startsWith("origin") ? (a = !0, s[l] = c) : i[l] = c
      }
    }
    if (t.transform || (o || n ? i.transform = nA(t, e.transform, n) : i.transform && (i.transform = "none")), a) {
      const {
        originX: l = "50%",
        originY: u = "50%",
        originZ: c = 0
      } = s;
      i.transformOrigin = `${l} ${u} ${c}`
    }
  }

  function Zf(e, {
    style: t,
    vars: n
  }, i, r) {
    Object.assign(e.style, t, r && r.getProjectionStyles(i));
    for (const s in n) e.style.setProperty(s, n[s])
  }

  function iA(e, {
    layout: t,
    layoutId: n
  }) {
    return Xi.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!hr[e] || e === "opacity")
  }

  function Uf(e, t, n) {
    var i;
    const {
      style: r
    } = e, s = {};
    for (const o in r)(Le(r[o]) || t.style && Le(t.style[o]) || iA(o, e) || ((i = n == null ? void 0 : n.getValue(o)) == null ? void 0 : i.liveStyle) !== void 0) && (s[o] = r[o]);
    return s
  }

  function rA(e) {
    return window.getComputedStyle(e)
  }
  class Bf extends Mf {
    constructor() {
      super(...arguments), this.type = "html", this.renderInstance = Zf
    }
    readValueFromInstance(t, n) {
      var i;
      if (Xi.has(n)) return (i = this.projection) != null && i.isProjecting ? ua(n) : Tb(t, n);
      {
        const r = rA(t),
          s = ($o(n) ? r.getPropertyValue(n) : r[n]) || 0;
        return typeof s == "string" ? s.trim() : s
      }
    }
    measureInstanceViewportBox(t, {
      transformPagePoint: n
    }) {
      return ub(t, n)
    }
    build(t, n, i) {
      qf(t, n, i.transformTemplate)
    }
    scrapeMotionValuesFromProps(t, n, i) {
      return Uf(t, n, i)
    }
  }
  const xa = e => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(),
    sA = {
      offset: "stroke-dashoffset",
      array: "stroke-dasharray"
    },
    oA = {
      offset: "strokeDashoffset",
      array: "strokeDasharray"
    };

  function aA(e, t, n = 1, i = 0, r = !0) {
    e.pathLength = 1;
    const s = r ? sA : oA;
    e[s.offset] = B.transform(-i);
    const o = B.transform(t),
      a = B.transform(n);
    e[s.array] = `${o} ${a}`
  }

  function lA(e, {
    attrX: t,
    attrY: n,
    attrScale: i,
    pathLength: r,
    pathSpacing: s = 1,
    pathOffset: o = 0,
    ...a
  }, l, u, c) {
    if (qf(e, a, u), l) {
      e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
      return
    }
    e.attrs = e.style, e.style = {};
    const {
      attrs: f,
      style: d
    } = e;
    f.transform && (d.transform = f.transform, delete f.transform), (d.transform || f.transformOrigin) && (d.transformOrigin = f.transformOrigin ?? "50% 50%", delete f.transformOrigin), d.transform && (d.transformBox = (c == null ? void 0 : c.transformBox) ?? "fill-box", delete f.transformBox), t !== void 0 && (f.x = t), n !== void 0 && (f.y = n), i !== void 0 && (f.scale = i), r !== void 0 && aA(f, r, s, o, !1)
  }
  const Gf = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]),
    cA = e => typeof e == "string" && e.toLowerCase() === "svg";

  function uA(e, t, n, i) {
    Zf(e, t, void 0, i);
    for (const r in t.attrs) e.setAttribute(Gf.has(r) ? r : xa(r), t.attrs[r])
  }

  function fA(e, t, n) {
    const i = Uf(e, t, n);
    for (const r in e)
      if (Le(e[r]) || Le(t[r])) {
        const s = zi.indexOf(r) !== -1 ? "attr" + r.charAt(0).toUpperCase() + r.substring(1) : r;
        i[s] = e[r]
      } return i
  }
  class Kf extends Mf {
    constructor() {
      super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = xe
    }
    getBaseTargetFromProps(t, n) {
      return t[n]
    }
    readValueFromInstance(t, n) {
      if (Xi.has(n)) {
        const i = Ff(n);
        return i && i.default || 0
      }
      return n = Gf.has(n) ? n : xa(n), t.getAttribute(n)
    }
    scrapeMotionValuesFromProps(t, n, i) {
      return fA(t, n, i)
    }
    build(t, n, i) {
      lA(t, n, this.isSVGTag, i.transformTemplate, i.style)
    }
    renderInstance(t, n, i, r) {
      uA(t, n, i, r)
    }
    mount(t) {
      this.isSVGTag = cA(t.tagName), super.mount(t)
    }
  }

  function dA(e, t) {
    return _u(e) ? new Kf(t) : new Bf(t)
  }

  function Ta(e) {
    return typeof e == "object" && !Array.isArray(e)
  }

  function La(e, t, n) {
    if (e instanceof EventTarget) return [e];
    if (typeof e == "string") {
      let i = document;
      const r = (n == null ? void 0 : n[e]) ?? i.querySelectorAll(e);
      return r ? Array.from(r) : []
    }
    return Array.from(e)
  }

  function Jf(e, t, n, i) {
    return typeof e == "string" && Ta(t) ? La(e, n, i) : e instanceof NodeList ? Array.from(e) : Array.isArray(e) ? e : [e]
  }

  function pA(e, t, n) {
    return e * (t + 1)
  }

  function Yf(e, t, n, i) {
    return typeof t == "number" ? t : t.startsWith("-") || t.startsWith("+") ? Math.max(0, e + parseFloat(t)) : t === "<" ? n : t.startsWith("<") ? Math.max(0, n + parseFloat(t.slice(1))) : i.get(t) ?? e
  }
  const be = (e, t, n) => e + (t - e) * n,
    hA = (e, t, n) => {
      const i = t - e;
      return ((n - e) % i + i) % i + e
    },
    Qf = e => Array.isArray(e) && typeof e[0] != "number";

  function _f(e, t) {
    return Qf(e) ? e[hA(0, e.length, t)] : e
  }

  function mA(e, t, n) {
    for (let i = 0; i < e.length; i++) {
      const r = e[i];
      r.at > t && r.at < n && (Ps(e, r), i--)
    }
  }

  function vA(e, t, n, i, r, s) {
    mA(e, r, s);
    for (let o = 0; o < t.length; o++) e.push({
      value: t[o],
      at: be(r, s, i[o]),
      easing: _f(n, o)
    })
  }

  function gA(e, t) {
    for (let n = 0; n < e.length; n++) e[n] = e[n] / (t + 1)
  }

  function yA(e, t) {
    return e.at === t.at ? e.value === null ? 1 : t.value === null ? -1 : 0 : e.at - t.at
  }
  const Ni = (e, t, n) => {
    const i = t - e;
    return i === 0 ? 1 : (n - e) / i
  };

  function $f(e, t) {
    const n = e[e.length - 1];
    for (let i = 1; i <= t; i++) {
      const r = Ni(0, t, i);
      e.push(be(n, 1, r))
    }
  }

  function ed(e) {
    const t = [0];
    return $f(t, e.length - 1), t
  }
  const xs = 2e4;

  function Sa(e) {
    let t = 0;
    const n = 50;
    let i = e.next(t);
    for (; !i.done && t < xs;) t += n, i = e.next(t);
    return t >= xs ? 1 / 0 : t
  }
  const Ft = e => e * 1e3,
    Kt = e => e / 1e3;

  function td(e, t = 100, n) {
    const i = n({
        ...e,
        keyframes: [0, t]
      }),
      r = Math.min(Sa(i), xs);
    return {
      type: "keyframes",
      ease: s => i.next(r * s).value / t,
      duration: Kt(r)
    }
  }

  function Oa(e) {
    return typeof e == "function" && "applyToOptions" in e
  }
  const bA = "easeInOut";

  function AA(e, {
    defaultTransition: t = {},
    ...n
  } = {}, i, r) {
    const s = t.duration || .3,
      o = new Map,
      a = new Map,
      l = {},
      u = new Map;
    let c = 0,
      f = 0,
      d = 0;
    for (let p = 0; p < e.length; p++) {
      const h = e[p];
      if (typeof h == "string") {
        u.set(h, f);
        continue
      } else if (!Array.isArray(h)) {
        u.set(h.name, Yf(f, h.at, c, u));
        continue
      }
      let [g, A, m = {}] = h;
      m.at !== void 0 && (f = Yf(f, m.at, c, u));
      let x = 0;
      const T = (P, O, N, V = 0, R = 0) => {
        const C = PA(P),
          {
            delay: I = 0,
            times: U = ed(C),
            type: j = "keyframes",
            repeat: Z,
            repeatType: se,
            repeatDelay: Ve = 0,
            ...pe
          } = O;
        let {
          ease: _ = t.ease || "easeOut",
          duration: Q
        } = O;
        const ze = typeof I == "function" ? I(V, R) : I,
          zt = C.length,
          nt = Oa(j) ? j : r == null ? void 0 : r[j || "keyframes"];
        if (zt <= 2 && nt) {
          let rn = 100;
          if (zt === 2 && TA(C)) {
            const pt = C[1] - C[0];
            rn = Math.abs(pt)
          }
          const dt = {
            ...pe
          };
          Q !== void 0 && (dt.duration = Ft(Q));
          const vt = td(dt, rn, nt);
          _ = vt.ease, Q = vt.duration
        }
        Q ?? (Q = s);
        const qe = f + ze;
        U.length === 1 && U[0] === 0 && (U[1] = 1);
        const zn = U.length - C.length;
        if (zn > 0 && $f(U, zn), C.length === 1 && C.unshift(null), Z) {
          Q = pA(Q, Z);
          const rn = [...C],
            dt = [...U];
          _ = Array.isArray(_) ? [..._] : [_];
          const vt = [..._];
          for (let pt = 0; pt < Z; pt++) {
            C.push(...rn);
            for (let Xt = 0; Xt < rn.length; Xt++) U.push(dt[Xt] + (pt + 1)), _.push(Xt === 0 ? "linear" : _f(vt, Xt - 1))
          }
          gA(U, Z)
        }
        const Gn = qe + Q;
        vA(N, C, _, U, qe, Gn), x = Math.max(ze + Q, x), d = Math.max(Gn, d)
      };
      if (Le(g)) {
        const P = nd(g, a);
        T(A, m, id("default", P))
      } else {
        const P = Jf(g, A, i, l),
          O = P.length;
        for (let N = 0; N < O; N++) {
          A = A, m = m;
          const V = P[N],
            R = nd(V, a);
          for (const C in A) T(A[C], wA(m, C), id(C, R), N, O)
        }
      }
      c = f, f += x
    }
    return a.forEach((p, h) => {
      for (const g in p) {
        const A = p[g];
        A.sort(yA);
        const m = [],
          x = [],
          T = [];
        for (let O = 0; O < A.length; O++) {
          const {
            at: N,
            value: V,
            easing: R
          } = A[O];
          m.push(V), x.push(Ni(0, d, N)), T.push(R || "easeOut")
        }
        x[0] !== 0 && (x.unshift(0), m.unshift(m[0]), T.unshift(bA)), x[x.length - 1] !== 1 && (x.push(1), m.push(null)), o.has(h) || o.set(h, {
          keyframes: {},
          transition: {}
        });
        const P = o.get(h);
        P.keyframes[g] = m, P.transition[g] = {
          ...t,
          duration: d,
          ease: T,
          times: x,
          ...n
        }
      }
    }), o
  }

  function nd(e, t) {
    return !t.has(e) && t.set(e, {}), t.get(e)
  }

  function id(e, t) {
    return t[e] || (t[e] = []), t[e]
  }

  function PA(e) {
    return Array.isArray(e) ? e : [e]
  }

  function wA(e, t) {
    return e && e[t] ? {
      ...e,
      ...e[t]
    } : {
      ...e
    }
  }
  const xA = e => typeof e == "number",
    TA = e => e.every(xA),
    LA = e => Array.isArray(e);

  function SA(e, t, n) {
    const i = e.getProps();
    return vf(i, t, i.custom, e)
  }

  function OA(e, t, n) {
    e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, Oi(n))
  }

  function zA(e) {
    return LA(e) ? e[e.length - 1] || 0 : e
  }

  function XA(e, t) {
    const n = SA(e, t);
    let {
      transitionEnd: i = {},
      transition: r = {},
      ...s
    } = n || {};
    s = {
      ...s,
      ...i
    };
    for (const o in s) {
      const a = zA(s[o]);
      OA(e, o, a)
    }
  }

  function DA(e) {
    return !!(Le(e) && e.add)
  }

  function VA(e, t) {
    const n = e.getValue("willChange");
    if (DA(n)) return n.add(t);
    if (!n && yn.WillChange) {
      const i = new yn.WillChange("auto");
      e.addValue("willChange", i), i.add(t)
    }
  }
  const NA = "data-" + xa("framerAppearId");

  function rd(e) {
    return e.props[NA]
  }
  const jA = e => e !== null;

  function RA(e, {
    repeat: t,
    repeatType: n = "loop"
  }, i) {
    const r = e.filter(jA),
      s = t && n !== "loop" && t % 2 === 1 ? 0 : r.length - 1;
    return r[s]
  }
  const FA = {
      type: "spring",
      stiffness: 500,
      damping: 25,
      restSpeed: 10
    },
    CA = e => ({
      type: "spring",
      stiffness: 550,
      damping: e === 0 ? 2 * Math.sqrt(550) : 30,
      restSpeed: 10
    }),
    WA = {
      type: "keyframes",
      duration: .8
    },
    HA = {
      type: "keyframes",
      ease: [.25, .1, .35, 1],
      duration: .3
    },
    kA = (e, {
      keyframes: t
    }) => t.length > 2 ? WA : Xi.has(e) ? e.startsWith("scale") ? CA(t[1]) : FA : HA;

  function EA({
    when: e,
    delay: t,
    delayChildren: n,
    staggerChildren: i,
    staggerDirection: r,
    repeat: s,
    repeatType: o,
    repeatDelay: a,
    from: l,
    elapsed: u,
    ...c
  }) {
    return !!Object.keys(c).length
  }

  function za(e, t) {
    return (e == null ? void 0 : e[t]) ?? (e == null ? void 0 : e.default) ?? e
  }

  function Xa(e, t, n) {
    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e
  }

  function MA({
    hue: e,
    saturation: t,
    lightness: n,
    alpha: i
  }) {
    e /= 360, t /= 100, n /= 100;
    let r = 0,
      s = 0,
      o = 0;
    if (!t) r = s = o = n;
    else {
      const a = n < .5 ? n * (1 + t) : n + t - n * t,
        l = 2 * n - a;
      r = Xa(l, a, e + 1 / 3), s = Xa(l, a, e), o = Xa(l, a, e - 1 / 3)
    }
    return {
      red: Math.round(r * 255),
      green: Math.round(s * 255),
      blue: Math.round(o * 255),
      alpha: i
    }
  }

  function Ts(e, t) {
    return n => n > 0 ? t : e
  }
  const Da = (e, t, n) => {
      const i = e * e,
        r = n * (t * t - i) + i;
      return r < 0 ? 0 : Math.sqrt(r)
    },
    IA = [ba, ci, Vi],
    qA = e => IA.find(t => t.test(e));

  function sd(e) {
    const t = qA(e);
    if (!t) return !1;
    let n = t.parse(e);
    return t === Vi && (n = MA(n)), n
  }
  const od = (e, t) => {
      const n = sd(e),
        i = sd(t);
      if (!n || !i) return Ts(e, t);
      const r = {
        ...n
      };
      return s => (r.red = Da(n.red, i.red, s), r.green = Da(n.green, i.green, s), r.blue = Da(n.blue, i.blue, s), r.alpha = be(n.alpha, i.alpha, s), ci.transform(r))
    },
    Va = new Set(["none", "hidden"]);

  function ZA(e, t) {
    return Va.has(e) ? n => n <= 0 ? e : t : n => n >= 1 ? t : e
  }
  const UA = (e, t) => n => t(e(n)),
    Pr = (...e) => e.reduce(UA);

  function BA(e, t) {
    return n => be(e, t, n)
  }

  function Na(e) {
    return typeof e == "number" ? BA : typeof e == "string" ? ea(e) ? Ts : Se.test(e) ? od : JA : Array.isArray(e) ? ad : typeof e == "object" ? Se.test(e) ? od : GA : Ts
  }

  function ad(e, t) {
    const n = [...e],
      i = n.length,
      r = e.map((s, o) => Na(s)(s, t[o]));
    return s => {
      for (let o = 0; o < i; o++) n[o] = r[o](s);
      return n
    }
  }

  function GA(e, t) {
    const n = {
        ...e,
        ...t
      },
      i = {};
    for (const r in n) e[r] !== void 0 && t[r] !== void 0 && (i[r] = Na(e[r])(e[r], t[r]));
    return r => {
      for (const s in i) n[s] = i[s](r);
      return n
    }
  }

  function KA(e, t) {
    const n = [],
      i = {
        color: 0,
        var: 0,
        number: 0
      };
    for (let r = 0; r < t.values.length; r++) {
      const s = t.types[r],
        o = e.indexes[s][i[s]],
        a = e.values[o] ?? 0;
      n[r] = a, i[s]++
    }
    return n
  }
  const JA = (e, t) => {
    const n = Wn.createTransformer(t),
      i = Ar(e),
      r = Ar(t);
    return i.indexes.var.length === r.indexes.var.length && i.indexes.color.length === r.indexes.color.length && i.indexes.number.length >= r.indexes.number.length ? Va.has(e) && !r.values.length || Va.has(t) && !i.values.length ? ZA(e, t) : Pr(ad(KA(i, r), r.values), n) : Ts(e, t)
  };

  function ld(e, t, n) {
    return typeof e == "number" && typeof t == "number" && typeof n == "number" ? be(e, t, n) : Na(e)(e, t)
  }
  const YA = e => {
      const t = ({
        timestamp: n
      }) => e(n);
      return {
        start: (n = !0) => ge.update(t, n),
        stop: () => bn(t),
        now: () => Me.isProcessing ? Me.timestamp : ot.now()
      }
    },
    cd = (e, t, n = 10) => {
      let i = "";
      const r = Math.max(Math.round(t / n), 2);
      for (let s = 0; s < r; s++) i += Math.round(e(s / (r - 1)) * 1e4) / 1e4 + ", ";
      return `linear(${i.substring(0,i.length-2)})`
    },
    QA = 5;

  function ud(e, t, n) {
    const i = Math.max(t - QA, 0);
    return pf(n - e(i), t - i)
  }
  const we = {
      stiffness: 100,
      damping: 10,
      mass: 1,
      velocity: 0,
      duration: 800,
      bounce: .3,
      visualDuration: .3,
      restSpeed: {
        granular: .01,
        default: 2
      },
      restDelta: {
        granular: .005,
        default: .5
      },
      minDuration: .01,
      maxDuration: 10,
      minDamping: .05,
      maxDamping: 1
    },
    ja = .001;

  function _A({
    duration: e = we.duration,
    bounce: t = we.bounce,
    velocity: n = we.velocity,
    mass: i = we.mass
  }) {
    let r, s, o = 1 - t;
    o = An(we.minDamping, we.maxDamping, o), e = An(we.minDuration, we.maxDuration, Kt(e)), o < 1 ? (r = u => {
      const c = u * o,
        f = c * e,
        d = c - n,
        p = Ra(u, o),
        h = Math.exp(-f);
      return ja - d / p * h
    }, s = u => {
      const f = u * o * e,
        d = f * n + n,
        p = Math.pow(o, 2) * Math.pow(u, 2) * e,
        h = Math.exp(-f),
        g = Ra(Math.pow(u, 2), o);
      return (-r(u) + ja > 0 ? -1 : 1) * ((d - p) * h) / g
    }) : (r = u => {
      const c = Math.exp(-u * e),
        f = (u - n) * e + 1;
      return -ja + c * f
    }, s = u => {
      const c = Math.exp(-u * e),
        f = (n - u) * (e * e);
      return c * f
    });
    const a = 5 / e,
      l = e0(r, s, a);
    if (e = Ft(e), isNaN(l)) return {
      stiffness: we.stiffness,
      damping: we.damping,
      duration: e
    };
    {
      const u = Math.pow(l, 2) * i;
      return {
        stiffness: u,
        damping: o * 2 * Math.sqrt(i * u),
        duration: e
      }
    }
  }
  const $A = 12;

  function e0(e, t, n) {
    let i = n;
    for (let r = 1; r < $A; r++) i = i - e(i) / t(i);
    return i
  }

  function Ra(e, t) {
    return e * Math.sqrt(1 - t * t)
  }
  const t0 = ["duration", "bounce"],
    n0 = ["stiffness", "damping", "mass"];

  function fd(e, t) {
    return t.some(n => e[n] !== void 0)
  }

  function i0(e) {
    let t = {
      velocity: we.velocity,
      stiffness: we.stiffness,
      damping: we.damping,
      mass: we.mass,
      isResolvedFromDuration: !1,
      ...e
    };
    if (!fd(e, n0) && fd(e, t0))
      if (e.visualDuration) {
        const n = e.visualDuration,
          i = 2 * Math.PI / (n * 1.2),
          r = i * i,
          s = 2 * An(.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(r);
        t = {
          ...t,
          mass: we.mass,
          stiffness: r,
          damping: s
        }
      } else {
        const n = _A(e);
        t = {
          ...t,
          ...n,
          mass: we.mass
        }, t.isResolvedFromDuration = !0
      } return t
  }

  function wr(e = we.visualDuration, t = we.bounce) {
    const n = typeof e != "object" ? {
      visualDuration: e,
      keyframes: [0, 1],
      bounce: t
    } : e;
    let {
      restSpeed: i,
      restDelta: r
    } = n;
    const s = n.keyframes[0],
      o = n.keyframes[n.keyframes.length - 1],
      a = {
        done: !1,
        value: s
      },
      {
        stiffness: l,
        damping: u,
        mass: c,
        duration: f,
        velocity: d,
        isResolvedFromDuration: p
      } = i0({
        ...n,
        velocity: -Kt(n.velocity || 0)
      }),
      h = d || 0,
      g = u / (2 * Math.sqrt(l * c)),
      A = o - s,
      m = Kt(Math.sqrt(l / c)),
      x = Math.abs(A) < 5;
    i || (i = x ? we.restSpeed.granular : we.restSpeed.default), r || (r = x ? we.restDelta.granular : we.restDelta.default);
    let T;
    if (g < 1) {
      const O = Ra(m, g);
      T = N => {
        const V = Math.exp(-g * m * N);
        return o - V * ((h + g * m * A) / O * Math.sin(O * N) + A * Math.cos(O * N))
      }
    } else if (g === 1) T = O => o - Math.exp(-m * O) * (A + (h + m * A) * O);
    else {
      const O = m * Math.sqrt(g * g - 1);
      T = N => {
        const V = Math.exp(-g * m * N),
          R = Math.min(O * N, 300);
        return o - V * ((h + g * m * A) * Math.sinh(R) + O * A * Math.cosh(R)) / O
      }
    }
    const P = {
      calculatedDuration: p && f || null,
      next: O => {
        const N = T(O);
        if (p) a.done = O >= f;
        else {
          let V = O === 0 ? h : 0;
          g < 1 && (V = O === 0 ? Ft(h) : ud(T, O, N));
          const R = Math.abs(V) <= i,
            C = Math.abs(o - N) <= r;
          a.done = R && C
        }
        return a.value = a.done ? o : N, a
      },
      toString: () => {
        const O = Math.min(Sa(P), xs),
          N = cd(V => P.next(O * V).value, O, 30);
        return O + "ms " + N
      },
      toTransition: () => {}
    };
    return P
  }
  wr.applyToOptions = e => {
    const t = td(e, 100, wr);
    return e.ease = t.ease, e.duration = Ft(t.duration), e.type = "keyframes", e
  };

  function Fa({
    keyframes: e,
    velocity: t = 0,
    power: n = .8,
    timeConstant: i = 325,
    bounceDamping: r = 10,
    bounceStiffness: s = 500,
    modifyTarget: o,
    min: a,
    max: l,
    restDelta: u = .5,
    restSpeed: c
  }) {
    const f = e[0],
      d = {
        done: !1,
        value: f
      },
      p = R => a !== void 0 && R < a || l !== void 0 && R > l,
      h = R => a === void 0 ? l : l === void 0 || Math.abs(a - R) < Math.abs(l - R) ? a : l;
    let g = n * t;
    const A = f + g,
      m = o === void 0 ? A : o(A);
    m !== A && (g = m - f);
    const x = R => -g * Math.exp(-R / i),
      T = R => m + x(R),
      P = R => {
        const C = x(R),
          I = T(R);
        d.done = Math.abs(C) <= u, d.value = d.done ? m : I
      };
    let O, N;
    const V = R => {
      p(d.value) && (O = R, N = wr({
        keyframes: [d.value, h(d.value)],
        velocity: ud(T, R, d.value),
        damping: r,
        stiffness: s,
        restDelta: u,
        restSpeed: c
      }))
    };
    return V(0), {
      calculatedDuration: null,
      next: R => {
        let C = !1;
        return !N && O === void 0 && (C = !0, P(R), V(R)), O !== void 0 && R >= O ? N.next(R - O) : (!C && P(R), d)
      }
    }
  }

  function r0(e, t, n) {
    const i = [],
      r = n || yn.mix || ld,
      s = e.length - 1;
    for (let o = 0; o < s; o++) {
      let a = r(e[o], e[o + 1]);
      if (t) {
        const l = Array.isArray(t) ? t[o] || st : t;
        a = Pr(l, a)
      }
      i.push(a)
    }
    return i
  }

  function s0(e, t, {
    clamp: n = !0,
    ease: i,
    mixer: r
  } = {}) {
    const s = e.length;
    if (wa(s === t.length), s === 1) return () => t[0];
    if (s === 2 && t[0] === t[1]) return () => t[1];
    const o = e[0] === e[1];
    e[0] > e[s - 1] && (e = [...e].reverse(), t = [...t].reverse());
    const a = r0(t, i, r),
      l = a.length,
      u = c => {
        if (o && c < e[0]) return t[0];
        let f = 0;
        if (l > 1)
          for (; f < e.length - 2 && !(c < e[f + 1]); f++);
        const d = Ni(e[f], e[f + 1], c);
        return a[f](d)
      };
    return n ? c => u(An(e[0], e[s - 1], c)) : u
  }

  function o0(e, t) {
    return e.map(n => n * t)
  }
  const dd = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e,
    a0 = 1e-7,
    l0 = 12;

  function c0(e, t, n, i, r) {
    let s, o, a = 0;
    do o = t + (n - t) / 2, s = dd(o, i, r) - e, s > 0 ? n = o : t = o; while (Math.abs(s) > a0 && ++a < l0);
    return o
  }

  function xr(e, t, n, i) {
    if (e === t && n === i) return st;
    const r = s => c0(s, 0, 1, e, n);
    return s => s === 0 || s === 1 ? s : dd(r(s), t, i)
  }
  const u0 = xr(.42, 0, 1, 1),
    f0 = xr(0, 0, .58, 1),
    pd = xr(.42, 0, .58, 1),
    hd = e => t => t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2,
    md = e => t => 1 - e(1 - t),
    vd = xr(.33, 1.53, .69, .99),
    Ca = md(vd),
    gd = hd(Ca),
    yd = e => (e *= 2) < 1 ? .5 * Ca(e) : .5 * (2 - Math.pow(2, -10 * (e - 1))),
    Wa = e => 1 - Math.sin(Math.acos(e)),
    bd = md(Wa),
    Ad = hd(Wa),
    Pd = e => Array.isArray(e) && typeof e[0] == "number",
    d0 = {
      linear: st,
      easeIn: u0,
      easeInOut: pd,
      easeOut: f0,
      circIn: Wa,
      circInOut: Ad,
      circOut: bd,
      backIn: Ca,
      backInOut: gd,
      backOut: vd,
      anticipate: yd
    },
    p0 = e => typeof e == "string",
    wd = e => {
      if (Pd(e)) {
        wa(e.length === 4);
        const [t, n, i, r] = e;
        return xr(t, n, i, r)
      } else if (p0(e)) return d0[e];
      return e
    };

  function h0(e, t) {
    return e.map(() => t || pd).splice(0, e.length - 1)
  }

  function Tr({
    duration: e = 300,
    keyframes: t,
    times: n,
    ease: i = "easeInOut"
  }) {
    const r = Qf(i) ? i.map(wd) : wd(i),
      s = {
        done: !1,
        value: t[0]
      },
      o = o0(n && n.length === t.length ? n : ed(t), e),
      a = s0(o, t, {
        ease: Array.isArray(r) ? r : h0(t, r)
      });
    return {
      calculatedDuration: e,
      next: l => (s.value = a(l), s.done = l >= e, s)
    }
  }
  const m0 = e => e !== null;

  function Ha(e, {
    repeat: t,
    repeatType: n = "loop"
  }, i, r = 1) {
    const s = e.filter(m0),
      a = r < 0 || t && n !== "loop" && t % 2 === 1 ? 0 : s.length - 1;
    return !a || i === void 0 ? s[a] : i
  }
  const v0 = {
    decay: Fa,
    inertia: Fa,
    tween: Tr,
    keyframes: Tr,
    spring: wr
  };

  function xd(e) {
    typeof e.type == "string" && (e.type = v0[e.type])
  }
  class ka {
    constructor() {
      this.updateFinished()
    }
    get finished() {
      return this._finished
    }
    updateFinished() {
      this._finished = new Promise(t => {
        this.resolve = t
      })
    }
    notifyFinished() {
      this.resolve()
    }
    then(t, n) {
      return this.finished.then(t, n)
    }
  }
  const g0 = e => e / 100;
  class Ea extends ka {
    constructor(t) {
      super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => {
        var n, i;
        const {
          motionValue: r
        } = this.options;
        r && r.updatedAt !== ot.now() && this.tick(ot.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), (i = (n = this.options).onStop) == null || i.call(n))
      }, this.options = t, this.initAnimation(), this.play(), t.autoplay === !1 && this.pause()
    }
    initAnimation() {
      const {
        options: t
      } = this;
      xd(t);
      const {
        type: n = Tr,
        repeat: i = 0,
        repeatDelay: r = 0,
        repeatType: s,
        velocity: o = 0
      } = t;
      let {
        keyframes: a
      } = t;
      const l = n || Tr;
      l !== Tr && typeof a[0] != "number" && (this.mixKeyframes = Pr(g0, ld(a[0], a[1])), a = [0, 100]);
      const u = l({
        ...t,
        keyframes: a
      });
      s === "mirror" && (this.mirroredGenerator = l({
        ...t,
        keyframes: [...a].reverse(),
        velocity: -o
      })), u.calculatedDuration === null && (u.calculatedDuration = Sa(u));
      const {
        calculatedDuration: c
      } = u;
      this.calculatedDuration = c, this.resolvedDuration = c + r, this.totalDuration = this.resolvedDuration * (i + 1) - r, this.generator = u
    }
    updateTime(t) {
      const n = Math.round(t - this.startTime) * this.playbackSpeed;
      this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = n
    }
    tick(t, n = !1) {
      const {
        generator: i,
        totalDuration: r,
        mixKeyframes: s,
        mirroredGenerator: o,
        resolvedDuration: a,
        calculatedDuration: l
      } = this;
      if (this.startTime === null) return i.next(0);
      const {
        delay: u = 0,
        keyframes: c,
        repeat: f,
        repeatType: d,
        repeatDelay: p,
        type: h,
        onUpdate: g,
        finalKeyframe: A
      } = this.options;
      this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - r / this.speed, this.startTime)), n ? this.currentTime = t : this.updateTime(t);
      const m = this.currentTime - u * (this.playbackSpeed >= 0 ? 1 : -1),
        x = this.playbackSpeed >= 0 ? m < 0 : m > r;
      this.currentTime = Math.max(m, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = r);
      let T = this.currentTime,
        P = i;
      if (f) {
        const R = Math.min(this.currentTime, r) / a;
        let C = Math.floor(R),
          I = R % 1;
        !I && R >= 1 && (I = 1), I === 1 && C--, C = Math.min(C, f + 1), !!(C % 2) && (d === "reverse" ? (I = 1 - I, p && (I -= p / a)) : d === "mirror" && (P = o)), T = An(0, 1, I) * a
      }
      const O = x ? {
        done: !1,
        value: c[0]
      } : P.next(T);
      s && (O.value = s(O.value));
      let {
        done: N
      } = O;
      !x && l !== null && (N = this.playbackSpeed >= 0 ? this.currentTime >= r : this.currentTime <= 0);
      const V = this.holdTime === null && (this.state === "finished" || this.state === "running" && N);
      return V && h !== Fa && (O.value = Ha(c, this.options, A, this.speed)), g && g(O.value), V && this.finish(), O
    }
    then(t, n) {
      return this.finished.then(t, n)
    }
    get duration() {
      return Kt(this.calculatedDuration)
    }
    get time() {
      return Kt(this.currentTime)
    }
    set time(t) {
      var n;
      t = Ft(t), this.currentTime = t, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.playbackSpeed), (n = this.driver) == null || n.start(!1)
    }
    get speed() {
      return this.playbackSpeed
    }
    set speed(t) {
      this.updateTime(ot.now());
      const n = this.playbackSpeed !== t;
      this.playbackSpeed = t, n && (this.time = Kt(this.currentTime))
    }
    play() {
      var t, n;
      if (this.isStopped) return;
      const {
        driver: i = YA,
        startTime: r
      } = this.options;
      this.driver || (this.driver = i(o => this.tick(o))), (n = (t = this.options).onPlay) == null || n.call(t);
      const s = this.driver.now();
      this.state === "finished" ? (this.updateFinished(), this.startTime = s) : this.holdTime !== null ? this.startTime = s - this.holdTime : this.startTime || (this.startTime = r ?? s), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start()
    }
    pause() {
      this.state = "paused", this.updateTime(ot.now()), this.holdTime = this.currentTime
    }
    complete() {
      this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null
    }
    finish() {
      var t, n;
      this.notifyFinished(), this.teardown(), this.state = "finished", (n = (t = this.options).onComplete) == null || n.call(t)
    }
    cancel() {
      var t, n;
      this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), (n = (t = this.options).onCancel) == null || n.call(t)
    }
    teardown() {
      this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null
    }
    stopDriver() {
      this.driver && (this.driver.stop(), this.driver = void 0)
    }
    sample(t) {
      return this.startTime = 0, this.tick(t, !0)
    }
    attachTimeline(t) {
      var n;
      return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), (n = this.driver) == null || n.stop(), t.observe(this)
    }
  }
  const y0 = e => e.startsWith("--");

  function b0(e, t, n) {
    y0(t) ? e.style.setProperty(t, n) : e.style[t] = n
  }

  function Ma(e) {
    let t;
    return () => (t === void 0 && (t = e()), t)
  }
  const A0 = Ma(() => window.ScrollTimeline !== void 0),
    P0 = {};

  function w0(e, t) {
    const n = Ma(e);
    return () => P0[t] ?? n()
  }
  const Td = w0(() => {
      try {
        document.createElement("div").animate({
          opacity: 0
        }, {
          easing: "linear(0, 1)"
        })
      } catch {
        return !1
      }
      return !0
    }, "linearEasing"),
    Lr = ([e, t, n, i]) => `cubic-bezier(${e}, ${t}, ${n}, ${i})`,
    Ld = {
      linear: "linear",
      ease: "ease",
      easeIn: "ease-in",
      easeOut: "ease-out",
      easeInOut: "ease-in-out",
      circIn: Lr([0, .65, .55, 1]),
      circOut: Lr([.55, 0, 1, .45]),
      backIn: Lr([.31, .01, .66, -.59]),
      backOut: Lr([.33, 1.53, .69, .99])
    };

  function Sd(e, t) {
    if (e) return typeof e == "function" ? Td() ? cd(e, t) : "ease-out" : Pd(e) ? Lr(e) : Array.isArray(e) ? e.map(n => Sd(n, t) || Ld.easeOut) : Ld[e]
  }

  function x0(e, t, n, {
    delay: i = 0,
    duration: r = 300,
    repeat: s = 0,
    repeatType: o = "loop",
    ease: a = "easeOut",
    times: l
  } = {}, u = void 0) {
    const c = {
      [t]: n
    };
    l && (c.offset = l);
    const f = Sd(a, r);
    Array.isArray(f) && (c.easing = f);
    const d = {
      delay: i,
      duration: r,
      easing: Array.isArray(f) ? "linear" : f,
      fill: "both",
      iterations: s + 1,
      direction: o === "reverse" ? "alternate" : "normal"
    };
    return u && (d.pseudoElement = u), e.animate(c, d)
  }

  function T0({
    type: e,
    ...t
  }) {
    return Oa(e) && Td() ? e.applyToOptions(t) : (t.duration ?? (t.duration = 300), t.ease ?? (t.ease = "easeOut"), t)
  }
  class L0 extends ka {
    constructor(t) {
      if (super(), this.finishedTime = null, this.isStopped = !1, !t) return;
      const {
        element: n,
        name: i,
        keyframes: r,
        pseudoElement: s,
        allowFlatten: o = !1,
        finalKeyframe: a,
        onComplete: l
      } = t;
      this.isPseudoElement = !!s, this.allowFlatten = o, this.options = t, wa(typeof t.type != "string");
      const u = T0(t);
      this.animation = x0(n, i, r, u, s), u.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => {
        if (this.finishedTime = this.time, !s) {
          const c = Ha(r, this.options, a, this.speed);
          this.updateMotionValue ? this.updateMotionValue(c) : b0(n, i, c), this.animation.cancel()
        }
        l == null || l(), this.notifyFinished()
      }
    }
    play() {
      this.isStopped || (this.animation.play(), this.state === "finished" && this.updateFinished())
    }
    pause() {
      this.animation.pause()
    }
    complete() {
      var t, n;
      (n = (t = this.animation).finish) == null || n.call(t)
    }
    cancel() {
      try {
        this.animation.cancel()
      } catch {}
    }
    stop() {
      if (this.isStopped) return;
      this.isStopped = !0;
      const {
        state: t
      } = this;
      t === "idle" || t === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel())
    }
    commitStyles() {
      var t, n;
      this.isPseudoElement || (n = (t = this.animation).commitStyles) == null || n.call(t)
    }
    get duration() {
      var t, n;
      const i = ((n = (t = this.animation.effect) == null ? void 0 : t.getComputedTiming) == null ? void 0 : n.call(t).duration) || 0;
      return Kt(Number(i))
    }
    get time() {
      return Kt(Number(this.animation.currentTime) || 0)
    }
    set time(t) {
      this.finishedTime = null, this.animation.currentTime = Ft(t)
    }
    get speed() {
      return this.animation.playbackRate
    }
    set speed(t) {
      t < 0 && (this.finishedTime = null), this.animation.playbackRate = t
    }
    get state() {
      return this.finishedTime !== null ? "finished" : this.animation.playState
    }
    get startTime() {
      return Number(this.animation.startTime)
    }
    set startTime(t) {
      this.animation.startTime = t
    }
    attachTimeline({
      timeline: t,
      observe: n
    }) {
      var i;
      return this.allowFlatten && ((i = this.animation.effect) == null || i.updateTiming({
        easing: "linear"
      })), this.animation.onfinish = null, t && A0() ? (this.animation.timeline = t, st) : n(this)
    }
  }
  const Od = {
    anticipate: yd,
    backInOut: gd,
    circInOut: Ad
  };

  function S0(e) {
    return e in Od
  }

  function O0(e) {
    typeof e.ease == "string" && S0(e.ease) && (e.ease = Od[e.ease])
  }
  const zd = 10;
  class z0 extends L0 {
    constructor(t) {
      O0(t), xd(t), super(t), t.startTime && (this.startTime = t.startTime), this.options = t
    }
    updateMotionValue(t) {
      const {
        motionValue: n,
        onUpdate: i,
        onComplete: r,
        element: s,
        ...o
      } = this.options;
      if (!n) return;
      if (t !== void 0) {
        n.set(t);
        return
      }
      const a = new Ea({
          ...o,
          autoplay: !1
        }),
        l = Ft(this.finishedTime ?? this.time);
      n.setWithVelocity(a.sample(l - zd).value, a.sample(l).value, zd), a.stop()
    }
  }
  const Xd = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && (Wn.test(e) || e === "0") && !e.startsWith("url("));

  function X0(e) {
    const t = e[0];
    if (e.length === 1) return !0;
    for (let n = 0; n < e.length; n++)
      if (e[n] !== t) return !0
  }

  function D0(e, t, n, i) {
    const r = e[0];
    if (r === null) return !1;
    if (t === "display" || t === "visibility") return !0;
    const s = e[e.length - 1],
      o = Xd(r, t),
      a = Xd(s, t);
    return !o || !a ? !1 : X0(e) || (n === "spring" || Oa(n)) && i
  }

  function Dd(e) {
    return typeof e == "object" && e !== null
  }

  function Vd(e) {
    return Dd(e) && "offsetHeight" in e
  }
  const V0 = new Set(["opacity", "clipPath", "filter", "transform"]),
    N0 = Ma(() => Object.hasOwnProperty.call(Element.prototype, "animate"));

  function j0(e) {
    var t;
    const {
      motionValue: n,
      name: i,
      repeatDelay: r,
      repeatType: s,
      damping: o,
      type: a
    } = e;
    if (!Vd((t = n == null ? void 0 : n.owner) == null ? void 0 : t.current)) return !1;
    const {
      onUpdate: l,
      transformTemplate: u
    } = n.owner.getProps();
    return N0() && i && V0.has(i) && (i !== "transform" || !u) && !l && !r && s !== "mirror" && o !== 0 && a !== "inertia"
  }
  const R0 = 40;
  class F0 extends ka {
    constructor({
      autoplay: t = !0,
      delay: n = 0,
      type: i = "keyframes",
      repeat: r = 0,
      repeatDelay: s = 0,
      repeatType: o = "loop",
      keyframes: a,
      name: l,
      motionValue: u,
      element: c,
      ...f
    }) {
      var d;
      super(), this.stop = () => {
        var g, A;
        this._animation && (this._animation.stop(), (g = this.stopTimeline) == null || g.call(this)), (A = this.keyframeResolver) == null || A.cancel()
      }, this.createdAt = ot.now();
      const p = {
          autoplay: t,
          delay: n,
          type: i,
          repeat: r,
          repeatDelay: s,
          repeatType: o,
          name: l,
          motionValue: u,
          element: c,
          ...f
        },
        h = (c == null ? void 0 : c.KeyframeResolver) || ma;
      this.keyframeResolver = new h(a, (g, A, m) => this.onKeyframesResolved(g, A, p, !m), l, u, c), (d = this.keyframeResolver) == null || d.scheduleResolve()
    }
    onKeyframesResolved(t, n, i, r) {
      this.keyframeResolver = void 0;
      const {
        name: s,
        type: o,
        velocity: a,
        delay: l,
        isHandoff: u,
        onUpdate: c
      } = i;
      this.resolvedAt = ot.now(), D0(t, s, o, a) || ((yn.instantAnimations || !l) && (c == null || c(Ha(t, i, n))), t[0] = t[t.length - 1], i.duration = 0, i.repeat = 0);
      const d = {
          startTime: r ? this.resolvedAt ? this.resolvedAt - this.createdAt > R0 ? this.resolvedAt : this.createdAt : this.createdAt : void 0,
          finalKeyframe: n,
          ...i,
          keyframes: t
        },
        p = !u && j0(d) ? new z0({
          ...d,
          element: d.motionValue.owner.current
        }) : new Ea(d);
      p.finished.then(() => this.notifyFinished()).catch(st), this.pendingTimeline && (this.stopTimeline = p.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = p
    }
    get finished() {
      return this._animation ? this.animation.finished : this._finished
    }
    then(t, n) {
      return this.finished.finally(t).then(() => {})
    }
    get animation() {
      var t;
      return this._animation || ((t = this.keyframeResolver) == null || t.resume(), Xb()), this._animation
    }
    get duration() {
      return this.animation.duration
    }
    get time() {
      return this.animation.time
    }
    set time(t) {
      this.animation.time = t
    }
    get speed() {
      return this.animation.speed
    }
    get state() {
      return this.animation.state
    }
    set speed(t) {
      this.animation.speed = t
    }
    get startTime() {
      return this.animation.startTime
    }
    attachTimeline(t) {
      return this._animation ? this.stopTimeline = this.animation.attachTimeline(t) : this.pendingTimeline = t, () => this.stop()
    }
    play() {
      this.animation.play()
    }
    pause() {
      this.animation.pause()
    }
    complete() {
      this.animation.complete()
    }
    cancel() {
      var t;
      this._animation && this.animation.cancel(), (t = this.keyframeResolver) == null || t.cancel()
    }
  }
  const Ia = (e, t, n, i = {}, r, s) => o => {
    const a = za(i, e) || {},
      l = a.delay || i.delay || 0;
    let {
      elapsed: u = 0
    } = i;
    u = u - Ft(l);
    const c = {
      keyframes: Array.isArray(n) ? n : [null, n],
      ease: "easeOut",
      velocity: t.getVelocity(),
      ...a,
      delay: -u,
      onUpdate: d => {
        t.set(d), a.onUpdate && a.onUpdate(d)
      },
      onComplete: () => {
        o(), a.onComplete && a.onComplete()
      },
      name: e,
      motionValue: t,
      element: s ? void 0 : r
    };
    EA(a) || Object.assign(c, kA(e, c)), c.duration && (c.duration = Ft(c.duration)), c.repeatDelay && (c.repeatDelay = Ft(c.repeatDelay)), c.from !== void 0 && (c.keyframes[0] = c.from);
    let f = !1;
    if ((c.type === !1 || c.duration === 0 && !c.repeatDelay) && (c.duration = 0, c.delay === 0 && (f = !0)), (yn.instantAnimations || yn.skipAnimations) && (f = !0, c.duration = 0, c.delay = 0), c.allowFlatten = !a.type && !a.ease, f && !s && t.get() !== void 0) {
      const d = RA(c.keyframes, a);
      if (d !== void 0) {
        ge.update(() => {
          c.onUpdate(d), c.onComplete()
        });
        return
      }
    }
    return a.isSync ? new Ea(c) : new F0(c)
  };

  function C0({
    protectedKeys: e,
    needsAnimating: t
  }, n) {
    const i = e.hasOwnProperty(n) && t[n] !== !0;
    return t[n] = !1, i
  }

  function W0(e, t, {
    delay: n = 0,
    transitionOverride: i,
    type: r
  } = {}) {
    let {
      transition: s = e.getDefaultTransition(),
      transitionEnd: o,
      ...a
    } = t;
    i && (s = i);
    const l = [],
      u = r && e.animationState && e.animationState.getState()[r];
    for (const c in a) {
      const f = e.getValue(c, e.latestValues[c] ?? null),
        d = a[c];
      if (d === void 0 || u && C0(u, c)) continue;
      const p = {
          delay: n,
          ...za(s || {}, c)
        },
        h = f.get();
      if (h !== void 0 && !f.isAnimating && !Array.isArray(d) && d === h && !p.velocity) continue;
      let g = !1;
      if (window.MotionHandoffAnimation) {
        const m = rd(e);
        if (m) {
          const x = window.MotionHandoffAnimation(m, c, ge);
          x !== null && (p.startTime = x, g = !0)
        }
      }
      VA(e, c), f.start(Ia(c, f, d, e.shouldReduceMotion && kf.has(c) ? {
        type: !1
      } : p, e, g));
      const A = f.animation;
      A && l.push(A)
    }
    return o && Promise.all(l).then(() => {
      ge.update(() => {
        o && XA(e, o)
      })
    }), l
  }

  function H0(e, t) {
    return e in t
  }
  class k0 extends Hf {
    constructor() {
      super(...arguments), this.type = "object"
    }
    readValueFromInstance(t, n) {
      if (H0(n, t)) {
        const i = t[n];
        if (typeof i == "string" || typeof i == "number") return i
      }
    }
    getBaseTargetFromProps() {}
    removeValueFromRenderState(t, n) {
      delete n.output[t]
    }
    measureInstanceViewportBox() {
      return xe()
    }
    build(t, n) {
      Object.assign(t.output, n)
    }
    renderInstance(t, {
      output: n
    }) {
      Object.assign(t, n)
    }
    sortInstanceNodePosition() {
      return 0
    }
  }

  function qa(e) {
    return Dd(e) && "ownerSVGElement" in e
  }

  function Nd(e) {
    return qa(e) && e.tagName === "svg"
  }

  function E0(e) {
    const t = {
        presenceContext: null,
        props: {},
        visualState: {
          renderState: {
            transform: {},
            transformOrigin: {},
            style: {},
            vars: {},
            attrs: {}
          },
          latestValues: {}
        }
      },
      n = qa(e) && !Nd(e) ? new Kf(t) : new Bf(t);
    n.mount(e), si.set(e, n)
  }

  function M0(e) {
    const t = {
        presenceContext: null,
        props: {},
        visualState: {
          renderState: {
            output: {}
          },
          latestValues: {}
        }
      },
      n = new k0(t);
    n.mount(e), si.set(e, n)
  }

  function jd(e, t, n) {
    const i = Le(e) ? e : Oi(e);
    return i.start(Ia("", i, t, n)), i.animation
  }

  function I0(e, t) {
    return Le(e) || typeof e == "number" || typeof e == "string" && !Ta(t)
  }

  function Rd(e, t, n, i) {
    const r = [];
    if (I0(e, t)) r.push(jd(e, Ta(t) && t.default || t, n && (n.default || n)));
    else {
      const s = Jf(e, t, i),
        o = s.length;
      for (let a = 0; a < o; a++) {
        const l = s[a],
          u = l instanceof Element ? E0 : M0;
        si.has(l) || u(l);
        const c = si.get(l),
          f = {
            ...n
          };
        "delay" in f && typeof f.delay == "function" && (f.delay = f.delay(a, o)), r.push(...W0(c, {
          ...t,
          transition: f
        }, {}))
      }
    }
    return r
  }

  function q0(e, t, n) {
    const i = [];
    return AA(e, t, n, {
      spring: wr
    }).forEach(({
      keyframes: s,
      transition: o
    }, a) => {
      i.push(...Rd(a, s, o))
    }), i
  }
  class Z0 {
    constructor(t) {
      this.stop = () => this.runAll("stop"), this.animations = t.filter(Boolean)
    }
    get finished() {
      return Promise.all(this.animations.map(t => t.finished))
    }
    getAll(t) {
      return this.animations[0][t]
    }
    setAll(t, n) {
      for (let i = 0; i < this.animations.length; i++) this.animations[i][t] = n
    }
    attachTimeline(t) {
      const n = this.animations.map(i => i.attachTimeline(t));
      return () => {
        n.forEach((i, r) => {
          i && i(), this.animations[r].stop()
        })
      }
    }
    get time() {
      return this.getAll("time")
    }
    set time(t) {
      this.setAll("time", t)
    }
    get speed() {
      return this.getAll("speed")
    }
    set speed(t) {
      this.setAll("speed", t)
    }
    get state() {
      return this.getAll("state")
    }
    get startTime() {
      return this.getAll("startTime")
    }
    get duration() {
      let t = 0;
      for (let n = 0; n < this.animations.length; n++) t = Math.max(t, this.animations[n].duration);
      return t
    }
    runAll(t) {
      this.animations.forEach(n => n[t]())
    }
    play() {
      this.runAll("play")
    }
    pause() {
      this.runAll("pause")
    }
    cancel() {
      this.runAll("cancel")
    }
    complete() {
      this.runAll("complete")
    }
  }
  class U0 extends Z0 {
    then(t, n) {
      return this.finished.finally(t).then(() => {})
    }
  }

  function B0(e) {
    return Array.isArray(e) && e.some(Array.isArray)
  }

  function G0(e) {
    function t(n, i, r) {
      let s = [];
      return B0(n) ? s = q0(n, i, e) : s = Rd(n, i, r, e), new U0(s)
    }
    return t
  }
  const K0 = G0(),
    J0 = ["initial", "animate", "whileInView", "whileHover", "whilePress", "whileDrag", "whileFocus", "exit"];
  class Y0 extends gn {
    constructor(t) {
      var n;
      super(t), this.animateUpdates = ({
        controlActiveState: i,
        directAnimate: r,
        directTransition: s,
        controlDelay: o = 0,
        isFallback: a,
        isExit: l
      } = {}) => {
        const {
          reducedMotion: u
        } = this.state.options.motionConfig;
        this.state.visualElement.shouldReduceMotion = u === "always" || u === "user" && !!bs.current;
        const c = this.state.target;
        this.state.target = {
          ...this.state.baseTarget
        };
        let f = {};
        f = this.resolveStateAnimation({
          controlActiveState: i,
          directAnimate: r,
          directTransition: s
        });
        const d = this.createAnimationFactories(c, f, o),
          {
            getChildAnimations: p,
            childAnimations: h
          } = this.setupChildAnimations(f, this.state.activeStates, a);
        return this.executeAnimations({
          factories: d,
          getChildAnimations: p,
          childAnimations: h,
          transition: f,
          controlActiveState: i,
          isExit: l
        })
      }, this.state.visualElement = dA(this.state.options.as, {
        presenceContext: null,
        parent: (n = this.state.parent) == null ? void 0 : n.visualElement,
        props: {
          ...this.state.options,
          whileTap: this.state.options.whilePress
        },
        visualState: {
          renderState: {
            transform: {},
            transformOrigin: {},
            style: {},
            vars: {},
            attrs: {}
          },
          latestValues: {
            ...this.state.baseTarget
          }
        },
        reducedMotionConfig: this.state.options.motionConfig.reducedMotion
      }), this.state.animateUpdates = this.animateUpdates, this.state.isMounted() && this.state.startAnimation()
    }
    updateAnimationControlsSubscription() {
      const {
        animate: t
      } = this.state.options;
      Yu(t) && (this.unmountControls = t.subscribe(this.state))
    }
    executeAnimations({
      factories: t,
      getChildAnimations: n,
      transition: i,
      controlActiveState: r,
      isExit: s = !1
    }) {
      const o = () => Promise.all(t.map(f => f()).filter(Boolean)),
        a = {
          ...this.state.target
        },
        l = this.state.element,
        u = f => {
          var d, p;
          l.dispatchEvent(tf("motionstart", a)), (p = (d = this.state.options).onAnimationStart) == null || p.call(d, a), f.then(() => {
            var h, g;
            l.dispatchEvent(tf("motioncomplete", a, s)), (g = (h = this.state.options).onAnimationComplete) == null || g.call(h, a)
          }).catch(st)
        },
        c = () => {
          const f = i != null && i.when ? (i.when === "beforeChildren" ? o() : n()).then(() => i.when === "beforeChildren" ? n() : o()) : Promise.all([o(), n()]);
          return u(f), f
        };
      return r ? c : c()
    }
    setupChildAnimations(t, n, i) {
      var r;
      if (!((r = this.state.visualElement.variantChildren) != null && r.size) || !n) return {
        getChildAnimations: () => Promise.resolve(),
        childAnimations: []
      };
      const {
        staggerChildren: s = 0,
        staggerDirection: o = 1,
        delayChildren: a = 0
      } = t || {}, l = (this.state.visualElement.variantChildren.size - 1) * s, u = o === 1 ? (f = 0) => f * s : (f = 0) => l - f * s, c = Array.from(this.state.visualElement.variantChildren).map((f, d) => {
        const p = a + u(d);
        return f.state.animateUpdates({
          controlActiveState: n,
          controlDelay: i ? 0 : p
        })
      }).filter(Boolean);
      return {
        getChildAnimations: () => Promise.all(c.map(f => f == null ? void 0 : f())),
        childAnimations: c
      }
    }
    createAnimationFactories(t, n, i) {
      const r = [];
      return Object.keys(this.state.target).forEach(s => {
        var o;
        if (!jy(t[s], this.state.target[s])) return;
        (o = this.state.baseTarget)[s] ?? (o[s] = nb.get(this.state.element, s));
        const a = this.state.target[s] === "none" && af(sf[s]) ? sf[s] : this.state.target[s];
        r.push(() => {
          var l;
          return K0(this.state.element, {
            [s]: a
          }, {
            ...(n == null ? void 0 : n[s]) || n,
            delay: (((l = n == null ? void 0 : n[s]) == null ? void 0 : l.delay) || (n == null ? void 0 : n.delay) || 0) + i
          })
        })
      }), r
    }
    resolveStateAnimation({
      controlActiveState: t,
      directAnimate: n,
      directTransition: i
    }) {
      let r = this.state.options.transition,
        s = {};
      const {
        variants: o,
        custom: a,
        transition: l,
        animatePresenceContext: u
      } = this.state.options, c = a ?? (u == null ? void 0 : u.custom);
      return this.state.activeStates = {
        ...this.state.activeStates,
        ...t
      }, J0.forEach(f => {
        if (!this.state.activeStates[f] || Yu(this.state.options[f])) return;
        const d = this.state.options[f];
        let p = af(d) ? vr(d, o, c) : void 0;
        if (this.state.visualElement.isVariantNode) {
          const h = vr(this.state.context[f], o, c);
          p = h ? Object.assign(h || {}, p) : s
        }
        p && (f !== "initial" && (r = p.transition || this.state.options.transition || {}), s = Object.assign(s, p))
      }), n && (s = vr(n, o, c), r = s.transition || i || l), Object.entries(s).forEach(([f, d]) => {
        f !== "transition" && (this.state.target[f] = d)
      }), r
    }
    mount() {
      const {
        element: t
      } = this.state;
      ef.set(t, this.state), si.get(t) || (this.state.visualElement.mount(t), si.set(t, this.state.visualElement)), this.state.visualElement.state = this.state, this.updateAnimationControlsSubscription()
    }
    update() {
      const {
        animate: t
      } = this.state.options, {
        animate: n
      } = this.state.visualElement.prevProps || {};
      t !== n && this.updateAnimationControlsSubscription()
    }
    unmount() {
      var t;
      (t = this.unmountControls) == null || t.call(this)
    }
  }
  const Q0 = {
    y: !1
  };

  function _0() {
    return Q0.y
  }
  const Fd = (e, t) => t ? e === t ? !0 : Fd(e, t.parentElement) : !1,
    $0 = e => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1;

  function Cd(e, t) {
    const n = La(e),
      i = new AbortController,
      r = {
        passive: !0,
        ...t,
        signal: i.signal
      };
    return [n, r, () => i.abort()]
  }
  const eP = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]);

  function tP(e) {
    return eP.has(e.tagName) || e.tabIndex !== -1
  }
  const Ls = new WeakSet;

  function Wd(e) {
    return t => {
      t.key === "Enter" && e(t)
    }
  }

  function Za(e, t) {
    e.dispatchEvent(new PointerEvent("pointer" + t, {
      isPrimary: !0,
      bubbles: !0
    }))
  }
  const nP = (e, t) => {
    const n = e.currentTarget;
    if (!n) return;
    const i = Wd(() => {
      if (Ls.has(n)) return;
      Za(n, "down");
      const r = Wd(() => {
          Za(n, "up")
        }),
        s = () => Za(n, "cancel");
      n.addEventListener("keyup", r, t), n.addEventListener("blur", s, t)
    });
    n.addEventListener("keydown", i, t), n.addEventListener("blur", () => n.removeEventListener("keydown", i), t)
  };

  function Hd(e) {
    return $0(e) && !0
  }

  function iP(e, t, n = {}) {
    const [i, r, s] = Cd(e, n), o = a => {
      const l = a.currentTarget;
      if (!Hd(a)) return;
      Ls.add(l);
      const u = t(l, a),
        c = (p, h) => {
          window.removeEventListener("pointerup", f), window.removeEventListener("pointercancel", d), Ls.has(l) && Ls.delete(l), Hd(p) && typeof u == "function" && u(p, {
            success: h
          })
        },
        f = p => {
          c(p, l === window || l === document || n.useGlobalTarget || Fd(l, p.target))
        },
        d = p => {
          c(p, !1)
        };
      window.addEventListener("pointerup", f, r), window.addEventListener("pointercancel", d, r)
    };
    return i.forEach(a => {
      (n.useGlobalTarget ? window : a).addEventListener("pointerdown", o, r), Vd(a) && (a.addEventListener("focus", u => nP(u, r)), !tP(a) && !a.hasAttribute("tabindex") && (a.tabIndex = 0))
    }), s
  }

  function kd(e) {
    return {
      point: {
        x: e.pageX,
        y: e.pageY
      }
    }
  }

  function Ed(e, t, n) {
    const i = e.options;
    i.whilePress && e.setActive("whilePress", n === "Start");
    const r = `onPress${n==="End"?"":n}`,
      s = i[r];
    s && ge.postRender(() => s(t, kd(t)))
  }
  class rP extends gn {
    isActive() {
      const {
        whilePress: t,
        onPress: n,
        onPressCancel: i,
        onPressStart: r
      } = this.state.options;
      return !!(t || n || i || r)
    }
    constructor(t) {
      super(t)
    }
    mount() {
      this.register()
    }
    update() {
      const {
        whilePress: t,
        onPress: n,
        onPressCancel: i,
        onPressStart: r
      } = this.state.options;
      t || n || i || r || this.register()
    }
    register() {
      const t = this.state.element;
      !t || !this.isActive() || (this.unmount(), this.unmount = iP(t, (n, i) => (Ed(this.state, i, "Start"), (r, {
        success: s
      }) => Ed(this.state, r, s ? "End" : "Cancel")), {
        useGlobalTarget: this.state.options.globalPressTarget
      }))
    }
  }

  function Md(e) {
    return !(e.pointerType === "touch" || _0())
  }

  function sP(e, t, n = {}) {
    const [i, r, s] = Cd(e, n), o = a => {
      if (!Md(a)) return;
      const {
        target: l
      } = a, u = t(l, a);
      if (typeof u != "function" || !l) return;
      const c = f => {
        Md(f) && (u(f), l.removeEventListener("pointerleave", c))
      };
      l.addEventListener("pointerleave", c, r)
    };
    return i.forEach(a => {
      a.addEventListener("pointerenter", o, r)
    }), s
  }

  function Id(e, t, n) {
    const i = e.options;
    i.whileHover && e.setActive("whileHover", n === "Start");
    const r = `onHover${n}`,
      s = i[r];
    s && ge.postRender(() => s(t, kd(t)))
  }
  class oP extends gn {
    isActive() {
      const {
        whileHover: t,
        onHoverStart: n,
        onHoverEnd: i
      } = this.state.options;
      return !!(t || n || i)
    }
    constructor(t) {
      super(t)
    }
    mount() {
      this.register()
    }
    update() {
      const {
        whileHover: t,
        onHoverStart: n,
        onHoverEnd: i
      } = this.state.visualElement.prevProps;
      t || n || i || this.register()
    }
    register() {
      const t = this.state.element;
      !t || !this.isActive() || (this.unmount(), this.unmount = sP(t, (n, i) => (Id(this.state, i, "Start"), r => {
        Id(this.state, r, "End")
      })))
    }
  }
  const aP = {
    some: 0,
    all: 1
  };

  function lP(e, t, {
    root: n,
    margin: i,
    amount: r = "some"
  } = {}) {
    const s = La(e),
      o = new WeakMap,
      a = u => {
        u.forEach(c => {
          const f = o.get(c.target);
          if (c.isIntersecting !== !!f)
            if (c.isIntersecting) {
              const d = t(c.target, c);
              typeof d == "function" ? o.set(c.target, d) : l.unobserve(c.target)
            } else typeof f == "function" && (f(c), o.delete(c.target))
        })
      },
      l = new IntersectionObserver(a, {
        root: n,
        rootMargin: i,
        threshold: typeof r == "number" ? r : aP[r]
      });
    return s.forEach(u => l.observe(u)), () => l.disconnect()
  }

  function qd(e, t, n) {
    const i = e.options;
    i.whileInView && e.setActive("whileInView", n === "Enter");
    const r = `onViewport${n}`,
      s = i[r];
    s && ge.postRender(() => s(t))
  }
  class cP extends gn {
    isActive() {
      const {
        whileInView: t,
        onViewportEnter: n,
        onViewportLeave: i
      } = this.state.options;
      return !!(t || n || i)
    }
    constructor(t) {
      super(t)
    }
    startObserver() {
      const t = this.state.element;
      if (!t || !this.isActive()) return;
      this.unmount();
      const {
        once: n,
        ...i
      } = this.state.options.inViewOptions || {};
      this.unmount = lP(t, (r, s) => {
        if (qd(this.state, s, "Enter"), !n) return o => {
          qd(this.state, s, "Leave")
        }
      }, i)
    }
    mount() {
      this.startObserver()
    }
    update() {
      const {
        props: t,
        prevProps: n
      } = this.state.visualElement;
      ["amount", "margin", "root"].some(uP(t, n)) && this.startObserver()
    }
  }

  function uP({
    inViewOptions: e = {}
  }, {
    inViewOptions: t = {}
  } = {}) {
    return n => e[n] !== t[n]
  }

  function Ss(e, t, n, i = {
    passive: !0
  }) {
    return e.addEventListener(t, n, i), () => e.removeEventListener(t, n)
  }
  class fP extends gn {
    constructor() {
      super(...arguments), this.isActive = !1
    }
    onFocus() {
      let t = !1;
      try {
        t = this.state.element.matches(":focus-visible")
      } catch {
        t = !0
      }
      t && (this.state.setActive("whileFocus", !0), this.isActive = !0)
    }
    onBlur() {
      this.isActive && (this.state.setActive("whileFocus", !1), this.isActive = !1)
    }
    mount() {
      this.unmount = Pr(Ss(this.state.element, "focus", () => this.onFocus()), Ss(this.state.element, "blur", () => this.onBlur()))
    }
  }
  const dP = (e, t) => e.depth - t.depth;
  class pP {
    constructor() {
      this.children = [], this.isDirty = !1
    }
    add(t) {
      oa(this.children, t), this.isDirty = !0
    }
    remove(t) {
      Ps(this.children, t), this.isDirty = !0
    }
    forEach(t) {
      this.isDirty && this.children.sort(dP), this.isDirty = !1, this.children.forEach(t)
    }
  }

  function hP(e, t) {
    const n = ot.now(),
      i = ({
        timestamp: r
      }) => {
        const s = r - n;
        s >= t && (bn(i), e(s - t))
      };
    return ge.setup(i, !0), () => bn(i)
  }

  function Ua(e) {
    return Le(e) ? e.get() : e
  }
  const Zd = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
    mP = Zd.length,
    Ud = e => typeof e == "string" ? parseFloat(e) : e,
    Bd = e => typeof e == "number" || B.test(e);

  function vP(e, t, n, i, r, s) {
    r ? (e.opacity = be(0, n.opacity ?? 1, gP(i)), e.opacityExit = be(t.opacity ?? 1, 0, yP(i))) : s && (e.opacity = be(t.opacity ?? 1, n.opacity ?? 1, i));
    for (let o = 0; o < mP; o++) {
      const a = `border${Zd[o]}Radius`;
      let l = Gd(t, a),
        u = Gd(n, a);
      if (l === void 0 && u === void 0) continue;
      l || (l = 0), u || (u = 0), l === 0 || u === 0 || Bd(l) === Bd(u) ? (e[a] = Math.max(be(Ud(l), Ud(u), i), 0), (Gt.test(u) || Gt.test(l)) && (e[a] += "%")) : e[a] = u
    }(t.rotate || n.rotate) && (e.rotate = be(t.rotate || 0, n.rotate || 0, i))
  }

  function Gd(e, t) {
    return e[t] !== void 0 ? e[t] : e.borderRadius
  }
  const gP = Kd(0, .5, bd),
    yP = Kd(.5, .95, st);

  function Kd(e, t, n) {
    return i => i < e ? 0 : i > t ? 1 : n(Ni(e, t, i))
  }

  function Jd(e, t) {
    e.min = t.min, e.max = t.max
  }

  function Pt(e, t) {
    Jd(e.x, t.x), Jd(e.y, t.y)
  }

  function Yd(e, t) {
    e.translate = t.translate, e.scale = t.scale, e.originPoint = t.originPoint, e.origin = t.origin
  }

  function Ba(e) {
    return e === void 0 || e === 1
  }

  function Ga({
    scale: e,
    scaleX: t,
    scaleY: n
  }) {
    return !Ba(e) || !Ba(t) || !Ba(n)
  }

  function ui(e) {
    return Ga(e) || Qd(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY
  }

  function Qd(e) {
    return _d(e.x) || _d(e.y)
  }

  function _d(e) {
    return e && e !== "0%"
  }

  function Os(e, t, n) {
    const i = e - n,
      r = t * i;
    return n + r
  }

  function $d(e, t, n, i, r) {
    return r !== void 0 && (e = Os(e, r, i)), Os(e, n, i) + t
  }

  function Ka(e, t = 0, n = 1, i, r) {
    e.min = $d(e.min, t, n, i, r), e.max = $d(e.max, t, n, i, r)
  }

  function ep(e, {
    x: t,
    y: n
  }) {
    Ka(e.x, t.translate, t.scale, t.originPoint), Ka(e.y, n.translate, n.scale, n.originPoint)
  }
  const tp = .999999999999,
    np = 1.0000000000001;

  function bP(e, t, n, i = !1) {
    const r = n.length;
    if (!r) return;
    t.x = t.y = 1;
    let s, o;
    for (let a = 0; a < r; a++) {
      s = n[a], o = s.projectionDelta;
      const {
        visualElement: l
      } = s.options;
      l && l.props.style && l.props.style.display === "contents" || (i && s.options.layoutScroll && s.scroll && s !== s.root && ji(e, {
        x: -s.scroll.offset.x,
        y: -s.scroll.offset.y
      }), o && (t.x *= o.x.scale, t.y *= o.y.scale, ep(e, o)), i && ui(s.latestValues) && ji(e, s.latestValues))
    }
    t.x < np && t.x > tp && (t.x = 1), t.y < np && t.y > tp && (t.y = 1)
  }

  function zs(e, t) {
    e.min = e.min + t, e.max = e.max + t
  }

  function ip(e, t, n, i, r = .5) {
    const s = be(e.min, e.max, r);
    Ka(e, t, n, s, i)
  }

  function ji(e, t) {
    ip(e.x, t.x, t.scaleX, t.scale, t.originX), ip(e.y, t.y, t.scaleY, t.scale, t.originY)
  }
  const rp = 1e-4,
    AP = 1 - rp,
    PP = 1 + rp,
    sp = .01,
    wP = 0 - sp,
    xP = 0 + sp;

  function wt(e) {
    return e.max - e.min
  }

  function TP(e, t, n) {
    return Math.abs(e - t) <= n
  }

  function op(e, t, n, i = .5) {
    e.origin = i, e.originPoint = be(t.min, t.max, e.origin), e.scale = wt(n) / wt(t), e.translate = be(n.min, n.max, e.origin) - e.originPoint, (e.scale >= AP && e.scale <= PP || isNaN(e.scale)) && (e.scale = 1), (e.translate >= wP && e.translate <= xP || isNaN(e.translate)) && (e.translate = 0)
  }

  function Sr(e, t, n, i) {
    op(e.x, t.x, n.x, i ? i.originX : void 0), op(e.y, t.y, n.y, i ? i.originY : void 0)
  }

  function ap(e, t, n) {
    e.min = n.min + t.min, e.max = e.min + wt(t)
  }

  function LP(e, t, n) {
    ap(e.x, t.x, n.x), ap(e.y, t.y, n.y)
  }

  function lp(e, t, n) {
    e.min = t.min - n.min, e.max = e.min + wt(t)
  }

  function Or(e, t, n) {
    lp(e.x, t.x, n.x), lp(e.y, t.y, n.y)
  }

  function cp(e, t, n, i, r) {
    return e -= t, e = Os(e, 1 / n, i), r !== void 0 && (e = Os(e, 1 / r, i)), e
  }

  function SP(e, t = 0, n = 1, i = .5, r, s = e, o = e) {
    if (Gt.test(t) && (t = parseFloat(t), t = be(o.min, o.max, t / 100) - o.min), typeof t != "number") return;
    let a = be(s.min, s.max, i);
    e === s && (a -= t), e.min = cp(e.min, t, n, a, r), e.max = cp(e.max, t, n, a, r)
  }

  function up(e, t, [n, i, r], s, o) {
    SP(e, t[n], t[i], t[r], t.scale, s, o)
  }
  const OP = ["x", "scaleX", "originX"],
    zP = ["y", "scaleY", "originY"];

  function fp(e, t, n, i) {
    up(e.x, t, OP, n ? n.x : void 0, i ? i.x : void 0), up(e.y, t, zP, n ? n.y : void 0, i ? i.y : void 0)
  }

  function dp(e) {
    return e.translate === 0 && e.scale === 1
  }

  function pp(e) {
    return dp(e.x) && dp(e.y)
  }

  function hp(e, t) {
    return e.min === t.min && e.max === t.max
  }

  function XP(e, t) {
    return hp(e.x, t.x) && hp(e.y, t.y)
  }

  function mp(e, t) {
    return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max)
  }

  function vp(e, t) {
    return mp(e.x, t.x) && mp(e.y, t.y)
  }

  function gp(e) {
    return wt(e.x) / wt(e.y)
  }

  function yp(e, t) {
    return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint
  }
  class DP {
    constructor() {
      this.members = []
    }
    add(t) {
      oa(this.members, t), t.scheduleRender()
    }
    remove(t) {
      if (Ps(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) {
        const n = this.members[this.members.length - 1];
        n && this.promote(n)
      }
    }
    relegate(t) {
      const n = this.members.findIndex(r => t === r);
      if (n === 0) return !1;
      let i;
      for (let r = n; r >= 0; r--) {
        const s = this.members[r];
        if (s.isPresent !== !1) {
          i = s;
          break
        }
      }
      return i ? (this.promote(i), !0) : !1
    }
    promote(t, n) {
      const i = this.lead;
      if (t !== i && (this.prevLead = i, this.lead = t, t.show(), i)) {
        i.instance && i.scheduleRender(), t.scheduleRender(), t.resumeFrom = i, n && (t.resumeFrom.preserveOpacity = !0), i.snapshot && (t.snapshot = i.snapshot, t.snapshot.latestValues = i.animationValues || i.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0);
        const {
          crossfade: r
        } = t.options;
        r === !1 && i.hide()
      }
    }
    exitAnimationComplete() {
      this.members.forEach(t => {
        const {
          options: n,
          resumingFrom: i
        } = t;
        n.onExitComplete && n.onExitComplete(), i && i.options.onExitComplete && i.options.onExitComplete()
      })
    }
    scheduleRender() {
      this.members.forEach(t => {
        t.instance && t.scheduleRender(!1)
      })
    }
    removeLeadSnapshot() {
      this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
    }
  }

  function VP(e, t, n) {
    let i = "";
    const r = e.x.translate / t.x,
      s = e.y.translate / t.y,
      o = (n == null ? void 0 : n.z) || 0;
    if ((r || s || o) && (i = `translate3d(${r}px, ${s}px, ${o}px) `), (t.x !== 1 || t.y !== 1) && (i += `scale(${1/t.x}, ${1/t.y}) `), n) {
      const {
        transformPerspective: u,
        rotate: c,
        rotateX: f,
        rotateY: d,
        skewX: p,
        skewY: h
      } = n;
      u && (i = `perspective(${u}px) ${i}`), c && (i += `rotate(${c}deg) `), f && (i += `rotateX(${f}deg) `), d && (i += `rotateY(${d}deg) `), p && (i += `skewX(${p}deg) `), h && (i += `skewY(${h}deg) `)
    }
    const a = e.x.scale * t.x,
      l = e.y.scale * t.y;
    return (a !== 1 || l !== 1) && (i += `scale(${a}, ${l})`), i || "none"
  }

  function bp(e) {
    return [e("x"), e("y")]
  }
  const Xs = {
      hasAnimatedSinceResize: !0,
      hasEverUpdated: !1
    },
    {
      schedule: NP
    } = $u(queueMicrotask, !1),
    Ja = ["", "X", "Y", "Z"],
    jP = {
      visibility: "hidden"
    },
    RP = 1e3;
  let FP = 0;

  function Ya(e, t, n, i) {
    const {
      latestValues: r
    } = t;
    r[e] && (n[e] = r[e], t.setStaticValue(e, 0), i && (i[e] = 0))
  }

  function Ap(e) {
    if (e.hasCheckedOptimisedAppear = !0, e.root === e) return;
    const {
      visualElement: t
    } = e.options;
    if (!t) return;
    const n = rd(t);
    if (window.MotionHasOptimisedAnimation(n, "transform")) {
      const {
        layout: r,
        layoutId: s
      } = e.options;
      window.MotionCancelOptimisedAnimation(n, "transform", ge, !(r || s))
    }
    const {
      parent: i
    } = e;
    i && !i.hasCheckedOptimisedAppear && Ap(i)
  }

  function Pp({
    attachResizeListener: e,
    defaultParent: t,
    measureScroll: n,
    checkIsScrollRoot: i,
    resetTransform: r
  }) {
    return class {
      constructor(o = {}, a = t == null ? void 0 : t()) {
        this.id = FP++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = {
          x: 1,
          y: 1
        }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
          this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots())
        }, this.updateProjection = () => {
          this.projectionUpdateScheduled = !1, this.nodes.forEach(HP), this.nodes.forEach(qP), this.nodes.forEach(ZP), this.nodes.forEach(kP)
        }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = o, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0;
        for (let l = 0; l < this.path.length; l++) this.path[l].shouldResetTransform = !0;
        this.root === this && (this.nodes = new pP)
      }
      addEventListener(o, a) {
        return this.eventHandlers.has(o) || this.eventHandlers.set(o, new aa), this.eventHandlers.get(o).add(a)
      }
      notifyListeners(o, ...a) {
        const l = this.eventHandlers.get(o);
        l && l.notify(...a)
      }
      hasListeners(o) {
        return this.eventHandlers.has(o)
      }
      mount(o) {
        if (this.instance) return;
        this.isSVG = qa(o) && !Nd(o), this.instance = o;
        const {
          layoutId: a,
          layout: l,
          visualElement: u
        } = this.options;
        if (u && !u.current && u.mount(o), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (l || a) && (this.isLayoutDirty = !0), e) {
          let c;
          const f = () => this.root.updateBlockedByResize = !1;
          e(o, () => {
            this.root.updateBlockedByResize = !0, c && c(), c = hP(f, 250), Xs.hasAnimatedSinceResize && (Xs.hasAnimatedSinceResize = !1, this.nodes.forEach(xp))
          })
        }
        a && this.root.registerSharedNode(a, this), this.options.animate !== !1 && u && (a || l) && this.addEventListener("didUpdate", ({
          delta: c,
          hasLayoutChanged: f,
          hasRelativeLayoutChanged: d,
          layout: p
        }) => {
          if (this.isTreeAnimationBlocked()) {
            this.target = void 0, this.relativeTarget = void 0;
            return
          }
          const h = this.options.transition || u.getDefaultTransition() || JP,
            {
              onLayoutAnimationStart: g,
              onLayoutAnimationComplete: A
            } = u.getProps(),
            m = !this.targetLayout || !vp(this.targetLayout, p),
            x = !f && d;
          if (this.options.layoutRoot || this.resumeFrom || x || f && (m || !this.currentAnimation)) {
            this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0);
            const T = {
              ...za(h, "layout"),
              onPlay: g,
              onComplete: A
            };
            (u.shouldReduceMotion || this.options.layoutRoot) && (T.delay = 0, T.type = !1), this.startAnimation(T), this.setAnimationOrigin(c, x)
          } else f || xp(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
          this.targetLayout = p
        })
      }
      unmount() {
        this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
        const o = this.getStack();
        o && o.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), bn(this.updateProjection)
      }
      blockUpdate() {
        this.updateManuallyBlocked = !0
      }
      unblockUpdate() {
        this.updateManuallyBlocked = !1
      }
      isUpdateBlocked() {
        return this.updateManuallyBlocked || this.updateBlockedByResize
      }
      isTreeAnimationBlocked() {
        return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
      }
      startUpdate() {
        this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(UP), this.animationId++)
      }
      getTransformTemplate() {
        const {
          visualElement: o
        } = this.options;
        return o && o.getProps().transformTemplate
      }
      willUpdate(o = !0) {
        if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
          this.options.onExitComplete && this.options.onExitComplete();
          return
        }
        if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && Ap(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return;
        this.isLayoutDirty = !0;
        for (let c = 0; c < this.path.length; c++) {
          const f = this.path[c];
          f.shouldResetTransform = !0, f.updateScroll("snapshot"), f.options.layoutRoot && f.willUpdate(!1)
        }
        const {
          layoutId: a,
          layout: l
        } = this.options;
        if (a === void 0 && !l) return;
        const u = this.getTransformTemplate();
        this.prevTransformTemplateValue = u ? u(this.latestValues, "") : void 0, this.updateSnapshot(), o && this.notifyListeners("willUpdate")
      }
      update() {
        if (this.updateScheduled = !1, this.isUpdateBlocked()) {
          this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(wp);
          return
        }
        this.isUpdating || this.nodes.forEach(MP), this.isUpdating = !1, this.nodes.forEach(IP), this.nodes.forEach(CP), this.nodes.forEach(WP), this.clearAllSnapshots();
        const a = ot.now();
        Me.delta = An(0, 1e3 / 60, a - Me.timestamp), Me.timestamp = a, Me.isProcessing = !0, na.update.process(Me), na.preRender.process(Me), na.render.process(Me), Me.isProcessing = !1
      }
      didUpdate() {
        this.updateScheduled || (this.updateScheduled = !0, NP.read(this.scheduleUpdate))
      }
      clearAllSnapshots() {
        this.nodes.forEach(EP), this.sharedNodes.forEach(BP)
      }
      scheduleUpdateProjection() {
        this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, ge.preRender(this.updateProjection, !1, !0))
      }
      scheduleCheckAfterUnmount() {
        ge.postRender(() => {
          this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
        })
      }
      updateSnapshot() {
        this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !wt(this.snapshot.measuredBox.x) && !wt(this.snapshot.measuredBox.y) && (this.snapshot = void 0))
      }
      updateLayout() {
        if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return;
        if (this.resumeFrom && !this.resumeFrom.instance)
          for (let l = 0; l < this.path.length; l++) this.path[l].updateScroll();
        const o = this.layout;
        this.layout = this.measure(!1), this.layoutCorrected = xe(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
        const {
          visualElement: a
        } = this.options;
        a && a.notify("LayoutMeasure", this.layout.layoutBox, o ? o.layoutBox : void 0)
      }
      updateScroll(o = "measure") {
        let a = !!(this.options.layoutScroll && this.instance);
        if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = !1), a && this.instance) {
          const l = i(this.instance);
          this.scroll = {
            animationId: this.root.animationId,
            phase: o,
            isRoot: l,
            offset: n(this.instance),
            wasRoot: this.scroll ? this.scroll.isRoot : l
          }
        }
      }
      resetTransform() {
        if (!r) return;
        const o = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout,
          a = this.projectionDelta && !pp(this.projectionDelta),
          l = this.getTransformTemplate(),
          u = l ? l(this.latestValues, "") : void 0,
          c = u !== this.prevTransformTemplateValue;
        o && this.instance && (a || ui(this.latestValues) || c) && (r(this.instance, u), this.shouldResetTransform = !1, this.scheduleRender())
      }
      measure(o = !0) {
        const a = this.measurePageBox();
        let l = this.removeElementScroll(a);
        return o && (l = this.removeTransform(l)), YP(l), {
          animationId: this.root.animationId,
          measuredBox: a,
          layoutBox: l,
          latestValues: {},
          source: this.id
        }
      }
      measurePageBox() {
        var o;
        const {
          visualElement: a
        } = this.options;
        if (!a) return xe();
        const l = a.measureViewportBox();
        if (!(((o = this.scroll) == null ? void 0 : o.wasRoot) || this.path.some(QP))) {
          const {
            scroll: c
          } = this.root;
          c && (zs(l.x, c.offset.x), zs(l.y, c.offset.y))
        }
        return l
      }
      removeElementScroll(o) {
        var a;
        const l = xe();
        if (Pt(l, o), (a = this.scroll) != null && a.wasRoot) return l;
        for (let u = 0; u < this.path.length; u++) {
          const c = this.path[u],
            {
              scroll: f,
              options: d
            } = c;
          c !== this.root && f && d.layoutScroll && (f.wasRoot && Pt(l, o), zs(l.x, f.offset.x), zs(l.y, f.offset.y))
        }
        return l
      }
      applyTransform(o, a = !1) {
        const l = xe();
        Pt(l, o);
        for (let u = 0; u < this.path.length; u++) {
          const c = this.path[u];
          !a && c.options.layoutScroll && c.scroll && c !== c.root && ji(l, {
            x: -c.scroll.offset.x,
            y: -c.scroll.offset.y
          }), ui(c.latestValues) && ji(l, c.latestValues)
        }
        return ui(this.latestValues) && ji(l, this.latestValues), l
      }
      removeTransform(o) {
        const a = xe();
        Pt(a, o);
        for (let l = 0; l < this.path.length; l++) {
          const u = this.path[l];
          if (!u.instance || !ui(u.latestValues)) continue;
          Ga(u.latestValues) && u.updateSnapshot();
          const c = xe(),
            f = u.measurePageBox();
          Pt(c, f), fp(a, u.latestValues, u.snapshot ? u.snapshot.layoutBox : void 0, c)
        }
        return ui(this.latestValues) && fp(a, this.latestValues), a
      }
      setTargetDelta(o) {
        this.targetDelta = o, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0
      }
      setOptions(o) {
        this.options = {
          ...this.options,
          ...o,
          crossfade: o.crossfade !== void 0 ? o.crossfade : !0
        }
      }
      clearMeasurements() {
        this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1
      }
      forceRelativeParentToResolveTarget() {
        this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Me.timestamp && this.relativeParent.resolveTargetDelta(!0)
      }
      resolveTargetDelta(o = !1) {
        var a;
        const l = this.getLead();
        this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = l.isSharedProjectionDirty);
        const u = !!this.resumingFrom || this !== l;
        if (!(o || u && this.isSharedProjectionDirty || this.isProjectionDirty || (a = this.parent) != null && a.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return;
        const {
          layout: f,
          layoutId: d
        } = this.options;
        if (!(!this.layout || !(f || d))) {
          if (this.resolvedRelativeTargetAt = Me.timestamp, !this.targetDelta && !this.relativeTarget) {
            const p = this.getClosestProjectingParent();
            p && p.layout && this.animationProgress !== 1 ? (this.relativeParent = p, this.forceRelativeParentToResolveTarget(), this.relativeTarget = xe(), this.relativeTargetOrigin = xe(), Or(this.relativeTargetOrigin, this.layout.layoutBox, p.layout.layoutBox), Pt(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
          }
          if (!(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = xe(), this.targetWithTransforms = xe()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), LP(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Pt(this.target, this.layout.layoutBox), ep(this.target, this.targetDelta)) : Pt(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget)) {
            this.attemptToResolveRelativeTarget = !1;
            const p = this.getClosestProjectingParent();
            p && !!p.resumingFrom == !!this.resumingFrom && !p.options.layoutScroll && p.target && this.animationProgress !== 1 ? (this.relativeParent = p, this.forceRelativeParentToResolveTarget(), this.relativeTarget = xe(), this.relativeTargetOrigin = xe(), Or(this.relativeTargetOrigin, this.target, p.target), Pt(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
          }
        }
      }
      getClosestProjectingParent() {
        if (!(!this.parent || Ga(this.parent.latestValues) || Qd(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
      }
      isProjecting() {
        return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
      }
      calcProjection() {
        var o;
        const a = this.getLead(),
          l = !!this.resumingFrom || this !== a;
        let u = !0;
        if ((this.isProjectionDirty || (o = this.parent) != null && o.isProjectionDirty) && (u = !1), l && (this.isSharedProjectionDirty || this.isTransformDirty) && (u = !1), this.resolvedRelativeTargetAt === Me.timestamp && (u = !1), u) return;
        const {
          layout: c,
          layoutId: f
        } = this.options;
        if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(c || f)) return;
        Pt(this.layoutCorrected, this.layout.layoutBox);
        const d = this.treeScale.x,
          p = this.treeScale.y;
        bP(this.layoutCorrected, this.treeScale, this.path, l), a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox, a.targetWithTransforms = xe());
        const {
          target: h
        } = a;
        if (!h) {
          this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
          return
        }!this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (Yd(this.prevProjectionDelta.x, this.projectionDelta.x), Yd(this.prevProjectionDelta.y, this.projectionDelta.y)), Sr(this.projectionDelta, this.layoutCorrected, h, this.latestValues), (this.treeScale.x !== d || this.treeScale.y !== p || !yp(this.projectionDelta.x, this.prevProjectionDelta.x) || !yp(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", h))
      }
      hide() {
        this.isVisible = !1
      }
      show() {
        this.isVisible = !0
      }
      scheduleRender(o = !0) {
        var a;
        if ((a = this.options.visualElement) == null || a.scheduleRender(), o) {
          const l = this.getStack();
          l && l.scheduleRender()
        }
        this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
      }
      createProjectionDeltas() {
        this.prevProjectionDelta = Si(), this.projectionDelta = Si(), this.projectionDeltaWithTransform = Si()
      }
      setAnimationOrigin(o, a = !1) {
        const l = this.snapshot,
          u = l ? l.latestValues : {},
          c = {
            ...this.latestValues
          },
          f = Si();
        (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a;
        const d = xe(),
          p = l ? l.source : void 0,
          h = this.layout ? this.layout.source : void 0,
          g = p !== h,
          A = this.getStack(),
          m = !A || A.members.length <= 1,
          x = !!(g && !m && this.options.crossfade === !0 && !this.path.some(KP));
        this.animationProgress = 0;
        let T;
        this.mixTargetDelta = P => {
          const O = P / 1e3;
          Tp(f.x, o.x, O), Tp(f.y, o.y, O), this.setTargetDelta(f), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Or(d, this.layout.layoutBox, this.relativeParent.layout.layoutBox), GP(this.relativeTarget, this.relativeTargetOrigin, d, O), T && XP(this.relativeTarget, T) && (this.isProjectionDirty = !1), T || (T = xe()), Pt(T, this.relativeTarget)), g && (this.animationValues = c, vP(c, u, this.latestValues, O, x, m)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = O
        }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
      }
      startAnimation(o) {
        var a, l, u;
        this.notifyListeners("animationStart"), (a = this.currentAnimation) == null || a.stop(), (u = (l = this.resumingFrom) == null ? void 0 : l.currentAnimation) == null || u.stop(), this.pendingAnimation && (bn(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = ge.update(() => {
          Xs.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = Oi(0)), this.currentAnimation = jd(this.motionValue, [0, 1e3], {
            ...o,
            velocity: 0,
            isSync: !0,
            onUpdate: c => {
              this.mixTargetDelta(c), o.onUpdate && o.onUpdate(c)
            },
            onStop: () => {},
            onComplete: () => {
              o.onComplete && o.onComplete(), this.completeAnimation()
            }
          }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0
        })
      }
      completeAnimation() {
        this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
        const o = this.getStack();
        o && o.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete")
      }
      finishAnimation() {
        this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(RP), this.currentAnimation.stop()), this.completeAnimation()
      }
      applyTransformsToTarget() {
        const o = this.getLead();
        let {
          targetWithTransforms: a,
          target: l,
          layout: u,
          latestValues: c
        } = o;
        if (!(!a || !l || !u)) {
          if (this !== o && this.layout && u && Xp(this.options.animationType, this.layout.layoutBox, u.layoutBox)) {
            l = this.target || xe();
            const f = wt(this.layout.layoutBox.x);
            l.x.min = o.target.x.min, l.x.max = l.x.min + f;
            const d = wt(this.layout.layoutBox.y);
            l.y.min = o.target.y.min, l.y.max = l.y.min + d
          }
          Pt(a, l), ji(a, c), Sr(this.projectionDeltaWithTransform, this.layoutCorrected, a, c)
        }
      }
      registerSharedNode(o, a) {
        this.sharedNodes.has(o) || this.sharedNodes.set(o, new DP), this.sharedNodes.get(o).add(a);
        const u = a.options.initialPromotionConfig;
        a.promote({
          transition: u ? u.transition : void 0,
          preserveFollowOpacity: u && u.shouldPreserveFollowOpacity ? u.shouldPreserveFollowOpacity(a) : void 0
        })
      }
      isLead() {
        const o = this.getStack();
        return o ? o.lead === this : !0
      }
      getLead() {
        var o;
        const {
          layoutId: a
        } = this.options;
        return a ? ((o = this.getStack()) == null ? void 0 : o.lead) || this : this
      }
      getPrevLead() {
        var o;
        const {
          layoutId: a
        } = this.options;
        return a ? (o = this.getStack()) == null ? void 0 : o.prevLead : void 0
      }
      getStack() {
        const {
          layoutId: o
        } = this.options;
        if (o) return this.root.sharedNodes.get(o)
      }
      promote({
        needsReset: o,
        transition: a,
        preserveFollowOpacity: l
      } = {}) {
        const u = this.getStack();
        u && u.promote(this, l), o && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({
          transition: a
        })
      }
      relegate() {
        const o = this.getStack();
        return o ? o.relegate(this) : !1
      }
      resetSkewAndRotation() {
        const {
          visualElement: o
        } = this.options;
        if (!o) return;
        let a = !1;
        const {
          latestValues: l
        } = o;
        if ((l.z || l.rotate || l.rotateX || l.rotateY || l.rotateZ || l.skewX || l.skewY) && (a = !0), !a) return;
        const u = {};
        l.z && Ya("z", o, u, this.animationValues);
        for (let c = 0; c < Ja.length; c++) Ya(`rotate${Ja[c]}`, o, u, this.animationValues), Ya(`skew${Ja[c]}`, o, u, this.animationValues);
        o.render();
        for (const c in u) o.setStaticValue(c, u[c]), this.animationValues && (this.animationValues[c] = u[c]);
        o.scheduleRender()
      }
      getProjectionStyles(o) {
        if (!this.instance || this.isSVG) return;
        if (!this.isVisible) return jP;
        const a = {
            visibility: ""
          },
          l = this.getTransformTemplate();
        if (this.needsReset) return this.needsReset = !1, a.opacity = "", a.pointerEvents = Ua(o == null ? void 0 : o.pointerEvents) || "", a.transform = l ? l(this.latestValues, "") : "none", a;
        const u = this.getLead();
        if (!this.projectionDelta || !this.layout || !u.target) {
          const p = {};
          return this.options.layoutId && (p.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, p.pointerEvents = Ua(o == null ? void 0 : o.pointerEvents) || ""), this.hasProjected && !ui(this.latestValues) && (p.transform = l ? l({}, "") : "none", this.hasProjected = !1), p
        }
        const c = u.animationValues || u.latestValues;
        this.applyTransformsToTarget(), a.transform = VP(this.projectionDeltaWithTransform, this.treeScale, c), l && (a.transform = l(c, a.transform));
        const {
          x: f,
          y: d
        } = this.projectionDelta;
        a.transformOrigin = `${f.origin*100}% ${d.origin*100}% 0`, u.animationValues ? a.opacity = u === this ? c.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : c.opacityExit : a.opacity = u === this ? c.opacity !== void 0 ? c.opacity : "" : c.opacityExit !== void 0 ? c.opacityExit : 0;
        for (const p in hr) {
          if (c[p] === void 0) continue;
          const {
            correct: h,
            applyTo: g,
            isCSSVariable: A
          } = hr[p], m = a.transform === "none" ? c[p] : h(c[p], u);
          if (g) {
            const x = g.length;
            for (let T = 0; T < x; T++) a[g[T]] = m
          } else A ? this.options.visualElement.renderState.vars[p] = m : a[p] = m
        }
        return this.options.layoutId && (a.pointerEvents = u === this ? Ua(o == null ? void 0 : o.pointerEvents) || "" : "none"), a
      }
      clearSnapshot() {
        this.resumeFrom = this.snapshot = void 0
      }
      resetTree() {
        this.root.nodes.forEach(o => {
          var a;
          return (a = o.currentAnimation) == null ? void 0 : a.stop()
        }), this.root.nodes.forEach(wp), this.root.sharedNodes.clear()
      }
    }
  }

  function CP(e) {
    e.updateLayout()
  }

  function WP(e) {
    var t;
    const n = ((t = e.resumeFrom) == null ? void 0 : t.snapshot) || e.snapshot;
    if (e.isLead() && e.layout && n && e.hasListeners("didUpdate")) {
      const {
        layoutBox: i,
        measuredBox: r
      } = e.layout, {
        animationType: s
      } = e.options, o = n.source !== e.layout.source;
      s === "size" ? bp(f => {
        const d = o ? n.measuredBox[f] : n.layoutBox[f],
          p = wt(d);
        d.min = i[f].min, d.max = d.min + p
      }) : Xp(s, n.layoutBox, i) && bp(f => {
        const d = o ? n.measuredBox[f] : n.layoutBox[f],
          p = wt(i[f]);
        d.max = d.min + p, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[f].max = e.relativeTarget[f].min + p)
      });
      const a = Si();
      Sr(a, i, n.layoutBox);
      const l = Si();
      o ? Sr(l, e.applyTransform(r, !0), n.measuredBox) : Sr(l, i, n.layoutBox);
      const u = !pp(a);
      let c = !1;
      if (!e.resumeFrom) {
        const f = e.getClosestProjectingParent();
        if (f && !f.resumeFrom) {
          const {
            snapshot: d,
            layout: p
          } = f;
          if (d && p) {
            const h = xe();
            Or(h, n.layoutBox, d.layoutBox);
            const g = xe();
            Or(g, i, p.layoutBox), vp(h, g) || (c = !0), f.options.layoutRoot && (e.relativeTarget = g, e.relativeTargetOrigin = h, e.relativeParent = f)
          }
        }
      }
      e.notifyListeners("didUpdate", {
        layout: i,
        snapshot: n,
        delta: l,
        layoutDelta: a,
        hasLayoutChanged: u,
        hasRelativeLayoutChanged: c
      })
    } else if (e.isLead()) {
      const {
        onExitComplete: i
      } = e.options;
      i && i()
    }
    e.options.transition = void 0
  }

  function HP(e) {
    e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty))
  }

  function kP(e) {
    e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1
  }

  function EP(e) {
    e.clearSnapshot()
  }

  function wp(e) {
    e.clearMeasurements()
  }

  function MP(e) {
    e.isLayoutDirty = !1
  }

  function IP(e) {
    const {
      visualElement: t
    } = e.options;
    t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform()
  }

  function xp(e) {
    e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0
  }

  function qP(e) {
    e.resolveTargetDelta()
  }

  function ZP(e) {
    e.calcProjection()
  }

  function UP(e) {
    e.resetSkewAndRotation()
  }

  function BP(e) {
    e.removeLeadSnapshot()
  }

  function Tp(e, t, n) {
    e.translate = be(t.translate, 0, n), e.scale = be(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint
  }

  function Lp(e, t, n, i) {
    e.min = be(t.min, n.min, i), e.max = be(t.max, n.max, i)
  }

  function GP(e, t, n, i) {
    Lp(e.x, t.x, n.x, i), Lp(e.y, t.y, n.y, i)
  }

  function KP(e) {
    return e.animationValues && e.animationValues.opacityExit !== void 0
  }
  const JP = {
      duration: .45,
      ease: [.4, 0, .1, 1]
    },
    Sp = e => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e),
    Op = Sp("applewebkit/") && !Sp("chrome/") ? Math.round : st;

  function zp(e) {
    e.min = Op(e.min), e.max = Op(e.max)
  }

  function YP(e) {
    zp(e.x), zp(e.y)
  }

  function Xp(e, t, n) {
    return e === "position" || e === "preserve-aspect" && !TP(gp(t), gp(n), .2)
  }

  function QP(e) {
    var t;
    return e !== e.root && ((t = e.scroll) == null ? void 0 : t.wasRoot)
  }

  function _P(e, t, n, i = {
    passive: !0
  }) {
    return e.addEventListener(t, n, i), () => e.removeEventListener(t, n)
  }
  const $P = Pp({
      attachResizeListener: (e, t) => _P(e, "resize", t),
      measureScroll: () => ({
        x: document.documentElement.scrollLeft || document.body.scrollLeft,
        y: document.documentElement.scrollTop || document.body.scrollTop
      }),
      checkIsScrollRoot: () => !0
    }),
    Qa = {
      current: void 0
    },
    e1 = Pp({
      measureScroll: e => ({
        x: e.scrollLeft,
        y: e.scrollTop
      }),
      defaultParent: () => {
        if (!Qa.current) {
          const e = new $P({});
          e.mount(window), e.setOptions({
            layoutScroll: !0
          }), Qa.current = e
        }
        return Qa.current
      },
      resetTransform: (e, t) => {
        e.style.transform = t !== void 0 ? t : "none"
      },
      checkIsScrollRoot: e => window.getComputedStyle(e).position === "fixed"
    });

  function Dp(e) {
    if (e) return e.options.allowProjection !== !1 ? e.projection : Dp(e.parent)
  }

  function Vp(e, t) {
    return t.max === t.min ? 0 : e / (t.max - t.min) * 100
  }
  const zr = {
      correct: (e, t) => {
        if (!t.target) return e;
        if (typeof e == "string")
          if (B.test(e)) e = parseFloat(e);
          else return e;
        const n = Vp(e, t.target.x),
          i = Vp(e, t.target.y);
        return `${n}% ${i}%`
      }
    },
    t1 = {
      correct: (e, {
        treeScale: t,
        projectionDelta: n
      }) => {
        const i = e,
          r = Wn.parse(e);
        if (r.length > 5) return i;
        const s = Wn.createTransformer(e),
          o = typeof r[0] != "number" ? 1 : 0,
          a = n.x.scale * t.x,
          l = n.y.scale * t.y;
        r[0 + o] /= a, r[1 + o] /= l;
        const u = be(a, l, .5);
        return typeof r[2 + o] == "number" && (r[2 + o] /= u), typeof r[3 + o] == "number" && (r[3 + o] /= u), s(r)
      }
    },
    Np = {
      borderRadius: {
        ...zr,
        applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
      },
      borderTopLeftRadius: zr,
      borderTopRightRadius: zr,
      borderBottomLeftRadius: zr,
      borderBottomRightRadius: zr,
      boxShadow: t1
    };

  function Xr(e) {
    return typeof e == "object" && e !== null && "nodeType" in e
  }
  class n1 extends gn {
    constructor(t) {
      super(t), Ju(Np)
    }
    initProjection() {
      const t = this.state.options;
      this.state.visualElement.projection = new e1(this.state.visualElement.latestValues, t["data-framer-portal-id"] ? void 0 : Dp(this.state.visualElement.parent)), this.state.visualElement.projection.isPresent = !0, this.setOptions()
    }
    beforeMount() {
      this.initProjection()
    }
    setOptions() {
      const t = this.state.options;
      this.state.visualElement.projection.setOptions({
        layout: t.layout,
        layoutId: t.layoutId,
        alwaysMeasureLayout: !!t.drag || t.dragConstraints && Xr(t.dragConstraints),
        visualElement: this.state.visualElement,
        animationType: typeof t.layout == "string" ? t.layout : "both",
        layoutRoot: t.layoutRoot,
        layoutScroll: t.layoutScroll,
        crossfade: t.crossfade,
        onExitComplete: () => {
          var n;
          if (!((n = this.state.visualElement.projection) != null && n.isPresent)) {
            const i = ta.get(this.state.element);
            this.state.isSafeToRemove = !0, i && i({
              detail: {
                isExit: !0
              }
            }, !0)
          }
        }
      })
    }
    update() {
      this.setOptions()
    }
    mount() {
      var t;
      (t = this.state.visualElement.projection) == null || t.mount(this.state.element)
    }
  }

  function jp(e) {
    return e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1
  }

  function _a(e, t = "page") {
    return {
      point: {
        x: e[`${t}X`],
        y: e[`${t}Y`]
      }
    }
  }

  function i1(e) {
    return t => jp(t) && e(t, _a(t))
  }

  function Dr(e, t, n, i) {
    return Ss(e, t, i1(n), i)
  }

  function Rp(e) {
    let t = null;
    return () => {
      const n = () => {
        t = null
      };
      return t === null ? (t = e, n) : !1
    }
  }
  const Fp = Rp("dragHorizontal"),
    Cp = Rp("dragVertical");

  function r1(e) {
    let t = !1;
    if (e === "y") t = Cp();
    else if (e === "x") t = Fp();
    else {
      const n = Fp(),
        i = Cp();
      n && i ? t = () => {
        n(), i()
      } : (n && n(), i && i())
    }
    return t
  }

  function $a(e) {
    return e.max - e.min
  }

  function s1(e, {
    min: t,
    max: n
  }, i) {
    return t !== void 0 && e < t ? e = i ? be(t, e, i.min) : Math.max(e, t) : n !== void 0 && e > n && (e = i ? be(n, e, i.max) : Math.min(e, n)), e
  }
  const el = .35;

  function o1(e, {
    top: t,
    left: n,
    bottom: i,
    right: r
  }) {
    return {
      x: Wp(e.x, n, r),
      y: Wp(e.y, t, i)
    }
  }

  function Wp(e, t, n) {
    return {
      min: t !== void 0 ? e.min + t : void 0,
      max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0
    }
  }

  function a1(e = el) {
    return e === !1 ? e = 0 : e === !0 && (e = el), {
      x: Hp(e, "left", "right"),
      y: Hp(e, "top", "bottom")
    }
  }

  function Hp(e, t, n) {
    return {
      min: kp(e, t),
      max: kp(e, n)
    }
  }

  function kp(e, t) {
    return typeof e == "number" ? e : e[t] || 0
  }

  function l1(e, t) {
    const n = {};
    return t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n
  }

  function c1(e, t) {
    return {
      x: Ep(e.x, t.x),
      y: Ep(e.y, t.y)
    }
  }

  function Ep(e, t) {
    let n = t.min - e.min,
      i = t.max - e.max;
    return t.max - t.min < e.max - e.min && ([n, i] = [i, n]), {
      min: n,
      max: i
    }
  }

  function u1(e, t) {
    let n = .5;
    const i = $a(e),
      r = $a(t);
    return r > i ? n = Ni(t.min, t.max - i, e.min) : i > r && (n = Ni(e.min, e.max - r, t.min)), An(0, 1, n)
  }
  const Mp = (e, t) => Math.abs(e - t);

  function f1(e, t) {
    const n = Mp(e.x, t.x),
      i = Mp(e.y, t.y);
    return Math.sqrt(n ** 2 + i ** 2)
  }
  class Ip {
    constructor(t, n, {
      transformPagePoint: i,
      contextWindow: r,
      dragSnapToOrigin: s = !1
    } = {}) {
      if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
          if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
          const f = nl(this.lastMoveEventInfo, this.history),
            d = this.startEvent !== null,
            p = f1(f.offset, {
              x: 0,
              y: 0
            }) >= 3;
          if (!d && !p) return;
          const {
            point: h
          } = f, {
            timestamp: g
          } = Me;
          this.history.push({
            ...h,
            timestamp: g
          });
          const {
            onStart: A,
            onMove: m
          } = this.handlers;
          d || (A && A(this.lastMoveEvent, f), this.startEvent = this.lastMoveEvent), m && m(this.lastMoveEvent, f)
        }, this.handlePointerMove = (f, d) => {
          this.lastMoveEvent = f, this.lastMoveEventInfo = tl(d, this.transformPagePoint), ge.update(this.updatePoint, !0)
        }, this.handlePointerUp = (f, d) => {
          this.end();
          const {
            onEnd: p,
            onSessionEnd: h,
            resumeAnimation: g
          } = this.handlers;
          if (this.dragSnapToOrigin && g && g(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return;
          const A = nl(f.type === "pointercancel" ? this.lastMoveEventInfo : tl(d, this.transformPagePoint), this.history);
          this.startEvent && p && p(f, A), h && h(f, A)
        }, !jp(t)) return;
      this.dragSnapToOrigin = s, this.handlers = n, this.transformPagePoint = i, this.contextWindow = r || window;
      const o = _a(t),
        a = tl(o, this.transformPagePoint),
        {
          point: l
        } = a,
        {
          timestamp: u
        } = Me;
      this.history = [{
        ...l,
        timestamp: u
      }];
      const {
        onSessionStart: c
      } = n;
      c && c(t, nl(a, this.history)), this.removeListeners = Pr(Dr(this.contextWindow, "pointermove", this.handlePointerMove), Dr(this.contextWindow, "pointerup", this.handlePointerUp), Dr(this.contextWindow, "pointercancel", this.handlePointerUp))
    }
    updateHandlers(t) {
      this.handlers = t
    }
    end() {
      this.removeListeners && this.removeListeners(), bn(this.updatePoint)
    }
  }

  function tl(e, t) {
    return t ? {
      point: t(e.point)
    } : e
  }

  function qp(e, t) {
    return {
      x: e.x - t.x,
      y: e.y - t.y
    }
  }

  function nl({
    point: e
  }, t) {
    return {
      point: e,
      delta: qp(e, Zp(t)),
      offset: qp(e, d1(t)),
      velocity: p1(t, .1)
    }
  }

  function d1(e) {
    return e[0]
  }

  function Zp(e) {
    return e[e.length - 1]
  }

  function p1(e, t) {
    if (e.length < 2) return {
      x: 0,
      y: 0
    };
    let n = e.length - 1,
      i = null;
    const r = Zp(e);
    for (; n >= 0 && (i = e[n], !(r.timestamp - i.timestamp > Ft(t)));) n--;
    if (!i) return {
      x: 0,
      y: 0
    };
    const s = Kt(r.timestamp - i.timestamp);
    if (s === 0) return {
      x: 0,
      y: 0
    };
    const o = {
      x: (r.x - i.x) / s,
      y: (r.y - i.y) / s
    };
    return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o
  }
  const Up = () => ({
    min: 0,
    max: 0
  });

  function h1() {
    return {
      x: Up(),
      y: Up()
    }
  }

  function Jt(e) {
    return [e("x"), e("y")]
  }

  function m1(e) {
    return !!(Le(e) && e.add)
  }

  function Bp(e, t) {
    const n = e.getValue("willChange");
    if (m1(n)) return n.add(t)
  }

  function Gp({
    top: e,
    left: t,
    right: n,
    bottom: i
  }) {
    return {
      x: {
        min: t,
        max: n
      },
      y: {
        min: e,
        max: i
      }
    }
  }

  function v1(e, t) {
    if (!t) return e;
    const n = t({
        x: e.left,
        y: e.top
      }),
      i = t({
        x: e.right,
        y: e.bottom
      });
    return {
      top: n.y,
      left: n.x,
      bottom: i.y,
      right: i.x
    }
  }

  function g1({
    x: e,
    y: t
  }) {
    return {
      top: t.min,
      right: e.max,
      bottom: t.max,
      left: e.min
    }
  }

  function Kp(e, t) {
    e.min = e.min + t, e.max = e.max + t
  }

  function y1(e, t) {
    return Gp(v1(e.getBoundingClientRect(), t))
  }

  function b1(e, t, n) {
    const i = y1(e, n),
      {
        scroll: r
      } = t;
    return r && (Kp(i.x, r.offset.x), Kp(i.y, r.offset.y)), i
  }

  function Jp(e) {
    return !ta.has(e.current)
  }

  function Yp({
    current: e
  }) {
    return e ? e.ownerDocument.defaultView : null
  }
  const A1 = new WeakMap;
  class P1 {
    constructor(t) {
      this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = {
        x: 0,
        y: 0
      }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = h1(), this.visualElement = t
    }
    start(t, {
      snapToCursor: n = !1
    } = {}) {
      if (!Jp(this.visualElement)) return;
      const i = u => {
          const {
            dragSnapToOrigin: c
          } = this.getProps();
          c ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(_a(u, "page").point)
        },
        r = (u, c) => {
          const {
            drag: f,
            dragPropagation: d,
            onDragStart: p
          } = this.getProps();
          if (f && !d && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = r1(f), !this.openGlobalLock)) return;
          this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Jt(g => {
            let A = this.getAxisMotionValue(g).get() || 0;
            if (Gt.test(A)) {
              const {
                projection: m
              } = this.visualElement;
              if (m && m.layout) {
                const x = m.layout.layoutBox[g];
                x && (A = $a(x) * (parseFloat(A) / 100))
              }
            }
            this.originPoint[g] = A
          }), p && ge.postRender(() => p(u, c)), Bp(this.visualElement, "transform"), this.visualElement.state.setActive("whileDrag", !0)
        },
        s = (u, c) => {
          const {
            dragPropagation: f,
            dragDirectionLock: d,
            onDirectionLock: p,
            onDrag: h
          } = this.getProps();
          if (!f && !this.openGlobalLock) return;
          const {
            offset: g
          } = c;
          if (d && this.currentDirection === null) {
            this.currentDirection = w1(g), this.currentDirection !== null && p && p(this.currentDirection);
            return
          }
          this.updateAxis("x", c.point, g), this.updateAxis("y", c.point, g), this.visualElement.render(), h && h(u, c)
        },
        o = (u, c) => this.stop(u, c),
        a = () => Jt(u => {
          var c;
          return this.getAnimationState(u) === "paused" && ((c = this.getAxisMotionValue(u).animation) == null ? void 0 : c.play())
        }),
        {
          dragSnapToOrigin: l
        } = this.getProps();
      this.panSession = new Ip(t, {
        onSessionStart: i,
        onStart: r,
        onMove: s,
        onSessionEnd: o,
        resumeAnimation: a
      }, {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin: l,
        contextWindow: Yp(this.visualElement)
      })
    }
    stop(t, n) {
      const i = this.isDragging;
      if (this.cancel(), !i) return;
      const {
        velocity: r
      } = n;
      this.startAnimation(r);
      const {
        onDragEnd: s
      } = this.getProps();
      s && ge.postRender(() => s(t, n))
    }
    cancel() {
      this.isDragging = !1;
      const {
        projection: t,
        animationState: n
      } = this.visualElement;
      t && (t.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
      const {
        dragPropagation: i
      } = this.getProps();
      !i && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), this.visualElement.state.setActive("whileDrag", !1)
    }
    updateAxis(t, n, i) {
      const {
        drag: r
      } = this.getProps();
      if (!i || !Ds(t, r, this.currentDirection)) return;
      const s = this.getAxisMotionValue(t);
      let o = this.originPoint[t] + i[t];
      this.constraints && this.constraints[t] && (o = s1(o, this.constraints[t], this.elastic[t])), s.set(o)
    }
    resolveConstraints() {
      var t;
      const {
        dragConstraints: n,
        dragElastic: i
      } = this.getProps(), r = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (t = this.visualElement.projection) == null ? void 0 : t.layout, s = this.constraints;
      n && Xr(n) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : n && r ? this.constraints = o1(r.layoutBox, n) : this.constraints = !1, this.elastic = a1(i), s !== this.constraints && r && this.constraints && !this.hasMutatedConstraints && Jt(o => {
        this.constraints !== !1 && this.getAxisMotionValue(o) && (this.constraints[o] = l1(r.layoutBox[o], this.constraints[o]))
      })
    }
    resolveRefConstraints() {
      const {
        dragConstraints: t,
        onMeasureDragConstraints: n
      } = this.getProps();
      if (!t || !Xr(t)) return !1;
      const i = t,
        {
          projection: r
        } = this.visualElement;
      if (!r || !r.layout) return !1;
      const s = b1(i, r.root, this.visualElement.getTransformPagePoint());
      let o = c1(r.layout.layoutBox, s);
      if (n) {
        const a = n(g1(o));
        this.hasMutatedConstraints = !!a, a && (o = Gp(a))
      }
      return o
    }
    startAnimation(t) {
      const {
        drag: n,
        dragMomentum: i,
        dragElastic: r,
        dragTransition: s,
        dragSnapToOrigin: o,
        onDragTransitionEnd: a
      } = this.getProps(), l = this.constraints || {}, u = Jt(c => {
        if (!Ds(c, n, this.currentDirection)) return;
        let f = l && l[c] || {};
        o && (f = {
          min: 0,
          max: 0
        });
        const d = r ? 200 : 1e6,
          p = r ? 40 : 1e7,
          h = {
            type: "inertia",
            velocity: i ? t[c] : 0,
            bounceStiffness: d,
            bounceDamping: p,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...s,
            ...f
          };
        return this.startAxisValueAnimation(c, h)
      });
      return Promise.all(u).then(a)
    }
    startAxisValueAnimation(t, n) {
      const i = this.getAxisMotionValue(t);
      return Bp(this.visualElement, t), i.start(Ia(t, i, 0, n, this.visualElement, !1))
    }
    stopAnimation() {
      Jp(this.visualElement) && Jt(t => this.getAxisMotionValue(t).stop())
    }
    pauseAnimation() {
      Jt(t => {
        var n;
        return (n = this.getAxisMotionValue(t).animation) == null ? void 0 : n.pause()
      })
    }
    getAnimationState(t) {
      var n;
      return (n = this.getAxisMotionValue(t).animation) == null ? void 0 : n.state
    }
    getAxisMotionValue(t) {
      const n = `_drag${t.toUpperCase()}`,
        i = this.visualElement.getProps();
      return i[n] || this.visualElement.getValue(t, (i.initial ? i.initial[t] : void 0) || 0)
    }
    snapToCursor(t) {
      Jt(n => {
        const {
          drag: i
        } = this.getProps();
        if (!Ds(n, i, this.currentDirection)) return;
        const {
          projection: r
        } = this.visualElement, s = this.getAxisMotionValue(n);
        if (r && r.layout) {
          const {
            min: o,
            max: a
          } = r.layout.layoutBox[n];
          s.set(t[n] - be(o, a, .5))
        }
      })
    }
    scalePositionWithinConstraints() {
      if (!this.visualElement.current) return;
      const {
        drag: t,
        dragConstraints: n
      } = this.getProps(), {
        projection: i
      } = this.visualElement;
      if (!Xr(n) || !i || !this.constraints) return;
      this.stopAnimation();
      const r = {
        x: 0,
        y: 0
      };
      Jt(o => {
        const a = this.getAxisMotionValue(o);
        if (a && this.constraints !== !1) {
          const l = a.get();
          r[o] = u1({
            min: l,
            max: l
          }, this.constraints[o])
        }
      });
      const {
        transformTemplate: s
      } = this.visualElement.getProps();
      this.visualElement.current.style.transform = s ? s({}, "") : "none", i.root && i.root.updateScroll(), i.updateLayout(), this.resolveConstraints(), Jt(o => {
        if (!Ds(o, t, null)) return;
        const a = this.getAxisMotionValue(o),
          {
            min: l,
            max: u
          } = this.constraints[o];
        a.set(be(l, u, r[o]))
      })
    }
    addListeners() {
      if (!this.visualElement.current) return;
      A1.set(this.visualElement, this);
      const t = this.visualElement.current,
        n = Dr(t, "pointerdown", l => {
          const {
            drag: u,
            dragListener: c = !0
          } = this.getProps();
          u && c && this.start(l)
        }),
        i = () => {
          const {
            dragConstraints: l
          } = this.getProps();
          Xr(l) && (this.constraints = this.resolveRefConstraints())
        },
        {
          projection: r
        } = this.visualElement,
        s = r.addEventListener("measure", i);
      r && !r.layout && (r.root && r.root.updateScroll(), r.updateLayout()), ge.read(i);
      const o = Ss(window, "resize", () => this.scalePositionWithinConstraints()),
        a = r.addEventListener("didUpdate", ({
          delta: l,
          hasLayoutChanged: u
        }) => {
          this.isDragging && u && (Jt(c => {
            const f = this.getAxisMotionValue(c);
            f && (this.originPoint[c] += l[c].translate, f.set(f.get() + l[c].translate))
          }), this.visualElement.render())
        });
      return () => {
        o(), n(), s(), a && a()
      }
    }
    getProps() {
      const t = this.visualElement.getProps(),
        {
          drag: n = !1,
          dragDirectionLock: i = !1,
          dragPropagation: r = !1,
          dragConstraints: s = !1,
          dragElastic: o = el,
          dragMomentum: a = !0
        } = t;
      return {
        ...t,
        drag: n,
        dragDirectionLock: i,
        dragPropagation: r,
        dragConstraints: s,
        dragElastic: o,
        dragMomentum: a
      }
    }
  }

  function Ds(e, t, n) {
    return (t === !0 || t === e) && (n === null || n === e)
  }

  function w1(e, t = 10) {
    let n = null;
    return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"), n
  }
  class x1 extends gn {
    constructor(t) {
      super(t), this.removeGroupControls = st, this.removeListeners = st, this.controls = new P1(t.visualElement)
    }
    mount() {
      const {
        dragControls: t
      } = this.state.options;
      t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || st
    }
    unmount() {
      this.removeGroupControls(), this.removeListeners()
    }
  }
  class T1 extends gn {
    constructor(t) {
      super(t), Ju(Np)
    }
    beforeUpdate() {
      this.state.willUpdate("beforeUpdate")
    }
    update() {
      this.didUpdate()
    }
    didUpdate() {
      var t, n;
      (this.state.options.layout || this.state.options.layoutId || this.state.options.drag) && ((n = (t = this.state.visualElement.projection) == null ? void 0 : t.root) == null || n.didUpdate())
    }
    mount() {
      var t;
      const n = this.state.options,
        i = this.state.options.layoutGroup;
      if (n.layout || n.layoutId) {
        const r = this.state.visualElement.projection;
        r && (r.promote(), (t = i == null ? void 0 : i.group) == null || t.add(r)), Xs.hasEverUpdated = !0
      }
      this.didUpdate()
    }
    beforeUnmount() {
      const t = this.state.visualElement.projection;
      t && (this.state.willUpdate("beforeUnmount"), this.state.options.layoutId ? (t.isPresent = !1, t.relegate()) : this.state.options.layout && (this.state.isSafeToRemove = !0))
    }
    unmount() {
      const t = this.state.options.layoutGroup,
        n = this.state.visualElement.projection;
      n && (t != null && t.group && (this.state.options.layout || this.state.options.layoutId) && t.group.remove(n), this.didUpdate())
    }
  }

  function Qp(e) {
    return (t, n) => {
      e && ge.postRender(() => e(t, n))
    }
  }
  class L1 extends gn {
    constructor() {
      super(...arguments), this.removePointerDownListener = st
    }
    onPointerDown(t) {
      this.session = new Ip(t, this.createPanHandlers(), {
        transformPagePoint: this.state.visualElement.getTransformPagePoint(),
        contextWindow: Yp(this.state.visualElement)
      })
    }
    createPanHandlers() {
      return {
        onSessionStart: Qp((t, n) => {
          const {
            onPanSessionStart: i
          } = this.state.options;
          i && i(t, n)
        }),
        onStart: Qp((t, n) => {
          const {
            onPanStart: i
          } = this.state.options;
          i && i(t, n)
        }),
        onMove: (t, n) => {
          const {
            onPan: i
          } = this.state.options;
          i && i(t, n)
        },
        onEnd: (t, n) => {
          const {
            onPanEnd: i
          } = this.state.options;
          delete this.session, i && ge.postRender(() => i(t, n))
        }
      }
    }
    mount() {
      this.removePointerDownListener = Dr(this.state.element, "pointerdown", this.onPointerDown.bind(this))
    }
    update() {}
    unmount() {
      this.removePointerDownListener(), this.session && this.session.end()
    }
  }
  const S1 = [Y0, rP, oP, cP, fP, n1, L1, x1, T1],
    O1 = {
      reducedMotion: "never",
      transition: void 0,
      nonce: void 0
    },
    [z1, t9] = mr("MotionConfig");

  function X1() {
    return z1(le(() => O1))
  }

  function Vs(e) {
    return (e == null ? void 0 : e.nodeType) === 3 || (e == null ? void 0 : e.nodeType) === 8 ? Vs(e.nextSibling) : e
  }
  const [D1, n9] = mr("LazyMotionContext");

  function V1(e) {
    const t = Dy(null),
      n = Ny({}),
      i = X1(),
      r = Ey({}),
      s = D1({
        features: te([]),
        strict: !1
      }),
      o = cg();

    function a() {
      return n.id && e.layoutId ? `${n.id}-${e.layoutId}` : e.layoutId || void 0
    }

    function l() {
      return {
        ...e,
        lazyMotionContext: s,
        layoutId: a(),
        transition: e.transition ?? i.value.transition,
        layoutGroup: n,
        motionConfig: i.value,
        inViewOptions: e.inViewOptions ?? i.value.inViewOptions,
        animatePresenceContext: r,
        initial: r.initial === !1 ? r.initial : e.initial === !0 ? void 0 : e.initial
      }
    }

    function u() {
      return {
        ...o,
        ...l()
      }
    }
    const c = new Uy(u(), t);
    Vy(c);

    function f() {
      var p;
      const h = c.type === "svg",
        g = {
          ...o
        };
      Object.keys(o).forEach(x => {
        Le(o[x]) && (g[x] = o[x].get())
      });
      let A = {
        ...e.style,
        ...h ? {} : ((p = c.visualElement) == null ? void 0 : p.latestValues) || c.baseTarget
      };
      if (h) {
        const {
          attrs: x,
          style: T
        } = ab({
          ...c.isMounted() ? c.target : c.baseTarget,
          ...A
        });
        (T.transform || x.transformOrigin) && (T.transformOrigin = x.transformOrigin ?? "50% 50%", delete x.transformOrigin), T.transform && (T.transformBox = T.transformBox ?? "fill-box", delete x.transformBox), Object.assign(g, x), A = T
      }
      e.drag && e.dragListener !== !1 && Object.assign(A, {
        userSelect: "none",
        WebkitUserSelect: "none",
        WebkitTouchCallout: "none",
        touchAction: e.drag === !0 ? "none" : `pan-${e.drag==="x"?"y":"x"}`
      });
      const m = ib(A);
      return m && (g.style = m), g
    }
    const d = ni().proxy;
    return Hc(() => {
      c.beforeMount()
    }), Zt(() => {
      c.mount(Vs(d.$el), u(), j1(d))
    }), as(() => c.beforeUnmount()), $n(() => {
      const p = Vs(d.$el);
      p != null && p.isConnected || c.unmount()
    }), kc(() => {
      c.beforeUpdate()
    }), Ec(() => {
      c.update(u())
    }), {
      getProps: l,
      getAttrs: f,
      layoutGroup: n,
      state: c
    }
  }
  const N1 = {
    ignoreStrict: {
      type: Boolean
    },
    forwardMotionProps: {
      type: Boolean,
      default: !1
    },
    asChild: {
      type: Boolean,
      default: !1
    },
    hover: {
      type: [String, Array, Object]
    },
    press: {
      type: [String, Array, Object]
    },
    inView: {
      type: [String, Array, Object]
    },
    focus: {
      type: [String, Array, Object]
    },
    whileDrag: {
      type: [String, Array, Object]
    },
    whileHover: {
      type: [String, Array, Object],
      default: ({
        hover: e
      }) => e
    },
    whilePress: {
      type: [String, Array, Object],
      default: ({
        press: e
      }) => e
    },
    whileInView: {
      type: [String, Array, Object],
      default: ({
        inView: e
      }) => e
    },
    whileFocus: {
      type: [String, Array, Object],
      default: ({
        focus: e
      }) => e
    },
    custom: {
      type: [String, Number, Object, Array]
    },
    initial: {
      type: [String, Array, Object, Boolean],
      default: void 0
    },
    animate: {
      type: [String, Array, Object],
      default: void 0
    },
    exit: {
      type: [String, Array, Object]
    },
    variants: {
      type: Object
    },
    inherit: {
      type: Boolean
    },
    style: {
      type: Object
    },
    transformTemplate: {
      type: Function
    },
    transition: {
      type: Object
    },
    layoutGroup: {
      type: Object
    },
    motionConfig: {
      type: Object
    },
    onAnimationComplete: {
      type: Function
    },
    onUpdate: {
      type: Function
    },
    layout: {
      type: [Boolean, String],
      default: !1
    },
    layoutId: {
      type: String,
      default: void 0
    },
    layoutScroll: {
      type: Boolean,
      default: !1
    },
    layoutRoot: {
      type: Boolean,
      default: !1
    },
    "data-framer-portal-id": {
      type: String
    },
    crossfade: {
      type: Boolean,
      default: !0
    },
    layoutDependency: {
      type: [String, Number, Object, Array]
    },
    onBeforeLayoutMeasure: {
      type: Function
    },
    onLayoutMeasure: {
      type: Function
    },
    onLayoutAnimationStart: {
      type: Function
    },
    onLayoutAnimationComplete: {
      type: Function
    },
    globalPressTarget: {
      type: Boolean
    },
    onPressStart: {
      type: Function
    },
    onPress: {
      type: Function
    },
    onPressCancel: {
      type: Function
    },
    onHoverStart: {
      type: Function
    },
    onHoverEnd: {
      type: Function
    },
    inViewOptions: {
      type: Object
    },
    onViewportEnter: {
      type: Function
    },
    onViewportLeave: {
      type: Function
    },
    drag: {
      type: [Boolean, String]
    },
    dragSnapToOrigin: {
      type: Boolean
    },
    dragDirectionLock: {
      type: Boolean
    },
    dragPropagation: {
      type: Boolean
    },
    dragConstraints: {
      type: [Boolean, Object]
    },
    dragElastic: {
      type: [Boolean, Number, Object],
      default: .5
    },
    dragMomentum: {
      type: Boolean,
      default: !0
    },
    dragTransition: {
      type: Object
    },
    dragListener: {
      type: Boolean,
      default: !0
    },
    dragControls: {
      type: Object
    },
    onDragStart: {
      type: Function
    },
    onDragEnd: {
      type: Function
    },
    onDrag: {
      type: Function
    },
    onDirectionLock: {
      type: Function
    },
    onDragTransitionEnd: {
      type: Function
    },
    onMeasureDragConstraints: {
      type: Function
    },
    onPanSessionStart: {
      type: Function
    },
    onPanStart: {
      type: Function
    },
    onPan: {
      type: Function
    },
    onPanEnd: {
      type: Function
    }
  };

  function j1(e) {
    var t;
    const n = ((t = Vs(e.$el)) == null ? void 0 : t.style.display) === "none";
    return e.$.vnode.transition && n
  }
  const R1 = new Map,
    F1 = new Map;

  function C1(e) {
    if (!Array.isArray(e)) return [e];
    const t = [];
    for (const n of e) Array.isArray(n) ? t.push(...n) : t.push(n);
    return t
  }
  const W1 = ["area", "img", "input"];

  function H1(e, t, n) {
    var i, r;
    if (typeof e == "string" && W1.includes(e)) return ur(e, t);
    if (e === "template") {
      if (!n.default) return null;
      const s = C1(n.default()),
        o = s.findIndex(c => c.type !== Ee);
      if (o === -1) return s;
      const a = s[o];
      (i = a.props) == null || delete i.ref;
      const l = a.props ? Au(t, a.props) : t;
      t.class && ((r = a.props) != null && r.class) && delete a.props.class;
      const u = pn(a, l);
      for (const c in l) c.startsWith("on") && (u.props || (u.props = {}), u.props[c] = l[c]);
      return s.length === 1 ? u : (s[o] = u, s)
    }
    return null
  }

  function _p(e, t = {}) {
    var n;
    const i = typeof e == "string",
      r = i ? e : e.name || "",
      s = ((n = t.features) == null ? void 0 : n.length) > 0 ? R1 : F1;
    if (i && (s != null && s.has(e))) return s.get(e);
    const o = Ce({
      inheritAttrs: !1,
      props: {
        ...N1,
        features: {
          type: Object,
          default: () => t.features || []
        },
        as: {
          type: [String, Object],
          default: e || "div"
        }
      },
      name: r ? `motion.${r}` : "Motion",
      setup(a, {
        slots: l
      }) {
        const {
          getProps: u,
          getAttrs: c,
          state: f
        } = V1(a);

        function d() {
          const p = f.element;
          if ((!(typeof a.as == "object") || a.asChild) && p) {
            const {
              style: g
            } = c();
            if (g)
              for (const [A, m] of Object.entries(g)) p.style[A] = m
          }
        }
        return () => {
          const p = u(),
            h = c(),
            g = a.asChild ? "template" : a.as,
            A = {
              ...t.forwardMotionProps || a.forwardMotionProps ? p : {},
              ...h,
              onVnodeUpdated: d
            },
            m = H1(g, A, l);
          return m !== null ? m : ur(g, {
            ...A
          }, l)
        }
      }
    });
    return i && (s == null || s.set(e, o)), o
  }

  function k1(e = []) {
    return new Proxy({}, {
      get(t, n) {
        return n === "create" ? (i, r) => _p(i, {
          ...r,
          features: e
        }) : _p(n, {
          features: e
        })
      }
    })
  }
  const Ns = k1(S1);
  Ns.create("div");
  const i9 = "modulepreload",
    r9 = function(e, t) {
      return new URL(e, t).href
    },
    s9 = {},
    Vr = function(t, n, i) {
      let r = Promise.resolve();

      function s(o) {
        const a = new Event("vite:preloadError", {
          cancelable: !0
        });
        if (a.payload = o, window.dispatchEvent(a), !a.defaultPrevented) throw o
      }
      return r.then(o => {
        for (const a of o || []) a.status === "rejected" && s(a.reason);
        return t().catch(s)
      })
    };

  function E1(e) {
    const {
      enabledDomains: t,
      outputs: n
    } = e;

    function i(o, a) {
      return !(t && !t.includes(a) || o === "debug" || o === "info")
    }

    function r(o, a, l, u) {
      if (!i(o, a)) return;
      const f = `[${new Date().toLocaleTimeString()}] [${o.toUpperCase()}] [${a}] ${l}`;
      if (n.includes("console")) {
        const d = {
          error: console.error,
          warn: console.warn,
          info: console.info,
          debug: console.log
        } [o];
        d(f, u || "")
      }
      if (n.includes("sentry") && o === "error") {
        const d = window.Sentry;
        d != null && d.captureException && d.captureException(new Error(l), {
          tags: {
            domain: a
          },
          extra: u
        })
      }
    }

    function s(o) {
      return {
        error: (a, l) => r("error", o, a, l),
        warn: (a, l) => r("warn", o, a, l),
        info: (a, l) => r("info", o, a, l),
        debug: (a, l) => r("debug", o, a, l)
      }
    }
    return {
      log: r,
      forDomain: s
    }
  }
  const Xe = E1({
      enabledDomains: [],
      outputs: ["console"]
    }),
    M1 = Xe.forDomain("ContentFactory"),
    I1 = {
      icon: tr(() => Vr(() => Promise.resolve().then(() => xL), void 0, Ke && Ke.tagName.toUpperCase() === "SCRIPT" && Ke.src || new URL("bundle.js", document.baseURI).href)),
      number: tr(() => Vr(() => Promise.resolve().then(() => NL), void 0, Ke && Ke.tagName.toUpperCase() === "SCRIPT" && Ke.src || new URL("bundle.js", document.baseURI).href)),
      line: tr(() => Vr(() => Promise.resolve().then(() => RL), void 0, Ke && Ke.tagName.toUpperCase() === "SCRIPT" && Ke.src || new URL("bundle.js", document.baseURI).href)),
      timer: tr(() => Vr(() => Promise.resolve().then(() => ML), void 0, Ke && Ke.tagName.toUpperCase() === "SCRIPT" && Ke.src || new URL("bundle.js", document.baseURI).href)),
      money: tr(() => Vr(() => Promise.resolve().then(() => ZL), void 0, Ke && Ke.tagName.toUpperCase() === "SCRIPT" && Ke.src || new URL("bundle.js", document.baseURI).href))
    },
    q1 = e => (M1.info("getContentComponent", e), I1[e]);
  /*!
   * shared v10.0.7
   * (c) 2025 kazuya kawaguchi
   * Released under the MIT License.
   */
  const js = typeof window < "u",
    Hn = (e, t = !1) => t ? Symbol.for(e) : Symbol(e),
    Nr = e => typeof e == "number" && isFinite(e),
    $p = e => nh(e) === "[object RegExp]",
    Z1 = e => Ct(e) && Object.keys(e).length === 0,
    Yt = Object.assign,
    U1 = Object.create,
    at = (e = null) => U1(e);
  let eh;
  const th = () => eh || (eh = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : at()),
    B1 = Object.prototype.hasOwnProperty;

  function Rs(e, t) {
    return B1.call(e, t)
  }
  const Pn = Array.isArray,
    Fs = e => typeof e == "function",
    Oe = e => typeof e == "string",
    wn = e => typeof e == "boolean",
    lt = e => e !== null && typeof e == "object",
    G1 = Object.prototype.toString,
    nh = e => G1.call(e),
    Ct = e => nh(e) === "[object Object]",
    Cs = e => !lt(e) || Pn(e);

  function Ws(e, t) {
    if (Cs(e) || Cs(t)) throw new Error("Invalid value");
    const n = [{
      src: e,
      des: t
    }];
    for (; n.length;) {
      const {
        src: i,
        des: r
      } = n.pop();
      Object.keys(i).forEach(s => {
        s !== "__proto__" && (lt(i[s]) && !lt(r[s]) && (r[s] = Array.isArray(i[s]) ? [] : at()), Cs(r[s]) || Cs(i[s]) ? r[s] = i[s] : n.push({
          src: i[s],
          des: r[s]
        }))
      })
    }
  }
  /*!
   * shared v10.0.7
   * (c) 2025 kazuya kawaguchi
   * Released under the MIT License.
   */
  const K1 = (e, t, n) => J1({
      l: e,
      k: t,
      s: n
    }),
    J1 = e => JSON.stringify(e).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027"),
    _e = e => typeof e == "number" && isFinite(e),
    Y1 = e => rl(e) === "[object Date]",
    ih = e => rl(e) === "[object RegExp]",
    il = e => Ae(e) && Object.keys(e).length === 0,
    kn = Object.assign,
    Q1 = Object.create,
    $e = (e = null) => Q1(e);
  let rh;
  const _1 = () => rh || (rh = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : $e());

  function sh(e) {
    return e.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;")
  }
  const $1 = Object.prototype.hasOwnProperty;

  function fi(e, t) {
    return $1.call(e, t)
  }
  const Qt = Array.isArray,
    De = e => typeof e == "function",
    Y = e => typeof e == "string",
    ct = e => typeof e == "boolean",
    Ie = e => e !== null && typeof e == "object",
    ew = e => Ie(e) && De(e.then) && De(e.catch),
    oh = Object.prototype.toString,
    rl = e => oh.call(e),
    Ae = e => rl(e) === "[object Object]",
    tw = e => e == null ? "" : Qt(e) || Ae(e) && e.toString === oh ? JSON.stringify(e, null, 2) : String(e);

  function sl(e, t = "") {
    return e.reduce((n, i, r) => r === 0 ? n + i : n + t + i, "")
  }

  function nw(e, t) {
    typeof console < "u" && (console.warn("[intlify] " + e), t && console.warn(t.stack))
  }
  /*!
   * message-compiler v10.0.7
   * (c) 2025 kazuya kawaguchi
   * Released under the MIT License.
   */
  function iw(e, t, n) {
    return {
      line: e,
      column: t,
      offset: n
    }
  }

  function ol(e, t, n) {
    return {
      start: e,
      end: t
    }
  }
  const ce = {
      EXPECTED_TOKEN: 1,
      INVALID_TOKEN_IN_PLACEHOLDER: 2,
      UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
      UNKNOWN_ESCAPE_SEQUENCE: 4,
      INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
      UNBALANCED_CLOSING_BRACE: 6,
      UNTERMINATED_CLOSING_BRACE: 7,
      EMPTY_PLACEHOLDER: 8,
      NOT_ALLOW_NEST_PLACEHOLDER: 9,
      INVALID_LINKED_FORMAT: 10,
      MUST_HAVE_MESSAGES_IN_PLURAL: 11,
      UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
      UNEXPECTED_EMPTY_LINKED_KEY: 13,
      UNEXPECTED_LEXICAL_ANALYSIS: 14
    },
    rw = 17;

  function Hs(e, t, n = {}) {
    const {
      domain: i,
      messages: r,
      args: s
    } = n, o = e, a = new SyntaxError(String(o));
    return a.code = e, t && (a.location = t), a.domain = i, a
  }

  function sw(e) {
    throw e
  }
  const xn = " ",
    ow = "\r",
    et = `
`,
    aw = "\u2028",
    lw = "\u2029";

  function cw(e) {
    const t = e;
    let n = 0,
      i = 1,
      r = 1,
      s = 0;
    const o = V => t[V] === ow && t[V + 1] === et,
      a = V => t[V] === et,
      l = V => t[V] === lw,
      u = V => t[V] === aw,
      c = V => o(V) || a(V) || l(V) || u(V),
      f = () => n,
      d = () => i,
      p = () => r,
      h = () => s,
      g = V => o(V) || l(V) || u(V) ? et : t[V],
      A = () => g(n),
      m = () => g(n + s);

    function x() {
      return s = 0, c(n) && (i++, r = 0), o(n) && n++, n++, r++, t[n]
    }

    function T() {
      return o(n + s) && s++, s++, t[n + s]
    }

    function P() {
      n = 0, i = 1, r = 1, s = 0
    }

    function O(V = 0) {
      s = V
    }

    function N() {
      const V = n + s;
      for (; V !== n;) x();
      s = 0
    }
    return {
      index: f,
      line: d,
      column: p,
      peekOffset: h,
      charAt: g,
      currentChar: A,
      currentPeek: m,
      next: x,
      peek: T,
      reset: P,
      resetPeek: O,
      skipToPeek: N
    }
  }
  const En = void 0,
    uw = ".",
    ah = "'",
    fw = "tokenizer";

  function dw(e, t = {}) {
    const n = t.location !== !1,
      i = cw(e),
      r = () => i.index(),
      s = () => iw(i.line(), i.column(), i.index()),
      o = s(),
      a = r(),
      l = {
        currentType: 13,
        offset: a,
        startLoc: o,
        endLoc: o,
        lastType: 13,
        lastOffset: a,
        lastStartLoc: o,
        lastEndLoc: o,
        braceNest: 0,
        inLinked: !1,
        text: ""
      },
      u = () => l,
      {
        onError: c
      } = t;

    function f(v, y, S, ...z) {
      const M = u();
      if (y.column += S, y.offset += S, c) {
        const F = n ? ol(M.startLoc, y) : null,
          L = Hs(v, F, {
            domain: fw,
            args: z
          });
        c(L)
      }
    }

    function d(v, y, S) {
      v.endLoc = s(), v.currentType = y;
      const z = {
        type: y
      };
      return n && (z.loc = ol(v.startLoc, v.endLoc)), S != null && (z.value = S), z
    }
    const p = v => d(v, 13);

    function h(v, y) {
      return v.currentChar() === y ? (v.next(), y) : (f(ce.EXPECTED_TOKEN, s(), 0, y), "")
    }

    function g(v) {
      let y = "";
      for (; v.currentPeek() === xn || v.currentPeek() === et;) y += v.currentPeek(), v.peek();
      return y
    }

    function A(v) {
      const y = g(v);
      return v.skipToPeek(), y
    }

    function m(v) {
      if (v === En) return !1;
      const y = v.charCodeAt(0);
      return y >= 97 && y <= 122 || y >= 65 && y <= 90 || y === 95
    }

    function x(v) {
      if (v === En) return !1;
      const y = v.charCodeAt(0);
      return y >= 48 && y <= 57
    }

    function T(v, y) {
      const {
        currentType: S
      } = y;
      if (S !== 2) return !1;
      g(v);
      const z = m(v.currentPeek());
      return v.resetPeek(), z
    }

    function P(v, y) {
      const {
        currentType: S
      } = y;
      if (S !== 2) return !1;
      g(v);
      const z = v.currentPeek() === "-" ? v.peek() : v.currentPeek(),
        M = x(z);
      return v.resetPeek(), M
    }

    function O(v, y) {
      const {
        currentType: S
      } = y;
      if (S !== 2) return !1;
      g(v);
      const z = v.currentPeek() === ah;
      return v.resetPeek(), z
    }

    function N(v, y) {
      const {
        currentType: S
      } = y;
      if (S !== 7) return !1;
      g(v);
      const z = v.currentPeek() === ".";
      return v.resetPeek(), z
    }

    function V(v, y) {
      const {
        currentType: S
      } = y;
      if (S !== 8) return !1;
      g(v);
      const z = m(v.currentPeek());
      return v.resetPeek(), z
    }

    function R(v, y) {
      const {
        currentType: S
      } = y;
      if (!(S === 7 || S === 11)) return !1;
      g(v);
      const z = v.currentPeek() === ":";
      return v.resetPeek(), z
    }

    function C(v, y) {
      const {
        currentType: S
      } = y;
      if (S !== 9) return !1;
      const z = () => {
          const F = v.currentPeek();
          return F === "{" ? m(v.peek()) : F === "@" || F === "|" || F === ":" || F === "." || F === xn || !F ? !1 : F === et ? (v.peek(), z()) : U(v, !1)
        },
        M = z();
      return v.resetPeek(), M
    }

    function I(v) {
      g(v);
      const y = v.currentPeek() === "|";
      return v.resetPeek(), y
    }

    function U(v, y = !0) {
      const S = (M = !1, F = "") => {
          const L = v.currentPeek();
          return L === "{" || L === "@" || !L ? M : L === "|" ? !(F === xn || F === et) : L === xn ? (v.peek(), S(!0, xn)) : L === et ? (v.peek(), S(!0, et)) : !0
        },
        z = S();
      return y && v.resetPeek(), z
    }

    function j(v, y) {
      const S = v.currentChar();
      return S === En ? En : y(S) ? (v.next(), S) : null
    }

    function Z(v) {
      const y = v.charCodeAt(0);
      return y >= 97 && y <= 122 || y >= 65 && y <= 90 || y >= 48 && y <= 57 || y === 95 || y === 36
    }

    function se(v) {
      return j(v, Z)
    }

    function Ve(v) {
      const y = v.charCodeAt(0);
      return y >= 97 && y <= 122 || y >= 65 && y <= 90 || y >= 48 && y <= 57 || y === 95 || y === 36 || y === 45
    }

    function pe(v) {
      return j(v, Ve)
    }

    function _(v) {
      const y = v.charCodeAt(0);
      return y >= 48 && y <= 57
    }

    function Q(v) {
      return j(v, _)
    }

    function ze(v) {
      const y = v.charCodeAt(0);
      return y >= 48 && y <= 57 || y >= 65 && y <= 70 || y >= 97 && y <= 102
    }

    function zt(v) {
      return j(v, ze)
    }

    function nt(v) {
      let y = "",
        S = "";
      for (; y = Q(v);) S += y;
      return S
    }

    function qe(v) {
      let y = "";
      for (;;) {
        const S = v.currentChar();
        if (S === "{" || S === "}" || S === "@" || S === "|" || !S) break;
        if (S === xn || S === et)
          if (U(v)) y += S, v.next();
          else {
            if (I(v)) break;
            y += S, v.next()
          }
        else y += S, v.next()
      }
      return y
    }

    function zn(v) {
      A(v);
      let y = "",
        S = "";
      for (; y = pe(v);) S += y;
      return v.currentChar() === En && f(ce.UNTERMINATED_CLOSING_BRACE, s(), 0), S
    }

    function Gn(v) {
      A(v);
      let y = "";
      return v.currentChar() === "-" ? (v.next(), y += `-${nt(v)}`) : y += nt(v), v.currentChar() === En && f(ce.UNTERMINATED_CLOSING_BRACE, s(), 0), y
    }

    function rn(v) {
      return v !== ah && v !== et
    }

    function dt(v) {
      A(v), h(v, "'");
      let y = "",
        S = "";
      for (; y = j(v, rn);) y === "\\" ? S += vt(v) : S += y;
      const z = v.currentChar();
      return z === et || z === En ? (f(ce.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, s(), 0), z === et && (v.next(), h(v, "'")), S) : (h(v, "'"), S)
    }

    function vt(v) {
      const y = v.currentChar();
      switch (y) {
        case "\\":
        case "'":
          return v.next(), `\\${y}`;
        case "u":
          return pt(v, y, 4);
        case "U":
          return pt(v, y, 6);
        default:
          return f(ce.UNKNOWN_ESCAPE_SEQUENCE, s(), 0, y), ""
      }
    }

    function pt(v, y, S) {
      h(v, y);
      let z = "";
      for (let M = 0; M < S; M++) {
        const F = zt(v);
        if (!F) {
          f(ce.INVALID_UNICODE_ESCAPE_SEQUENCE, s(), 0, `\\${y}${z}${v.currentChar()}`);
          break
        }
        z += F
      }
      return `\\${y}${z}`
    }

    function Xt(v) {
      return v !== "{" && v !== "}" && v !== xn && v !== et
    }

    function Xn(v) {
      A(v);
      let y = "",
        S = "";
      for (; y = j(v, Xt);) S += y;
      return S
    }

    function oo(v) {
      let y = "",
        S = "";
      for (; y = se(v);) S += y;
      return S
    }

    function b(v) {
      const y = S => {
        const z = v.currentChar();
        return z === "{" || z === "@" || z === "|" || z === "(" || z === ")" || !z || z === xn ? S : (S += z, v.next(), y(S))
      };
      return y("")
    }

    function w(v) {
      A(v);
      const y = h(v, "|");
      return A(v), y
    }

    function D(v, y) {
      let S = null;
      switch (v.currentChar()) {
        case "{":
          return y.braceNest >= 1 && f(ce.NOT_ALLOW_NEST_PLACEHOLDER, s(), 0), v.next(), S = d(y, 2, "{"), A(v), y.braceNest++, S;
        case "}":
          return y.braceNest > 0 && y.currentType === 2 && f(ce.EMPTY_PLACEHOLDER, s(), 0), v.next(), S = d(y, 3, "}"), y.braceNest--, y.braceNest > 0 && A(v), y.inLinked && y.braceNest === 0 && (y.inLinked = !1), S;
        case "@":
          return y.braceNest > 0 && f(ce.UNTERMINATED_CLOSING_BRACE, s(), 0), S = H(v, y) || p(y), y.braceNest = 0, S;
        default: {
          let M = !0,
            F = !0,
            L = !0;
          if (I(v)) return y.braceNest > 0 && f(ce.UNTERMINATED_CLOSING_BRACE, s(), 0), S = d(y, 1, w(v)), y.braceNest = 0, y.inLinked = !1, S;
          if (y.braceNest > 0 && (y.currentType === 4 || y.currentType === 5 || y.currentType === 6)) return f(ce.UNTERMINATED_CLOSING_BRACE, s(), 0), y.braceNest = 0, W(v, y);
          if (M = T(v, y)) return S = d(y, 4, zn(v)), A(v), S;
          if (F = P(v, y)) return S = d(y, 5, Gn(v)), A(v), S;
          if (L = O(v, y)) return S = d(y, 6, dt(v)), A(v), S;
          if (!M && !F && !L) return S = d(y, 12, Xn(v)), f(ce.INVALID_TOKEN_IN_PLACEHOLDER, s(), 0, S.value), A(v), S;
          break
        }
      }
      return S
    }

    function H(v, y) {
      const {
        currentType: S
      } = y;
      let z = null;
      const M = v.currentChar();
      switch ((S === 7 || S === 8 || S === 11 || S === 9) && (M === et || M === xn) && f(ce.INVALID_LINKED_FORMAT, s(), 0), M) {
        case "@":
          return v.next(), z = d(y, 7, "@"), y.inLinked = !0, z;
        case ".":
          return A(v), v.next(), d(y, 8, ".");
        case ":":
          return A(v), v.next(), d(y, 9, ":");
        default:
          return I(v) ? (z = d(y, 1, w(v)), y.braceNest = 0, y.inLinked = !1, z) : N(v, y) || R(v, y) ? (A(v), H(v, y)) : V(v, y) ? (A(v), d(y, 11, oo(v))) : C(v, y) ? (A(v), M === "{" ? D(v, y) || z : d(y, 10, b(v))) : (S === 7 && f(ce.INVALID_LINKED_FORMAT, s(), 0), y.braceNest = 0, y.inLinked = !1, W(v, y))
      }
    }

    function W(v, y) {
      let S = {
        type: 13
      };
      if (y.braceNest > 0) return D(v, y) || p(y);
      if (y.inLinked) return H(v, y) || p(y);
      switch (v.currentChar()) {
        case "{":
          return D(v, y) || p(y);
        case "}":
          return f(ce.UNBALANCED_CLOSING_BRACE, s(), 0), v.next(), d(y, 3, "}");
        case "@":
          return H(v, y) || p(y);
        default: {
          if (I(v)) return S = d(y, 1, w(v)), y.braceNest = 0, y.inLinked = !1, S;
          if (U(v)) return d(y, 0, qe(v));
          break
        }
      }
      return S
    }

    function k() {
      const {
        currentType: v,
        offset: y,
        startLoc: S,
        endLoc: z
      } = l;
      return l.lastType = v, l.lastOffset = y, l.lastStartLoc = S, l.lastEndLoc = z, l.offset = r(), l.startLoc = s(), i.currentChar() === En ? d(l, 13) : W(i, l)
    }
    return {
      nextToken: k,
      currentOffset: r,
      currentPosition: s,
      context: u
    }
  }
  const pw = "parser",
    hw = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;

  function mw(e, t, n) {
    switch (e) {
      case "\\\\":
        return "\\";
      case "\\'":
        return "'";
      default: {
        const i = parseInt(t || n, 16);
        return i <= 55295 || i >= 57344 ? String.fromCodePoint(i) : ""
      }
    }
  }

  function vw(e = {}) {
    const t = e.location !== !1,
      {
        onError: n
      } = e;

    function i(m, x, T, P, ...O) {
      const N = m.currentPosition();
      if (N.offset += P, N.column += P, n) {
        const V = t ? ol(T, N) : null,
          R = Hs(x, V, {
            domain: pw,
            args: O
          });
        n(R)
      }
    }

    function r(m, x, T) {
      const P = {
        type: m
      };
      return t && (P.start = x, P.end = x, P.loc = {
        start: T,
        end: T
      }), P
    }

    function s(m, x, T, P) {
      t && (m.end = x, m.loc && (m.loc.end = T))
    }

    function o(m, x) {
      const T = m.context(),
        P = r(3, T.offset, T.startLoc);
      return P.value = x, s(P, m.currentOffset(), m.currentPosition()), P
    }

    function a(m, x) {
      const T = m.context(),
        {
          lastOffset: P,
          lastStartLoc: O
        } = T,
        N = r(5, P, O);
      return N.index = parseInt(x, 10), m.nextToken(), s(N, m.currentOffset(), m.currentPosition()), N
    }

    function l(m, x) {
      const T = m.context(),
        {
          lastOffset: P,
          lastStartLoc: O
        } = T,
        N = r(4, P, O);
      return N.key = x, m.nextToken(), s(N, m.currentOffset(), m.currentPosition()), N
    }

    function u(m, x) {
      const T = m.context(),
        {
          lastOffset: P,
          lastStartLoc: O
        } = T,
        N = r(9, P, O);
      return N.value = x.replace(hw, mw), m.nextToken(), s(N, m.currentOffset(), m.currentPosition()), N
    }

    function c(m) {
      const x = m.nextToken(),
        T = m.context(),
        {
          lastOffset: P,
          lastStartLoc: O
        } = T,
        N = r(8, P, O);
      return x.type !== 11 ? (i(m, ce.UNEXPECTED_EMPTY_LINKED_MODIFIER, T.lastStartLoc, 0), N.value = "", s(N, P, O), {
        nextConsumeToken: x,
        node: N
      }) : (x.value == null && i(m, ce.UNEXPECTED_LEXICAL_ANALYSIS, T.lastStartLoc, 0, _t(x)), N.value = x.value || "", s(N, m.currentOffset(), m.currentPosition()), {
        node: N
      })
    }

    function f(m, x) {
      const T = m.context(),
        P = r(7, T.offset, T.startLoc);
      return P.value = x, s(P, m.currentOffset(), m.currentPosition()), P
    }

    function d(m) {
      const x = m.context(),
        T = r(6, x.offset, x.startLoc);
      let P = m.nextToken();
      if (P.type === 8) {
        const O = c(m);
        T.modifier = O.node, P = O.nextConsumeToken || m.nextToken()
      }
      switch (P.type !== 9 && i(m, ce.UNEXPECTED_LEXICAL_ANALYSIS, x.lastStartLoc, 0, _t(P)), P = m.nextToken(), P.type === 2 && (P = m.nextToken()), P.type) {
        case 10:
          P.value == null && i(m, ce.UNEXPECTED_LEXICAL_ANALYSIS, x.lastStartLoc, 0, _t(P)), T.key = f(m, P.value || "");
          break;
        case 4:
          P.value == null && i(m, ce.UNEXPECTED_LEXICAL_ANALYSIS, x.lastStartLoc, 0, _t(P)), T.key = l(m, P.value || "");
          break;
        case 5:
          P.value == null && i(m, ce.UNEXPECTED_LEXICAL_ANALYSIS, x.lastStartLoc, 0, _t(P)), T.key = a(m, P.value || "");
          break;
        case 6:
          P.value == null && i(m, ce.UNEXPECTED_LEXICAL_ANALYSIS, x.lastStartLoc, 0, _t(P)), T.key = u(m, P.value || "");
          break;
        default: {
          i(m, ce.UNEXPECTED_EMPTY_LINKED_KEY, x.lastStartLoc, 0);
          const O = m.context(),
            N = r(7, O.offset, O.startLoc);
          return N.value = "", s(N, O.offset, O.startLoc), T.key = N, s(T, O.offset, O.startLoc), {
            nextConsumeToken: P,
            node: T
          }
        }
      }
      return s(T, m.currentOffset(), m.currentPosition()), {
        node: T
      }
    }

    function p(m) {
      const x = m.context(),
        T = x.currentType === 1 ? m.currentOffset() : x.offset,
        P = x.currentType === 1 ? x.endLoc : x.startLoc,
        O = r(2, T, P);
      O.items = [];
      let N = null;
      do {
        const C = N || m.nextToken();
        switch (N = null, C.type) {
          case 0:
            C.value == null && i(m, ce.UNEXPECTED_LEXICAL_ANALYSIS, x.lastStartLoc, 0, _t(C)), O.items.push(o(m, C.value || ""));
            break;
          case 5:
            C.value == null && i(m, ce.UNEXPECTED_LEXICAL_ANALYSIS, x.lastStartLoc, 0, _t(C)), O.items.push(a(m, C.value || ""));
            break;
          case 4:
            C.value == null && i(m, ce.UNEXPECTED_LEXICAL_ANALYSIS, x.lastStartLoc, 0, _t(C)), O.items.push(l(m, C.value || ""));
            break;
          case 6:
            C.value == null && i(m, ce.UNEXPECTED_LEXICAL_ANALYSIS, x.lastStartLoc, 0, _t(C)), O.items.push(u(m, C.value || ""));
            break;
          case 7: {
            const I = d(m);
            O.items.push(I.node), N = I.nextConsumeToken || null;
            break
          }
        }
      } while (x.currentType !== 13 && x.currentType !== 1);
      const V = x.currentType === 1 ? x.lastOffset : m.currentOffset(),
        R = x.currentType === 1 ? x.lastEndLoc : m.currentPosition();
      return s(O, V, R), O
    }

    function h(m, x, T, P) {
      const O = m.context();
      let N = P.items.length === 0;
      const V = r(1, x, T);
      V.cases = [], V.cases.push(P);
      do {
        const R = p(m);
        N || (N = R.items.length === 0), V.cases.push(R)
      } while (O.currentType !== 13);
      return N && i(m, ce.MUST_HAVE_MESSAGES_IN_PLURAL, T, 0), s(V, m.currentOffset(), m.currentPosition()), V
    }

    function g(m) {
      const x = m.context(),
        {
          offset: T,
          startLoc: P
        } = x,
        O = p(m);
      return x.currentType === 13 ? O : h(m, T, P, O)
    }

    function A(m) {
      const x = dw(m, kn({}, e)),
        T = x.context(),
        P = r(0, T.offset, T.startLoc);
      return t && P.loc && (P.loc.source = m), P.body = g(x), e.onCacheKey && (P.cacheKey = e.onCacheKey(m)), T.currentType !== 13 && i(x, ce.UNEXPECTED_LEXICAL_ANALYSIS, T.lastStartLoc, 0, m[T.offset] || ""), s(P, x.currentOffset(), x.currentPosition()), P
    }
    return {
      parse: A
    }
  }

  function _t(e) {
    if (e.type === 13) return "EOF";
    const t = (e.value || "").replace(/\r?\n/gu, "\\n");
    return t.length > 10 ? t.slice(0, 9) + "" : t
  }

  function gw(e, t = {}) {
    const n = {
      ast: e,
      helpers: new Set
    };
    return {
      context: () => n,
      helper: s => (n.helpers.add(s), s)
    }
  }

  function lh(e, t) {
    for (let n = 0; n < e.length; n++) al(e[n], t)
  }

  function al(e, t) {
    switch (e.type) {
      case 1:
        lh(e.cases, t), t.helper("plural");
        break;
      case 2:
        lh(e.items, t);
        break;
      case 6: {
        al(e.key, t), t.helper("linked"), t.helper("type");
        break
      }
      case 5:
        t.helper("interpolate"), t.helper("list");
        break;
      case 4:
        t.helper("interpolate"), t.helper("named");
        break
    }
  }

  function yw(e, t = {}) {
    const n = gw(e);
    n.helper("normalize"), e.body && al(e.body, n);
    const i = n.context();
    e.helpers = Array.from(i.helpers)
  }

  function bw(e) {
    const t = e.body;
    return t.type === 2 ? ch(t) : t.cases.forEach(n => ch(n)), e
  }

  function ch(e) {
    if (e.items.length === 1) {
      const t = e.items[0];
      (t.type === 3 || t.type === 9) && (e.static = t.value, delete t.value)
    } else {
      const t = [];
      for (let n = 0; n < e.items.length; n++) {
        const i = e.items[n];
        if (!(i.type === 3 || i.type === 9) || i.value == null) break;
        t.push(i.value)
      }
      if (t.length === e.items.length) {
        e.static = sl(t);
        for (let n = 0; n < e.items.length; n++) {
          const i = e.items[n];
          (i.type === 3 || i.type === 9) && delete i.value
        }
      }
    }
  }

  function Ri(e) {
    switch (e.t = e.type, e.type) {
      case 0: {
        const t = e;
        Ri(t.body), t.b = t.body, delete t.body;
        break
      }
      case 1: {
        const t = e,
          n = t.cases;
        for (let i = 0; i < n.length; i++) Ri(n[i]);
        t.c = n, delete t.cases;
        break
      }
      case 2: {
        const t = e,
          n = t.items;
        for (let i = 0; i < n.length; i++) Ri(n[i]);
        t.i = n, delete t.items, t.static && (t.s = t.static, delete t.static);
        break
      }
      case 3:
      case 9:
      case 8:
      case 7: {
        const t = e;
        t.value && (t.v = t.value, delete t.value);
        break
      }
      case 6: {
        const t = e;
        Ri(t.key), t.k = t.key, delete t.key, t.modifier && (Ri(t.modifier), t.m = t.modifier, delete t.modifier);
        break
      }
      case 5: {
        const t = e;
        t.i = t.index, delete t.index;
        break
      }
      case 4: {
        const t = e;
        t.k = t.key, delete t.key;
        break
      }
    }
    delete e.type
  }

  function Aw(e, t) {
    const {
      filename: n,
      breakLineCode: i,
      needIndent: r
    } = t, s = t.location !== !1, o = {
      filename: n,
      code: "",
      column: 1,
      line: 1,
      offset: 0,
      map: void 0,
      breakLineCode: i,
      needIndent: r,
      indentLevel: 0
    };
    s && e.loc && (o.source = e.loc.source);
    const a = () => o;

    function l(g, A) {
      o.code += g
    }

    function u(g, A = !0) {
      const m = A ? i : "";
      l(r ? m + "  ".repeat(g) : m)
    }

    function c(g = !0) {
      const A = ++o.indentLevel;
      g && u(A)
    }

    function f(g = !0) {
      const A = --o.indentLevel;
      g && u(A)
    }

    function d() {
      u(o.indentLevel)
    }
    return {
      context: a,
      push: l,
      indent: c,
      deindent: f,
      newline: d,
      helper: g => `_${g}`,
      needIndent: () => o.needIndent
    }
  }

  function Pw(e, t) {
    const {
      helper: n
    } = e;
    e.push(`${n("linked")}(`), Fi(e, t.key), t.modifier ? (e.push(", "), Fi(e, t.modifier), e.push(", _type")) : e.push(", undefined, _type"), e.push(")")
  }

  function ww(e, t) {
    const {
      helper: n,
      needIndent: i
    } = e;
    e.push(`${n("normalize")}([`), e.indent(i());
    const r = t.items.length;
    for (let s = 0; s < r && (Fi(e, t.items[s]), s !== r - 1); s++) e.push(", ");
    e.deindent(i()), e.push("])")
  }

  function xw(e, t) {
    const {
      helper: n,
      needIndent: i
    } = e;
    if (t.cases.length > 1) {
      e.push(`${n("plural")}([`), e.indent(i());
      const r = t.cases.length;
      for (let s = 0; s < r && (Fi(e, t.cases[s]), s !== r - 1); s++) e.push(", ");
      e.deindent(i()), e.push("])")
    }
  }

  function Tw(e, t) {
    t.body ? Fi(e, t.body) : e.push("null")
  }

  function Fi(e, t) {
    const {
      helper: n
    } = e;
    switch (t.type) {
      case 0:
        Tw(e, t);
        break;
      case 1:
        xw(e, t);
        break;
      case 2:
        ww(e, t);
        break;
      case 6:
        Pw(e, t);
        break;
      case 8:
        e.push(JSON.stringify(t.value), t);
        break;
      case 7:
        e.push(JSON.stringify(t.value), t);
        break;
      case 5:
        e.push(`${n("interpolate")}(${n("list")}(${t.index}))`, t);
        break;
      case 4:
        e.push(`${n("interpolate")}(${n("named")}(${JSON.stringify(t.key)}))`, t);
        break;
      case 9:
        e.push(JSON.stringify(t.value), t);
        break;
      case 3:
        e.push(JSON.stringify(t.value), t);
        break
    }
  }
  const Lw = (e, t = {}) => {
    const n = Y(t.mode) ? t.mode : "normal",
      i = Y(t.filename) ? t.filename : "message.intl";
    t.sourceMap;
    const r = t.breakLineCode != null ? t.breakLineCode : n === "arrow" ? ";" : `
`,
      s = t.needIndent ? t.needIndent : n !== "arrow",
      o = e.helpers || [],
      a = Aw(e, {
        filename: i,
        breakLineCode: r,
        needIndent: s
      });
    a.push(n === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"), a.indent(s), o.length > 0 && (a.push(`const { ${sl(o.map(c=>`${c}: _${c}`),", ")} } = ctx`), a.newline()), a.push("return "), Fi(a, e), a.deindent(s), a.push("}"), delete e.helpers;
    const {
      code: l,
      map: u
    } = a.context();
    return {
      ast: e,
      code: l,
      map: u ? u.toJSON() : void 0
    }
  };

  function Sw(e, t = {}) {
    const n = kn({}, t),
      i = !!n.jit,
      r = !!n.minify,
      s = n.optimize == null ? !0 : n.optimize,
      a = vw(n).parse(e);
    return i ? (s && bw(a), r && Ri(a), {
      ast: a,
      code: ""
    }) : (yw(a, n), Lw(a, n))
  }
  /*!
   * core-base v10.0.7
   * (c) 2025 kazuya kawaguchi
   * Released under the MIT License.
   */
  function Ow() {
    typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (_1().__INTLIFY_PROD_DEVTOOLS__ = !1)
  }

  function $t(e) {
    return Ie(e) && ll(e) === 0 && (fi(e, "b") || fi(e, "body"))
  }
  const uh = ["b", "body"];

  function zw(e) {
    return Mn(e, uh)
  }
  const fh = ["c", "cases"];

  function Xw(e) {
    return Mn(e, fh, [])
  }
  const dh = ["s", "static"];

  function Dw(e) {
    return Mn(e, dh)
  }
  const ph = ["i", "items"];

  function Vw(e) {
    return Mn(e, ph, [])
  }
  const hh = ["t", "type"];

  function ll(e) {
    return Mn(e, hh)
  }
  const mh = ["v", "value"];

  function ks(e, t) {
    const n = Mn(e, mh);
    if (n != null) return n;
    throw jr(t)
  }
  const vh = ["m", "modifier"];

  function Nw(e) {
    return Mn(e, vh)
  }
  const gh = ["k", "key"];

  function jw(e) {
    const t = Mn(e, gh);
    if (t) return t;
    throw jr(6)
  }

  function Mn(e, t, n) {
    for (let i = 0; i < t.length; i++) {
      const r = t[i];
      if (fi(e, r) && e[r] != null) return e[r]
    }
    return n
  }
  const yh = [...uh, ...fh, ...dh, ...ph, ...gh, ...vh, ...mh, ...hh];

  function jr(e) {
    return new Error(`unhandled node type: ${e}`)
  }

  function cl(e) {
    return n => Rw(n, e)
  }

  function Rw(e, t) {
    const n = zw(t);
    if (n == null) throw jr(0);
    if (ll(n) === 1) {
      const s = Xw(n);
      return e.plural(s.reduce((o, a) => [...o, bh(e, a)], []))
    } else return bh(e, n)
  }

  function bh(e, t) {
    const n = Dw(t);
    if (n != null) return e.type === "text" ? n : e.normalize([n]);
    {
      const i = Vw(t).reduce((r, s) => [...r, ul(e, s)], []);
      return e.normalize(i)
    }
  }

  function ul(e, t) {
    const n = ll(t);
    switch (n) {
      case 3:
        return ks(t, n);
      case 9:
        return ks(t, n);
      case 4: {
        const i = t;
        if (fi(i, "k") && i.k) return e.interpolate(e.named(i.k));
        if (fi(i, "key") && i.key) return e.interpolate(e.named(i.key));
        throw jr(n)
      }
      case 5: {
        const i = t;
        if (fi(i, "i") && _e(i.i)) return e.interpolate(e.list(i.i));
        if (fi(i, "index") && _e(i.index)) return e.interpolate(e.list(i.index));
        throw jr(n)
      }
      case 6: {
        const i = t,
          r = Nw(i),
          s = jw(i);
        return e.linked(ul(e, s), r ? ul(e, r) : void 0, e.type)
      }
      case 7:
        return ks(t, n);
      case 8:
        return ks(t, n);
      default:
        throw new Error(`unhandled node on format message part: ${n}`)
    }
  }
  const Fw = e => e;
  let Es = $e();

  function Cw(e, t = {}) {
    let n = !1;
    const i = t.onError || sw;
    return t.onError = r => {
      n = !0, i(r)
    }, {
      ...Sw(e, t),
      detectError: n
    }
  }

  function Ww(e, t) {
    if (Y(e)) {
      ct(t.warnHtmlMessage) && t.warnHtmlMessage;
      const i = (t.onCacheKey || Fw)(e),
        r = Es[i];
      if (r) return r;
      const {
        ast: s,
        detectError: o
      } = Cw(e, {
        ...t,
        location: !1,
        jit: !0
      }), a = cl(s);
      return o ? a : Es[i] = a
    } else {
      const n = e.cacheKey;
      if (n) {
        const i = Es[n];
        return i || (Es[n] = cl(e))
      } else return cl(e)
    }
  }
  let Rr = null;

  function Hw(e) {
    Rr = e
  }

  function kw(e, t, n) {
    Rr && Rr.emit("i18n:init", {
      timestamp: Date.now(),
      i18n: e,
      version: t,
      meta: n
    })
  }
  const Ew = Mw("function:translate");

  function Mw(e) {
    return t => Rr && Rr.emit(e, t)
  }
  const Tn = {
      INVALID_ARGUMENT: rw,
      INVALID_DATE_ARGUMENT: 18,
      INVALID_ISO_DATE_ARGUMENT: 19,
      NOT_SUPPORT_LOCALE_PROMISE_VALUE: 21,
      NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: 22,
      NOT_SUPPORT_LOCALE_TYPE: 23
    },
    Iw = 24;

  function Ln(e) {
    return Hs(e, null, void 0)
  }

  function fl(e, t) {
    return t.locale != null ? Ah(t.locale) : Ah(e.locale)
  }
  let dl;

  function Ah(e) {
    if (Y(e)) return e;
    if (De(e)) {
      if (e.resolvedOnce && dl != null) return dl;
      if (e.constructor.name === "Function") {
        const t = e();
        if (ew(t)) throw Ln(Tn.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
        return dl = t
      } else throw Ln(Tn.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION)
    } else throw Ln(Tn.NOT_SUPPORT_LOCALE_TYPE)
  }

  function qw(e, t, n) {
    return [...new Set([n, ...Qt(t) ? t : Ie(t) ? Object.keys(t) : Y(t) ? [t] : [n]])]
  }

  function Ph(e, t, n) {
    const i = Y(n) ? n : Is,
      r = e;
    r.__localeChainCache || (r.__localeChainCache = new Map);
    let s = r.__localeChainCache.get(i);
    if (!s) {
      s = [];
      let o = [n];
      for (; Qt(o);) o = wh(s, o, t);
      const a = Qt(t) || !Ae(t) ? t : t.default ? t.default : null;
      o = Y(a) ? [a] : a, Qt(o) && wh(s, o, !1), r.__localeChainCache.set(i, s)
    }
    return s
  }

  function wh(e, t, n) {
    let i = !0;
    for (let r = 0; r < t.length && ct(i); r++) {
      const s = t[r];
      Y(s) && (i = Zw(e, t[r], n))
    }
    return i
  }

  function Zw(e, t, n) {
    let i;
    const r = t.split("-");
    do {
      const s = r.join("-");
      i = Uw(e, s, n), r.splice(-1, 1)
    } while (r.length && i === !0);
    return i
  }

  function Uw(e, t, n) {
    let i = !1;
    if (!e.includes(t) && (i = !0, t)) {
      i = t[t.length - 1] !== "!";
      const r = t.replace(/!/g, "");
      e.push(r), (Qt(n) || Ae(n)) && n[r] && (i = n[r])
    }
    return i
  }
  const In = [];
  In[0] = {
    w: [0],
    i: [3, 0],
    "[": [4],
    o: [7]
  }, In[1] = {
    w: [1],
    ".": [2],
    "[": [4],
    o: [7]
  }, In[2] = {
    w: [2],
    i: [3, 0],
    0: [3, 0]
  }, In[3] = {
    i: [3, 0],
    0: [3, 0],
    w: [1, 1],
    ".": [2, 1],
    "[": [4, 1],
    o: [7, 1]
  }, In[4] = {
    "'": [5, 0],
    '"': [6, 0],
    "[": [4, 2],
    "]": [1, 3],
    o: 8,
    l: [4, 0]
  }, In[5] = {
    "'": [4, 0],
    o: 8,
    l: [5, 0]
  }, In[6] = {
    '"': [4, 0],
    o: 8,
    l: [6, 0]
  };
  const Bw = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;

  function Gw(e) {
    return Bw.test(e)
  }

  function Kw(e) {
    const t = e.charCodeAt(0),
      n = e.charCodeAt(e.length - 1);
    return t === n && (t === 34 || t === 39) ? e.slice(1, -1) : e
  }

  function Jw(e) {
    if (e == null) return "o";
    switch (e.charCodeAt(0)) {
      case 91:
      case 93:
      case 46:
      case 34:
      case 39:
        return e;
      case 95:
      case 36:
      case 45:
        return "i";
      case 9:
      case 10:
      case 13:
      case 160:
      case 65279:
      case 8232:
      case 8233:
        return "w"
    }
    return "i"
  }

  function Yw(e) {
    const t = e.trim();
    return e.charAt(0) === "0" && isNaN(parseInt(e)) ? !1 : Gw(t) ? Kw(t) : "*" + t
  }

  function Qw(e) {
    const t = [];
    let n = -1,
      i = 0,
      r = 0,
      s, o, a, l, u, c, f;
    const d = [];
    d[0] = () => {
      o === void 0 ? o = a : o += a
    }, d[1] = () => {
      o !== void 0 && (t.push(o), o = void 0)
    }, d[2] = () => {
      d[0](), r++
    }, d[3] = () => {
      if (r > 0) r--, i = 4, d[0]();
      else {
        if (r = 0, o === void 0 || (o = Yw(o), o === !1)) return !1;
        d[1]()
      }
    };

    function p() {
      const h = e[n + 1];
      if (i === 5 && h === "'" || i === 6 && h === '"') return n++, a = "\\" + h, d[0](), !0
    }
    for (; i !== null;)
      if (n++, s = e[n], !(s === "\\" && p())) {
        if (l = Jw(s), f = In[i], u = f[l] || f.l || 8, u === 8 || (i = u[0], u[1] !== void 0 && (c = d[u[1]], c && (a = s, c() === !1)))) return;
        if (i === 7) return t
      }
  }
  const xh = new Map;

  function _w(e, t) {
    return Ie(e) ? e[t] : null
  }

  function $w(e, t) {
    if (!Ie(e)) return null;
    let n = xh.get(t);
    if (n || (n = Qw(t), n && xh.set(t, n)), !n) return null;
    const i = n.length;
    let r = e,
      s = 0;
    for (; s < i;) {
      const o = n[s];
      if (yh.includes(o) && $t(r)) return null;
      const a = r[o];
      if (a === void 0 || De(r)) return null;
      r = a, s++
    }
    return r
  }
  const ex = "10.0.7",
    Ms = -1,
    Is = "en-US",
    Th = "",
    Lh = e => `${e.charAt(0).toLocaleUpperCase()}${e.substr(1)}`;

  function tx() {
    return {
      upper: (e, t) => t === "text" && Y(e) ? e.toUpperCase() : t === "vnode" && Ie(e) && "__v_isVNode" in e ? e.children.toUpperCase() : e,
      lower: (e, t) => t === "text" && Y(e) ? e.toLowerCase() : t === "vnode" && Ie(e) && "__v_isVNode" in e ? e.children.toLowerCase() : e,
      capitalize: (e, t) => t === "text" && Y(e) ? Lh(e) : t === "vnode" && Ie(e) && "__v_isVNode" in e ? Lh(e.children) : e
    }
  }
  let Sh;

  function nx(e) {
    Sh = e
  }
  let Oh;

  function ix(e) {
    Oh = e
  }
  let zh;

  function rx(e) {
    zh = e
  }
  let Xh = null;
  const sx = e => {
      Xh = e
    },
    ox = () => Xh;
  let Dh = null;
  const Vh = e => {
      Dh = e
    },
    ax = () => Dh;
  let Nh = 0;

  function lx(e = {}) {
    const t = De(e.onWarn) ? e.onWarn : nw,
      n = Y(e.version) ? e.version : ex,
      i = Y(e.locale) || De(e.locale) ? e.locale : Is,
      r = De(i) ? Is : i,
      s = Qt(e.fallbackLocale) || Ae(e.fallbackLocale) || Y(e.fallbackLocale) || e.fallbackLocale === !1 ? e.fallbackLocale : r,
      o = Ae(e.messages) ? e.messages : pl(r),
      a = Ae(e.datetimeFormats) ? e.datetimeFormats : pl(r),
      l = Ae(e.numberFormats) ? e.numberFormats : pl(r),
      u = kn($e(), e.modifiers, tx()),
      c = e.pluralRules || $e(),
      f = De(e.missing) ? e.missing : null,
      d = ct(e.missingWarn) || ih(e.missingWarn) ? e.missingWarn : !0,
      p = ct(e.fallbackWarn) || ih(e.fallbackWarn) ? e.fallbackWarn : !0,
      h = !!e.fallbackFormat,
      g = !!e.unresolving,
      A = De(e.postTranslation) ? e.postTranslation : null,
      m = Ae(e.processor) ? e.processor : null,
      x = ct(e.warnHtmlMessage) ? e.warnHtmlMessage : !0,
      T = !!e.escapeParameter,
      P = De(e.messageCompiler) ? e.messageCompiler : Sh,
      O = De(e.messageResolver) ? e.messageResolver : Oh || _w,
      N = De(e.localeFallbacker) ? e.localeFallbacker : zh || qw,
      V = Ie(e.fallbackContext) ? e.fallbackContext : void 0,
      R = e,
      C = Ie(R.__datetimeFormatters) ? R.__datetimeFormatters : new Map,
      I = Ie(R.__numberFormatters) ? R.__numberFormatters : new Map,
      U = Ie(R.__meta) ? R.__meta : {};
    Nh++;
    const j = {
      version: n,
      cid: Nh,
      locale: i,
      fallbackLocale: s,
      messages: o,
      modifiers: u,
      pluralRules: c,
      missing: f,
      missingWarn: d,
      fallbackWarn: p,
      fallbackFormat: h,
      unresolving: g,
      postTranslation: A,
      processor: m,
      warnHtmlMessage: x,
      escapeParameter: T,
      messageCompiler: P,
      messageResolver: O,
      localeFallbacker: N,
      fallbackContext: V,
      onWarn: t,
      __meta: U
    };
    return j.datetimeFormats = a, j.numberFormats = l, j.__datetimeFormatters = C, j.__numberFormatters = I, __INTLIFY_PROD_DEVTOOLS__ && kw(j, n, U), j
  }
  const pl = e => ({
    [e]: $e()
  });

  function hl(e, t, n, i, r) {
    const {
      missing: s,
      onWarn: o
    } = e;
    if (s !== null) {
      const a = s(e, n, t, r);
      return Y(a) ? a : t
    } else return t
  }

  function Fr(e, t, n) {
    const i = e;
    i.__localeChainCache = new Map, e.localeFallbacker(e, n, t)
  }

  function cx(e, t) {
    return e === t ? !1 : e.split("-")[0] === t.split("-")[0]
  }

  function ux(e, t) {
    const n = t.indexOf(e);
    if (n === -1) return !1;
    for (let i = n + 1; i < t.length; i++)
      if (cx(e, t[i])) return !0;
    return !1
  }

  function jh(e, ...t) {
    const {
      datetimeFormats: n,
      unresolving: i,
      fallbackLocale: r,
      onWarn: s,
      localeFallbacker: o
    } = e, {
      __datetimeFormatters: a
    } = e, [l, u, c, f] = ml(...t), d = ct(c.missingWarn) ? c.missingWarn : e.missingWarn;
    ct(c.fallbackWarn) ? c.fallbackWarn : e.fallbackWarn;
    const p = !!c.part,
      h = fl(e, c),
      g = o(e, r, h);
    if (!Y(l) || l === "") return new Intl.DateTimeFormat(h, f).format(u);
    let A = {},
      m, x = null;
    const T = "datetime format";
    for (let N = 0; N < g.length && (m = g[N], A = n[m] || {}, x = A[l], !Ae(x)); N++) hl(e, l, m, d, T);
    if (!Ae(x) || !Y(m)) return i ? Ms : l;
    let P = `${m}__${l}`;
    il(f) || (P = `${P}__${JSON.stringify(f)}`);
    let O = a.get(P);
    return O || (O = new Intl.DateTimeFormat(m, kn({}, x, f)), a.set(P, O)), p ? O.formatToParts(u) : O.format(u)
  }
  const Rh = ["localeMatcher", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "formatMatcher", "hour12", "timeZone", "dateStyle", "timeStyle", "calendar", "dayPeriod", "numberingSystem", "hourCycle", "fractionalSecondDigits"];

  function ml(...e) {
    const [t, n, i, r] = e, s = $e();
    let o = $e(),
      a;
    if (Y(t)) {
      const l = t.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
      if (!l) throw Ln(Tn.INVALID_ISO_DATE_ARGUMENT);
      const u = l[3] ? l[3].trim().startsWith("T") ? `${l[1].trim()}${l[3].trim()}` : `${l[1].trim()}T${l[3].trim()}` : l[1].trim();
      a = new Date(u);
      try {
        a.toISOString()
      } catch {
        throw Ln(Tn.INVALID_ISO_DATE_ARGUMENT)
      }
    } else if (Y1(t)) {
      if (isNaN(t.getTime())) throw Ln(Tn.INVALID_DATE_ARGUMENT);
      a = t
    } else if (_e(t)) a = t;
    else throw Ln(Tn.INVALID_ARGUMENT);
    return Y(n) ? s.key = n : Ae(n) && Object.keys(n).forEach(l => {
      Rh.includes(l) ? o[l] = n[l] : s[l] = n[l]
    }), Y(i) ? s.locale = i : Ae(i) && (o = i), Ae(r) && (o = r), [s.key || "", a, s, o]
  }

  function Fh(e, t, n) {
    const i = e;
    for (const r in n) {
      const s = `${t}__${r}`;
      i.__datetimeFormatters.has(s) && i.__datetimeFormatters.delete(s)
    }
  }

  function Ch(e, ...t) {
    const {
      numberFormats: n,
      unresolving: i,
      fallbackLocale: r,
      onWarn: s,
      localeFallbacker: o
    } = e, {
      __numberFormatters: a
    } = e, [l, u, c, f] = vl(...t), d = ct(c.missingWarn) ? c.missingWarn : e.missingWarn;
    ct(c.fallbackWarn) ? c.fallbackWarn : e.fallbackWarn;
    const p = !!c.part,
      h = fl(e, c),
      g = o(e, r, h);
    if (!Y(l) || l === "") return new Intl.NumberFormat(h, f).format(u);
    let A = {},
      m, x = null;
    const T = "number format";
    for (let N = 0; N < g.length && (m = g[N], A = n[m] || {}, x = A[l], !Ae(x)); N++) hl(e, l, m, d, T);
    if (!Ae(x) || !Y(m)) return i ? Ms : l;
    let P = `${m}__${l}`;
    il(f) || (P = `${P}__${JSON.stringify(f)}`);
    let O = a.get(P);
    return O || (O = new Intl.NumberFormat(m, kn({}, x, f)), a.set(P, O)), p ? O.formatToParts(u) : O.format(u)
  }
  const Wh = ["localeMatcher", "style", "currency", "currencyDisplay", "currencySign", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits", "compactDisplay", "notation", "signDisplay", "unit", "unitDisplay", "roundingMode", "roundingPriority", "roundingIncrement", "trailingZeroDisplay"];

  function vl(...e) {
    const [t, n, i, r] = e, s = $e();
    let o = $e();
    if (!_e(t)) throw Ln(Tn.INVALID_ARGUMENT);
    const a = t;
    return Y(n) ? s.key = n : Ae(n) && Object.keys(n).forEach(l => {
      Wh.includes(l) ? o[l] = n[l] : s[l] = n[l]
    }), Y(i) ? s.locale = i : Ae(i) && (o = i), Ae(r) && (o = r), [s.key || "", a, s, o]
  }

  function Hh(e, t, n) {
    const i = e;
    for (const r in n) {
      const s = `${t}__${r}`;
      i.__numberFormatters.has(s) && i.__numberFormatters.delete(s)
    }
  }
  const fx = e => e,
    dx = e => "",
    px = "text",
    hx = e => e.length === 0 ? "" : sl(e),
    mx = tw;

  function kh(e, t) {
    return e = Math.abs(e), t === 2 ? e ? e > 1 ? 1 : 0 : 1 : e ? Math.min(e, 2) : 0
  }

  function vx(e) {
    const t = _e(e.pluralIndex) ? e.pluralIndex : -1;
    return e.named && (_e(e.named.count) || _e(e.named.n)) ? _e(e.named.count) ? e.named.count : _e(e.named.n) ? e.named.n : t : t
  }

  function gx(e, t) {
    t.count || (t.count = e), t.n || (t.n = e)
  }

  function yx(e = {}) {
    const t = e.locale,
      n = vx(e),
      i = Ie(e.pluralRules) && Y(t) && De(e.pluralRules[t]) ? e.pluralRules[t] : kh,
      r = Ie(e.pluralRules) && Y(t) && De(e.pluralRules[t]) ? kh : void 0,
      s = m => m[i(n, m.length, r)],
      o = e.list || [],
      a = m => o[m],
      l = e.named || $e();
    _e(e.pluralIndex) && gx(n, l);
    const u = m => l[m];

    function c(m, x) {
      const T = De(e.messages) ? e.messages(m, !!x) : Ie(e.messages) ? e.messages[m] : !1;
      return T || (e.parent ? e.parent.message(m) : dx)
    }
    const f = m => e.modifiers ? e.modifiers[m] : fx,
      d = Ae(e.processor) && De(e.processor.normalize) ? e.processor.normalize : hx,
      p = Ae(e.processor) && De(e.processor.interpolate) ? e.processor.interpolate : mx,
      h = Ae(e.processor) && Y(e.processor.type) ? e.processor.type : px,
      A = {
        list: a,
        named: u,
        plural: s,
        linked: (m, ...x) => {
          const [T, P] = x;
          let O = "text",
            N = "";
          x.length === 1 ? Ie(T) ? (N = T.modifier || N, O = T.type || O) : Y(T) && (N = T || N) : x.length === 2 && (Y(T) && (N = T || N), Y(P) && (O = P || O));
          const V = c(m, !0)(A),
            R = O === "vnode" && Qt(V) && N ? V[0] : V;
          return N ? f(N)(R, O) : R
        },
        message: c,
        type: h,
        interpolate: p,
        normalize: d,
        values: kn($e(), o, l)
      };
    return A
  }
  const Eh = () => "",
    xt = e => De(e);

  function Mh(e, ...t) {
    const {
      fallbackFormat: n,
      postTranslation: i,
      unresolving: r,
      messageCompiler: s,
      fallbackLocale: o,
      messages: a
    } = e, [l, u] = gl(...t), c = ct(u.missingWarn) ? u.missingWarn : e.missingWarn, f = ct(u.fallbackWarn) ? u.fallbackWarn : e.fallbackWarn, d = ct(u.escapeParameter) ? u.escapeParameter : e.escapeParameter, p = !!u.resolvedMessage, h = Y(u.default) || ct(u.default) ? ct(u.default) ? s ? l : () => l : u.default : n ? s ? l : () => l : null, g = n || h != null && (Y(h) || De(h)), A = fl(e, u);
    d && bx(u);
    let [m, x, T] = p ? [l, A, a[A] || $e()] : Ih(e, l, A, o, f, c), P = m, O = l;
    if (!p && !(Y(P) || $t(P) || xt(P)) && g && (P = h, O = P), !p && (!(Y(P) || $t(P) || xt(P)) || !Y(x))) return r ? Ms : l;
    let N = !1;
    const V = () => {
        N = !0
      },
      R = xt(P) ? P : qh(e, l, x, P, O, V);
    if (N) return P;
    const C = wx(e, x, T, u),
      I = yx(C),
      U = Ax(e, R, I),
      j = i ? i(U, l) : U;
    if (__INTLIFY_PROD_DEVTOOLS__) {
      const Z = {
        timestamp: Date.now(),
        key: Y(l) ? l : xt(P) ? P.key : "",
        locale: x || (xt(P) ? P.locale : ""),
        format: Y(P) ? P : xt(P) ? P.source : "",
        message: j
      };
      Z.meta = kn({}, e.__meta, ox() || {}), Ew(Z)
    }
    return j
  }

  function bx(e) {
    Qt(e.list) ? e.list = e.list.map(t => Y(t) ? sh(t) : t) : Ie(e.named) && Object.keys(e.named).forEach(t => {
      Y(e.named[t]) && (e.named[t] = sh(e.named[t]))
    })
  }

  function Ih(e, t, n, i, r, s) {
    const {
      messages: o,
      onWarn: a,
      messageResolver: l,
      localeFallbacker: u
    } = e, c = u(e, i, n);
    let f = $e(),
      d, p = null;
    const h = "translate";
    for (let g = 0; g < c.length && (d = c[g], f = o[d] || $e(), (p = l(f, t)) === null && (p = f[t]), !(Y(p) || $t(p) || xt(p))); g++)
      if (!ux(d, c)) {
        const A = hl(e, t, d, s, h);
        A !== t && (p = A)
      } return [p, d, f]
  }

  function qh(e, t, n, i, r, s) {
    const {
      messageCompiler: o,
      warnHtmlMessage: a
    } = e;
    if (xt(i)) {
      const u = i;
      return u.locale = u.locale || n, u.key = u.key || t, u
    }
    if (o == null) {
      const u = () => i;
      return u.locale = n, u.key = t, u
    }
    const l = o(i, Px(e, n, r, i, a, s));
    return l.locale = n, l.key = t, l.source = i, l
  }

  function Ax(e, t, n) {
    return t(n)
  }

  function gl(...e) {
    const [t, n, i] = e, r = $e();
    if (!Y(t) && !_e(t) && !xt(t) && !$t(t)) throw Ln(Tn.INVALID_ARGUMENT);
    const s = _e(t) ? String(t) : (xt(t), t);
    return _e(n) ? r.plural = n : Y(n) ? r.default = n : Ae(n) && !il(n) ? r.named = n : Qt(n) && (r.list = n), _e(i) ? r.plural = i : Y(i) ? r.default = i : Ae(i) && kn(r, i), [s, r]
  }

  function Px(e, t, n, i, r, s) {
    return {
      locale: t,
      key: n,
      warnHtmlMessage: r,
      onError: o => {
        throw s && s(o), o
      },
      onCacheKey: o => K1(t, n, o)
    }
  }

  function wx(e, t, n, i) {
    const {
      modifiers: r,
      pluralRules: s,
      messageResolver: o,
      fallbackLocale: a,
      fallbackWarn: l,
      missingWarn: u,
      fallbackContext: c
    } = e, d = {
      locale: t,
      modifiers: r,
      pluralRules: s,
      messages: (p, h) => {
        let g = o(n, p);
        if (g == null && (c || h)) {
          const [, , A] = Ih(c || e, p, t, a, l, u);
          g = o(A, p)
        }
        if (Y(g) || $t(g)) {
          let A = !1;
          const x = qh(e, p, t, g, p, () => {
            A = !0
          });
          return A ? Eh : x
        } else return xt(g) ? g : Eh
      }
    };
    return e.processor && (d.processor = e.processor), i.list && (d.list = i.list), i.named && (d.named = i.named), _e(i.plural) && (d.pluralIndex = i.plural), d
  }
  Ow();
  /*!
   * vue-i18n v10.0.7
   * (c) 2025 kazuya kawaguchi
   * Released under the MIT License.
   */
  const xx = "10.0.7";

  function Tx() {
    typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (th().__INTLIFY_PROD_DEVTOOLS__ = !1)
  }
  const Tt = {
    UNEXPECTED_RETURN_TYPE: Iw,
    INVALID_ARGUMENT: 25,
    MUST_BE_CALL_SETUP_TOP: 26,
    NOT_INSTALLED: 27,
    REQUIRED_VALUE: 28,
    INVALID_VALUE: 29,
    NOT_INSTALLED_WITH_PROVIDE: 31,
    UNEXPECTED_ERROR: 32
  };

  function Wt(e, ...t) {
    return Hs(e, null, void 0)
  }
  const yl = Hn("__translateVNode"),
    bl = Hn("__datetimeParts"),
    Al = Hn("__numberParts"),
    Lx = Hn("__setPluralRules"),
    Sx = Hn("__injectWithOption"),
    Pl = Hn("__dispose");

  function Cr(e) {
    if (!lt(e) || $t(e)) return e;
    for (const t in e)
      if (Rs(e, t))
        if (!t.includes(".")) lt(e[t]) && Cr(e[t]);
        else {
          const n = t.split("."),
            i = n.length - 1;
          let r = e,
            s = !1;
          for (let o = 0; o < i; o++) {
            if (n[o] === "__proto__") throw new Error(`unsafe key: ${n[o]}`);
            if (n[o] in r || (r[n[o]] = at()), !lt(r[n[o]])) {
              s = !0;
              break
            }
            r = r[n[o]]
          }
          if (s || ($t(r) ? yh.includes(n[i]) || delete e[t] : (r[n[i]] = e[t], delete e[t])), !$t(r)) {
            const o = r[n[i]];
            lt(o) && Cr(o)
          }
        } return e
  }

  function Zh(e, t) {
    const {
      messages: n,
      __i18n: i,
      messageResolver: r,
      flatJson: s
    } = t, o = Ct(n) ? n : Pn(i) ? at() : {
      [e]: at()
    };
    if (Pn(i) && i.forEach(a => {
        if ("locale" in a && "resource" in a) {
          const {
            locale: l,
            resource: u
          } = a;
          l ? (o[l] = o[l] || at(), Ws(u, o[l])) : Ws(u, o)
        } else Oe(a) && Ws(JSON.parse(a), o)
      }), r == null && s)
      for (const a in o) Rs(o, a) && Cr(o[a]);
    return o
  }

  function Uh(e) {
    return e.type
  }

  function Ox(e, t, n) {
    let i = lt(t.messages) ? t.messages : at();
    "__i18nGlobal" in n && (i = Zh(e.locale.value, {
      messages: i,
      __i18n: n.__i18nGlobal
    }));
    const r = Object.keys(i);
    r.length && r.forEach(s => {
      e.mergeLocaleMessage(s, i[s])
    });
    {
      if (lt(t.datetimeFormats)) {
        const s = Object.keys(t.datetimeFormats);
        s.length && s.forEach(o => {
          e.mergeDateTimeFormat(o, t.datetimeFormats[o])
        })
      }
      if (lt(t.numberFormats)) {
        const s = Object.keys(t.numberFormats);
        s.length && s.forEach(o => {
          e.mergeNumberFormat(o, t.numberFormats[o])
        })
      }
    }
  }

  function Bh(e) {
    return ne(sr, null, e, 0)
  }
  const Gh = "__INTLIFY_META__",
    Kh = () => [],
    zx = () => !1;
  let Jh = 0;

  function Yh(e) {
    return (t, n, i, r) => e(n, i, ni() || void 0, r)
  }
  const Xx = () => {
    const e = ni();
    let t = null;
    return e && (t = Uh(e)[Gh]) ? {
      [Gh]: t
    } : null
  };

  function Qh(e = {}) {
    const {
      __root: t,
      __injectWithOption: n
    } = e, i = t === void 0, r = e.flatJson, s = js ? te : bc;
    let o = wn(e.inheritLocale) ? e.inheritLocale : !0;
    const a = s(t && o ? t.locale.value : Oe(e.locale) ? e.locale : Is),
      l = s(t && o ? t.fallbackLocale.value : Oe(e.fallbackLocale) || Pn(e.fallbackLocale) || Ct(e.fallbackLocale) || e.fallbackLocale === !1 ? e.fallbackLocale : a.value),
      u = s(Zh(a.value, e)),
      c = s(Ct(e.datetimeFormats) ? e.datetimeFormats : {
        [a.value]: {}
      }),
      f = s(Ct(e.numberFormats) ? e.numberFormats : {
        [a.value]: {}
      });
    let d = t ? t.missingWarn : wn(e.missingWarn) || $p(e.missingWarn) ? e.missingWarn : !0,
      p = t ? t.fallbackWarn : wn(e.fallbackWarn) || $p(e.fallbackWarn) ? e.fallbackWarn : !0,
      h = t ? t.fallbackRoot : wn(e.fallbackRoot) ? e.fallbackRoot : !0,
      g = !!e.fallbackFormat,
      A = Fs(e.missing) ? e.missing : null,
      m = Fs(e.missing) ? Yh(e.missing) : null,
      x = Fs(e.postTranslation) ? e.postTranslation : null,
      T = t ? t.warnHtmlMessage : wn(e.warnHtmlMessage) ? e.warnHtmlMessage : !0,
      P = !!e.escapeParameter;
    const O = t ? t.modifiers : Ct(e.modifiers) ? e.modifiers : {};
    let N = e.pluralRules || t && t.pluralRules,
      V;
    V = (() => {
      i && Vh(null);
      const L = {
        version: xx,
        locale: a.value,
        fallbackLocale: l.value,
        messages: u.value,
        modifiers: O,
        pluralRules: N,
        missing: m === null ? void 0 : m,
        missingWarn: d,
        fallbackWarn: p,
        fallbackFormat: g,
        unresolving: !0,
        postTranslation: x === null ? void 0 : x,
        warnHtmlMessage: T,
        escapeParameter: P,
        messageResolver: e.messageResolver,
        messageCompiler: e.messageCompiler,
        __meta: {
          framework: "vue"
        }
      };
      L.datetimeFormats = c.value, L.numberFormats = f.value, L.__datetimeFormatters = Ct(V) ? V.__datetimeFormatters : void 0, L.__numberFormatters = Ct(V) ? V.__numberFormatters : void 0;
      const X = lx(L);
      return i && Vh(X), X
    })(), Fr(V, a.value, l.value);

    function C() {
      return [a.value, l.value, u.value, c.value, f.value]
    }
    const I = le({
        get: () => a.value,
        set: L => {
          a.value = L, V.locale = a.value
        }
      }),
      U = le({
        get: () => l.value,
        set: L => {
          l.value = L, V.fallbackLocale = l.value, Fr(V, a.value, L)
        }
      }),
      j = le(() => u.value),
      Z = le(() => c.value),
      se = le(() => f.value);

    function Ve() {
      return Fs(x) ? x : null
    }

    function pe(L) {
      x = L, V.postTranslation = L
    }

    function _() {
      return A
    }

    function Q(L) {
      L !== null && (m = Yh(L)), A = L, V.missing = m
    }
    const ze = (L, X, q, K, $, ke) => {
      C();
      let Te;
      try {
        __INTLIFY_PROD_DEVTOOLS__,
        i || (V.fallbackContext = t ? ax() : void 0),
        Te = L(V)
      }
      finally {
        __INTLIFY_PROD_DEVTOOLS__,
        i || (V.fallbackContext = void 0)
      }
      if (q !== "translate exists" && Nr(Te) && Te === Ms || q === "translate exists" && !Te) {
        const [Dt, kt] = X();
        return t && h ? K(t) : $(Dt)
      } else {
        if (ke(Te)) return Te;
        throw Wt(Tt.UNEXPECTED_RETURN_TYPE)
      }
    };

    function zt(...L) {
      return ze(X => Reflect.apply(Mh, null, [X, ...L]), () => gl(...L), "translate", X => Reflect.apply(X.t, X, [...L]), X => X, X => Oe(X))
    }

    function nt(...L) {
      const [X, q, K] = L;
      if (K && !lt(K)) throw Wt(Tt.INVALID_ARGUMENT);
      return zt(X, q, Yt({
        resolvedMessage: !0
      }, K || {}))
    }

    function qe(...L) {
      return ze(X => Reflect.apply(jh, null, [X, ...L]), () => ml(...L), "datetime format", X => Reflect.apply(X.d, X, [...L]), () => Th, X => Oe(X))
    }

    function zn(...L) {
      return ze(X => Reflect.apply(Ch, null, [X, ...L]), () => vl(...L), "number format", X => Reflect.apply(X.n, X, [...L]), () => Th, X => Oe(X))
    }

    function Gn(L) {
      return L.map(X => Oe(X) || Nr(X) || wn(X) ? Bh(String(X)) : X)
    }
    const dt = {
      normalize: Gn,
      interpolate: L => L,
      type: "vnode"
    };

    function vt(...L) {
      return ze(X => {
        let q;
        const K = X;
        try {
          K.processor = dt, q = Reflect.apply(Mh, null, [K, ...L])
        } finally {
          K.processor = null
        }
        return q
      }, () => gl(...L), "translate", X => X[yl](...L), X => [Bh(X)], X => Pn(X))
    }

    function pt(...L) {
      return ze(X => Reflect.apply(Ch, null, [X, ...L]), () => vl(...L), "number format", X => X[Al](...L), Kh, X => Oe(X) || Pn(X))
    }

    function Xt(...L) {
      return ze(X => Reflect.apply(jh, null, [X, ...L]), () => ml(...L), "datetime format", X => X[bl](...L), Kh, X => Oe(X) || Pn(X))
    }

    function Xn(L) {
      N = L, V.pluralRules = N
    }

    function oo(L, X) {
      return ze(() => {
        if (!L) return !1;
        const q = Oe(X) ? X : a.value,
          K = D(q),
          $ = V.messageResolver(K, L);
        return $t($) || xt($) || Oe($)
      }, () => [L], "translate exists", q => Reflect.apply(q.te, q, [L, X]), zx, q => wn(q))
    }

    function b(L) {
      let X = null;
      const q = Ph(V, l.value, a.value);
      for (let K = 0; K < q.length; K++) {
        const $ = u.value[q[K]] || {},
          ke = V.messageResolver($, L);
        if (ke != null) {
          X = ke;
          break
        }
      }
      return X
    }

    function w(L) {
      const X = b(L);
      return X ?? (t ? t.tm(L) || {} : {})
    }

    function D(L) {
      return u.value[L] || {}
    }

    function H(L, X) {
      if (r) {
        const q = {
          [L]: X
        };
        for (const K in q) Rs(q, K) && Cr(q[K]);
        X = q[L]
      }
      u.value[L] = X, V.messages = u.value
    }

    function W(L, X) {
      u.value[L] = u.value[L] || {};
      const q = {
        [L]: X
      };
      if (r)
        for (const K in q) Rs(q, K) && Cr(q[K]);
      X = q[L], Ws(X, u.value[L]), V.messages = u.value
    }

    function k(L) {
      return c.value[L] || {}
    }

    function v(L, X) {
      c.value[L] = X, V.datetimeFormats = c.value, Fh(V, L, X)
    }

    function y(L, X) {
      c.value[L] = Yt(c.value[L] || {}, X), V.datetimeFormats = c.value, Fh(V, L, X)
    }

    function S(L) {
      return f.value[L] || {}
    }

    function z(L, X) {
      f.value[L] = X, V.numberFormats = f.value, Hh(V, L, X)
    }

    function M(L, X) {
      f.value[L] = Yt(f.value[L] || {}, X), V.numberFormats = f.value, Hh(V, L, X)
    }
    Jh++, t && js && (dn(t.locale, L => {
      o && (a.value = L, V.locale = L, Fr(V, a.value, l.value))
    }), dn(t.fallbackLocale, L => {
      o && (l.value = L, V.fallbackLocale = L, Fr(V, a.value, l.value))
    }));
    const F = {
      id: Jh,
      locale: I,
      fallbackLocale: U,
      get inheritLocale() {
        return o
      },
      set inheritLocale(L) {
        o = L, L && t && (a.value = t.locale.value, l.value = t.fallbackLocale.value, Fr(V, a.value, l.value))
      },
      get availableLocales() {
        return Object.keys(u.value).sort()
      },
      messages: j,
      get modifiers() {
        return O
      },
      get pluralRules() {
        return N || {}
      },
      get isGlobal() {
        return i
      },
      get missingWarn() {
        return d
      },
      set missingWarn(L) {
        d = L, V.missingWarn = d
      },
      get fallbackWarn() {
        return p
      },
      set fallbackWarn(L) {
        p = L, V.fallbackWarn = p
      },
      get fallbackRoot() {
        return h
      },
      set fallbackRoot(L) {
        h = L
      },
      get fallbackFormat() {
        return g
      },
      set fallbackFormat(L) {
        g = L, V.fallbackFormat = g
      },
      get warnHtmlMessage() {
        return T
      },
      set warnHtmlMessage(L) {
        T = L, V.warnHtmlMessage = L
      },
      get escapeParameter() {
        return P
      },
      set escapeParameter(L) {
        P = L, V.escapeParameter = L
      },
      t: zt,
      getLocaleMessage: D,
      setLocaleMessage: H,
      mergeLocaleMessage: W,
      getPostTranslationHandler: Ve,
      setPostTranslationHandler: pe,
      getMissingHandler: _,
      setMissingHandler: Q,
      [Lx]: Xn
    };
    return F.datetimeFormats = Z, F.numberFormats = se, F.rt = nt, F.te = oo, F.tm = w, F.d = qe, F.n = zn, F.getDateTimeFormat = k, F.setDateTimeFormat = v, F.mergeDateTimeFormat = y, F.getNumberFormat = S, F.setNumberFormat = z, F.mergeNumberFormat = M, F[Sx] = n, F[yl] = vt, F[bl] = Xt, F[Al] = pt, F
  }
  const wl = {
    tag: {
      type: [String, Object]
    },
    locale: {
      type: String
    },
    scope: {
      type: String,
      validator: e => e === "parent" || e === "global",
      default: "parent"
    },
    i18n: {
      type: Object
    }
  };

  function Dx({
    slots: e
  }, t) {
    return t.length === 1 && t[0] === "default" ? (e.default ? e.default() : []).reduce((i, r) => [...i, ...r.type === We ? r.children : [r]], []) : t.reduce((n, i) => {
      const r = e[i];
      return r && (n[i] = r()), n
    }, at())
  }

  function _h() {
    return We
  }
  const $h = Ce({
    name: "i18n-t",
    props: Yt({
      keypath: {
        type: String,
        required: !0
      },
      plural: {
        type: [Number, String],
        validator: e => Nr(e) || !isNaN(e)
      }
    }, wl),
    setup(e, t) {
      const {
        slots: n,
        attrs: i
      } = t, r = e.i18n || en({
        useScope: e.scope,
        __useComponent: !0
      });
      return () => {
        const s = Object.keys(n).filter(f => f !== "_"),
          o = at();
        e.locale && (o.locale = e.locale), e.plural !== void 0 && (o.plural = Oe(e.plural) ? +e.plural : e.plural);
        const a = Dx(t, s),
          l = r[yl](e.keypath, a, o),
          u = Yt(at(), i),
          c = Oe(e.tag) || lt(e.tag) ? e.tag : _h();
        return ur(c, u, l)
      }
    }
  });

  function Vx(e) {
    return Pn(e) && !Oe(e[0])
  }

  function em(e, t, n, i) {
    const {
      slots: r,
      attrs: s
    } = t;
    return () => {
      const o = {
        part: !0
      };
      let a = at();
      e.locale && (o.locale = e.locale), Oe(e.format) ? o.key = e.format : lt(e.format) && (Oe(e.format.key) && (o.key = e.format.key), a = Object.keys(e.format).reduce((d, p) => n.includes(p) ? Yt(at(), d, {
        [p]: e.format[p]
      }) : d, at()));
      const l = i(e.value, o, a);
      let u = [o.key];
      Pn(l) ? u = l.map((d, p) => {
        const h = r[d.type],
          g = h ? h({
            [d.type]: d.value,
            index: p,
            parts: l
          }) : [d.value];
        return Vx(g) && (g[0].key = `${d.type}-${p}`), g
      }) : Oe(l) && (u = [l]);
      const c = Yt(at(), s),
        f = Oe(e.tag) || lt(e.tag) ? e.tag : _h();
      return ur(f, c, u)
    }
  }
  const tm = Ce({
      name: "i18n-n",
      props: Yt({
        value: {
          type: Number,
          required: !0
        },
        format: {
          type: [String, Object]
        }
      }, wl),
      setup(e, t) {
        const n = e.i18n || en({
          useScope: e.scope,
          __useComponent: !0
        });
        return em(e, t, Wh, (...i) => n[Al](...i))
      }
    }),
    nm = Ce({
      name: "i18n-d",
      props: Yt({
        value: {
          type: [Number, Date],
          required: !0
        },
        format: {
          type: [String, Object]
        }
      }, wl),
      setup(e, t) {
        const n = e.i18n || en({
          useScope: e.scope,
          __useComponent: !0
        });
        return em(e, t, Rh, (...i) => n[bl](...i))
      }
    });

  function Nx(e, t) {
    const n = e;
    if (e.mode === "composition") return n.__getInstance(t) || e.global;
    {
      const i = n.__getInstance(t);
      return i != null ? i.__composer : e.global.__composer
    }
  }

  function jx(e) {
    const t = o => {
      const {
        instance: a,
        value: l
      } = o;
      if (!a || !a.$) throw Wt(Tt.UNEXPECTED_ERROR);
      const u = Nx(e, a.$),
        c = im(l);
      return [Reflect.apply(u.t, u, [...rm(c)]), u]
    };
    return {
      created: (o, a) => {
        const [l, u] = t(a);
        js && e.global === u && (o.__i18nWatcher = dn(u.locale, () => {
          a.instance && a.instance.$forceUpdate()
        })), o.__composer = u, o.textContent = l
      },
      unmounted: o => {
        js && o.__i18nWatcher && (o.__i18nWatcher(), o.__i18nWatcher = void 0, delete o.__i18nWatcher), o.__composer && (o.__composer = void 0, delete o.__composer)
      },
      beforeUpdate: (o, {
        value: a
      }) => {
        if (o.__composer) {
          const l = o.__composer,
            u = im(a);
          o.textContent = Reflect.apply(l.t, l, [...rm(u)])
        }
      },
      getSSRProps: o => {
        const [a] = t(o);
        return {
          textContent: a
        }
      }
    }
  }

  function im(e) {
    if (Oe(e)) return {
      path: e
    };
    if (Ct(e)) {
      if (!("path" in e)) throw Wt(Tt.REQUIRED_VALUE, "path");
      return e
    } else throw Wt(Tt.INVALID_VALUE)
  }

  function rm(e) {
    const {
      path: t,
      locale: n,
      args: i,
      choice: r,
      plural: s
    } = e, o = {}, a = i || {};
    return Oe(n) && (o.locale = n), Nr(r) && (o.plural = r), Nr(s) && (o.plural = s), [t, a, o]
  }

  function Rx(e, t, ...n) {
    const i = Ct(n[0]) ? n[0] : {};
    (wn(i.globalInstall) ? i.globalInstall : !0) && ([$h.name, "I18nT"].forEach(s => e.component(s, $h)), [tm.name, "I18nN"].forEach(s => e.component(s, tm)), [nm.name, "I18nD"].forEach(s => e.component(s, nm))), e.directive("t", jx(t))
  }
  const Fx = Hn("global-vue-i18n");

  function Cx(e = {}, t) {
    const n = wn(e.globalInjection) ? e.globalInjection : !0,
      i = new Map,
      [r, s] = Wx(e),
      o = Hn("");

    function a(f) {
      return i.get(f) || null
    }

    function l(f, d) {
      i.set(f, d)
    }

    function u(f) {
      i.delete(f)
    }
    const c = {
      get mode() {
        return "composition"
      },
      async install(f, ...d) {
        if (f.__VUE_I18N_SYMBOL__ = o, f.provide(f.__VUE_I18N_SYMBOL__, c), Ct(d[0])) {
          const g = d[0];
          c.__composerExtend = g.__composerExtend, c.__vueI18nExtend = g.__vueI18nExtend
        }
        let p = null;
        n && (p = Ux(f, c.global)), Rx(f, c, ...d);
        const h = f.unmount;
        f.unmount = () => {
          p && p(), c.dispose(), h()
        }
      },
      get global() {
        return s
      },
      dispose() {
        r.stop()
      },
      __instances: i,
      __getInstance: a,
      __setInstance: l,
      __deleteInstance: u
    };
    return c
  }

  function en(e = {}) {
    const t = ni();
    if (t == null) throw Wt(Tt.MUST_BE_CALL_SETUP_TOP);
    if (!t.isCE && t.appContext.app != null && !t.appContext.app.__VUE_I18N_SYMBOL__) throw Wt(Tt.NOT_INSTALLED);
    const n = Hx(t),
      i = Ex(n),
      r = Uh(t),
      s = kx(e, r);
    if (s === "global") return Ox(i, e, r), i;
    if (s === "parent") {
      let l = Mx(n, t, e.__useComponent);
      return l == null && (l = i), l
    }
    const o = n;
    let a = o.__getInstance(t);
    if (a == null) {
      const l = Yt({}, e);
      "__i18n" in r && (l.__i18n = r.__i18n), i && (l.__root = i), a = Qh(l), o.__composerExtend && (a[Pl] = o.__composerExtend(a)), qx(o, t, a), o.__setInstance(t, a)
    }
    return a
  }

  function Wx(e, t, n) {
    const i = cv(),
      r = i.run(() => Qh(e));
    if (r == null) throw Wt(Tt.UNEXPECTED_ERROR);
    return [i, r]
  }

  function Hx(e) {
    const t = jn(e.isCE ? Fx : e.appContext.app.__VUE_I18N_SYMBOL__);
    if (!t) throw Wt(e.isCE ? Tt.NOT_INSTALLED_WITH_PROVIDE : Tt.UNEXPECTED_ERROR);
    return t
  }

  function kx(e, t) {
    return Z1(e) ? "__i18n" in t ? "local" : "global" : e.useScope ? e.useScope : "local"
  }

  function Ex(e) {
    return e.mode === "composition" ? e.global : e.global.__composer
  }

  function Mx(e, t, n = !1) {
    let i = null;
    const r = t.root;
    let s = Ix(t, n);
    for (; s != null;) {
      const o = e;
      if (e.mode === "composition" && (i = o.__getInstance(s)), i != null || r === s) break;
      s = s.parent
    }
    return i
  }

  function Ix(e, t = !1) {
    return e == null ? null : t && e.vnode.ctx || e.parent
  }

  function qx(e, t, n) {
    Zt(() => {}, t), $n(() => {
      const i = n;
      e.__deleteInstance(t);
      const r = i[Pl];
      r && (r(), delete i[Pl])
    }, t)
  }
  const Zx = ["locale", "fallbackLocale", "availableLocales"],
    sm = ["t", "rt", "d", "n", "tm", "te"];

  function Ux(e, t) {
    const n = Object.create(null);
    return Zx.forEach(r => {
      const s = Object.getOwnPropertyDescriptor(t, r);
      if (!s) throw Wt(Tt.UNEXPECTED_ERROR);
      const o = Re(s.value) ? {
        get() {
          return s.value.value
        },
        set(a) {
          s.value.value = a
        }
      } : {
        get() {
          return s.get && s.get()
        }
      };
      Object.defineProperty(n, r, o)
    }), e.config.globalProperties.$i18n = n, sm.forEach(r => {
      const s = Object.getOwnPropertyDescriptor(t, r);
      if (!s || !s.value) throw Wt(Tt.UNEXPECTED_ERROR);
      Object.defineProperty(e.config.globalProperties, `$${r}`, s)
    }), () => {
      delete e.config.globalProperties.$i18n, sm.forEach(r => {
        delete e.config.globalProperties[`$${r}`]
      })
    }
  }
  if (Tx(), nx(Ww), ix($w), rx(Ph), __INTLIFY_PROD_DEVTOOLS__) {
    const e = th();
    e.__INTLIFY__ = !0, Hw(e.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__)
  }
  const Bx = {
      class: "tooltip-text"
    },
    Gx = ["innerHTML"],
    Kx = 176,
    Jx = Ce({
      __name: "CoinTooltip",
      props: {
        height: {},
        scale: {},
        message: {}
      },
      emits: ["click"],
      setup(e, {
        emit: t
      }) {
        const {
          t: n
        } = en(), i = e, r = t, s = te(null), o = te("right"), a = le(() => {
          const f = 48 * (i.scale ?? 1);
          return {
            title: `${f*.9}px`,
            subtitle: `${f*1.1}px`,
            base: f
          }
        }), l = () => {
          if (s.value) {
            const f = Kx * (i.scale ?? 1);
            s.value.style.height = `${f}px`
          }
        }, u = () => {
          if (s.value) {
            const f = s.value.getBoundingClientRect(),
              d = window.innerWidth / 2;
            o.value = f.left > d ? "left" : "right"
          }
        };
        Zt(() => {
          l(), Vo(() => {
            u()
          })
        }), dn(() => i.scale, () => {
          l(), Vo(() => {
            u()
          })
        });
        const c = () => {
          r("click")
        };
        return (f, d) => (ae(), rt(mn, {
          name: o.value === "left" ? "slide-left" : "slide-right",
          appear: ""
        }, {
          default: ve(() => [ee("div", {
            ref_key: "tooltipContainer",
            ref: s,
            class: Zi(["tooltip-container", `tooltip-${o.value}`]),
            style: bt({
              "--base-size": `${a.value.base}px`
            }),
            onClick: vs(c, ["stop"])
          }, [ee("span", Bx, [ee("span", {
            style: bt({
              fontSize: a.value.title
            }),
            innerHTML: fe(n)(`${f.message}`).replace(/\n/g, "<br>")
          }, null, 12, Gx)])], 6)]),
          _: 1
        }, 8, ["name"]))
      }
    }),
    Lt = (e, t) => {
      const n = e.__vccOpts || e;
      for (const [i, r] of t) n[i] = r;
      return n
    },
    Yx = Lt(Jx, [
      ["__scopeId", "data-v-65f5ce74"]
    ]),
    om = "data:image/png;base64,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",
    xl = 186,
    Qx = 1116,
    _x = Lt(Ce({
      __name: "CoinAnimation",
      props: {
        scale: {}
      },
      emits: ["animation_end"],
      setup(e, {
        expose: t,
        emit: n
      }) {
        const i = e,
          r = le(() => i.scale ?? 1),
          s = n,
          o = te(!1),
          a = () => {
            o.value = !0
          },
          l = () => {
            o.value = !1
          },
          u = () => {
            o.value = !1, s("animation_end")
          };
        return t({
          run: a,
          cancel: l
        }), (c, f) => (ae(), Ue("div", {
          class: Zi(["coin-sprite", {
            "coin-animate": o.value
          }]),
          style: bt({
            width: `${xl}px`,
            height: `${xl}px`,
            transform: `translate(-50%, -50%) scale(${r.value})`,
            backgroundSize: `${Qx}px ${xl}px`,
            backgroundImage: fe(om) ? `url(${fe(om)})` : "none"
          }),
          onAnimationend: u
        }, null, 38))
      }
    }), [
      ["__scopeId", "data-v-894a8d02"]
    ]),
    am = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAATrSURBVHgB7Z29ctNKFIDPWoHJUPmG/uLm5rbQ3jvJOPWN75gnwHkC4AkSOjrgCYAniIefOoEwDGVKBhoDDTTBVDAD0rJH0RrHkbQ/Wu0eBX0zmTj2zkr7aS3tnj1SAAizud7d3lxf2QbCREAUlAec7YiX/dXeBXjz7uszIAhJgXPyJGQlkhOYI09CUiIpgSXyJOQkkhGoIU9CSiIJgQbyJGQkBhdoIU9CQmJQgRXkSYJLDCbQgTxJUIlBBDqUJwkm0bvAGuRJgkj0KrBGeRLvEr0J9CBP4lWiF4GDf1duAIPbqnIMYMoYfBQvuwVFVJ9LvEnsgAeic8lYNHxSVgblRTHf4Ly4XFqmwzdUdaVwvjNYuziCmvEicLw/nZQ1XMobv5weVq1rrtLDKIrHUDNeBCJFDRfyJrryVHXNVXq4JD4X5aZQM94EIosNT+VFZvKK6prhUR7iVSAiGy5e7qfyxN9gSd4BEfKu+pKHLEEAMmkb4ACsa9jvbvyI2X1xQLaqHBAbggh0jcsDYor3r/BZoxVYkVZgRazPgTi3FfYnj55PH0KDSefowIa2Qx+rHigDAwlnD/5f716DhjILcHC4/CNhe+Jqrppjn8JY4GJUBSVST7/I41R0yFKikcD/1lbu54akxMS9SRILQ2sWErUFojwGfFRYoCESlXFJQ4laApXyMhjnI5vziC9w3xiwkbKggUSlQF15x+Ejf5N4G3DfxNz5Cu6rsrCmxFKBJvKyYcAEiIMScV9dSSwUaCGPbM9bxKXEXIFnWZ7ElUS2+Ib2BUPMQuJ46er589+dysOwlPjVh4Jt4nkW3NKNE7Yr1mJ6ypI5HeaEQO2e9zuzIHEmsJWnz2wpQlw0U4GtPHOkRNbKq8R+pwMJydsHqJMuYIk1mPQrPPynezmO2B5Xp0y0QM45EGkl6jEvL/v7F0YSxeU84Z174JiIJduFY7KattlhyXUcLKvKLcrL3juJiUTG2N3Hz49ugkM21/7Yg4KBtGD/ycFnpwNp3bS7PHnIqakcpllgrgom/IACzvmNAQZZG8pgfeVOFXlI7lzYSKIYAjVRIg7fsAOoypXJQwqjMWdZosl8X5W/UxoPPIsSXcpDlBFpE4lJzkWJIEyjgJY8RGtNREei+Gz89OBoBMTBfeTACpMBTOQh2qtypRKP10O2oCEUSTSVhxitC+dKbGhUelGijTzEODPhhMQGh/QRKdFWHmKVGyMlNlmeBCUKeVdsVxSts7NsEsOpUqUTtPmBFWkFVqQVWJFgAgdrF4fgiEHfXV2mBBGIMTgOya6LuXMaVYmT3VCpdd4FzgcwqwYgMJ43CwwEyk/0KjAv+osSbRqe9uLFeF4Aid4ElobODRvusq6qULpjPb3LXNDLfvKYrPaWexph+P5fly58efv+6yuoGTJ3rKeI3iPmpWWrY33dNYxzUTIGD3gLgA773V6ciNU+nTSyClQJDFhuzx91S/QtL9umX+qSGEJetl3/uJZo8tAK1wRbBHIlMaS8bPvhqJrQFFoeEjQaY7Jkmg/fCh3YDR7OspUo5sBbjw+mXsZ65ftBBKOssGN5D4AAZJ7i+/rDt49/X1r+hHePlxbk7NaTF5/vAhFIPUf6zftvh0Liu0KJqbyjHSAEuSeZF0okKA8h+Sz9UxKJykPI/jcHlLj657K4yHWeUZWH/ATZ3XKPovW6BgAAAABJRU5ErkJggg==",
    E = {
      currency: "",
      locale: "",
      identifier: "",
      rules: {
        currency: {
          subunits: 0,
          code: "",
          symbol: ""
        }
      },
      drops_url: "",
      drops_token: "",
      fe_script_url: "",
      isShowLobby: !1,
      isShowGameList: !1,
      isShowProfile: !1,
      challenges_url: "",
      challenges_token: ""
    },
    $x = () => {
      var e, t, n, i, r, s, o, a, l, u, c, f, d, p, h, g, A;
      E.currency = window.__OPTIONS__.currency, E.locale = window.__OPTIONS__.locale, E.identifier = window.__OPTIONS__.identifier, E.rules = (e = window.__OPTIONS__) == null ? void 0 : e.rules, E.drops_url = ((n = (t = window.__OPTIONS__) == null ? void 0 : t.lobby_v2_options) == null ? void 0 : n.drops_api_url) || "", E.drops_token = ((r = (i = window.__OPTIONS__) == null ? void 0 : i.lobby_v2_options) == null ? void 0 : r.drops_token) || "", E.fe_script_url = ((o = (s = window.__OPTIONS__) == null ? void 0 : s.lobby_v2_options) == null ? void 0 : o.drops_fe_script_url) || "", E.isShowLobby = ((l = (a = window.__OPTIONS__) == null ? void 0 : a.lobby_v2_options) == null ? void 0 : l.lobby_enabled) || !1, E.isShowGameList = ((c = (u = window.__OPTIONS__) == null ? void 0 : u.lobby_v2_options) == null ? void 0 : c.gamelist_enabled) || !1, E.isShowProfile = ((d = (f = window.__OPTIONS__) == null ? void 0 : f.lobby_v2_options) == null ? void 0 : d.profile_enabled) || !1, E.challenges_url = ((h = (p = window.__OPTIONS__) == null ? void 0 : p.lobby_v2_options) == null ? void 0 : h.challenges_api_url) || "", E.challenges_token = ((A = (g = window.__OPTIONS__) == null ? void 0 : g.lobby_v2_options) == null ? void 0 : A.challenges_token) || ""
    },
    e8 = "en-SOCIAL",
    lm = le(() => E.locale === e8),
    t8 = Xe.forDomain("FormatCurrency"),
    cm = e => {
      const t = e.subunits ? Math.floor(Math.log10(e.subunits)) : 0,
        n = e.code || "",
        i = e.symbol || "",
        r = (f, d) => lm.value ? `${d} ${f}` : `${f} ${d}`,
        s = (f, d = !1, p, h, g) => {
          let A = f / Math.pow(10, h);
          t8.info("toFullMoney", {
            localCents: f,
            useSymbol: d,
            currency: p,
            exponent: h,
            currencySymbol: g,
            value: A
          });
          const m = d ? g : p;
          return {
            value: A % 1 === 0 ? A.toFixed(0) : A.toFixed(h),
            symbol: m
          }
        },
        o = (f, d = !1) => s(f, d, n, t, i),
        a = (f, d = !1) => s(f, d, "EUR", 2, ""),
        l = (f, d = !1, p, h, g) => {
          let A = f / Math.pow(10, h);
          const m = d ? g : p;
          if (A === 0) return `0 ${m}`;
          if (A < 1) {
            const T = A.toString().match(/^(\d+\.0*[^0])/);
            return r(T ? parseFloat(T[1]) : "0", m)
          }
          if (A >= 1) {
            A = Math.trunc(A);
            const x = [{
              range: 1e9,
              suffix: "B"
            }, {
              range: 1e6,
              suffix: "M"
            }, {
              range: 1e3,
              suffix: "K"
            }];
            for (const {
                range: T,
                suffix: P
              }
              of x)
              if (A >= T) {
                const O = Math.floor(A / T * 10) / 10;
                return r(`${O}${P}`, m)
              }
          }
          return r(A, m)
        };
      return {
        toFullForLocal: o,
        toFullForEuro: a,
        toShortForLocal: (f, d = !1) => l(f, d, n, t, i),
        toShortForEuro: (f, d = !1) => l(f, d, "EUR", 2, "")
      }
    };

  function n8(e, t) {
    let n = null;
    return (...i) => {
      n !== null && clearTimeout(n), n = setTimeout(() => {
        e(...i)
      }, t)
    }
  }

  function i8(e = {}) {
    const {
      baseCoinSize: t = 186,
      portraitPaddingX: n = 45,
      portraitTop: i = 150,
      portraitBottom: r = 300,
      landscapePaddingX: s = 50,
      landscapePaddingY: o = 100,
      resizeDebounceMs: a = 300
    } = e, l = te(.7), u = te({
      top: 100,
      right: 100,
      bottom: 100,
      left: 100
    }), c = te({
      width: 0,
      height: 0
    }), f = le(() => ({
      width: t * l.value,
      height: t * l.value
    })), d = le(() => window.innerHeight > window.innerWidth), p = () => d.value ? Math.min(window.innerHeight / 1920, window.innerWidth / 1080, 1) : Math.min(window.innerHeight / 1080, window.innerWidth / 1920, 1), h = () => {
      let m = p();
      l.value = m;
      const x = d.value ? {
        left: n * m,
        right: n * m,
        top: i * m,
        bottom: r * m
      } : {
        left: s * m,
        right: s * m,
        top: o * m,
        bottom: o * m
      };
      u.value = x
    }, g = () => {
      h(), c.value = {
        width: window.innerWidth,
        height: window.innerHeight
      }
    }, A = n8(g, a);
    return Zt(() => {
      g(), window.addEventListener("resize", A)
    }), $n(() => {
      window.removeEventListener("resize", A)
    }), {
      scale: cn(l),
      padding: cn(u),
      containerBounds: cn(c),
      coinDimensions: cn(f),
      isPortrait: cn(d),
      updateContainerBounds: g,
      calculatePadding: h,
      calculateGameScale: p
    }
  }
  const r8 = ["src"],
    s8 = Lt(Ce({
      __name: "CoinWidget",
      props: {
        state: {},
        content: {},
        context: {}
      },
      setup(e) {
        const t = Xe.forDomain("coinWidget"),
          n = i8(),
          i = te({
            xPercent: 0,
            yPercent: 0
          }),
          r = le(() => {
            n.coinDimensions.value.width, n.coinDimensions.value.height;
            const R = n.containerBounds.value.width - n.padding.value.left - n.padding.value.right,
              C = n.containerBounds.value.height - n.padding.value.top - n.padding.value.bottom;
            return {
              x: R * (i.value.xPercent / 100),
              y: C * (i.value.yPercent / 100)
            }
          }),
          s = () => {
            n.isPortrait.value ? i.value = {
              xPercent: 0,
              yPercent: 0
            } : i.value = {
              xPercent: 0,
              yPercent: 100
            }
          },
          o = te(null),
          a = te(null),
          l = te(null),
          u = te(null),
          c = te({
            top: 0,
            left: 0,
            right: 0,
            bottom: 0
          }),
          f = te(!1);

        function d() {
          const R = o.value;
          if (!R) return;
          const C = R.getBoundingClientRect();
          c.value = {
            top: 0,
            left: 0,
            right: C.width - 50,
            bottom: C.height - 50
          }
        }
        const p = e,
          h = le(() => p.content ? q1(p.content.type) : null),
          g = le(() => {
            const R = n.padding.value.left + n.padding.value.right,
              C = n.padding.value.top + n.padding.value.bottom;
            return {
              top: `${n.padding.value.top}px`,
              right: `${n.padding.value.right}px`,
              bottom: `${n.padding.value.bottom}px`,
              left: `${n.padding.value.left}px`,
              width: `calc(100% - ${R}px)`,
              height: `calc(100% - ${C}px)`
            }
          });
        dn(() => n.isPortrait.value, () => {
          s()
        });
        const A = jn("app-view-machine-actor");
        A.on("START_COIN_ANIMATION", R => {
          t.info("Received START_COIN_ANIMATION event", u.value), u.value && u.value.run()
        }), A && (A.on("START_DRAGGING", () => {
          t.info("Received START_DRAGGING event")
        }), A.on("STOP_DRAGGING", () => {
          t.info("Received STOP_DRAGGING event")
        }));
        const m = R => {
            if (t.info("pointer down"), R.target.closest(".tooltip-container")) {
              t.info("tooltip click detected, allowing propagation");
              return
            }
            R.stopPropagation(), R.preventDefault()
          },
          x = R => {
            if (t.info("pointer up - isDragging:", f.value), R.target.closest(".tooltip-container")) {
              t.info("tooltip click detected in pointer up, ignoring");
              return
            }
            f.value ? (f.value = !1, A.send({
              type: "DROP"
            })) : (t.info("coin clicked"), A.send({
              type: "OPEN_LOBBY",
              source: "coin"
            }))
          },
          T = () => {
            t.info("tooltip click"), A.send({
              type: "OPEN_LOBBY",
              source: "tooltip"
            })
          },
          P = R => {
            t.info("pointer leave - ending drag"), A.send({
              type: "DROP"
            })
          },
          O = R => {
            f.value = !0, t.info("Drag actually started!", R), A.send({
              type: "DRAG"
            })
          },
          N = R => {
            if (!o.value) return;
            const C = o.value.getBoundingClientRect(),
              I = n.coinDimensions.value.width,
              U = n.coinDimensions.value.height,
              j = C.width - I,
              Z = C.height - U,
              se = Math.max(0, Math.min(j, R.x)),
              Ve = Math.max(0, Math.min(Z, R.y));
            i.value.xPercent = se / j * 100, i.value.yPercent = Ve / Z * 100
          };
        Zt(() => {
          var R;
          d(), t.info("onMounted content:", p.state), s(), o.value && (l.value = new ResizeObserver(d), l.value.observe(o.value)), (R = u.value) == null || R.run()
        }), as(() => {
          l.value && o.value && (l.value.unobserve(o.value), l.value.disconnect())
        });
        const V = () => {
          A.send({
            type: "ANIMATION_END"
          })
        };
        return (R, C) => {
          var I, U, j, Z;
          return ae(), Ue("div", {
            ref_key: "containerRef",
            ref: o,
            class: "container",
            style: bt(g.value),
            onPointerleave: P
          }, [ne(fe(Ns).div, {
            ref_key: "widgetRef",
            ref: a,
            style: bt({
              opacity: (I = R.state) != null && I.matches("showCoinWidget.disabled") ? .5 : 1,
              userSelect: "none",
              pointerEvents: (U = R.state) != null && U.matches("showCoinWidget.disabled") ? "none" : "auto",
              position: "absolute",
              transform: `translate(${r.value.x}px, ${r.value.y}px)`,
              width: `${fe(n).coinDimensions.value.width}px`,
              height: `${fe(n).coinDimensions.value.height}px`
            }),
            disabled: (j = R.state) == null ? void 0 : j.matches("showCoinWidget.disabled"),
            drag: !((Z = R.state) != null && Z.matches("showCoinWidget.disabled")),
            dragDistance: 5,
            whileHover: {
              scale: 1.1
            },
            whileTap: {
              boxShadow: "0px 0px 15px rgba(0,0,0,0.2)"
            },
            dragTransition: {
              bounceStiffness: 0,
              bounceDamping: 0
            },
            dragElastic: 0,
            dragMomentum: !1,
            class: "box",
            dragConstraints: o.value,
            onPointerdown: vs(m, ["stop"]),
            onPointerup: x,
            onDragStart: O,
            onDrag: N,
            onClick: C[0] || (C[0] = vs(() => {}, ["stop"])),
            onMousedown: C[1] || (C[1] = vs(() => {}, ["stop"])),
            initial: {
              scale: .8
            },
            animate: {
              scale: 1
            },
            transition: {
              type: "spring",
              stiffness: 500,
              damping: 15,
              mass: 1
            }
          }, {
            default: ve(() => {
              var se, Ve, pe, _, Q;
              return [ne(_x, {
                ref_key: "coinAnimationRef",
                ref: u,
                scale: fe(n).scale.value,
                style: {
                  pointerEvents: "none",
                  touchAction: "none",
                  cursor: "inherit"
                },
                onAnimation_end: V
              }, null, 8, ["scale"]), (se = R.state) != null && se.matches("showCoinWidget.showContent") ? (ae(), rt(fe(Ns).div, {
                initial: {
                  scale: .8,
                  opacity: 0
                },
                animate: {
                  scale: 1,
                  opacity: 1
                },
                exit: {
                  scale: .8,
                  opacity: 0,
                  zIndex: 10
                },
                transition: {
                  type: "spring",
                  stiffness: 500,
                  damping: 15,
                  mass: 1
                },
                key: `content-${(Ve=R.content)==null?void 0:Ve.type}`,
                class: "coin-content"
              }, {
                default: ve(() => [h.value && R.content ? (ae(), rt(sg(h.value), {
                  key: 0,
                  data: R.content,
                  scale: fe(n).scale.value
                }, null, 8, ["data", "scale"])) : Rt("", !0)]),
                _: 1
              })) : Rt("", !0), (pe = R.state) != null && pe.matches("showCoinWidget.dragging") ? (ae(), rt(fe(Ns).div, {
                key: `dragging-${(_=R.content)==null?void 0:_.type}`,
                class: "coin-content",
                initial: {
                  scale: .8,
                  opacity: 0
                },
                animate: {
                  scale: 1,
                  opacity: 1
                },
                exit: {
                  scale: .8,
                  opacity: 0
                },
                transition: {
                  type: "spring",
                  stiffness: 500,
                  damping: 15,
                  mass: 1
                }
              }, {
                default: ve(() => [ee("img", {
                  src: fe(am),
                  alt: "Drag icon",
                  style: bt({
                    transform: `scale(${fe(n).scale.value})`,
                    objectFit: "contain",
                    transformOrigin: "center",
                    pointerEvents: "none",
                    touchAction: "none"
                  })
                }, null, 12, r8)]),
                _: 1
              })) : Rt("", !0), R.context.tooltipMessage ? (ae(), rt(Yx, {
                scale: fe(n).scale.value,
                key: `tooltip-${(Q=R.content)==null?void 0:Q.type}`,
                message: R.context.tooltipMessage.message,
                onClick: T
              }, null, 8, ["scale", "message"])) : Rt("", !0)]
            }),
            _: 1
          }, 8, ["style", "disabled", "drag", "dragConstraints"])], 36)
        }
      }
    }), [
      ["__scopeId", "data-v-f2b66c65"]
    ]);
  var tn = (e => (e.APP_RUN = "APP_RUN", e.APP_DISABLE = "APP_DISABLE", e.APP_ENABLE = "APP_ENABLE", e.APP_UI_OVERLAP = "APP_UI_OVERLAP", e))(tn || {});
  const o8 = {
      CONFIRM_PLAYER_WIN: "confirm_player_win"
    },
    a8 = te(!1);
  cn(te(a8));
  const l8 = te(!1);
  te(l8);
  const c8 = te(!1);
  te(c8);
  const u8 = te(!1);
  te(u8);
  const f8 = te(!1);
  cn(te(f8));
  const d8 = te(""),
    Wr = new Map,
    Hr = (e, t) => {
      var n;
      Wr.has(e) || Wr.set(e, []), (n = Wr.get(e)) == null || n.push(t)
    },
    p8 = (e, t) => {
      const n = Wr.get(e);
      if (n) {
        const i = n.indexOf(t);
        i > -1 && n.splice(i, 1)
      }
    },
    qs = (e, t) => {
      const n = Wr.get(e);
      n && n.forEach(i => i(e, t))
    },
    um = Xe.forDomain("ExtEvents"),
    kr = {
      OPEN_LOBBY: "open_lobby",
      INIT_EXT_WIDGETS: "init_ext_widgets",
      DISABLE_EXT_WIDGETS: "disable_ext_widgets",
      ENABLE_EXT_WIDGETS: "enable_ext_widgets",
      GAME_UI_OVERLAP: "game_ui_overlap"
    },
    h8 = e => {
      qs(tn.APP_UI_OVERLAP, e)
    },
    fm = e => {
      const t = e.data;
      switch (t.name) {
        case kr.GAME_UI_OVERLAP:
          um.info("GAME_UI_OVERLAP", t), h8(t == null ? void 0 : t.isOverlapped);
          break;
        case kr.INIT_EXT_WIDGETS:
          um.info("INIT_EXT_WIDGETS", t), qs(tn.APP_RUN, {
            isOverlapped: t == null ? void 0 : t.isOverlapped,
            isEnabled: t == null ? void 0 : t.isEnabled
          });
          break;
        case kr.DISABLE_EXT_WIDGETS:
          qs(tn.APP_DISABLE);
          break;
        case kr.ENABLE_EXT_WIDGETS:
          qs(tn.APP_ENABLE);
          break
      }
    },
    m8 = () => (window.addEventListener("message", fm), {
      cleanup: () => {
        window.removeEventListener("message", fm)
      }
    }),
    v8 = Xe.forDomain("GameHelper"),
    g8 = () => {
      window.postMessage({
        name: "pause_gameplay"
      }, "*")
    },
    y8 = () => {
      window.postMessage({
        name: "resume_gameplay"
      }, "*")
    },
    Zs = (e = null, t) => {
      v8.info("openLobby", t), window.postMessage({
        name: kr.OPEN_LOBBY,
        eventType: t,
        id: e
      }, "*")
    },
    b8 = Xe.forDomain("CommandDispatcher"),
    di = e => {
      b8.info("commandDispatchEvent", e), window.dispatchEvent(new CustomEvent("external/analytics/incoming", {
        detail: {
          type: "track",
          payload: e
        }
      }))
    },
    A8 = {
      class: "fixed inset-0 z-[998] flex items-center justify-center overflow-auto bg-black bg-opacity-80 font-sans"
    },
    P8 = {
      class: "viewport flex min-h-full items-center justify-center py-4"
    },
    w8 = {
      class: "flex h-full flex-col items-center justify-center p-6 text-center"
    },
    x8 = {
      class: "won-text uppercase"
    },
    T8 = {
      class: "prize-text flex flex-col items-center"
    },
    L8 = {
      class: "flex items-baseline gap-1 text-white"
    },
    S8 = {
      class: "eur-eur"
    },
    O8 = {
      class: "eur-value"
    },
    z8 = {
      class: "eur-value"
    },
    X8 = {
      class: "eur-eur"
    },
    D8 = {
      class: "local-currency"
    },
    V8 = {
      class: "local-currency-tip"
    },
    N8 = ["innerHTML"],
    j8 = {
      class: "campaign-title"
    },
    R8 = {
      class: "logo mt-2"
    },
    F8 = ["src"],
    C8 = Ce({
      __name: "WinPopup",
      props: {
        playerWin: {}
      },
      emits: ["confirmPlayerWin"],
      setup(e, {
        emit: t
      }) {
        var N, V, R, C, I, U;
        const n = Xe.forDomain("WinPopup"),
          {
            t: i
          } = en(),
          r = t,
          s = e,
          {
            toFullForEuro: o,
            toFullForLocal: a
          } = cm({
            code: (V = (N = E == null ? void 0 : E.rules) == null ? void 0 : N.currency) == null ? void 0 : V.code,
            symbol: (C = (R = E == null ? void 0 : E.rules) == null ? void 0 : R.currency) == null ? void 0 : C.symbol,
            subunits: (U = (I = E == null ? void 0 : E.rules) == null ? void 0 : I.currency) == null ? void 0 : U.subunits
          }),
          l = Jv("popupContarerRef"),
          u = le(() => {
            var j, Z;
            return n.info("skinName", (j = s.playerWin) == null ? void 0 : j.skin), n.info("theme", "light"), ((Z = s.playerWin) == null ? void 0 : Z.skin) || "default"
          }),
          c = le(() => `https://drops-skins.bgaming-network.com/skins/${u.value}/bg.png`),
          f = le(() => `https://drops-skins.bgaming-network.com/skins/${u.value}/footer_logo.png`),
          d = () => {
            n.info("confirmPlayerWin"), r("confirmPlayerWin")
          },
          p = () => {
            var j, Z;
            di({
              eventName: "drops_win_popup_closed",
              eventData: {
                game_identifier: E == null ? void 0 : E.identifier,
                campaign_id: (j = s.playerWin) == null ? void 0 : j.campaign_id,
                campaign_status: (Z = s.playerWin) == null ? void 0 : Z.campaign_status
              }
            }), d()
          },
          h = () => {
            var j, Z;
            di({
              eventName: "drops_win_popup_continue",
              eventData: {
                game_identifier: E == null ? void 0 : E.identifier,
                campaign_id: (j = s.playerWin) == null ? void 0 : j.campaign_id,
                campaign_status: (Z = s.playerWin) == null ? void 0 : Z.campaign_status
              }
            }), d()
          },
          g = j => {
            j.preventDefault(), n.info("Touch event detected"), d()
          },
          A = j => {
            var Z, se;
            l.value && !l.value.contains(j.target) && (di({
              eventName: "drops_win_popup_backdrop_closed",
              eventData: {
                game_identifier: E == null ? void 0 : E.identifier,
                campaign_id: (Z = s.playerWin) == null ? void 0 : Z.campaign_id,
                campaign_status: (se = s.playerWin) == null ? void 0 : se.campaign_status
              }
            }), d())
          },
          m = j => {
            l.value && !l.value.contains(j.target) && d()
          },
          x = le(() => {
            var j;
            return ((j = s.playerWin) == null ? void 0 : j.campaign_currency) !== "EUR"
          }),
          T = le(() => {
            var j;
            return ((j = s.playerWin) == null ? void 0 : j.campaign_currency) !== (E == null ? void 0 : E.currency)
          }),
          P = le(() => {
            var j, Z;
            return x.value ? a(((j = s.playerWin) == null ? void 0 : j.amount_cents_in_player_currency) || 0) : o(((Z = s.playerWin) == null ? void 0 : Z.amount_cents_in_campaign_currency) || 0)
          }),
          O = le(() => {
            var j;
            return a(((j = s.playerWin) == null ? void 0 : j.amount_cents_in_player_currency) || 0)
          });
        return Zt(() => {
          var j, Z;
          di({
            eventName: "drops_win_popup_shown",
            eventData: {
              game_identifier: E == null ? void 0 : E.identifier,
              campaign_id: (j = s.playerWin) == null ? void 0 : j.campaign_id,
              campaign_status: (Z = s.playerWin) == null ? void 0 : Z.campaign_status
            }
          }), g8(), window.addEventListener("mouseup", A), window.addEventListener("touchend", m)
        }), $n(() => {
          y8(), window.removeEventListener("mouseup", A), window.removeEventListener("touchend", m)
        }), (j, Z) => (ae(), Ue("div", A8, [ee("div", P8, [ne(mn, {
          name: "fade"
        }, {
          default: ve(() => [ee("div", {
            ref_key: "popupContarerRef",
            ref: l,
            class: "popup-container mx-auto"
          }, [ee("div", {
            class: "relative h-full w-full overflow-hidden rounded-3xl bg-cover bg-center bg-no-repeat",
            style: bt({
              backgroundImage: `url(${c.value})`
            })
          }, [ee("div", w8, [ne(mn, {
            name: "fade-delayed"
          }, {
            default: ve(() => [ee("button", {
              class: "absolute right-4 top-4 cursor-pointer touch-manipulation text-4xl text-white text-opacity-80",
              onClick: p,
              onTouchstart: g
            }, "  ", 32)]),
            _: 1
          }), ne(mn, {
            name: "slide-down"
          }, {
            default: ve(() => [ee("h1", x8, je(fe(i)("win.win_label")), 1)]),
            _: 1
          }), ne(mn, {
            name: "slide-up"
          }, {
            default: ve(() => [ee("div", T8, [ee("div", L8, [fe(lm) ? (ae(), Ue(We, {
              key: 0
            }, [ee("span", S8, je(P.value.symbol), 1), ee("span", O8, je(P.value.value), 1)], 64)) : (ae(), Ue(We, {
              key: 1
            }, [ee("span", z8, je(P.value.value), 1), ee("span", X8, je(P.value.symbol), 1)], 64))]), T.value ? (ae(), Ue(We, {
              key: 0
            }, [ee("p", D8, je(O.value.value) + " " + je(O.value.symbol), 1), ee("p", V8, je(fe(i)("win.minded_tip")), 1)], 64)) : Rt("", !0)])]),
            _: 1
          }), ne(mn, {
            name: "fade-delayed"
          }, {
            default: ve(() => [ee("p", {
              class: "prize-tip-text",
              innerHTML: fe(i)("win.payment_time_tip").replace(/\n/g, "<br>")
            }, null, 8, N8)]),
            _: 1
          }), ne(mn, {
            name: "scale-up"
          }, {
            default: ve(() => [ee("button", {
              onClick: h,
              onTouchstart: g,
              class: "conf-btn touch-manipulation"
            }, je(fe(i)("win.continue_btn")), 33)]),
            _: 1
          }), ne(mn, {
            name: "fade-delayed"
          }, {
            default: ve(() => {
              var se;
              return [ee("div", j8, je((se = j.playerWin) == null ? void 0 : se.campaign_title), 1)]
            }),
            _: 1
          }), ne(mn, {
            name: "fade-delayed"
          }, {
            default: ve(() => [ee("div", R8, [ee("img", {
              src: f.value,
              alt: "Logo",
              class: "h-6"
            }, null, 8, F8)])]),
            _: 1
          })])], 4)], 512)]),
          _: 1
        })])]))
      }
    }),
    W8 = {
      key: 0,
      id: "coin-theme"
    },
    H8 = Lt(Ce({
      __name: "App",
      setup(e) {
        const t = jn("app-view-machine-actor"),
          n = Xe.forDomain("App");
        t.subscribe(l => {
          n.info("state:", l), l.value && (i.value = l, r.value = l.value, s.value = l.context, o.value = l.context.playerWin, t.getSnapshot().context)
        });
        const i = te(null),
          r = te(null),
          s = te({
            count: 0
          }),
          o = te(null),
          a = () => {
            n.info("confirmPlayerWin"), t.send({
              type: "CONTINUE"
            })
          };
        return Zt(() => {
          n.info("app onMounted:", i.value), n.info("app onMounted:", t.getSnapshot().value)
        }), (l, u) => {
          var c, f, d, p, h;
          return (c = i.value) != null && c.matches("hidden") ? Rt("", !0) : (ae(), Ue("div", W8, [(f = i.value) != null && f.matches("showWinPopup") ? (ae(), rt(C8, {
            key: 0,
            playerWin: o.value,
            onConfirmPlayerWin: a
          }, null, 8, ["playerWin"])) : Rt("", !0), (d = i.value) != null && d.matches("showCoinWidget") ? Zv((ae(), rt(s8, {
            key: 1,
            state: i.value,
            content: (p = s.value) == null ? void 0 : p.currentAnimation,
            context: s.value
          }, null, 8, ["state", "content", "context"])), [
            [oy, !((h = i.value) != null && h.matches("showCoinWidget.game_ui_overlap"))]
          ]) : Rt("", !0)]))
        }
      }
    }), [
      ["__scopeId", "data-v-707316fb"]
    ]),
    k8 = Xe.forDomain("useDropAPI");

  function E8(e) {
    k8.info("useDropAPI start", e);
    const t = f => {
        const d = f.indexOf("/api/");
        return d !== -1 ? f.slice(0, d) : f
      },
      n = () => t(e.url),
      i = () => "/api/v1/lobby/",
      r = () => {
        const f = e.token;
        return f ? {
          headers: {
            Authorization: `Bearer ${f}`
          }
        } : {}
      },
      s = f => `${n()}${i()}${f}`;
    return {
      fetchDropsList: async () => await fetch(s("drop_campaigns"), r()).then(f => f.json()).then(f => f.data),
      fetchPlayerWin: async f => await fetch(s(`drop_campaigns/${f}/player_prize`), r()).then(d => d.json()),
      fetchCoinInfo: async f => await fetch(s(`drop_campaigns/${f}/coin_info`), r()).then(d => d.json()),
      confirmPlayerWin: async f => await fetch(s(`won_prizes/${f}/acknowledge`), {
        method: "POST",
        ...r()
      }).then(d => d.json()),
      fetchDropsExist: async () => await fetch(s("drop_campaigns/exists_by_casino"), r()).then(f => f.json())
    }
  }
  const M8 = {
      widget: {
        drop_prize: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Max prize"
          }
        },
        drop_left: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Prizes left"
          }
        },
        drop_tooltip: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: `Join new
Drop`
          }
        },
        challenge_rank: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "#"
          }
        },
        challenge_start: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Starts in"
          }
        },
        challenge_finish: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Finishes in"
          }
        },
        challenge_tooltip: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: `Join new
Challenge`
          }
        },
        timer_day: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "day"
          }
        },
        timer_days: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "days"
          }
        }
      },
      win: {
        win_label: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "You won"
          }
        },
        continue_btn: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "Continue"
          }
        },
        minded_tip: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: "in your currency"
          }
        },
        payment_time_tip: {
          t: 0,
          b: {
            t: 2,
            i: [{
              t: 3
            }],
            s: `the prize will be paid
within 72 hours`
          }
        }
      }
    },
    Tl = Cx({
      locale: "en",
      fallbackLocale: "en",
      messages: {}
    }),
    I8 = async (e, t) => {
      try {
        return await (await fetch(`${t}/l10n/${e}/common.json`)).json()
      } catch {
        return M8
      }
    }, q8 = async (e, t) => {
      const n = await I8(e, t);
      Tl.global.setLocaleMessage(e, n), Tl.global.locale.value = e
    };

  function Z8() {
    if (typeof globalThis < "u") return globalThis;
    if (typeof self < "u") return self;
    if (typeof window < "u") return window;
    if (typeof global < "u") return global
  }

  function U8() {
    const e = Z8();
    if (e.__xstate__) return e.__xstate__
  }
  const B8 = e => {
    if (typeof window > "u") return;
    const t = U8();
    t && t.register(e)
  };
  class dm {
    constructor(t) {
      this._process = t, this._active = !1, this._current = null, this._last = null
    }
    start() {
      this._active = !0, this.flush()
    }
    clear() {
      this._current && (this._current.next = null, this._last = this._current)
    }
    enqueue(t) {
      const n = {
        value: t,
        next: null
      };
      if (this._current) {
        this._last.next = n, this._last = n;
        return
      }
      this._current = n, this._last = n, this._active && this.flush()
    }
    flush() {
      for (; this._current;) {
        const t = this._current;
        this._process(t.value), this._current = t.next
      }
      this._last = null
    }
  }
  const pm = ".",
    G8 = "",
    hm = "",
    K8 = "#",
    J8 = "*",
    mm = "xstate.init",
    Us = "xstate.stop";

  function Y8(e, t) {
    return {
      type: `xstate.after.${e}.${t}`
    }
  }

  function Ll(e, t) {
    return {
      type: `xstate.done.state.${e}`,
      output: t
    }
  }

  function Q8(e, t) {
    return {
      type: `xstate.done.actor.${e}`,
      output: t,
      actorId: e
    }
  }

  function _8(e, t) {
    return {
      type: `xstate.error.actor.${e}`,
      error: t,
      actorId: e
    }
  }

  function vm(e) {
    return {
      type: mm,
      input: e
    }
  }

  function Sn(e) {
    setTimeout(() => {
      throw e
    })
  }
  const $8 = typeof Symbol == "function" && Symbol.observable || "@@observable";

  function gm(e, t) {
    const n = ym(e),
      i = ym(t);
    return typeof i == "string" ? typeof n == "string" ? i === n : !1 : typeof n == "string" ? n in i : Object.keys(n).every(r => r in i ? gm(n[r], i[r]) : !1)
  }

  function Sl(e) {
    if (Pm(e)) return e;
    const t = [];
    let n = "";
    for (let i = 0; i < e.length; i++) {
      switch (e.charCodeAt(i)) {
        case 92:
          n += e[i + 1], i++;
          continue;
        case 46:
          t.push(n), n = "";
          continue
      }
      n += e[i]
    }
    return t.push(n), t
  }

  function ym(e) {
    if (jT(e)) return e.value;
    if (typeof e != "string") return e;
    const t = Sl(e);
    return eT(t)
  }

  function eT(e) {
    if (e.length === 1) return e[0];
    const t = {};
    let n = t;
    for (let i = 0; i < e.length - 1; i++)
      if (i === e.length - 2) n[e[i]] = e[i + 1];
      else {
        const r = n;
        n = {}, r[e[i]] = n
      } return t
  }

  function bm(e, t) {
    const n = {},
      i = Object.keys(e);
    for (let r = 0; r < i.length; r++) {
      const s = i[r];
      n[s] = t(e[s], s, e, r)
    }
    return n
  }

  function Am(e) {
    return Pm(e) ? e : [e]
  }

  function qn(e) {
    return e === void 0 ? [] : Am(e)
  }

  function Ol(e, t, n, i) {
    return typeof e == "function" ? e({
      context: t,
      event: n,
      self: i
    }) : e
  }

  function Pm(e) {
    return Array.isArray(e)
  }

  function tT(e) {
    return e.type.startsWith("xstate.error.actor")
  }

  function Ci(e) {
    return Am(e).map(t => typeof t > "u" || typeof t == "string" ? {
      target: t
    } : t)
  }

  function wm(e) {
    if (!(e === void 0 || e === G8)) return qn(e)
  }

  function zl(e, t, n) {
    var s, o, a;
    const i = typeof e == "object",
      r = i ? e : void 0;
    return {
      next: (s = i ? e.next : e) == null ? void 0 : s.bind(r),
      error: (o = i ? e.error : t) == null ? void 0 : o.bind(r),
      complete: (a = i ? e.complete : n) == null ? void 0 : a.bind(r)
    }
  }

  function xm(e, t) {
    return `${t}.${e}`
  }

  function Xl(e, t) {
    const n = t.match(/^xstate\.invoke\.(\d+)\.(.*)/);
    if (!n) return e.implementations.actors[t];
    const [, i, r] = n, o = e.getStateNodeById(r).config.invoke;
    return (Array.isArray(o) ? o[i] : o).src
  }

  function Tm(e, t) {
    return `${e.sessionId}.${t}`
  }
  let nT = 0;

  function iT(e, t) {
    const n = new Map,
      i = new Map,
      r = new WeakMap,
      s = new Set,
      o = {},
      {
        clock: a,
        logger: l
      } = t,
      u = {
        schedule: (d, p, h, g, A = Math.random().toString(36).slice(2)) => {
          const m = {
              source: d,
              target: p,
              event: h,
              delay: g,
              id: A,
              startedAt: Date.now()
            },
            x = Tm(d, A);
          f._snapshot._scheduledEvents[x] = m;
          const T = a.setTimeout(() => {
            delete o[x], delete f._snapshot._scheduledEvents[x], f._relay(d, p, h)
          }, g);
          o[x] = T
        },
        cancel: (d, p) => {
          const h = Tm(d, p),
            g = o[h];
          delete o[h], delete f._snapshot._scheduledEvents[h], g !== void 0 && a.clearTimeout(g)
        },
        cancelAll: d => {
          for (const p in f._snapshot._scheduledEvents) {
            const h = f._snapshot._scheduledEvents[p];
            h.source === d && u.cancel(d, h.id)
          }
        }
      },
      c = d => {
        if (!s.size) return;
        const p = {
          ...d,
          rootId: e.sessionId
        };
        s.forEach(h => {
          var g;
          return (g = h.next) == null ? void 0 : g.call(h, p)
        })
      },
      f = {
        _snapshot: {
          _scheduledEvents: ((t == null ? void 0 : t.snapshot) && t.snapshot.scheduler) ?? {}
        },
        _bookId: () => `x:${nT++}`,
        _register: (d, p) => (n.set(d, p), d),
        _unregister: d => {
          n.delete(d.sessionId);
          const p = r.get(d);
          p !== void 0 && (i.delete(p), r.delete(d))
        },
        get: d => i.get(d),
        _set: (d, p) => {
          const h = i.get(d);
          if (h && h !== p) throw new Error(`Actor with system ID '${d}' already exists.`);
          i.set(d, p), r.set(p, d)
        },
        inspect: d => {
          const p = zl(d);
          return s.add(p), {
            unsubscribe() {
              s.delete(p)
            }
          }
        },
        _sendInspectionEvent: c,
        _relay: (d, p, h) => {
          f._sendInspectionEvent({
            type: "@xstate.event",
            sourceRef: d,
            actorRef: p,
            event: h
          }), p._send(h)
        },
        scheduler: u,
        getSnapshot: () => ({
          _scheduledEvents: {
            ...f._snapshot._scheduledEvents
          }
        }),
        start: () => {
          const d = f._snapshot._scheduledEvents;
          f._snapshot._scheduledEvents = {};
          for (const p in d) {
            const {
              source: h,
              target: g,
              event: A,
              delay: m,
              id: x
            } = d[p];
            u.schedule(h, g, A, m, x)
          }
        },
        _clock: a,
        _logger: l
      };
    return f
  }
  let Dl = !1;
  const Vl = 1;
  let ut = function(e) {
    return e[e.NotStarted = 0] = "NotStarted", e[e.Running = 1] = "Running", e[e.Stopped = 2] = "Stopped", e
  }({});
  const rT = {
    clock: {
      setTimeout: (e, t) => setTimeout(e, t),
      clearTimeout: e => clearTimeout(e)
    },
    logger: console.log.bind(console),
    devTools: !1
  };
  class sT {
    constructor(t, n) {
      this.logic = t, this._snapshot = void 0, this.clock = void 0, this.options = void 0, this.id = void 0, this.mailbox = new dm(this._process.bind(this)), this.observers = new Set, this.eventListeners = new Map, this.logger = void 0, this._processingStatus = ut.NotStarted, this._parent = void 0, this._syncSnapshot = void 0, this.ref = void 0, this._actorScope = void 0, this._systemId = void 0, this.sessionId = void 0, this.system = void 0, this._doneEvent = void 0, this.src = void 0, this._deferred = [];
      const i = {
          ...rT,
          ...n
        },
        {
          clock: r,
          logger: s,
          parent: o,
          syncSnapshot: a,
          id: l,
          systemId: u,
          inspect: c
        } = i;
      this.system = o ? o.system : iT(this, {
        clock: r,
        logger: s
      }), c && !o && this.system.inspect(zl(c)), this.sessionId = this.system._bookId(), this.id = l ?? this.sessionId, this.logger = (n == null ? void 0 : n.logger) ?? this.system._logger, this.clock = (n == null ? void 0 : n.clock) ?? this.system._clock, this._parent = o, this._syncSnapshot = a, this.options = i, this.src = i.src ?? t, this.ref = this, this._actorScope = {
        self: this,
        id: this.id,
        sessionId: this.sessionId,
        logger: this.logger,
        defer: f => {
          this._deferred.push(f)
        },
        system: this.system,
        stopChild: f => {
          if (f._parent !== this) throw new Error(`Cannot stop child actor ${f.id} of ${this.id} because it is not a child`);
          f._stop()
        },
        emit: f => {
          const d = this.eventListeners.get(f.type),
            p = this.eventListeners.get("*");
          if (!d && !p) return;
          const h = [...d ? d.values() : [], ...p ? p.values() : []];
          for (const g of h) g(f)
        },
        actionExecutor: f => {
          const d = () => {
            if (this._actorScope.system._sendInspectionEvent({
                type: "@xstate.action",
                actorRef: this,
                action: {
                  type: f.type,
                  params: f.params
                }
              }), !f.exec) return;
            const p = Dl;
            try {
              Dl = !0, f.exec(f.info, f.params)
            } finally {
              Dl = p
            }
          };
          this._processingStatus === ut.Running ? d() : this._deferred.push(d)
        }
      }, this.send = this.send.bind(this), this.system._sendInspectionEvent({
        type: "@xstate.actor",
        actorRef: this
      }), u && (this._systemId = u, this.system._set(u, this)), this._initState((n == null ? void 0 : n.snapshot) ?? (n == null ? void 0 : n.state)), u && this._snapshot.status !== "active" && this.system._unregister(this)
    }
    _initState(t) {
      var n;
      try {
        this._snapshot = t ? this.logic.restoreSnapshot ? this.logic.restoreSnapshot(t, this._actorScope) : t : this.logic.getInitialSnapshot(this._actorScope, (n = this.options) == null ? void 0 : n.input)
      } catch (i) {
        this._snapshot = {
          status: "error",
          output: void 0,
          error: i
        }
      }
    }
    update(t, n) {
      var r, s;
      this._snapshot = t;
      let i;
      for (; i = this._deferred.shift();) try {
        i()
      } catch (o) {
        this._deferred.length = 0, this._snapshot = {
          ...t,
          status: "error",
          error: o
        }
      }
      switch (this._snapshot.status) {
        case "active":
          for (const o of this.observers) try {
            (r = o.next) == null || r.call(o, t)
          } catch (a) {
            Sn(a)
          }
          break;
        case "done":
          for (const o of this.observers) try {
            (s = o.next) == null || s.call(o, t)
          } catch (a) {
            Sn(a)
          }
          this._stopProcedure(), this._complete(), this._doneEvent = Q8(this.id, this._snapshot.output), this._parent && this.system._relay(this, this._parent, this._doneEvent);
          break;
        case "error":
          this._error(this._snapshot.error);
          break
      }
      this.system._sendInspectionEvent({
        type: "@xstate.snapshot",
        actorRef: this,
        event: n,
        snapshot: t
      })
    }
    subscribe(t, n, i) {
      var s;
      const r = zl(t, n, i);
      if (this._processingStatus !== ut.Stopped) this.observers.add(r);
      else switch (this._snapshot.status) {
        case "done":
          try {
            (s = r.complete) == null || s.call(r)
          } catch (o) {
            Sn(o)
          }
          break;
        case "error": {
          const o = this._snapshot.error;
          if (!r.error) Sn(o);
          else try {
            r.error(o)
          } catch (a) {
            Sn(a)
          }
          break
        }
      }
      return {
        unsubscribe: () => {
          this.observers.delete(r)
        }
      }
    }
    on(t, n) {
      let i = this.eventListeners.get(t);
      i || (i = new Set, this.eventListeners.set(t, i));
      const r = n.bind(void 0);
      return i.add(r), {
        unsubscribe: () => {
          i.delete(r)
        }
      }
    }
    start() {
      if (this._processingStatus === ut.Running) return this;
      this._syncSnapshot && this.subscribe({
        next: i => {
          i.status === "active" && this.system._relay(this, this._parent, {
            type: `xstate.snapshot.${this.id}`,
            snapshot: i
          })
        },
        error: () => {}
      }), this.system._register(this.sessionId, this), this._systemId && this.system._set(this._systemId, this), this._processingStatus = ut.Running;
      const t = vm(this.options.input);
      switch (this.system._sendInspectionEvent({
          type: "@xstate.event",
          sourceRef: this._parent,
          actorRef: this,
          event: t
        }), this._snapshot.status) {
        case "done":
          return this.update(this._snapshot, t), this;
        case "error":
          return this._error(this._snapshot.error), this
      }
      if (this._parent || this.system.start(), this.logic.start) try {
        this.logic.start(this._snapshot, this._actorScope)
      } catch (i) {
        return this._snapshot = {
          ...this._snapshot,
          status: "error",
          error: i
        }, this._error(i), this
      }
      return this.update(this._snapshot, t), this.options.devTools && this.attachDevTools(), this.mailbox.start(), this
    }
    _process(t) {
      let n, i;
      try {
        n = this.logic.transition(this._snapshot, t, this._actorScope)
      } catch (r) {
        i = {
          err: r
        }
      }
      if (i) {
        const {
          err: r
        } = i;
        this._snapshot = {
          ...this._snapshot,
          status: "error",
          error: r
        }, this._error(r);
        return
      }
      this.update(n, t), t.type === Us && (this._stopProcedure(), this._complete())
    }
    _stop() {
      return this._processingStatus === ut.Stopped ? this : (this.mailbox.clear(), this._processingStatus === ut.NotStarted ? (this._processingStatus = ut.Stopped, this) : (this.mailbox.enqueue({
        type: Us
      }), this))
    }
    stop() {
      if (this._parent) throw new Error("A non-root actor cannot be stopped directly.");
      return this._stop()
    }
    _complete() {
      var t;
      for (const n of this.observers) try {
        (t = n.complete) == null || t.call(n)
      } catch (i) {
        Sn(i)
      }
      this.observers.clear()
    }
    _reportError(t) {
      if (!this.observers.size) {
        this._parent || Sn(t);
        return
      }
      let n = !1;
      for (const i of this.observers) {
        const r = i.error;
        n || (n = !r);
        try {
          r == null || r(t)
        } catch (s) {
          Sn(s)
        }
      }
      this.observers.clear(), n && Sn(t)
    }
    _error(t) {
      this._stopProcedure(), this._reportError(t), this._parent && this.system._relay(this, this._parent, _8(this.id, t))
    }
    _stopProcedure() {
      return this._processingStatus !== ut.Running ? this : (this.system.scheduler.cancelAll(this), this.mailbox.clear(), this.mailbox = new dm(this._process.bind(this)), this._processingStatus = ut.Stopped, this.system._unregister(this), this)
    }
    _send(t) {
      this._processingStatus !== ut.Stopped && this.mailbox.enqueue(t)
    }
    send(t) {
      this.system._relay(void 0, this, t)
    }
    attachDevTools() {
      const {
        devTools: t
      } = this.options;
      t && (typeof t == "function" ? t : B8)(this)
    }
    toJSON() {
      return {
        xstate$$type: Vl,
        id: this.id
      }
    }
    getPersistedSnapshot(t) {
      return this.logic.getPersistedSnapshot(this._snapshot, t)
    } [$8]() {
      return this
    }
    getSnapshot() {
      return this._snapshot
    }
  }

  function Zn(e, ...[t]) {
    return new sT(e, t)
  }

  function oT(e, t, n, i, {
    sendId: r
  }) {
    const s = typeof r == "function" ? r(n, i) : r;
    return [t, {
      sendId: s
    }, void 0]
  }

  function aT(e, t) {
    e.defer(() => {
      e.system.scheduler.cancel(e.self, t.sendId)
    })
  }

  function lT(e) {
    function t(n, i) {}
    return t.type = "xstate.cancel", t.sendId = e, t.resolve = oT, t.execute = aT, t
  }

  function cT(e, t, n, i, {
    id: r,
    systemId: s,
    src: o,
    input: a,
    syncSnapshot: l
  }) {
    const u = typeof o == "string" ? Xl(t.machine, o) : o,
      c = typeof r == "function" ? r(n) : r;
    let f, d;
    return u && (d = typeof a == "function" ? a({
      context: t.context,
      event: n.event,
      self: e.self
    }) : a, f = Zn(u, {
      id: c,
      src: o,
      parent: e.self,
      syncSnapshot: l,
      systemId: s,
      input: d
    })), [mi(t, {
      children: {
        ...t.children,
        [c]: f
      }
    }), {
      id: r,
      systemId: s,
      actorRef: f,
      src: o,
      input: d
    }, void 0]
  }

  function uT(e, {
    actorRef: t
  }) {
    t && e.defer(() => {
      t._processingStatus !== ut.Stopped && t.start()
    })
  }

  function fT(...[e, {
    id: t,
    systemId: n,
    input: i,
    syncSnapshot: r = !1
  } = {}]) {
    function s(o, a) {}
    return s.type = "xstate.spawnChild", s.id = t, s.systemId = n, s.src = e, s.input = i, s.syncSnapshot = r, s.resolve = cT, s.execute = uT, s
  }

  function dT(e, t, n, i, {
    actorRef: r
  }) {
    const s = typeof r == "function" ? r(n, i) : r,
      o = typeof s == "string" ? t.children[s] : s;
    let a = t.children;
    return o && (a = {
      ...a
    }, delete a[o.id]), [mi(t, {
      children: a
    }), o, void 0]
  }

  function pT(e, t) {
    if (t) {
      if (e.system._unregister(t), t._processingStatus !== ut.Running) {
        e.stopChild(t);
        return
      }
      e.defer(() => {
        e.stopChild(t)
      })
    }
  }

  function Lm(e) {
    function t(n, i) {}
    return t.type = "xstate.stopChild", t.actorRef = e, t.resolve = dT, t.execute = pT, t
  }

  function Nl(e, t, n, i) {
    const {
      machine: r
    } = i, s = typeof e == "function", o = s ? e : r.implementations.guards[typeof e == "string" ? e : e.type];
    if (!s && !o) throw new Error(`Guard '${typeof e=="string"?e:e.type}' is not implemented.'.`);
    if (typeof o != "function") return Nl(o, t, n, i);
    const a = {
        context: t,
        event: n
      },
      l = s || typeof e == "string" ? void 0 : "params" in e ? typeof e.params == "function" ? e.params({
        context: t,
        event: n
      }) : e.params : void 0;
    return "check" in o ? o.check(i, a, o) : o(a, l)
  }
  const jl = e => e.type === "atomic" || e.type === "final";

  function Wi(e) {
    return Object.values(e.states).filter(t => t.type !== "history")
  }

  function Er(e, t) {
    const n = [];
    if (t === e) return n;
    let i = e.parent;
    for (; i && i !== t;) n.push(i), i = i.parent;
    return n
  }

  function Bs(e) {
    const t = new Set(e),
      n = Om(t);
    for (const i of t)
      if (i.type === "compound" && (!n.get(i) || !n.get(i).length)) Dm(i).forEach(r => t.add(r));
      else if (i.type === "parallel") {
      for (const r of Wi(i))
        if (r.type !== "history" && !t.has(r)) {
          const s = Dm(r);
          for (const o of s) t.add(o)
        }
    }
    for (const i of t) {
      let r = i.parent;
      for (; r;) t.add(r), r = r.parent
    }
    return t
  }

  function Sm(e, t) {
    const n = t.get(e);
    if (!n) return {};
    if (e.type === "compound") {
      const r = n[0];
      if (r) {
        if (jl(r)) return r.key
      } else return {}
    }
    const i = {};
    for (const r of n) i[r.key] = Sm(r, t);
    return i
  }

  function Om(e) {
    const t = new Map;
    for (const n of e) t.has(n) || t.set(n, []), n.parent && (t.has(n.parent) || t.set(n.parent, []), t.get(n.parent).push(n));
    return t
  }

  function zm(e, t) {
    const n = Bs(t);
    return Sm(e, Om(n))
  }

  function Rl(e, t) {
    return t.type === "compound" ? Wi(t).some(n => n.type === "final" && e.has(n)) : t.type === "parallel" ? Wi(t).every(n => Rl(e, n)) : t.type === "final"
  }
  const Gs = e => e[0] === K8;

  function hT(e, t) {
    return e.transitions.get(t) || [...e.transitions.keys()].filter(i => {
      if (i === J8) return !0;
      if (!i.endsWith(".*")) return !1;
      const r = i.split("."),
        s = t.split(".");
      for (let o = 0; o < r.length; o++) {
        const a = r[o],
          l = s[o];
        if (a === "*") return o === r.length - 1;
        if (a !== l) return !1
      }
      return !0
    }).sort((i, r) => r.length - i.length).flatMap(i => e.transitions.get(i))
  }

  function mT(e) {
    const t = e.config.after;
    if (!t) return [];
    const n = r => {
      const s = Y8(r, e.id),
        o = s.type;
      return e.entry.push(qT(s, {
        id: o,
        delay: r
      })), e.exit.push(lT(o)), o
    };
    return Object.keys(t).flatMap(r => {
      const s = t[r],
        o = typeof s == "string" ? {
          target: s
        } : s,
        a = Number.isNaN(+r) ? r : +r,
        l = n(a);
      return qn(o).map(u => ({
        ...u,
        event: l,
        delay: a
      }))
    }).map(r => {
      const {
        delay: s
      } = r;
      return {
        ...pi(e, r.event, r),
        delay: s
      }
    })
  }

  function pi(e, t, n) {
    const i = wm(n.target),
      r = n.reenter ?? !1,
      s = yT(e, i),
      o = {
        ...n,
        actions: qn(n.actions),
        guard: n.guard,
        target: s,
        source: e,
        reenter: r,
        eventType: t,
        toJSON: () => ({
          ...o,
          source: `#${e.id}`,
          target: s ? s.map(a => `#${a.id}`) : void 0
        })
      };
    return o
  }

  function vT(e) {
    const t = new Map;
    if (e.config.on)
      for (const n of Object.keys(e.config.on)) {
        if (n === hm) throw new Error('Null events ("") cannot be specified as a transition key. Use `always: { ... }` instead.');
        const i = e.config.on[n];
        t.set(n, Ci(i).map(r => pi(e, n, r)))
      }
    if (e.config.onDone) {
      const n = `xstate.done.state.${e.id}`;
      t.set(n, Ci(e.config.onDone).map(i => pi(e, n, i)))
    }
    for (const n of e.invoke) {
      if (n.onDone) {
        const i = `xstate.done.actor.${n.id}`;
        t.set(i, Ci(n.onDone).map(r => pi(e, i, r)))
      }
      if (n.onError) {
        const i = `xstate.error.actor.${n.id}`;
        t.set(i, Ci(n.onError).map(r => pi(e, i, r)))
      }
      if (n.onSnapshot) {
        const i = `xstate.snapshot.${n.id}`;
        t.set(i, Ci(n.onSnapshot).map(r => pi(e, i, r)))
      }
    }
    for (const n of e.after) {
      let i = t.get(n.eventType);
      i || (i = [], t.set(n.eventType, i)), i.push(n)
    }
    return t
  }

  function gT(e, t) {
    const n = typeof t == "string" ? e.states[t] : t ? e.states[t.target] : void 0;
    if (!n && t) throw new Error(`Initial state node "${t}" not found on parent state node #${e.id}`);
    const i = {
      source: e,
      actions: !t || typeof t == "string" ? [] : qn(t.actions),
      eventType: null,
      reenter: !1,
      target: n ? [n] : [],
      toJSON: () => ({
        ...i,
        source: `#${e.id}`,
        target: n ? [`#${n.id}`] : []
      })
    };
    return i
  }

  function yT(e, t) {
    if (t !== void 0) return t.map(n => {
      if (typeof n != "string") return n;
      if (Gs(n)) return e.machine.getStateNodeById(n);
      const i = n[0] === pm;
      if (i && !e.parent) return Ks(e, n.slice(1));
      const r = i ? e.key + n : n;
      if (e.parent) try {
        return Ks(e.parent, r)
      } catch (s) {
        throw new Error(`Invalid transition definition for state node '${e.id}':
${s.message}`)
      } else throw new Error(`Invalid target: "${n}" is not a valid target from the root node. Did you mean ".${n}"?`)
    })
  }

  function Xm(e) {
    const t = wm(e.config.target);
    return t ? {
      target: t.map(n => typeof n == "string" ? Ks(e.parent, n) : n)
    } : e.parent.initial
  }

  function hi(e) {
    return e.type === "history"
  }

  function Dm(e) {
    const t = Vm(e);
    for (const n of t)
      for (const i of Er(n, e)) t.add(i);
    return t
  }

  function Vm(e) {
    const t = new Set;

    function n(i) {
      if (!t.has(i)) {
        if (t.add(i), i.type === "compound") n(i.initial.target[0]);
        else if (i.type === "parallel")
          for (const r of Wi(i)) n(r)
      }
    }
    return n(e), t
  }

  function Hi(e, t) {
    if (Gs(t)) return e.machine.getStateNodeById(t);
    if (!e.states) throw new Error(`Unable to retrieve child state '${t}' from '${e.id}'; no child states exist.`);
    const n = e.states[t];
    if (!n) throw new Error(`Child state '${t}' does not exist on '${e.id}'`);
    return n
  }

  function Ks(e, t) {
    if (typeof t == "string" && Gs(t)) try {
      return e.machine.getStateNodeById(t)
    } catch {}
    const n = Sl(t).slice();
    let i = e;
    for (; n.length;) {
      const r = n.shift();
      if (!r.length) break;
      i = Hi(i, r)
    }
    return i
  }

  function Js(e, t) {
    if (typeof t == "string") {
      const r = e.states[t];
      if (!r) throw new Error(`State '${t}' does not exist on '${e.id}'`);
      return [e, r]
    }
    const n = Object.keys(t),
      i = n.map(r => Hi(e, r)).filter(Boolean);
    return [e.machine.root, e].concat(i, n.reduce((r, s) => {
      const o = Hi(e, s);
      if (!o) return r;
      const a = Js(o, t[s]);
      return r.concat(a)
    }, []))
  }

  function bT(e, t, n, i) {
    const s = Hi(e, t).next(n, i);
    return !s || !s.length ? e.next(n, i) : s
  }

  function AT(e, t, n, i) {
    const r = Object.keys(t),
      s = Hi(e, r[0]),
      o = Fl(s, t[r[0]], n, i);
    return !o || !o.length ? e.next(n, i) : o
  }

  function PT(e, t, n, i) {
    const r = [];
    for (const s of Object.keys(t)) {
      const o = t[s];
      if (!o) continue;
      const a = Hi(e, s),
        l = Fl(a, o, n, i);
      l && r.push(...l)
    }
    return r.length ? r : e.next(n, i)
  }

  function Fl(e, t, n, i) {
    return typeof t == "string" ? bT(e, t, n, i) : Object.keys(t).length === 1 ? AT(e, t, n, i) : PT(e, t, n, i)
  }

  function wT(e) {
    return Object.keys(e.states).map(t => e.states[t]).filter(t => t.type === "history")
  }

  function Un(e, t) {
    let n = e;
    for (; n.parent && n.parent !== t;) n = n.parent;
    return n.parent === t
  }

  function xT(e, t) {
    const n = new Set(e),
      i = new Set(t);
    for (const r of n)
      if (i.has(r)) return !0;
    for (const r of i)
      if (n.has(r)) return !0;
    return !1
  }

  function Nm(e, t, n) {
    const i = new Set;
    for (const r of e) {
      let s = !1;
      const o = new Set;
      for (const a of i)
        if (xT(Wl([r], t, n), Wl([a], t, n)))
          if (Un(r.source, a.source)) o.add(a);
          else {
            s = !0;
            break
          } if (!s) {
        for (const a of o) i.delete(a);
        i.add(r)
      }
    }
    return Array.from(i)
  }

  function TT(e) {
    const [t, ...n] = e;
    for (const i of Er(t, void 0))
      if (n.every(r => Un(r, i))) return i
  }

  function Cl(e, t) {
    if (!e.target) return [];
    const n = new Set;
    for (const i of e.target)
      if (hi(i))
        if (t[i.id])
          for (const r of t[i.id]) n.add(r);
        else
          for (const r of Cl(Xm(i), t)) n.add(r);
    else n.add(i);
    return [...n]
  }

  function jm(e, t) {
    const n = Cl(e, t);
    if (!n) return;
    if (!e.reenter && n.every(r => r === e.source || Un(r, e.source))) return e.source;
    const i = TT(n.concat(e.source));
    if (i) return i;
    if (!e.reenter) return e.source.machine.root
  }

  function Wl(e, t, n) {
    var r;
    const i = new Set;
    for (const s of e)
      if ((r = s.target) != null && r.length) {
        const o = jm(s, n);
        s.reenter && s.source === o && i.add(o);
        for (const a of t) Un(a, o) && i.add(a)
      } return [...i]
  }

  function LT(e, t) {
    if (e.length !== t.size) return !1;
    for (const n of e)
      if (!t.has(n)) return !1;
    return !0
  }

  function Hl(e, t, n, i, r, s) {
    if (!e.length) return t;
    const o = new Set(t._nodes);
    let a = t.historyValue;
    const l = Nm(e, o, a);
    let u = t;
    r || ([u, a] = XT(u, i, n, l, o, a, s, n.actionExecutor)), u = Ei(u, i, n, l.flatMap(f => f.actions), s, void 0), u = OT(u, i, n, l, o, s, a, r);
    const c = [...o];
    u.status === "done" && (u = Ei(u, i, n, c.sort((f, d) => d.order - f.order).flatMap(f => f.exit), s, void 0));
    try {
      return a === t.historyValue && LT(t._nodes, o) ? u : mi(u, {
        _nodes: c,
        historyValue: a
      })
    } catch (f) {
      throw f
    }
  }

  function ST(e, t, n, i, r) {
    if (i.output === void 0) return;
    const s = Ll(r.id, r.output !== void 0 && r.parent ? Ol(r.output, e.context, t, n.self) : void 0);
    return Ol(i.output, e.context, s, n.self)
  }

  function OT(e, t, n, i, r, s, o, a) {
    let l = e;
    const u = new Set,
      c = new Set;
    zT(i, o, c, u), a && c.add(e.machine.root);
    const f = new Set;
    for (const d of [...u].sort((p, h) => p.order - h.order)) {
      r.add(d);
      const p = [];
      p.push(...d.entry);
      for (const h of d.invoke) p.push(fT(h.src, {
        ...h,
        syncSnapshot: !!h.onSnapshot
      }));
      if (c.has(d)) {
        const h = d.initial.actions;
        p.push(...h)
      }
      if (l = Ei(l, t, n, p, s, d.invoke.map(h => h.id)), d.type === "final") {
        const h = d.parent;
        let g = (h == null ? void 0 : h.type) === "parallel" ? h : h == null ? void 0 : h.parent,
          A = g || d;
        for ((h == null ? void 0 : h.type) === "compound" && s.push(Ll(h.id, d.output !== void 0 ? Ol(d.output, l.context, t, n.self) : void 0));
          (g == null ? void 0 : g.type) === "parallel" && !f.has(g) && Rl(r, g);) f.add(g), s.push(Ll(g.id)), A = g, g = g.parent;
        if (g) continue;
        l = mi(l, {
          status: "done",
          output: ST(l, t, n, l.machine.root, A)
        })
      }
    }
    return l
  }

  function zT(e, t, n, i) {
    for (const r of e) {
      const s = jm(r, t);
      for (const a of r.target || []) !hi(a) && (r.source !== a || r.source !== s || r.reenter) && (i.add(a), n.add(a)), ki(a, t, n, i);
      const o = Cl(r, t);
      for (const a of o) {
        const l = Er(a, s);
        (s == null ? void 0 : s.type) === "parallel" && l.push(s), Rm(i, t, n, l, !r.source.parent && r.reenter ? void 0 : s)
      }
    }
  }

  function ki(e, t, n, i) {
    var r;
    if (hi(e))
      if (t[e.id]) {
        const s = t[e.id];
        for (const o of s) i.add(o), ki(o, t, n, i);
        for (const o of s) kl(o, e.parent, i, t, n)
      } else {
        const s = Xm(e);
        for (const o of s.target) i.add(o), s === ((r = e.parent) == null ? void 0 : r.initial) && n.add(e.parent), ki(o, t, n, i);
        for (const o of s.target) kl(o, e.parent, i, t, n)
      }
    else if (e.type === "compound") {
      const [s] = e.initial.target;
      hi(s) || (i.add(s), n.add(s)), ki(s, t, n, i), kl(s, e, i, t, n)
    } else if (e.type === "parallel")
      for (const s of Wi(e).filter(o => !hi(o)))[...i].some(o => Un(o, s)) || (hi(s) || (i.add(s), n.add(s)), ki(s, t, n, i))
  }

  function Rm(e, t, n, i, r) {
    for (const s of i)
      if ((!r || Un(s, r)) && e.add(s), s.type === "parallel")
        for (const o of Wi(s).filter(a => !hi(a)))[...e].some(a => Un(a, o)) || (e.add(o), ki(o, t, n, e))
  }

  function kl(e, t, n, i, r) {
    Rm(n, i, r, Er(e, t))
  }

  function XT(e, t, n, i, r, s, o, a) {
    let l = e;
    const u = Wl(i, r, s);
    u.sort((f, d) => d.order - f.order);
    let c;
    for (const f of u)
      for (const d of wT(f)) {
        let p;
        d.history === "deep" ? p = h => jl(h) && Un(h, f) : p = h => h.parent === f, c ?? (c = {
          ...s
        }), c[d.id] = Array.from(r).filter(p)
      }
    for (const f of u) l = Ei(l, t, n, [...f.exit, ...f.invoke.map(d => Lm(d.id))], o, void 0), r.delete(f);
    return [l, c || s]
  }

  function DT(e, t) {
    return e.implementations.actions[t]
  }

  function Fm(e, t, n, i, r, s) {
    const {
      machine: o
    } = e;
    let a = e;
    for (const l of i) {
      const u = typeof l == "function",
        c = u ? l : DT(o, typeof l == "string" ? l : l.type),
        f = {
          context: a.context,
          event: t,
          self: n.self,
          system: n.system
        },
        d = u || typeof l == "string" ? void 0 : "params" in l ? typeof l.params == "function" ? l.params({
          context: a.context,
          event: t
        }) : l.params : void 0;
      if (!c || !("resolve" in c)) {
        n.actionExecutor({
          type: typeof l == "string" ? l : typeof l == "object" ? l.type : l.name || "(anonymous)",
          info: f,
          params: d,
          exec: c
        });
        continue
      }
      const p = c,
        [h, g, A] = p.resolve(n, a, f, d, c, r);
      a = h, "retryResolve" in p && (s == null || s.push([p, g])), "execute" in p && n.actionExecutor({
        type: p.type,
        info: f,
        params: g,
        exec: p.execute.bind(null, n, g)
      }), A && (a = Fm(a, t, n, A, r, s))
    }
    return a
  }

  function Ei(e, t, n, i, r, s) {
    const o = s ? [] : void 0,
      a = Fm(e, t, n, i, {
        internalQueue: r,
        deferredActorIds: s
      }, o);
    return o == null || o.forEach(([l, u]) => {
      l.retryResolve(n, a, u)
    }), a
  }

  function El(e, t, n, i) {
    let r = e;
    const s = [];

    function o(u, c, f) {
      n.system._sendInspectionEvent({
        type: "@xstate.microstep",
        actorRef: n.self,
        event: c,
        snapshot: u,
        _transitions: f
      }), s.push(u)
    }
    if (t.type === Us) return r = mi(Cm(r, t, n), {
      status: "stopped"
    }), o(r, t, []), {
      snapshot: r,
      microstates: s
    };
    let a = t;
    if (a.type !== mm) {
      const u = a,
        c = tT(u),
        f = Wm(u, r);
      if (c && !f.length) return r = mi(e, {
        status: "error",
        error: u.error
      }), o(r, u, []), {
        snapshot: r,
        microstates: s
      };
      r = Hl(f, e, n, a, !1, i), o(r, u, f)
    }
    let l = !0;
    for (; r.status === "active";) {
      let u = l ? VT(r, a) : [];
      const c = u.length ? r : void 0;
      if (!u.length) {
        if (!i.length) break;
        a = i.shift(), u = Wm(a, r)
      }
      r = Hl(u, r, n, a, !1, i), l = r !== c, o(r, a, u)
    }
    return r.status !== "active" && Cm(r, a, n), {
      snapshot: r,
      microstates: s
    }
  }

  function Cm(e, t, n) {
    return Ei(e, t, n, Object.values(e.children).map(i => Lm(i)), [], void 0)
  }

  function Wm(e, t) {
    return t.machine.getTransitionData(t, e)
  }

  function VT(e, t) {
    const n = new Set,
      i = e._nodes.filter(jl);
    for (const r of i) e: for (const s of [r].concat(Er(r, void 0)))
      if (s.always) {
        for (const o of s.always)
          if (o.guard === void 0 || Nl(o.guard, e.context, t, e)) {
            n.add(o);
            break e
          }
      } return Nm(Array.from(n), new Set(e._nodes), e.historyValue)
  }

  function NT(e, t) {
    const n = Bs(Js(e, t));
    return zm(e, [...n])
  }

  function jT(e) {
    return !!e && typeof e == "object" && "machine" in e && "value" in e
  }
  const RT = function(t) {
      return gm(t, this.value)
    },
    FT = function(t) {
      return this.tags.has(t)
    },
    CT = function(t) {
      const n = this.machine.getTransitionData(this, t);
      return !!(n != null && n.length) && n.some(i => i.target !== void 0 || i.actions.length)
    },
    WT = function() {
      const {
        _nodes: t,
        tags: n,
        machine: i,
        getMeta: r,
        toJSON: s,
        can: o,
        hasTag: a,
        matches: l,
        ...u
      } = this;
      return {
        ...u,
        tags: Array.from(n)
      }
    },
    HT = function() {
      return this._nodes.reduce((t, n) => (n.meta !== void 0 && (t[n.id] = n.meta), t), {})
    };

  function Ys(e, t) {
    return {
      status: e.status,
      output: e.output,
      error: e.error,
      machine: t,
      context: e.context,
      _nodes: e._nodes,
      value: zm(t.root, e._nodes),
      tags: new Set(e._nodes.flatMap(n => n.tags)),
      children: e.children,
      historyValue: e.historyValue || {},
      matches: RT,
      hasTag: FT,
      can: CT,
      getMeta: HT,
      toJSON: WT
    }
  }

  function mi(e, t = {}) {
    return Ys({
      ...e,
      ...t
    }, e.machine)
  }

  function kT(e) {
    if (typeof e != "object" || e === null) return {};
    const t = {};
    for (const n in e) {
      const i = e[n];
      Array.isArray(i) && (t[n] = i.map(r => ({
        id: r.id
      })))
    }
    return t
  }

  function ET(e, t) {
    const {
      _nodes: n,
      tags: i,
      machine: r,
      children: s,
      context: o,
      can: a,
      hasTag: l,
      matches: u,
      getMeta: c,
      toJSON: f,
      ...d
    } = e, p = {};
    for (const g in s) {
      const A = s[g];
      p[g] = {
        snapshot: A.getPersistedSnapshot(t),
        src: A.src,
        systemId: A._systemId,
        syncSnapshot: A._syncSnapshot
      }
    }
    return {
      ...d,
      context: Hm(o),
      children: p,
      historyValue: kT(d.historyValue)
    }
  }

  function Hm(e) {
    let t;
    for (const n in e) {
      const i = e[n];
      if (i && typeof i == "object")
        if ("sessionId" in i && "send" in i && "ref" in i) t ?? (t = Array.isArray(e) ? e.slice() : {
          ...e
        }), t[n] = {
          xstate$$type: Vl,
          id: i.id
        };
        else {
          const r = Hm(i);
          r !== i && (t ?? (t = Array.isArray(e) ? e.slice() : {
            ...e
          }), t[n] = r)
        }
    }
    return t ?? e
  }

  function MT(e, t, n, i, {
    event: r,
    id: s,
    delay: o
  }, {
    internalQueue: a
  }) {
    const l = t.machine.implementations.delays;
    if (typeof r == "string") throw new Error(`Only event objects may be used with raise; use raise({ type: "${r}" }) instead`);
    const u = typeof r == "function" ? r(n, i) : r;
    let c;
    if (typeof o == "string") {
      const f = l && l[o];
      c = typeof f == "function" ? f(n, i) : f
    } else c = typeof o == "function" ? o(n, i) : o;
    return typeof c != "number" && a.push(u), [t, {
      event: u,
      id: s,
      delay: c
    }, void 0]
  }

  function IT(e, t) {
    const {
      event: n,
      delay: i,
      id: r
    } = t;
    if (typeof i == "number") {
      e.defer(() => {
        const s = e.self;
        e.system.scheduler.schedule(s, s, n, i, r)
      });
      return
    }
  }

  function qT(e, t) {
    function n(i, r) {}
    return n.type = "xstate.raise", n.event = e, n.id = t == null ? void 0 : t.id, n.delay = t == null ? void 0 : t.delay, n.resolve = MT, n.execute = IT, n
  }
  const km = "xstate.promise.resolve",
    Em = "xstate.promise.reject",
    Qs = new WeakMap;

  function Ht(e) {
    return {
      config: e,
      transition: (n, i, r) => {
        var s;
        if (n.status !== "active") return n;
        switch (i.type) {
          case km: {
            const o = i.data;
            return {
              ...n,
              status: "done",
              output: o,
              input: void 0
            }
          }
          case Em:
            return {
              ...n, status: "error", error: i.data, input: void 0
            };
          case Us:
            return (s = Qs.get(r.self)) == null || s.abort(), {
              ...n,
              status: "stopped",
              input: void 0
            };
          default:
            return n
        }
      },
      start: (n, {
        self: i,
        system: r,
        emit: s
      }) => {
        if (n.status !== "active") return;
        const o = new AbortController;
        Qs.set(i, o), Promise.resolve(e({
          input: n.input,
          system: r,
          self: i,
          signal: o.signal,
          emit: s
        })).then(l => {
          i.getSnapshot().status === "active" && (Qs.delete(i), r._relay(i, i, {
            type: km,
            data: l
          }))
        }, l => {
          i.getSnapshot().status === "active" && (Qs.delete(i), r._relay(i, i, {
            type: Em,
            data: l
          }))
        })
      },
      getInitialSnapshot: (n, i) => ({
        status: "active",
        output: void 0,
        error: void 0,
        input: i
      }),
      getPersistedSnapshot: n => n,
      restoreSnapshot: n => n
    }
  }

  function ZT(e, {
    machine: t,
    context: n
  }, i, r) {
    const s = (o, a) => {
      if (typeof o == "string") {
        const l = Xl(t, o);
        if (!l) throw new Error(`Actor logic '${o}' not implemented in machine '${t.id}'`);
        const u = Zn(l, {
          id: a == null ? void 0 : a.id,
          parent: e.self,
          syncSnapshot: a == null ? void 0 : a.syncSnapshot,
          input: typeof(a == null ? void 0 : a.input) == "function" ? a.input({
            context: n,
            event: i,
            self: e.self
          }) : a == null ? void 0 : a.input,
          src: o,
          systemId: a == null ? void 0 : a.systemId
        });
        return r[u.id] = u, u
      } else return Zn(o, {
        id: a == null ? void 0 : a.id,
        parent: e.self,
        syncSnapshot: a == null ? void 0 : a.syncSnapshot,
        input: a == null ? void 0 : a.input,
        src: o,
        systemId: a == null ? void 0 : a.systemId
      })
    };
    return (o, a) => {
      const l = s(o, a);
      return r[l.id] = l, e.defer(() => {
        l._processingStatus !== ut.Stopped && l.start()
      }), l
    }
  }

  function UT(e, t, n, i, {
    assignment: r
  }) {
    if (!t.context) throw new Error("Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.");
    const s = {},
      o = {
        context: t.context,
        event: n.event,
        spawn: ZT(e, t, n.event, s),
        self: e.self,
        system: e.system
      };
    let a = {};
    if (typeof r == "function") a = r(o, i);
    else
      for (const u of Object.keys(r)) {
        const c = r[u];
        a[u] = typeof c == "function" ? c(o, i) : c
      }
    const l = Object.assign({}, t.context, a);
    return [mi(t, {
      context: l,
      children: Object.keys(s).length ? {
        ...t.children,
        ...s
      } : t.children
    }), void 0, void 0]
  }

  function ft(e) {
    function t(n, i) {}
    return t.type = "xstate.assign", t.assignment = e, t.resolve = UT, t
  }
  const Mm = new WeakMap;

  function Mi(e, t, n) {
    let i = Mm.get(e);
    return i ? t in i || (i[t] = n()) : (i = {
      [t]: n()
    }, Mm.set(e, i)), i[t]
  }
  const BT = {},
    Mr = e => typeof e == "string" ? {
      type: e
    } : typeof e == "function" ? "resolve" in e ? {
      type: e.type
    } : {
      type: e.name
    } : e;
  class _s {
    constructor(t, n) {
      if (this.config = t, this.key = void 0, this.id = void 0, this.type = void 0, this.path = void 0, this.states = void 0, this.history = void 0, this.entry = void 0, this.exit = void 0, this.parent = void 0, this.machine = void 0, this.meta = void 0, this.output = void 0, this.order = -1, this.description = void 0, this.tags = [], this.transitions = void 0, this.always = void 0, this.parent = n._parent, this.key = n._key, this.machine = n._machine, this.path = this.parent ? this.parent.path.concat(this.key) : [], this.id = this.config.id || [this.machine.id, ...this.path].join(pm), this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? "compound" : this.config.history ? "history" : "atomic"), this.description = this.config.description, this.order = this.machine.idMap.size, this.machine.idMap.set(this.id, this), this.states = this.config.states ? bm(this.config.states, (i, r) => new _s(i, {
          _parent: this,
          _key: r,
          _machine: this.machine
        })) : BT, this.type === "compound" && !this.config.initial) throw new Error(`No initial state specified for compound state node "#${this.id}". Try adding { initial: "${Object.keys(this.states)[0]}" } to the state config.`);
      this.history = this.config.history === !0 ? "shallow" : this.config.history || !1, this.entry = qn(this.config.entry).slice(), this.exit = qn(this.config.exit).slice(), this.meta = this.config.meta, this.output = this.type === "final" || !this.parent ? this.config.output : void 0, this.tags = qn(t.tags).slice()
    }
    _initialize() {
      this.transitions = vT(this), this.config.always && (this.always = Ci(this.config.always).map(t => pi(this, hm, t))), Object.keys(this.states).forEach(t => {
        this.states[t]._initialize()
      })
    }
    get definition() {
      return {
        id: this.id,
        key: this.key,
        version: this.machine.version,
        type: this.type,
        initial: this.initial ? {
          target: this.initial.target,
          source: this,
          actions: this.initial.actions.map(Mr),
          eventType: null,
          reenter: !1,
          toJSON: () => ({
            target: this.initial.target.map(t => `#${t.id}`),
            source: `#${this.id}`,
            actions: this.initial.actions.map(Mr),
            eventType: null
          })
        } : void 0,
        history: this.history,
        states: bm(this.states, t => t.definition),
        on: this.on,
        transitions: [...this.transitions.values()].flat().map(t => ({
          ...t,
          actions: t.actions.map(Mr)
        })),
        entry: this.entry.map(Mr),
        exit: this.exit.map(Mr),
        meta: this.meta,
        order: this.order || -1,
        output: this.output,
        invoke: this.invoke,
        description: this.description,
        tags: this.tags
      }
    }
    toJSON() {
      return this.definition
    }
    get invoke() {
      return Mi(this, "invoke", () => qn(this.config.invoke).map((t, n) => {
        const {
          src: i,
          systemId: r
        } = t, s = t.id ?? xm(this.id, n), o = typeof i == "string" ? i : `xstate.invoke.${xm(this.id,n)}`;
        return {
          ...t,
          src: o,
          id: s,
          systemId: r,
          toJSON() {
            const {
              onDone: a,
              onError: l,
              ...u
            } = t;
            return {
              ...u,
              type: "xstate.invoke",
              src: o,
              id: s
            }
          }
        }
      }))
    }
    get on() {
      return Mi(this, "on", () => [...this.transitions].flatMap(([n, i]) => i.map(r => [n, r])).reduce((n, [i, r]) => (n[i] = n[i] || [], n[i].push(r), n), {}))
    }
    get after() {
      return Mi(this, "delayedTransitions", () => mT(this))
    }
    get initial() {
      return Mi(this, "initial", () => gT(this, this.config.initial))
    }
    next(t, n) {
      const i = n.type,
        r = [];
      let s;
      const o = Mi(this, `candidates-${i}`, () => hT(this, i));
      for (const a of o) {
        const {
          guard: l
        } = a, u = t.context;
        let c = !1;
        try {
          c = !l || Nl(l, u, n, t)
        } catch (f) {
          const d = typeof l == "string" ? l : typeof l == "object" ? l.type : void 0;
          throw new Error(`Unable to evaluate guard ${d?`'${d}' `:""}in transition for event '${i}' in state node '${this.id}':
${f.message}`)
        }
        if (c) {
          r.push(...a.actions), s = a;
          break
        }
      }
      return s ? [s] : void 0
    }
    get events() {
      return Mi(this, "events", () => {
        const {
          states: t
        } = this, n = new Set(this.ownEvents);
        if (t)
          for (const i of Object.keys(t)) {
            const r = t[i];
            if (r.states)
              for (const s of r.events) n.add(`${s}`)
          }
        return Array.from(n)
      })
    }
    get ownEvents() {
      const t = new Set([...this.transitions.keys()].filter(n => this.transitions.get(n).some(i => !(!i.target && !i.actions.length && !i.reenter))));
      return Array.from(t)
    }
  }
  const GT = "#";
  class Ml {
    constructor(t, n) {
      this.config = t, this.version = void 0, this.schemas = void 0, this.implementations = void 0, this.__xstatenode = !0, this.idMap = new Map, this.root = void 0, this.id = void 0, this.states = void 0, this.events = void 0, this.id = t.id || "(machine)", this.implementations = {
        actors: (n == null ? void 0 : n.actors) ?? {},
        actions: (n == null ? void 0 : n.actions) ?? {},
        delays: (n == null ? void 0 : n.delays) ?? {},
        guards: (n == null ? void 0 : n.guards) ?? {}
      }, this.version = this.config.version, this.schemas = this.config.schemas, this.transition = this.transition.bind(this), this.getInitialSnapshot = this.getInitialSnapshot.bind(this), this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this), this.restoreSnapshot = this.restoreSnapshot.bind(this), this.start = this.start.bind(this), this.root = new _s(t, {
        _key: this.id,
        _machine: this
      }), this.root._initialize(), this.states = this.root.states, this.events = this.root.events
    }
    provide(t) {
      const {
        actions: n,
        guards: i,
        actors: r,
        delays: s
      } = this.implementations;
      return new Ml(this.config, {
        actions: {
          ...n,
          ...t.actions
        },
        guards: {
          ...i,
          ...t.guards
        },
        actors: {
          ...r,
          ...t.actors
        },
        delays: {
          ...s,
          ...t.delays
        }
      })
    }
    resolveState(t) {
      const n = NT(this.root, t.value),
        i = Bs(Js(this.root, n));
      return Ys({
        _nodes: [...i],
        context: t.context || {},
        children: {},
        status: Rl(i, this.root) ? "done" : t.status || "active",
        output: t.output,
        error: t.error,
        historyValue: t.historyValue
      }, this)
    }
    transition(t, n, i) {
      return El(t, n, i, []).snapshot
    }
    microstep(t, n, i) {
      return El(t, n, i, []).microstates
    }
    getTransitionData(t, n) {
      return Fl(this.root, t.value, t, n) || []
    }
    getPreInitialState(t, n, i) {
      const {
        context: r
      } = this.config, s = Ys({
        context: typeof r != "function" && r ? r : {},
        _nodes: [this.root],
        children: {},
        status: "active"
      }, this);
      return typeof r == "function" ? Ei(s, n, t, [ft(({
        spawn: a,
        event: l,
        self: u
      }) => r({
        spawn: a,
        input: l.input,
        self: u
      }))], i, void 0) : s
    }
    getInitialSnapshot(t, n) {
      const i = vm(n),
        r = [],
        s = this.getPreInitialState(t, i, r),
        o = Hl([{
          target: [...Vm(this.root)],
          source: this.root,
          reenter: !0,
          actions: [],
          eventType: null,
          toJSON: null
        }], s, t, i, !0, r),
        {
          snapshot: a
        } = El(o, i, t, r);
      return a
    }
    start(t) {
      Object.values(t.children).forEach(n => {
        n.getSnapshot().status === "active" && n.start()
      })
    }
    getStateNodeById(t) {
      const n = Sl(t),
        i = n.slice(1),
        r = Gs(n[0]) ? n[0].slice(GT.length) : n[0],
        s = this.idMap.get(r);
      if (!s) throw new Error(`Child state node '#${r}' does not exist on machine '${this.id}'`);
      return Ks(s, i)
    }
    get definition() {
      return this.root.definition
    }
    toJSON() {
      return this.definition
    }
    getPersistedSnapshot(t, n) {
      return ET(t, n)
    }
    restoreSnapshot(t, n) {
      const i = {},
        r = t.children;
      Object.keys(r).forEach(f => {
        const d = r[f],
          p = d.snapshot,
          h = d.src,
          g = typeof h == "string" ? Xl(this, h) : h;
        if (!g) return;
        const A = Zn(g, {
          id: f,
          parent: n.self,
          syncSnapshot: d.syncSnapshot,
          snapshot: p,
          src: h,
          systemId: d.systemId
        });
        i[f] = A
      });

      function s(f, d) {
        if (d instanceof _s) return d;
        try {
          return f.machine.getStateNodeById(d.id)
        } catch {}
      }

      function o(f, d) {
        if (!d || typeof d != "object") return {};
        const p = {};
        for (const h in d) {
          const g = d[h];
          for (const A of g) {
            const m = s(f, A);
            m && (p[h] ?? (p[h] = []), p[h].push(m))
          }
        }
        return p
      }
      const a = o(this.root, t.historyValue),
        l = Ys({
          ...t,
          children: i,
          _nodes: Array.from(Bs(Js(this.root, t.value))),
          historyValue: a
        }, this),
        u = new Set;

      function c(f, d) {
        if (!u.has(f)) {
          u.add(f);
          for (const p in f) {
            const h = f[p];
            if (h && typeof h == "object") {
              if ("xstate$$type" in h && h.xstate$$type === Vl) {
                f[p] = d[h.id];
                continue
              }
              c(h, d)
            }
          }
        }
      }
      return c(l.context, i), l
    }
  }

  function KT(e, t, n, i, {
    event: r
  }) {
    const s = typeof r == "function" ? r(n, i) : r;
    return [t, {
      event: s
    }, void 0]
  }

  function JT(e, {
    event: t
  }) {
    e.defer(() => e.emit(t))
  }

  function Be(e) {
    function t(n, i) {}
    return t.type = "xstate.emit", t.event = e, t.resolve = KT, t.execute = JT, t
  }

  function YT(e, t) {
    return new Ml(e, t)
  }

  function $s({
    schemas: e,
    actors: t,
    actions: n,
    guards: i,
    delays: r
  }) {
    return {
      createMachine: s => YT({
        ...s,
        schemas: e
      }, {
        actors: t,
        actions: n,
        guards: i,
        delays: r
      })
    }
  }
  const Il = Xe.forDomain("AnimationLoop"),
    QT = () => {
      const e = {
          eventType: "drop",
          id: null
        },
        t = {
          logo_icon: {
            content: {
              eventType: "none",
              icon: "logo",
              type: "icon",
              value: "",
              label: ""
            },
            active: !0,
            repeat: -1
          },
          drop_total_num: {
            content: {
              eventType: "drop",
              icon: "none",
              type: "number",
              value: "100",
              label: "widget.drop_left"
            },
            active: !1,
            repeat: -1
          },
          drop_max_prize: {
            content: {
              eventType: "drop",
              icon: "none",
              type: "money",
              value: "1000",
              label: "widget.drop_prize"
            },
            active: !1,
            repeat: -1
          },
          challenge_time: {
            content: {
              eventType: "challenge",
              icon: "none",
              type: "timer",
              value: "60",
              label: "widget.challenge_start"
            },
            active: !1,
            repeat: -1
          },
          challenge_place: {
            content: null,
            active: !1,
            repeat: -1
          },
          drag_icon: {
            content: {
              eventType: "none",
              icon: "drag",
              type: "icon",
              value: "",
              label: ""
            },
            active: !1,
            repeat: -1,
            anim_circle: 3,
            anim_circle_current: 0
          }
        };
      let n = -1;
      const i = Object.keys(t),
        r = (c, f) => {
          t[c] && (f ? (Il.info("updateContent: for " + c, f), t[c].content = f, t[c].active = !0) : t[c].active = !1)
        },
        s = () => {
          Il.info("nextAnimation currentIndex", n);
          let c = 0;
          for (; c < i.length;) {
            n = (n + 1) % i.length;
            const f = i[n],
              d = t[f];
            if (d != null && d.anim_circle && (d.anim_circle_current = (d.anim_circle_current ?? 0) + 1, (d == null ? void 0 : d.anim_circle_current) % (d == null ? void 0 : d.anim_circle) === 0 ? d.active = !0 : d.active = !1), d.active) return d.repeat > 0 && (t[f].repeat = d.repeat - 1, t[f].repeat === 0 && (t[f].active = !1)), Il.info("nextAnimation content", d.active), a(d), d.content;
            c++
          }
          return a(t[i[0]]), t[i[0]].content
        },
        o = () => t[i[0]].content,
        a = c => {
          var f;
          (f = c.content) != null && f.id && (e.eventType = c.content.eventType, e.id = c.content.id)
        };
      return {
        getLobbyEvent: () => e,
        updateContent: r,
        nextAnimation: s,
        getAnimationContent: o,
        hasEventAnimation: () => {
          var c;
          for (const f of i) {
            const d = t[f];
            if (((c = d.content) == null ? void 0 : c.eventType) !== "none" && d.active) return !0
          }
          return !1
        }
      }
    };
  var eo = (e => (e.JoinNewDrop = "widget.drop_tooltip", e.JoinNewChallenge = "widget.challenge_tooltip", e))(eo || {});

  function _T() {
    const e = [],
      t = "widget.drop_tooltip";
    let n = {
      event_id: "9999",
      message: "widget.drop_tooltip",
      event_type: "drop"
    };
    const i = new Set;
    let r = !1;
    return {
      addTooltip: (d, p) => {
        if (!r && !i.has(d.event_id))
          if (i.add(d.event_id), e.length === 0)
            for (let h = 0; h < p; h++) e.push(d);
          else {
            const h = [];
            for (let m = 0; m < p; m++) h.push(d);
            const g = [],
              A = Math.max(h.length, e.length);
            for (let m = 0; m < A; m++) m < h.length && g.push(h[m]), m < e.length && g.push(e[m]);
            e.length = 0, e.push(...g)
          }
      },
      getNextTooltip: () => e.length === 0 ? (n = null, null) : (n = e.shift() || null, n),
      clear: d => {
        const p = e.filter(h => h.event_id !== d);
        e.length = 0, e.push(...p)
      },
      clearAll: () => {
        e.length = 0, r = !0
      },
      getQueueLength: () => e.length,
      getCurrentQueue: () => [...e],
      tooltipMessage: t,
      getCurrentTooltip: () => n
    }
  }
  const me = Xe.forDomain("AppViewStateMachine"),
    $T = $s({
      actions: {
        clearPlayerWin: ft({
          playerWin: null
        }),
        openLobby: ({
          context: e,
          event: t
        }) => {
          me.info("openLobby action called");
          const n = t.source || "coin";
          if (me.info("openLobby source:", n), n === "tooltip") {
            const i = e.tooltipController.getCurrentTooltip();
            me.info("Current tooltip:", i), i && i.event_type && i.event_id ? Zs(parseInt(i.event_id), i.event_type) : (me.warn("No valid current tooltip found, using default values"), Zs(null, "root"))
          } else {
            const i = e.animationLoop.getLobbyEvent();
            me.info("lobbyEvent from animationLoop:", i), i && i.eventType && i.id ? Zs(i.id, i.eventType) : (me.warn("No valid lobbyEvent found, using default values"), Zs(null, "root"))
          }
          e.tooltipController.clearAll()
        },
        trackLobbyCoinClick: ({
          context: e,
          event: t
        }) => {
          me.info("trackLobbyCoinClick", t);
          const n = e.animationLoop.getLobbyEvent(),
            i = e.animationLoop.hasEventAnimation();
          di({
            eventName: "lobby_coin_click",
            eventData: {
              coin_state: n.eventType || "lobby",
              mode: i ? "active" : "passive",
              game_identifier: E == null ? void 0 : E.identifier
            }
          })
        },
        trackLobbyCoinShown: ({
          context: e,
          event: t
        }) => {
          me.info("trackLobbyCoinShown", t), e.animationLoop.getLobbyEvent(), e.animationLoop.hasEventAnimation(), di({
            eventName: "lobby_coin_shown",
            eventData: {
              coin_state: "null",
              mode: "null",
              game_identifier: E == null ? void 0 : E.identifier
            }
          })
        },
        trackLobbyCoinDrop: ({
          context: e,
          event: t
        }) => {
          me.info("trackLobbyCoinDrop", t);
          const n = e.animationLoop.getLobbyEvent(),
            i = e.animationLoop.hasEventAnimation();
          di({
            eventName: "lobby_coin_moved",
            eventData: {
              coin_state: n.eventType || "lobby",
              mode: i ? "active" : "passive",
              game_identifier: E == null ? void 0 : E.identifier
            }
          })
        },
        emitStartCoinAnimation: Be({
          type: "START_COIN_ANIMATION"
        }),
        emitStartDragging: Be({
          type: "START_DRAGGING"
        }),
        emitStopDragging: Be({
          type: "STOP_DRAGGING"
        }),
        emiteConfirmPlayerWin: Be({
          type: "CONFIRM_PLAYER_WIN"
        })
      }
    }).createMachine({
      id: "appView",
      context: ({
        input: e
      }) => ({
        animationLoop: e.animationLoop,
        tooltipController: e.tooltipController,
        playerWin: e.playerWin,
        currentAnimation: null,
        tooltipMessage: null,
        lastShowContentTime: null
      }),
      initial: "hidden",
      on: {
        UPDATE_PLAYER_WIN: {
          actions: ({
            event: e,
            context: t
          }) => {
            t.playerWin = e.value, me.info("UPDATE_PLAYER_WIN", t.playerWin)
          }
        },
        HIDE: {
          actions: () => {
            me.info("HIDE")
          },
          target: "#appView.hidden"
        }
      },
      states: {
        hidden: {
          entry: () => {
            me.info("enter hidden")
          },
          on: {
            ACTIVATE: {
              actions: ["trackLobbyCoinShown"],
              target: "showCoinWidget.loading"
            },
            SHOW: {
              actions: () => {
                me.info("SHOW")
              },
              target: "#appView.showCoinWidget.showContent"
            }
          }
        },
        showWinPopup: {
          entry: ({
            context: e
          }) => {
            me.info("enter showWinPopup")
          },
          on: {
            CONTINUE: {
              actions: ["clearPlayerWin", ({
                context: e
              }) => {
                me.info("CONTINUE", e.playerWin)
              }, "emiteConfirmPlayerWin"],
              target: "showCoinWidget"
            }
          }
        },
        showCoinWidget: {
          initial: "loading",
          on: {
            OVERLAP_ON: {
              entry: () => {
                me.info("enter OVERLAP_ON")
              },
              target: ".game_ui_overlap"
            },
            DISABLE: {
              entry: () => {
                me.info("enter DISABLE")
              },
              target: "showCoinWidget.disabled"
            }
          },
          states: {
            loading: {
              entry: () => {
                me.info("enter loading")
              },
              on: {
                ACTIVATE: {
                  target: "showContent"
                }
              },
              after: {
                500: "showContent"
              }
            },
            disabled: {
              entry: () => {
                me.info("enter disabled")
              },
              on: {
                ENABLE: "showContent"
              }
            },
            game_ui_overlap: {
              entry: () => {
                me.info("enter game_ui_overlap------------------------")
              },
              on: {
                OVERLAP_OFF: "showContent"
              }
            },
            showContent: {
              entry: [({
                context: e
              }) => {
                e.currentAnimation = e.animationLoop.nextAnimation(), me.info("enter showContent, currentAnimation:", e.currentAnimation);
                const t = Date.now(),
                  n = e.lastShowContentTime ? t - e.lastShowContentTime : 1 / 0;
                if (me.info("TIMER:", n / 1e3), n > 6e4) {
                  const i = e.tooltipController.getNextTooltip();
                  me.info("nextTooltip:", i), i && (e.tooltipMessage = i, me.info("Tooltip set:", e.tooltipMessage))
                }
              }],
              exit: [({
                context: e
              }) => {
                e.tooltipMessage !== null && (e.lastShowContentTime = Date.now(), e.tooltipMessage = null, me.info("Cleared tooltip message and saved time"))
              }],
              always: [{
                guard: ({
                  context: e
                }) => e.playerWin !== null,
                target: "#appView.showWinPopup"
              }],
              on: {
                DRAG: "dragging",
                OPEN_LOBBY: {
                  actions: ["openLobby", "trackLobbyCoinClick"],
                  target: "disabled"
                },
                DISABLE: "disabled"
              },
              after: {
                1e4: "coinAnimation"
              }
            },
            coinAnimation: {
              entry: [({
                context: e,
                event: t
              }) => {
                me.info("enter coinAnimation - checking context state:", {
                  currentAnimation: e.currentAnimation,
                  playerWin: e.playerWin,
                  previousState: t.type
                })
              }, "emitStartCoinAnimation"],
              on: {
                DRAG: "dragging",
                DISABLE: "disabled",
                OPEN_LOBBY: {
                  actions: "openLobby"
                },
                ANIMATION_END: "showContent"
              }
            },
            dragging: {
              entry: "emitStartDragging",
              exit: ["emitStopDragging", "trackLobbyCoinDrop"],
              on: {
                DROP: "showContent",
                DISABLE: "disabled"
              }
            }
          }
        }
      }
    }),
    re = Xe.forDomain("DropServiceMachine"),
    eL = $s({
      actions: {
        emitActivate: Be({
          type: "ACTIVATE",
          message: "Hello"
        }),
        assignCurrentCampaign: ft({
          currentCampaign: ({
            event: e
          }) => e.output.campaign
        }),
        clearCurrentCampaign: ft({
          currentCampaign: null
        }),
        emitCampaignChanged: Be(({
          context: e
        }) => ({
          type: "CAMPAIGN_CHANGED",
          data: e.currentCampaign
        })),
        clearCoinInfo: ft({
          coinInfo: null
        }),
        assignCoinInfo: ft({
          coinInfo: ({
            context: e,
            event: t
          }) => {
            var n;
            return re.info("assignCoinInfo", t.output.coinInfo), t.output.coinInfo.campaign_currency = ((n = e.currentCampaign) == null ? void 0 : n.campaign_currency) || "EUR", t.output.coinInfo
          }
        }),
        emitCoinUpdate: Be(({
          context: e
        }) => ({
          type: "COIN_UPDATE",
          data: {
            coinInfo: e.coinInfo,
            campaign: e.currentCampaign
          }
        })),
        assignPlayerWin: ft({
          playerWin: ({
            context: e,
            event: t
          }) => {
            var n, i;
            return (n = e.currentCampaign) != null && n.campaign_currency && (t.output.playerWin.campaign_currency = e.currentCampaign.campaign_currency, t.output.playerWin.campaign_title = e.currentCampaign.public_name, t.output.playerWin.campaign_id = e.currentCampaign.id, t.output.playerWin.campaign_status = e.currentCampaign.status), t.output.playerWin.skin = (i = e.currentCampaign) == null ? void 0 : i.skin, re.info("assignPlayerWin", t.output.playerWin), t.output.playerWin
          }
        }),
        emitPlayerWin: Be(({
          context: e
        }) => ({
          type: "PLAYER_WIN",
          data: e.playerWin
        })),
        clearPlayerWin: ft({
          playerWin: null
        }),
        emitShowWin: Be({
          type: "SHOW_WIN"
        })
      },
      actors: {
        initDrop: Ht(async ({
          input: e
        }) => {
          re.info("initDrop");
          try {
            const t = await e.dropAPI.fetchDropsList();
            if (t && t.length > 0) return re.info("initDrop success", t), {
              success: !0,
              campaigns: t
            }
          } catch (t) {
            re.error("Failed to fetch campaigns:", t)
          }
          return re.error("initDrop failed"), {
            success: !1
          }
        }),
        getActiveCampaign: Ht(async ({
          input: e
        }) => {
          re.info("get active campaign");
          try {
            const t = await e.dropAPI.fetchDropsList();
            let n = t == null ? void 0 : t.find(i => i.status === "ongoing" && i.game_identifiers.includes(e.identifier));
            if (n || (n = t == null ? void 0 : t.find(i => i.status === "ongoing")), n) return re.info("get active campaign success", n), {
              success: !0,
              campaign: n
            }
          } catch (t) {
            re.error("Failed to fetch active campaign:", t)
          }
          return {
            success: !1
          }
        }),
        fetchCoinInfo: Ht(async ({
          input: e
        }) => {
          var t;
          re.info("get coin info");
          try {
            if (!((t = e.currentCampaign) != null && t.id)) return {
              success: !1,
              error: "No campaign ID"
            };
            const n = await e.dropAPI.fetchCoinInfo(e.currentCampaign.id);
            if (n) return re.info("get coin info success", n), {
              success: !0,
              coinInfo: n
            }
          } catch (n) {
            re.error("Failed to fetch coin info:", n)
          }
          return {
            success: !1
          }
        }),
        checkPlayerWin: Ht(async ({
          input: e
        }) => {
          var t;
          re.info("check player win");
          try {
            return (t = e.currentCampaign) != null && t.id ? {
              success: !0,
              playerWin: await e.dropAPI.fetchPlayerWin(e.currentCampaign.id)
            } : {
              success: !1,
              error: "No campaign ID"
            }
          } catch (n) {
            re.error("Failed to fetch player win:", n)
          }
          return {
            success: !1
          }
        }),
        confirmPlayerWin: Ht(async ({
          input: e
        }) => {
          var t;
          re.info("confirm player win", e.playerWin);
          try {
            return (t = e.playerWin) != null && t.id ? (await e.dropAPI.confirmPlayerWin(e.playerWin.id), re.info("confirm player win success"), {
              success: !0
            }) : {
              success: !1,
              error: "No player win ID"
            }
          } catch (n) {
            re.error("Failed to confirm player win:", n)
          }
          return {
            success: !1
          }
        })
      }
    }).createMachine({
      id: "drop",
      initial: "idle",
      context: ({
        input: e
      }) => ({
        dropAPI: e.dropAPI,
        campaign: null,
        currentCampaign: null,
        coinInfo: null,
        playerWin: null,
        identifier: e.identifier
      }),
      on: {
        STOP: ".waiting"
      },
      states: {
        idle: {
          on: {
            RUN: "init"
          }
        },
        init: {
          invoke: {
            src: "initDrop",
            input: ({
              context: e
            }) => e,
            onDone: [{
              guard: ({
                event: e
              }) => e.output.success,
              target: "passive"
            }, {
              target: "retry"
            }],
            onError: {
              target: "retry"
            }
          }
        },
        retry: {
          after: {
            18e4: "init"
          }
        },
        waiting: {
          entry: () => re.info("waiting state"),
          on: {
            START: "init"
          }
        },
        passive: {
          invoke: {
            src: "getActiveCampaign",
            input: ({
              context: e
            }) => e,
            onDone: [{
              guard: ({
                event: e,
                context: t
              }) => {
                var i, r;
                const n = e.output.success && ((i = e.output.campaign) == null ? void 0 : i.player_joined) && e.output.campaign.game_identifiers.includes(t.identifier);
                return re.info("Guard 1 - new joined campaign (from passive state):", {
                  success: e.output.success,
                  player_joined: (r = e.output.campaign) == null ? void 0 : r.player_joined,
                  result: n
                }), n
              },
              actions: ["assignCurrentCampaign", "emitCampaignChanged"],
              target: "active.playerWinCheck.joined"
            }, {
              guard: ({
                context: e,
                event: t
              }) => {
                const n = t.output.success && e.currentCampaign === null && t.output.campaign !== null;
                return re.info("Guard 2 - new not joined campaign (from passive state):", {
                  success: t.output.success,
                  currentCampaign: e.currentCampaign,
                  newCampaign: t.output.campaign,
                  result: n
                }), n
              },
              actions: ["assignCurrentCampaign", "emitCampaignChanged"],
              target: "active.playerWinCheck.idle"
            }, {
              guard: ({
                context: e
              }) => {
                var n, i;
                const t = e.currentCampaign !== null && e.currentCampaign.player_joined && e.currentCampaign.game_identifiers.includes(e.identifier);
                return re.info("Guard 3 - existing joined campaign (from passive state):", {
                  currentCampaign: e.currentCampaign,
                  player_joined: (n = e.currentCampaign) == null ? void 0 : n.player_joined,
                  game_identifiers: (i = e.currentCampaign) == null ? void 0 : i.game_identifiers,
                  identifier: e.identifier,
                  result: t
                }), t
              },
              target: "active.playerWinCheck.joined"
            }, {
              guard: ({
                context: e
              }) => {
                var n;
                const t = e.currentCampaign !== null && !e.currentCampaign.player_joined;
                return re.info("Guard 4 - existing not joined campaign (from passive state):", {
                  currentCampaign: e.currentCampaign,
                  player_joined: (n = e.currentCampaign) == null ? void 0 : n.player_joined,
                  result: t
                }), t
              },
              target: "active.playerWinCheck.idle"
            }, {
              guard: () => (re.info("Guard 5 - fallback to retry_passive (from passive state)"), !0),
              target: "retry_passive"
            }],
            onError: {
              target: "retry_passive"
            }
          }
        },
        retry_passive: {
          after: {
            18e4: "passive"
          }
        },
        active: {
          entry: "emitActivate",
          type: "parallel",
          states: {
            updateCoinInfo: {
              initial: "coinInfo",
              states: {
                coinInfo: {
                  invoke: {
                    src: "fetchCoinInfo",
                    input: ({
                      context: e
                    }) => e,
                    onDone: [{
                      guard: ({
                        event: e
                      }) => e.output.success,
                      actions: ["assignCoinInfo", "emitCoinUpdate"],
                      target: "retry_coinInfo"
                    }, {
                      actions: ({
                        context: e,
                        event: t
                      }) => {
                        var n;
                        re.info("fetchCoinInfo failed - checking context state:", {
                          coinInfo: e.coinInfo,
                          currentCampaign: e.currentCampaign,
                          playerWin: e.playerWin,
                          drop_campaign_status: (n = e.coinInfo) == null ? void 0 : n.drop_campaign_status,
                          previousState: t.type
                        })
                      },
                      target: "retry_coinInfo"
                    }],
                    onError: {
                      target: "retry_coinInfo"
                    }
                  }
                },
                retry_coinInfo: {
                  entry: () => re.info("retry_coinInfo state"),
                  after: {
                    6e4: "coinInfo"
                  }
                }
              }
            },
            playerWinCheck: {
              initial: "idle",
              states: {
                idle: {
                  entry: ({
                    context: e,
                    event: t
                  }) => {
                    var n;
                    return re.info("Idle state for non-joined campaigns - entered from passive state transition", {
                      playerWin: e.playerWin,
                      currentCampaign: e.currentCampaign,
                      player_joined: (n = e.currentCampaign) == null ? void 0 : n.player_joined,
                      previousState: t.type,
                      event: t
                    })
                  }
                },
                joined: {
                  entry: ({
                    context: e,
                    event: t
                  }) => {
                    var n;
                    return re.info("Joined state - entered from passive state transition", {
                      playerWin: e.playerWin,
                      currentCampaign: e.currentCampaign,
                      player_joined: (n = e.currentCampaign) == null ? void 0 : n.player_joined,
                      previousState: t.type,
                      event: t
                    })
                  },
                  invoke: {
                    src: "checkPlayerWin",
                    input: ({
                      context: e
                    }) => e,
                    onDone: [{
                      guard: ({
                        context: e,
                        event: t
                      }) => {
                        let n = t.output.success && t.output.playerWin;
                        return re.info("check  PlayerWin ", t.output.playerWin), re.info("check  context PlayerWin ", e.playerWin), n
                      },
                      actions: ["assignPlayerWin", "emitPlayerWin", "emitShowWin"],
                      target: "showWin"
                    }, {
                      guard: ({
                        context: e,
                        event: t
                      }) => {
                        var n;
                        return t.output.success && t.output.playerWin === null && ((n = e.coinInfo) == null ? void 0 : n.drop_campaign_status) !== "ongoing"
                      },
                      target: "#drop.passive"
                    }, {
                      guard: ({
                        event: e
                      }) => (re.info("Checking guard condition for playerWin", e.output), e.output.success && e.output.playerWin === null),
                      target: "retry_playerWin"
                    }, {
                      target: "retry_playerWin"
                    }],
                    onError: {
                      target: "retry_playerWin"
                    }
                  }
                },
                showWin: {
                  entry: ({
                    context: e
                  }) => re.info("showWin state", e.playerWin)
                },
                retry_playerWin: {
                  entry: () => re.info("retry_playerWin state"),
                  after: {
                    15e3: "joined"
                  }
                }
              }
            }
          },
          on: {
            DEACTIVATE: "init",
            CONFIRM_PLAYER_WIN: "confirmingWin"
          }
        },
        confirmingWin: {
          entry: ({
            context: e
          }) => re.info("confirmingWin state", e.playerWin),
          invoke: {
            src: "confirmPlayerWin",
            input: ({
              context: e
            }) => e,
            onDone: {
              actions: "clearPlayerWin",
              target: "active.playerWinCheck.joined"
            },
            onError: {
              actions: "clearPlayerWin",
              target: "active"
            }
          }
        }
      }
    }),
    tt = Xe.forDomain("AvailableServiceMachine"),
    tL = $s({
      actions: {
        emitAvailable: Be({
          type: "SUCCESS",
          message: "Service is available"
        }),
        emitNotAvailable: Be({
          type: "NOT_AVAILABLE",
          message: "Service is not available"
        })
      },
      actors: {
        checkCampaigns: Ht(async ({
          input: e
        }) => {
          if (tt.info("checkCampaigns"), !e.dropAPI) return {
            success: !1,
            error: "DropAPI is not available"
          };
          try {
            return await e.dropAPI.fetchDropsExist() ? (tt.info("checkCampaigns success - found valid campaign"), {
              success: !0,
              hasCampaign: !0
            }) : (tt.info("checkCampaigns - no valid campaigns found"), {
              success: !0,
              hasCampaign: !1
            })
          } catch (t) {
            return tt.error("Failed to check campaigns:", t), {
              success: !1,
              error: t
            }
          }
        }),
        checkChallenges: Ht(async ({
          input: e
        }) => {
          if (tt.info("checkChallenges"), !e.challengeAPI) return {
            success: !1,
            error: "ChallengeAPI is not available"
          };
          try {
            return await e.challengeAPI.fetchChallengesExist() ? (tt.info("checkChallenges success - found valid challenge"), {
              success: !0,
              hasChallenge: !0
            }) : (tt.info("checkChallenges - no valid challenges found"), {
              success: !0,
              hasChallenge: !1
            })
          } catch (t) {
            return tt.error("Failed to check challenges:", t), {
              success: !1,
              error: t
            }
          }
        }),
        checkChallengePermissions: Ht(async ({
          input: e
        }) => {
          if (tt.info("checkChallengePermissions"), !e.challengeAPI) return {
            success: !1,
            error: "ChallengeAPI is not available"
          };
          try {
            return await e.challengeAPI.fetchChallengePermissions() ? (tt.info("checkChallengePermissions success - permissions granted"), {
              success: !0,
              hasPermissions: !0
            }) : (tt.info("checkChallengePermissions - no permissions granted"), {
              success: !0,
              hasPermissions: !1
            })
          } catch (t) {
            return tt.error("Failed to check challenge permissions:", t), {
              success: !1,
              error: t
            }
          }
        })
      }
    }).createMachine({
      id: "available",
      initial: "checkingCampaigns",
      context: ({
        input: e
      }) => ({
        dropAPI: e.dropAPI,
        challengeAPI: e.challengeAPI,
        identifier: e.identifier
      }),
      on: {
        RESTART: ".checkingCampaigns"
      },
      states: {
        checkingCampaigns: {
          invoke: {
            src: "checkCampaigns",
            input: ({
              context: e
            }) => e,
            onDone: [{
              guard: ({
                event: e
              }) => e.output.success && e.output.hasCampaign,
              actions: "emitAvailable",
              target: "available"
            }, {
              guard: ({
                event: e
              }) => e.output.success && !e.output.hasCampaign,
              target: "checkingChallenges"
            }, {
              target: "retry"
            }],
            onError: {
              target: "retry"
            }
          }
        },
        checkingChallenges: {
          invoke: {
            src: "checkChallenges",
            input: ({
              context: e
            }) => e,
            onDone: [{
              guard: ({
                event: e
              }) => e.output.success && e.output.hasChallenge,
              actions: "emitAvailable",
              target: "available"
            }, {
              guard: ({
                event: e
              }) => e.output.success && !e.output.hasChallenge,
              target: "checkingPermissions"
            }, {
              target: "retry"
            }],
            onError: {
              target: "retry"
            }
          }
        },
        checkingPermissions: {
          invoke: {
            src: "checkChallengePermissions",
            input: ({
              context: e
            }) => e,
            onDone: [{
              guard: ({
                event: e
              }) => e.output.success && e.output.hasPermissions,
              actions: "emitAvailable",
              target: "available"
            }, {
              guard: ({
                event: e
              }) => e.output.success && !e.output.hasPermissions,
              actions: "emitNotAvailable",
              target: "notAvailable"
            }, {
              target: "retry"
            }],
            onError: {
              target: "retry"
            }
          }
        },
        available: {
          entry: () => tt.info("Service is available"),
          on: {
            RESTART: "checkingCampaigns"
          }
        },
        notAvailable: {
          entry: () => tt.info("Service is not available"),
          on: {
            RESTART: "checkingCampaigns"
          }
        },
        retry: {
          entry: () => tt.info("Retrying availability check"),
          after: {
            18e4: "checkingCampaigns"
          }
        }
      }
    });
  var Im = (e => (e.Allowed = "allowed", e.DeniedBuy = "denied_buy", e.OnlyFeature = "only_feature", e))(Im || {}),
    vi = (e => (e.Ongoing = "ongoing", e.Planned = "planned", e.Sync = "result_calculating", e.Finished = "finished", e.Cancelled = "cancelled", e))(vi || {});
  vi.Ongoing, vi.Planned, vi.Finished, vi.Ongoing, Im.Allowed;
  const de = Xe.forDomain("ChallengeServiceMachine"),
    nL = $s({
      actions: {
        emitActivate: Be({
          type: "ACTIVATE",
          message: "Challenge activated"
        }),
        assignActiveChallenge: ft({
          activeChallenge: ({
            event: e
          }) => e.output.activeChallenge
        }),
        assignOngoingNotJoinedChallenge: ft({
          ongoingNotJoinedChallenge: ({
            event: e
          }) => e.output.ongoingNotJoinedChallenge
        }),
        emitActiveChallenge: Be(({
          context: e
        }) => ({
          type: "UPDATE_ACTIVE_CHALLENGE",
          data: e.activeChallenge
        })),
        emitOngoingNotJoinedChallenge: Be(({
          context: e
        }) => ({
          type: "UPDATE_ONGOING_NOT_JOINED_CHALLENGE",
          data: e.ongoingNotJoinedChallenge
        })),
        mergeChallengeDetails: ft({
          activeChallenge: ({
            context: e,
            event: t
          }) => (de.info("mergeChallengeDetails", t.output.challengeDetails), !e.activeChallenge || !t.output.challengeDetails ? t.output.challengeDetails : {
            ...e.activeChallenge,
            ...t.output.challengeDetails
          })
        }),
        emmitClearActiveChallenge: Be({
          type: "CLEAR_ACTIVE_CHALLENGE"
        }),
        assignLeaderboardPreview: ft({
          leaderboardPreview: ({
            event: e
          }) => e.output.leaderboardPreview
        }),
        emitLeaderboardPreview: Be(({
          context: e
        }) => ({
          type: "LEADERBOARD_PREVIEW",
          data: e.leaderboardPreview
        })),
        clearActiveChallenge: ft({
          activeChallenge: null
        }),
        clearLeaderboardPreview: ft({
          leaderboardPreview: null
        })
      },
      actors: {
        fetchChallengeList: Ht(async ({
          input: e
        }) => {
          var t, n, i, r, s, o;
          de.info("fetchChallengeList");
          try {
            const a = await e.challengeAPI.fetchChallengesList();
            if (a) {
              let l = ((t = a == null ? void 0 : a.active) == null ? void 0 : t.find(c => {
                var f;
                return (f = c.game_identifiers) == null ? void 0 : f.includes(e.identifier)
              })) || ((n = a == null ? void 0 : a.planned) == null ? void 0 : n.find(c => {
                var f;
                return (f = c.game_identifiers) == null ? void 0 : f.includes(e.identifier)
              }));
              l || (l = ((i = a == null ? void 0 : a.active) == null ? void 0 : i[0]) || ((r = a == null ? void 0 : a.planned) == null ? void 0 : r[0]));
              let u = null;
              return (!l || l.player_active) && (u = ((s = a == null ? void 0 : a.active) == null ? void 0 : s.find(c => !c.player_active)) || ((o = a == null ? void 0 : a.planned) == null ? void 0 : o.find(c => !c.player_active))), de.info("fetchChallengeList success", {
                challengeLists: a,
                activeChallenge: l
              }), {
                success: !0,
                challengeLists: a,
                activeChallenge: l,
                ongoingNotJoinedChallenge: u
              }
            }
          } catch (a) {
            de.error("Failed to fetch challenge list:", a)
          }
          return de.error("fetchChallengeList failed"), {
            success: !1
          }
        }),
        fetchChallengeDetails: Ht(async ({
          input: e
        }) => {
          var t;
          de.info("fetchChallengeDetails");
          try {
            if (!((t = e.activeChallenge) != null && t.id)) return {
              success: !1,
              error: "No active challenge ID"
            };
            const n = await e.challengeAPI.fetchChallengeById(e.activeChallenge.id);
            if (n) return de.info("fetchChallengeDetails success", n), {
              success: !0,
              challengeDetails: n
            }
          } catch (n) {
            de.error("Failed to fetch challenge details:", n)
          }
          return {
            success: !1
          }
        }),
        fetchLeaderboardPreview: Ht(async ({
          input: e
        }) => {
          var t;
          de.info("fetchLeaderboardPreview");
          try {
            if (!((t = e.activeChallenge) != null && t.id)) return {
              success: !1,
              error: "No active challenge ID"
            };
            const n = await e.challengeAPI.fetchChallengeLeaderboardPreview(e.activeChallenge.id);
            if (n) return de.info("fetchLeaderboardPreview success", n), {
              success: !0,
              leaderboardPreview: n
            }
          } catch (n) {
            de.error("Failed to fetch leaderboard preview:", n)
          }
          return {
            success: !1
          }
        })
      }
    }).createMachine({
      id: "challenge",
      initial: "idle",
      context: ({
        input: e
      }) => ({
        challengeAPI: e.challengeAPI,
        activeChallenge: null,
        ongoingNotJoinedChallenge: null,
        leaderboardPreview: null,
        identifier: e.identifier
      }),
      on: {
        pause: ".pause"
      },
      states: {
        idle: {
          on: {
            RUN: "init"
          }
        },
        init: {
          entry: ["clearActiveChallenge", "clearLeaderboardPreview", "emmitClearActiveChallenge"],
          invoke: {
            src: "fetchChallengeList",
            input: ({
              context: e
            }) => e,
            onDone: [{
              guard: ({
                event: e
              }) => (de.info("fetchChallengeList guard", e.output.activeChallenge), e.output.success && e.output.activeChallenge),
              actions: ["assignActiveChallenge", "assignOngoingNotJoinedChallenge", "emitActivate", "emitActiveChallenge", "emitOngoingNotJoinedChallenge"],
              target: "planned"
            }, {
              target: "retry"
            }],
            onError: {
              target: "retry"
            }
          }
        },
        retry: {
          after: {
            6e4: "init"
          }
        },
        planned: {
          entry: ({
            context: e
          }) => {
            de.info("planned activeChallenge", e.activeChallenge)
          },
          exit: ({
            context: e
          }) => {
            de.info("planned exit", e.activeChallenge)
          },
          always: [{
            guard: ({
              context: e
            }) => {
              var r;
              if (!((r = e.activeChallenge) != null && r.start_at)) return de.info("No start_at time available, transitioning to checkStart"), !0;
              const t = new Date(e.activeChallenge.start_at),
                n = new Date,
                i = n >= t;
              return de.info("Checking challenge start time", {
                start_at: e.activeChallenge.start_at,
                startTime: t.toISOString(),
                currentTime: n.toISOString(),
                hasStarted: i
              }), i
            },
            target: "checkStart"
          }, {
            target: "planne_waiting"
          }]
        },
        planne_waiting: {
          entry: () => {
            de.info("planne_waiting")
          },
          after: {
            5e3: {
              target: "planned"
            }
          }
        },
        checkStart: {
          entry: () => {
            de.info("checkStart")
          },
          invoke: {
            src: "fetchChallengeDetails",
            input: ({
              context: e
            }) => e,
            onDone: [{
              guard: ({
                event: e
              }) => e.output.success && e.output.challengeDetails && e.output.challengeDetails.status === vi.Planned,
              target: "waiting_checkStart"
            }, {
              guard: ({
                event: e
              }) => e.output.success && e.output.challengeDetails && e.output.challengeDetails.status === vi.Cancelled,
              target: "init"
            }, {
              guard: ({
                context: e,
                event: t
              }) => {
                var n;
                return t.output.success && t.output.challengeDetails && t.output.challengeDetails.player_active && ((n = t.output.challengeDetails.game_identifiers) == null ? void 0 : n.includes(e.identifier))
              },
              actions: ["mergeChallengeDetails", "emitActiveChallenge"],
              target: "joining"
            }, {
              guard: ({
                event: e
              }) => e.output.success && e.output.challengeDetails,
              actions: ["mergeChallengeDetails", "emitActiveChallenge"],
              target: "ongoing"
            }, {
              target: "init"
            }],
            onError: {
              target: "init"
            }
          }
        },
        waiting_checkStart: {
          entry: () => {
            de.info("waiting_checkStart")
          },
          after: {
            5e3: {
              target: "checkStart"
            }
          }
        },
        ongoing: {
          always: [{
            guard: ({
              context: e
            }) => {
              var r;
              if (de.info("planning to ongoing", e.activeChallenge), !((r = e.activeChallenge) != null && r.finish_at)) return de.info("No finish_at time available, staying in ongoing"), !1;
              const t = new Date(e.activeChallenge.finish_at),
                n = new Date,
                i = n >= t;
              return de.info("Checking challenge finish time", {
                finish_at: e.activeChallenge.finish_at,
                finishTime: t.toISOString(),
                currentTime: n.toISOString(),
                hasFinished: i
              }), i
            },
            target: "init"
          }, {
            target: "ongoing_waiting"
          }]
        },
        ongoing_waiting: {
          entry: () => {
            de.info("ongoing_waiting")
          },
          after: {
            5e3: {
              target: "ongoing"
            }
          }
        },
        joining: {
          entry: () => {
            de.info("joining")
          },
          always: [{
            guard: ({
              context: e
            }) => {
              var r;
              if (de.info("planning to ongoing", e.activeChallenge), !((r = e.activeChallenge) != null && r.finish_at)) return de.info("No finish_at time available, staying in ongoing"), !1;
              const t = new Date(e.activeChallenge.finish_at),
                n = new Date,
                i = n >= t;
              return de.info("Checking challenge finish time", {
                finish_at: e.activeChallenge.finish_at,
                finishTime: t.toISOString(),
                currentTime: n.toISOString(),
                hasFinished: i
              }), i
            },
            target: "init"
          }],
          invoke: {
            src: "fetchLeaderboardPreview",
            input: ({
              context: e
            }) => e,
            onDone: [{
              guard: ({
                event: e
              }) => e.output.success,
              actions: ["assignLeaderboardPreview", "emitLeaderboardPreview"],
              target: "retry_joining"
            }, {
              target: "retry_joining"
            }],
            onError: {
              target: "init"
            }
          }
        },
        retry_joining: {
          after: {
            15e3: "joining"
          }
        },
        pause: {
          on: {
            resume: "init"
          }
        }
      }
    }),
    iL = Xe.forDomain("useChallengeAPI");

  function rL(e) {
    iL.info("useChallengeAPI start", e);
    const t = () => e.url,
      n = () => "/api/v1/lobby/",
      i = () => {
        const c = e.token;
        return c ? {
          headers: {
            Authorization: `Bearer ${c}`
          }
        } : {}
      },
      r = c => `${t()}${n()}${c}`;
    return {
      fetchChallengesList: async () => await fetch(r("challenges"), i()).then(c => c.json().then(f => f.data)),
      fetchChallengeById: async c => await fetch(r(`challenges/${c}`), i()).then(f => f.json()),
      fetchChallengeLeaderboardPreview: async c => await fetch(r(`challenges/${c}/leaderboard/preview`), i()).then(f => f.json()),
      fetchChallengePermissions: async () => await fetch(r("challenges/permissions"), i()).then(c => c.json().then(f => f.p2p_creation_allowed ?? !1)),
      fetchChallengesExist: async () => await fetch(r("challenges/exists_by_casino"), i()).then(c => c.json())
    }
  }
  const Ge = Xe.forDomain("AppController");
  let to = !1,
    Ir = !0,
    St, Bn, nn, Ot, On, no = null,
    io = null;
  const sL = e => {
      Ge.info("initApp"), $x(), !(!E.isShowLobby || !(E != null && E.drops_url)) && (no = E8({
        url: E.drops_url,
        token: E.drops_token
      }), io = rL({
        url: E.challenges_url,
        token: E.challenges_token
      }), q8(E == null ? void 0 : E.locale, E == null ? void 0 : E.fe_script_url), oL(no, io), m8(), St = QT(), Bn = _T(), Ot = Zn($T, {
        input: {
          animationLoop: St,
          tooltipController: Bn,
          playerWin: null,
          currentAnimation: St.getAnimationContent(),
          tooltipMessage: null,
          lastShowContentTime: null
        }
      }), Ge.info("initApplication"), e.provide("app-view-machine-actor", Ot), Ot.start(), Hr(tn.APP_RUN, qm))
    },
    oL = (e, t) => {
      nn = Zn(eL, {
        input: {
          dropAPI: e,
          campaign: null,
          currentCampaign: null,
          coinInfo: null,
          playerWin: null,
          identifier: E.identifier
        }
      }), nn.start(), On = Zn(nL, {
        input: {
          challengeAPI: t,
          activeChallenge: null,
          ongoingNotJoinedChallenge: null,
          leaderboardPreview: null,
          identifier: E.identifier
        }
      }), On.start()
    },
    qm = async (e, t) => {
      p8(tn.APP_RUN, qm), Ge.info("handleRun", t), to = t.isOverlapped, Ir = t.isEnabled, Ge.info("handleRun after", {
        isOverlapped: to,
        isEnabled: Ir
      }), Hr(tn.APP_UI_OVERLAP, yL), Hr(tn.APP_DISABLE, gL), Hr(tn.APP_ENABLE, vL), E.isShowProfile || E.isShowGameList ? (Zm(), Um()) : aL()
    }, Zm = () => {
      if (Ot.send({
          type: "ACTIVATE"
        }), to) {
        Ot.send({
          type: "OVERLAP_ON"
        });
        return
      }
      if (!Ir) {
        Ot.send({
          type: "DISABLE"
        });
        return
      }
    };
  let Ii;
  const aL = () => {
      Ii = Zn(tL, {
        input: {
          dropAPI: no,
          challengeAPI: io,
          identifier: E.identifier
        }
      }), Ii.on("SUCCESS", e => {
        Ge.info("checkIsCoinAvailable SUCCESS"), Zm(), Um(), Ii.stop()
      }), Ii.on("NOT_AVAILABLE", e => {
        Ii.stop()
      }), Ii.start()
    },
    Um = () => {
      if (Ge.info("runServices"), !no) {
        Ge.error("DropAPI is not available");
        return
      }
      if (Ot.on("CONFIRM_PLAYER_WIN", e => {
          nn.send({
            type: "CONFIRM_PLAYER_WIN"
          })
        }), nn.on("CAMPAIGN_CHANGED", e => {
          lL(e)
        }), nn.on("COIN_UPDATE", e => {
          cL(e)
        }), nn.on("PLAYER_WIN", e => {
          uL(e)
        }), !io) {
        Ge.error("ChallengeAPI is not available");
        return
      }
      On.on("UPDATE_ACTIVE_CHALLENGE", e => {
        fL(e)
      }), On.on("UPDATE_ONGOING_NOT_JOINED_CHALLENGE", e => {
        dL(e)
      }), On.on("CLEAR_ACTIVE_CHALLENGE", e => {
        pL(e)
      }), On.on("LEADERBOARD_PREVIEW", e => {
        hL(e)
      }), Hr(o8.CONFIRM_PLAYER_WIN, mL), nn.send({
        type: "RUN"
      }), On.send({
        type: "RUN"
      })
    },
    Bm = () => {
      St.updateContent("drop_total_num", null), St.updateContent("drop_max_prize", null)
    },
    lL = e => {
      Ge.info("onCampaignChanged", e.data);
      var t = e.data;
      (!t || t.status !== "ongoing") && Bm(), t.status === "ongoing" && !t.player_joined ? Bn.addTooltip({
        event_id: e.data.id,
        message: eo.JoinNewDrop,
        event_type: "drop"
      }, 2) : Bn.clear(e.data.id)
    },
    cL = e => {
      if (Ge.info("onCoinUpdate", e.data), e.data.coinInfo.drop_campaign_status !== "ongoing") {
        Bm(), Bn.clear(e.data.campaign.id);
        return
      }
      St.updateContent("drop_total_num", {
        icon: "drop",
        type: "number",
        value: e.data.coinInfo.total_remaining_prizes,
        label: "widget.drop_left",
        eventType: "drop",
        id: e.data.campaign.id
      }), St.updateContent("drop_max_prize", {
        icon: "drop",
        type: "money",
        value: e.data.coinInfo.max_prize,
        campaign_currency: e.data.campaign.campaign_currency,
        label: "widget.drop_prize",
        eventType: "drop",
        id: e.data.campaign.id
      })
    },
    uL = e => {
      Ge.info("onPlayerWin", e), Ot.send({
        type: "UPDATE_PLAYER_WIN",
        value: e.data
      })
    },
    fL = e => {
      Ge.info("onActiveChallenge", e.data), e.data.status === "planned" ? St.updateContent("challenge_time", {
        icon: "challenge",
        type: "timer",
        value: e.data.start_at,
        label: "widget.challenge_start",
        eventType: "challenge",
        id: e.data.id
      }) : e.data.status === "ongoing" && St.updateContent("challenge_time", {
        icon: "challenge",
        type: "timer",
        value: e.data.finish_at,
        label: "widget.challenge_finish",
        eventType: "challenge",
        id: e.data.id
      }), e.data.player_active ? Bn.clear(e.data.id) : Bn.addTooltip({
        event_id: e.data.id,
        message: eo.JoinNewChallenge,
        event_type: "challenge"
      }, 2)
    },
    dL = e => {
      Ge.info("onOngoingNotJoinedChallenge", e.data), e.data && Bn.addTooltip({
        event_id: e.data.id,
        message: eo.JoinNewChallenge,
        event_type: "challenge"
      }, 2)
    },
    pL = e => {
      Ge.info("onClearActiveChallenge", e.data), St.updateContent("challenge_place", null), St.updateContent("challenge_time", null)
    },
    hL = e => {
      Ge.info("onLeaderboardPreview", e.data), e.data.rank && St.updateContent("challenge_place", {
        icon: "challenge",
        type: "line",
        value: e.data.rank,
        label: "widget.challenge_rank",
        eventType: "challenge",
        id: e.data.id
      })
    },
    mL = (e, t) => {
      nn.send({
        type: "SHOWN"
      })
    },
    vL = (e, t) => {
      Ir = !0, Ot.send({
        type: "ENABLE"
      })
    },
    gL = (e, t) => {
      Ir = !1, Ot.send({
        type: "DISABLE"
      })
    },
    yL = (e, t) => {
      Ge.info("handleUiOverlap", t), to = t, t ? (nn.send({
        type: "STOP"
      }), On.send({
        type: "pause"
      }), Ot.send({
        type: "OVERLAP_ON"
      })) : (nn.send({
        type: "START"
      }), On.send({
        type: "resume"
      }), Ot.send({
        type: "OVERLAP_OFF"
      }))
    },
    bL = {
      install: e => {
        sL(e)
      }
    },
    Gm = Xe.forDomain("ThemeManager"),
    AL = () => {
      try {
        const e = "light",
          t = document.getElementById("coin-theme");
        if (!t) throw new Error("#coin-theme element not found");
        e === "dark" || (t.classList.remove("dark"), d8.value = ""), Gm.info("initTheme", e)
      } catch (e) {
        Gm.error("initTheme failed", e)
      }
    },
    ql = Ly(H8);
  ql.use(bL), ql.use(Tl);
  let qr = document.getElementById("coin-app");
  qr || (qr = document.createElement("div"), qr.id = "coin-app", document.body.appendChild(qr)), ql.mount(qr), AL(), console.log("%cGrowth Drops > App Version: dr-2.1.2", "border: 1px solid #E22134; padding: 4px 8px; font-weight: 600"), console.log("%cGrowth Drops > Git Branch/Git Commit: HEAD 2c98ba0 v2.1.2", "border: 1px solid #E22134; padding: 4px 8px; font-weight: 600"), console.log("%cGrowth Drops > Build mode: production", "border: 1px solid #E22134; padding: 4px 8px; font-weight: 600");
  const PL = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAABRCAYAAACQX/VFAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAARJSURBVHgB7ZtRbhs3EIZndtX3jdv3+gZRX4uo3by2MqqeoPIJmp4g6QmcnMD2CapCRl67gIy+Wj5BlPckVl6TJSczlDbYOLa14hgmGeQzDErrleBfJIfk/CMclUW/NngAgUDABTfnlGfzHtTzSbVcgge9GqDgtoRAEP84jIGaZQ0H9yqE7Hg6e320xdtABvFREtjDvcG9F3uDb8ddXxSjEAf3024j6Jcfi/6m+6MV0iCCshzPhj/tPL7pvuiFfIToyU1i0hEisJhfBzuPrvpTWkJAwjUdDB98V16+npwQAdEc8vpXtK8lKUQCQG2zT4ZYkkIcRH+2e6UHSniLcbTpHl69d/nGgh9sXA+2oHhvsjG3T+WJWsh09mZ/m/uHD4oSMRuzuD9ACU/832At5M6H1snpsmLxY/4n9hHAa4PYot8Mr2BzZDpbHvGg+wt0FHXdc8M16GRfiYEKFBDa8EIcRH+DAhZwf92GReaMZq64iAjxrCMV+IIQdrK3IcSX4AlSREJAH4bjEGLJJSC84H3XQtp091qXiEJIhqvI4wXiuXsPiIMCPMHMVtLGIYToPnhiYpojvCB6be/5dYvn1XIuj4MLGZYFJ+R8hxZWzaPgQtBk3ueSPLcf92lBhUhKlPdKY/Cj4oT3onkSTAgfiPj4ax+DL5R/smsOIkR6whg8I4Jd8EDyBCenr6r2NfWZ3X2yHTCQ93kv8jOHWh5O1n/d4EjVnhsNaiFsEr3odqcFLXJuyXN62J4bDWohd4UTYVjE7HMRQhKbRjecRMT/q8XvKqIW4o7AhM94OP1wkwgh2qHFIiYsYH9SXXQ6dMVsvY0kRHf1EaMeWo2PyE7vf5vCfConxJLD/Nl1bpWQ0lG3cG7VNT5iemf2a0zRNJMPLIaDwKh9SR1+LWSd/RGXZCDeb91CyYgEAQ4AVVO7ohbyfMuaEUEiEE/eQ9AJKozJpBjIfZBBhpZs+k5mFw8J8BgUyKGsCctB58g3uX3ES/gcFLC7O5Y2qBA3vq3StWJ3V5oo/BHQuVaFDK9I8lr0Lyhgm3oUhZDc6HxERIijRzadNTZBRHEIEQhXOVwfxBCNRghbaAtQEI8QlbMbyRxxIL4FBV+tt9uGI8/3oOBL6ZFlRHMENPngiIQoquvEa49CyKhDyfhNsJC3UQgxea4SgojzOIpqwKrqG9lrDy9kfVQtQUEOEF5IbfEfUCCWg+QAgmXjpTr0vWRBiJS1wCuv/c6FiAD2E0tj7QGCophmDVHmMjFqIXuDncOu9xJS3xiXYfde/NrIsJqu3V21kK0Mf4Lmq2G3ggV61jxOxgy9jPRGL4dJ8zzZTSMRHkdRwqFBeuPk9M2T9rUEv5q0Khq4fD3BHhGn9/OigWSESE/IVzWms+Xkqr8nEbXWlQ+/J1v54Ei58kGGESEe9zL7dFJdLLq8ptd7B8s61yWRtaySc8i/9pwI5tOV1bAVHwCb7ZYxAf0ISwAAAABJRU5ErkJggg==",
    wL = ["src"],
    xL = Object.freeze(Object.defineProperty({
      __proto__: null,
      default: Lt(Ce({
        __name: "IconContent",
        props: {
          data: {},
          scale: {}
        },
        setup(e) {
          var i;
          const t = Xe.forDomain("IconContent"),
            n = e;
          return t.info("IconContent props.data:", n.data), t.info("IconContent props.data.icon:", (i = n.data) == null ? void 0 : i.icon), (r, s) => (ae(), Ue("div", {
            class: "coin-widget-container",
            style: bt({
              transform: `scale(${n.scale||1})`,
              transformOrigin: "center center"
            })
          }, [ee("img", {
            src: n.data.icon === "logo" ? fe(PL) : fe(am),
            alt: "icon",
            class: "content-icon"
          }, null, 8, wL)], 4))
        }
      }), [
        ["__scopeId", "data-v-b904ef38"]
      ])
    }, Symbol.toStringTag, {
      value: "Module"
    })),
    TL = {
      class: "coin-widget-container"
    },
    LL = {
      key: 0,
      class: "slot-icon"
    },
    SL = {
      key: 1,
      class: "slot-middle"
    },
    OL = {
      key: 2,
      class: "slot-down"
    },
    ro = Lt(Ce({
      __name: "ContentTemplate",
      props: {
        scale: {}
      },
      setup(e) {
        const t = e,
          n = lg();
        return (i, r) => (ae(), Ue("div", TL, [ee("div", {
          class: "content-wrapper",
          style: bt({
            transform: `scale(${t.scale||1})`,
            transformOrigin: "center center"
          })
        }, [fe(n).icon ? (ae(), Ue("div", LL, [Wo(i.$slots, "icon", {}, void 0)])) : Rt("", !0), fe(n).middle ? (ae(), Ue("div", SL, [Wo(i.$slots, "middle", {}, void 0)])) : Rt("", !0), fe(n).down ? (ae(), Ue("div", OL, [Wo(i.$slots, "down", {}, void 0)])) : Rt("", !0)], 4)]))
      }
    }), [
      ["__scopeId", "data-v-7b6b89ec"]
    ]),
    Km = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACEAAAAeCAYAAACiyHcXAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAALfSURBVHgBxVa9chMxEN7VXcFQHT8P4IqW0FHk5+gdCE8Q+wmSPEHCE+A8Ac4TcIwzDF00EGgxLdWlZ4KomGEsLauzzqeLE1u+C8NX2CdpJX1a7bcrhADspEnCfwmsDpVJpZYZ4TKD55vJHhEeUTMSgIiD0cfLg0U20aJB9kBHG/zAn3egOZ4+6tzF7xe/5U0GYtHsPzpK4RZARGuLxtHet9aiRzjvbiR6zNewA22BMOafd9cNxcIMsbt5f8BU9+D/QQlsGHC3iCRmd88kZED0Bem8ZoJ4Bm2BeAzGZLU+ga+BwMaKipFMTk6pUaTVSCrp225v3FPU1ltGZKfnl/LKuh0qCELO6ojycoCMmItiDtgcWsLEk1rCstIvD0YEF4JPL6sdaevqAgj4DdpBvZdq7HdoT/oCKBMurUrXl1qWtSXIjKEd5uYTmN3yO4pAFskKgWYa1kbU5MruakcC6550h0xdU7ITcuHYDNGphLPbfnf9YWkEp+dKoqeglcFB6Te5DMzUxoc/sf8FieJKDL2qyOs3/rUQNPaGOj3/IctGdzM5ZM92XDMbfVLDGQmL0Wc1ABcbvGlHazybEaGK4CrgoM58Aiy1o2k/5HFEB5Wdh6KOGPxasrXGRFHfnoZ1/XPlfEHRsziejCca30IVBxBrepJ9qRQz955w5fvMc5s90bBYE6gHoZgWrYyL4H5JfhpbdFBeQ2V6DVxlHfCmu3BLsF6NNL30PeCN3YztjaTHUeoHU5PNFSvuOI5hcNNTb+nzrimZkM0923B015MUhNhhfb+4jlCxMeKJrZi8+TjkkevmrQ4bMxObdKaleIarUR8KAQ3gklvtBW0V1IRAYxIWsamnci75v6AhGpPQER7WOoh25ypwIIJjgh/EnHYpdZPWFmRPWX5wau7bKglLEEMAtjce9IjMUdmmxeZp+cHBa9P1E1iCwOvQ//RFHuQJ+97QGrYMwhoEwuaMeEL9ENu/2qxG+npaJrUAAAAASUVORK5CYII=",
    zL = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAgCAYAAADud3N8AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJWSURBVHgB7Za/dhJBFMa/O0tFtcH0ro0pxT7gpg6cQ55A7SzNEwBPEO3s0CcIHrCwynpAW6nTSKzVbJeGneudhSWAsEwgWZv8mt3ZuTvf/P3uECyo+a47Qq5IkS5K8clcJSEE44IdNchhNGgHYbiuPUqrrPi7PqKoLq8+7AkI6kOn9/s9biJqxEhHLWZ42BBpeAio5jJxZ/FDtVw4gdbv5NXFdsj/XHvs5XF+cfVlpehhqdCSwFe4Xfy9h3nv/OfVx39EK2W3LlPyGndDcc/LuzLiz6YQr2m19OAFQ7dw17Bz0O3/ClRcIF1HFlB8EkAV35VjQWfIChmtokg9R5YoXVNMXESm8DNFWxjAZprwZKTGOTJE9KY2WNl3GyAa7y6xMMfhp6vM+7C888PMkInr9C4fLYuRJOFFms6mVsrU7Pb/NMyrSoK6/dB8COJ6wBtFdIotkP+n3i2dayeCc6KGnMNHdD3dfqVc2Oj8GnfDJDNNZu14tn5O1EynMxJhYDytzI3K/q6PG2DcTaaykZRF8EDaHa4UjYW/hQNobk4/UHRq1gcWjOP0SVJmzceLgktFDZ2v4Rvp7dtJ0R3p9etrbhfxxklSovz/ybSzBLWqkVxOy27GYNwAinGeTSHSqj6zcYaycVZmLFrTey+K6DtfJ/Rg8vQnT7P2A2nFNR1LBJeto7WooVpyawz740Pgo04vbKfHWFAt7VyyxfUlzSxmUbCALe9LxlRs4qxEb5t70f8vOvXiLEUZE2daT2ATZCUqKe8lrb9hBCYOFliZQ0JatkmzvUX+AryF5cz3Wp86AAAAAElFTkSuQmCC",
    XL = ["src"],
    so = Lt(Ce({
      __name: "EventIcon",
      props: {
        icon: {},
        scale: {}
      },
      setup(e) {
        const t = e,
          n = le(() => t.icon === "drop" ? zL : (t.icon === "challenge", Km));
        return (i, r) => (ae(), Ue("img", {
          src: n.value,
          alt: "icon",
          class: "coin-icon"
        }, null, 8, XL))
      }
    }), [
      ["__scopeId", "data-v-4fe84296"]
    ]),
    DL = {
      class: "middle"
    },
    VL = {
      class: "down"
    },
    NL = Object.freeze(Object.defineProperty({
      __proto__: null,
      default: Lt(Ce({
        __name: "NumberContent",
        props: {
          data: {},
          scale: {}
        },
        setup(e) {
          const t = e,
            {
              t: n
            } = en();
          return (i, r) => (ae(), rt(ro, {
            scale: t.scale
          }, ls({
            _: 2
          }, [t.data.eventType !== "none" ? {
            name: "icon",
            fn: ve(() => [ne(so, {
              icon: t.data.eventType
            }, null, 8, ["icon"])]),
            key: "0"
          } : void 0, t.data.value ? {
            name: "middle",
            fn: ve(() => [ee("div", DL, je(t.data.value), 1)]),
            key: "1"
          } : void 0, t.data.label ? {
            name: "down",
            fn: ve(() => [ee("div", VL, je(fe(n)(`${t.data.label}`)), 1)]),
            key: "2"
          } : void 0]), 1032, ["scale"]))
        }
      }), [
        ["__scopeId", "data-v-0a90cefe"]
      ])
    }, Symbol.toStringTag, {
      value: "Module"
    })),
    jL = {
      class: "middle"
    },
    RL = Object.freeze(Object.defineProperty({
      __proto__: null,
      default: Lt(Ce({
        __name: "OneLineContent",
        props: {
          data: {},
          scale: {}
        },
        setup(e) {
          const t = e,
            {
              t: n
            } = en();
          return (i, r) => (ae(), rt(ro, {
            scale: t.scale
          }, ls({
            _: 2
          }, [t.data.eventType !== "none" ? {
            name: "icon",
            fn: ve(() => [ne(so, {
              icon: t.data.eventType
            }, null, 8, ["icon"])]),
            key: "0"
          } : void 0, t.data.value ? {
            name: "middle",
            fn: ve(() => [ee("div", jL, "#" + je(t.data.value), 1)]),
            key: "1"
          } : void 0, t.data.label ? {
            name: "down",
            fn: ve(() => [r[0] || (r[0] = ee("div", {
              class: "down"
            }, null, -1))]),
            key: "2"
          } : void 0]), 1032, ["scale"]))
        }
      }), [
        ["__scopeId", "data-v-64634c19"]
      ])
    }, Symbol.toStringTag, {
      value: "Module"
    })),
    FL = {
      class: "timer-container"
    },
    CL = {
      key: 0,
      class: "timer-loader"
    },
    WL = {
      key: 1,
      class: "timer-display"
    },
    HL = {
      class: "timer-text"
    },
    kL = Lt(Ce({
      __name: "Timer",
      props: {
        time: {}
      },
      setup(e) {
        const {
          t
        } = en(), n = e, i = te(new Date);
        let r = null;
        const s = le(() => new Date(n.time)),
          o = le(() => s.value.getTime() - i.value.getTime()),
          a = le(() => o.value < 0),
          l = le(() => {
            if (a.value) return "";
            const c = o.value,
              f = Math.floor(c / (1e3 * 60 * 60 * 24)),
              d = Math.floor(c % (1e3 * 60 * 60 * 24) / (1e3 * 60 * 60)),
              p = Math.floor(c % (1e3 * 60 * 60) / (1e3 * 60)),
              h = Math.floor(c % (1e3 * 60) / 1e3);
            return f > 0 ? `${f} ${t(f===1?"widget.timer_day":"widget.timer_days")}` : `${d}:${p.toString().padStart(2,"0")}:${h.toString().padStart(2,"0")}`
          }),
          u = () => {
            i.value = new Date
          };
        return Zt(() => {
          u(), r = window.setInterval(u, 1e3)
        }), $n(() => {
          r && (clearInterval(r), r = null)
        }), (c, f) => (ae(), Ue("div", FL, [a.value ? (ae(), Ue("div", CL, f[0] || (f[0] = [ee("div", {
          class: "loader-spinner"
        }, null, -1)]))) : (ae(), Ue("div", WL, [ee("span", HL, je(l.value), 1)]))]))
      }
    }), [
      ["__scopeId", "data-v-25525c3f"]
    ]),
    EL = {
      class: "middle"
    },
    ML = Object.freeze(Object.defineProperty({
      __proto__: null,
      default: Lt(Ce({
        __name: "TimerContent",
        props: {
          data: {},
          scale: {}
        },
        setup(e) {
          const {
            t
          } = en(), n = e;
          return (i, r) => (ae(), rt(ro, {
            scale: n.scale
          }, ls({
            _: 2
          }, [n.data.eventType !== "none" ? {
            name: "icon",
            fn: ve(() => [ne(so, {
              icon: n.data.eventType
            }, null, 8, ["icon"])]),
            key: "0"
          } : void 0, n.data.label ? {
            name: "middle",
            fn: ve(() => [ee("div", EL, je(fe(t)(`${n.data.label}`)), 1)]),
            key: "1"
          } : void 0, n.data.value ? {
            name: "down",
            fn: ve(() => [ne(kL, {
              time: n.data.value
            }, null, 8, ["time"])]),
            key: "2"
          } : void 0]), 1032, ["scale"]))
        }
      }), [
        ["__scopeId", "data-v-433004a4"]
      ])
    }, Symbol.toStringTag, {
      value: "Module"
    })),
    IL = {
      class: "middle"
    },
    qL = {
      class: "down"
    },
    ZL = Object.freeze(Object.defineProperty({
      __proto__: null,
      default: Lt(Ce({
        __name: "MoneyContent",
        props: {
          data: {},
          scale: {}
        },
        setup(e) {
          var u, c, f, d, p, h;
          const t = Xe.forDomain("MoneyContent"),
            {
              toShortForLocal: n,
              toShortForEuro: i
            } = cm({
              code: (c = (u = E == null ? void 0 : E.rules) == null ? void 0 : u.currency) == null ? void 0 : c.code,
              symbol: (d = (f = E == null ? void 0 : E.rules) == null ? void 0 : f.currency) == null ? void 0 : d.symbol,
              subunits: (h = (p = E == null ? void 0 : E.rules) == null ? void 0 : p.currency) == null ? void 0 : h.subunits
            }),
            r = le(() => a.data.campaign_currency !== "EUR"),
            s = g => (t.info("props.data.campaign_currency: ", a.data.campaign_currency), t.info("formatValue: ", a.data), t.info("isSingleCurrency: ", r.value), r.value ? n(g, !0) : i(g, !0)),
            o = le(() => s(a.data.value)),
            a = e,
            {
              t: l
            } = en();
          return (g, A) => (ae(), rt(ro, {
            scale: a.scale
          }, ls({
            _: 2
          }, [a.data.eventType !== "none" ? {
            name: "icon",
            fn: ve(() => [ne(so, {
              icon: a.data.eventType,
              style: {
                paddingTop: "8px"
              }
            }, null, 8, ["icon"])]),
            key: "0"
          } : void 0, a.data.value ? {
            name: "middle",
            fn: ve(() => [ee("div", IL, je(o.value), 1)]),
            key: "1"
          } : void 0, a.data.label ? {
            name: "down",
            fn: ve(() => [ee("div", qL, je(fe(l)(`${a.data.label}`)), 1)]),
            key: "2"
          } : void 0]), 1032, ["scale"]))
        }
      }), [
        ["__scopeId", "data-v-9b317e0a"]
      ])
    }, Symbol.toStringTag, {
      value: "Module"
    }))
})();